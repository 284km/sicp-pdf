\documentclass[oneside]{book}
\usepackage{zxjatype}

\setjamainfont[BoldFont=IPAゴシック]{IPA明朝}
\setjasansfont{IPAゴシック}
\setjamonofont{IPAゴシック}
\renewcommand\indexname{索引} 
\renewcommand{\contentsname}{目次}

% New line height: 1.05 * 1.2 = 1.26
\renewcommand{\baselinestretch}{1.05}

\newfontfamily\greekfont[Mapping=TeX]{CMU Serif} % Computer Modern Unicode
\usepackage{polyglossia}
\setotherlanguage{greek}

% To be able to use '\-/' in place of '-' inside \code{}
% so that long function names containing hyphens 
% can be broken up after the hyphen:
\usepackage[shortcuts]{extdash} 

% So that file names with multiple dots don't confuse 
% graphicx package when using \includegraphics command:
\usepackage[multidot]{grffile}
\usepackage{graphicx}

\usepackage[usenames,dvipsnames,x11names]{xcolor}
\usepackage{amsmath}

% Workaround to fix mismatched left and right math delimiters. Taken from: 
% http://tex.stackexchange.com/questions/63410/parentheses-differ-xelatex-fontspec-newtxmath-libertine
\DeclareSymbolFont{parenthesis}{T1}{fxl}{m}{n}
\DeclareMathDelimiter{(}{\mathopen}{parenthesis}{"28}{largesymbols}{"00}
\DeclareMathDelimiter{)}{\mathclose}{parenthesis}{"29}{largesymbols}{"01}
\DeclareMathDelimiter{[}{\mathopen}{parenthesis}{"5B}{largesymbols}{"02} 
\DeclareMathDelimiter{]}{\mathclose}{parenthesis}{"5D}{largesymbols}{"03} 
\DeclareMathDelimiter{\lbrace}{\mathopen}{parenthesis}{"7B}{largesymbols}{"08} 
\DeclareMathDelimiter{\rbrace}{\mathclose}{parenthesis}{"7D}{largesymbols}{"09}

\usepackage{fancyvrb}
\usepackage{imakeidx}
\usepackage[totoc,font=footnotesize]{idxlayout}
\usepackage{fancyhdr}
\pagestyle{plain}
\usepackage[final]{pdfpages} % inserts pages from a pdf file

% Page geometry for 10-inch tablets:
\usepackage[papersize={148mm,197mm},
            top=21mm,
            textwidth=111mm,
            textheight=148mm,
            hcentering,
]{geometry}

\usepackage{titlesec}  % to change the appearance of section titles 
\usepackage{listings}  % for syntax highlighted code listings
\usepackage{verbatim}  % for simple verbatim and comment environments
\usepackage{enumerate} % allows customized labels in enumerations
\usepackage{hyperref}  % makes cross references and URLs clickable 
\definecolor{LinkRed}{HTML}{80171F}
\hypersetup{
  pdfauthor={Harold Abelson, Gerald Jay Sussman, Julie Sussman},
  pdftitle={Structure and Interpretation of Computer Programs, 2nd ed.},
  pdfsubject={computer science, programming, abstraction},
  colorlinks=true,
  linkcolor=LinkRed,
  urlcolor=LinkRed,
}

% Document colors 
\definecolor{SchemeLight}  {HTML} {686868}
\definecolor{SchemeSteel}  {HTML} {787878}
\definecolor{SchemeDark}   {HTML} {262626}
\definecolor{SchemeBlue}   {HTML} {4172A3}
\definecolor{SchemeGreen}  {HTML} {487818}
\definecolor{SchemeBrown}  {HTML} {A07040}
\definecolor{SchemeRed}    {HTML} {AD4D3A}
\definecolor{SchemeViolet} {HTML} {7040A0}
\definecolor{DropCapGray}  {HTML} {A8A8A8}
\definecolor{ChapterGray}  {HTML} {C8C8C8}

\usepackage{lettrine}  % adds commands that make drop capitals
\renewcommand{\LettrineFontHook}{\rmfamily\bfseries\color{DropCapGray}}
\renewcommand{\DefaultLraise}{0.00}
\renewcommand{\DefaultLoversize}{0.02}
\renewcommand{\DefaultLhang}{0.12}
\setlength{\DefaultFindent}{1pt}
\setlength{\DefaultNindent}{0em}

\lstset{%
  % Scheme syntax highlighter
    columns=fixed,
    extendedchars=true,
    upquote=true,
    showstringspaces=false,
    sensitive=false,
    mathescape=true,
    escapechar=~,
    alsodigit={>,<,/,-,=,!,?,*},
    alsoletter=',
    morestring=[b]",
    morecomment=[l];,
    % Keyword list taken form functional.py in Pygments package:
    morekeywords={lambda, define, if, else, cond, and, or, case,%
      let, let*, letrec, begin, do, delay, set!, =>, quote,%
      quasiquote, unquote, unquote-splicing, define-syntax, let-syntax,%
      letrec-syntax, syntax-rules},
    % If keywords are quoted, they must not be highlighted:
    emph={'lambda, 'define, 'if, 'else, 'cond, 'and, 'or, 'case,%
      'let, 'let*, 'letrec, 'begin, 'do, 'delay, 'set!, '=>, 'quote,%
      'quasiquote, 'unquote, 'unquote-splicing, 'define-syntax, 'let-syntax,%
      'letrec-syntax, 'syntax-rules}, 
    emphstyle=\color{SchemeDark},
    % Paint error red:
    emph={[2]error},emphstyle=[2]\color{SchemeRed},%
    % Builtins taken from functional.py:
    emph={[3]*, +, -, /, <, <=, =, >, >=, abs, acos, angle,
        append, apply, asin, assoc, assq, assv, atan,
        boolean?, caaaar, caaadr, caaar, caadar, caaddr, caadr,
        caar, cadaar, cadadr, cadar, caddar, cadddr, caddr,
        cadr, call-with-current-continuation, call-with-input-file,
        call-with-output-file, call-with-values, call/cc, car,
        cdaaar, cdaadr, cdaar, cdadar, cdaddr, cdadr, cdar,
        cddaar, cddadr, cddar, cdddar, cddddr, cdddr, cddr,
        cdr, ceiling, char->integer, char-alphabetic?, char-ci<=?,
        char-ci<?, char-ci=?, char-ci>=?, char-ci>?, char-downcase,
        char-lower-case?, char-numeric?, char-ready?, char-upcase,
        char-upper-case?, char-whitespace?, char<=?, char<?, char=?,
        char>=?, char>?, char?, close-input-port, close-output-port,
        complex?, cons, cos, current-input-port, current-output-port,
        denominator, display, dynamic-wind, eof-object?, eq?,
        equal?, eqv?, eval, even?, exact->inexact, exact?, exp,
        expt, floor, for-each, force, gcd, imag-part,
        inexact->exact, inexact?, input-port?, integer->char,
        integer?, interaction-environment, lcm, length, list,
        list->string, list->vector, list-ref, list-tail, list?,
        load, log, magnitude, make-polar, make-rectangular,
        make-string, make-vector, map, max, member, memq, memv,
        min, modulo, negative?, newline, not, null-environment,
        null?, number->string, number?, numerator, odd?,
        open-input-file, open-output-file, output-port?, pair?,
        peek-char, port?, positive?, procedure?, quotient,
        rational?, rationalize, read, read-char, real-part, real?,
        remainder, reverse, round, scheme-report-environment,
        set-car!, set-cdr!, sin, sqrt, string, string->list,
        string->number, string->symbol, string-append, string-ci<=?,
        string-ci<?, string-ci=?, string-ci>=?, string-ci>?,
        string-copy, string-fill!, string-length, string-ref,
        string-set!, string<=?, string<?, string=?, string>=?,
        string>?, string?, substring, symbol->string, symbol?,
        tan, transcript-off, transcript-on, truncate, values,
        vector, vector->list, vector-fill!, vector-length,
        vector-ref, vector-set!, vector?, with-input-from-file,
        with-output-to-file, write, write-char, zero?},
    emphstyle=[3]\color{SchemeViolet},%
    %
    basicstyle=\color{SchemeLight}\ttfamily,
    keywordstyle=\color{SchemeBlue}\bfseries,
    identifierstyle=\color{SchemeDark},
    stringstyle=\color{SchemeGreen},
    commentstyle=\color{SchemeLight}\itshape,
}
  
\newcommand{\acronym}[1]{\textsc{\MakeLowercase{#1}}}
\newcommand{\newterm}[1]{\index{#1}\emph{#1}}
\newcommand{\jnewterm}[1]{\index{#1}{\bf #1}}
\newcommand{\strong}[1]{\textbf{#1}}
\newcommand{\var}[1]{\textsl{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\link}[1]{\hyperref[#1]{#1}}
\newcommand{\heading}[1]{{\sffamily\bfseries #1}}
\newcommand{\dark}{\color{SchemeDark}}

\newenvironment{example}%
  {\verbatim\small}%
  {\endverbatim}

\newenvironment{smallexample}%
  {\verbatim\footnotesize}%
  {\endverbatim}

\lstnewenvironment{scheme}[1][]
{\lstset{basicstyle=\ttfamily\small\color{SchemeLight},#1}}
{}

\lstnewenvironment{smallscheme}[1][]
{\lstset{basicstyle=\ttfamily\footnotesize\color{SchemeLight},#1}}
{}

\makeatletter
\@definecounter{yakuchu}
\@addtoreset{yakuchu}{book}%
\def\yakuchu{%
\@ifnextchar[\@xfootnote %]
{\stepcounter{yakuchu}%
\protected@xdef\@thefnmark{訳注\theyakuchu}%
\@footnotemark\@footnotetext}}
\def\yakuchutext{%
\@ifnextchar [\@xfootnotenext %]
{\protected@xdef\@thefnmark{訳注\theyakuchu}%
\@footnotetext}}
\def\yakuchumark{%
\@ifnextchar[\@xfootnotemark %]
{\stepcounter{yakuchu}%
\protected@xdef\@thefnmark{訳注\theyakuchu}%
\@footnotemark}}
\makeatother

\titleformat{\chapter}[display]
  {\color{SchemeDark}\normalfont\sffamily\bfseries\LARGE}
  {\filright \color{ChapterGray}\fontsize{3em}{0em}\selectfont
    \oldstylenums{\thechapter}}
  {1em}
  {\filright}
  
\titleformat{\section}
{\color{SchemeDark}\normalfont\Large\sffamily\bfseries}
{\color{SchemeSteel}\thesection}{0.8em}{}

\titleformat{\subsection}
{\color{SchemeDark}\normalfont\large\sffamily\bfseries}
{\color{SchemeSteel}\thesubsection}{0.8em}{}

\titleformat{\subsubsection}
{\color{black}\normalfont\normalsize\sffamily\bfseries}
{\color{SchemeSteel}\thesubsubsection}{0.8em}{}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\frenchspacing
\makeindex

%====================%
%  End of preamble.  %
%====================%

\begin{document}
\pagenumbering{roman}
\VerbatimFootnotes

%             **********************************************************
%         sicp
%            Structure and Interpretation of Computer Programs, 2e
%             Unofficial Texinfo Format
%
% utfversion      2.andresraba5.2 
% utfversiondate  February 10, 2014
%
%             This file is licensed under a Creative Commons 
%             Attribution-ShareAlike 3.0 Unported License 
%             http://creativecommons.org/licenses/by-sa/3.0/
%             
%             This is a Texinfo file.  To convert it to Info hypertext
%             format, you will need the `makeinfo' program from the GNU
%             Texinfo package.  To produce a PDF, use `texi2pdf'. 
%             For more information about this file,
%             see the text under `\label{UTF' below.}
%             
%             Various versions of sicp.texi and preformatted sicp.info
%             can be found at the following Web pages:
%             
%                 http://www.neilvandyke.org/sicp-texi/
%                 http://sicpebook.wordpress.com/
%                 [add your own here]
%             
%             **********************************************************

% HISTORY:
%
% * Version 1 (April, 2001) by Lytha Ayth.
%
% * Version 2 (April 20, 2001) by Lytha Ayth.
%
% * Version 2.nwv1 (March 11, 2002) by Neil W. Van Dyke.
%   Cosmetic change to heading in Info format, and comment changes.
% 
% * Version 2.neilvandyke1 (February 10, 2003) by Neil W. Van Dyke
%   Correction to Exercise 1.39 formula, spotted by Steve VanDevender.
%   Added URL of Abelson and Sussman video lectures.
%
% * Version 2.neilvandyke2 (unreleased)
%
% * Version 2.neilvandyke3 (April 20, 2006) by Neil W. Van Dyke
%   Pedro Kr\"oger patch to add missing Lisp example.
%
% * Version 2.neilvandyke4 (January 10, 2007) by Neil W. Van Dyke
%   Brad Walker patch to add \code{@dircategory} and \code{@direntry}.
%
% * Version 2.andresraba1 (May 23, 2011) by Andres Raba.
%   Mathematics typeset in TeX, figures redrawn in vector graphics,
%   typeface changed, cross-references improved, hyperlinks added,
%   known errors and typos corrected.
%
% * Version 2.andresraba2 (November 21, 2011) by Andres Raba.
%   Minor change to the appearance of diagrams. Adjusted page layout.
%   Fixed some typos. License changed from CC BY-NC to CC BY-SA.
%
% * Version 2.andresraba3 (November 22, 2012) by Andres Raba.
%   Improved layout and pagination. Included list of figures.
%   Added punctuation to displayed math. Updated citation links.

% * (Version 2.andresraba4 is a pocket version, described in
%   sicp-pocket.texi.)

% * Version 2.andresraba5 (September 20, 2013) by Andres Raba.
%   Texinfo source is converted to LaTeX. Pages are redesigned.

% The Algorithmic Language Scheme

\frontmatter

\includepdf[scale=0.92]{coverpage.pdf}

\pagebreak

\vspace*{\fill}
\thispagestyle{empty}

\begin{small}

\noindent
{\copyright}1996 by The Massachusetts Institute of Technology

\vspace{1.26em}
\noindent
Structure and Interpretation of Computer Programs,\\
second edition

\vspace{1.26em}
\noindent
Harold Abelson and Gerald Jay Sussman\\
with Julie Sussman, foreword by Alan J. Perlis

\vspace{1.6em}
\noindent
\includegraphics[width=25mm]{fig/icons/by-nc-sa.pdf}

\vspace{0.4em}
\noindent
This work is licensed under a Creative Commons\\ 
Attribution-NonCommercial-ShareAlike 3.0 Unported License\\
(\href{http://creativecommons.org/licenses/by-nc-sa/3.0/}{\acronym{CC BY-NC-SA} 3.0}).
Based on a work at \href{http://mitpress.mit.edu/sicp/}{mitpress.mit.edu}.

\vspace{1.26em}
\noindent
The \acronym{MIT} Press\\
Cambridge, Massachusetts\\ 
London, England

\vspace{1.26em}
\noindent
McGraw-Hill Book Company\\
New York, St. Louis, San Francisco,\\ 
Montreal, Toronto

\vspace{1.26em}
\noindent
Unofficial Texinfo Format \href{http://sicpebook.wordpress.com}{2.andresraba5.2} (February 10, 2014),\\ 
based on \href{http://www.neilvandyke.org/sicp-texi/}{2.neilvandyke4} (January 10, 2007).

\vspace{1.26em}
\noindent
日本語： by \href{http://github.com/minghai/sicp-pdf/}{minghai} based on 2.andresraba5.2 (March 31, 2014).

\end{small}

\pagebreak

\tableofcontents

\small  % Added by minghai. (Japanese fonts looks too big.)

%=======================================================================================================

\chapter*{非公式Texinfoフォーマット}
\addcontentsline{toc}{chapter}{非公式Texinfoフォーマット}
\label{UTF}

これは\acronym{SICP}の非公式Texinfo版\yakuchu{
英語版にはTexinfo版がありますが、日本語版にはありません。{\LaTeX}ソースとPDFのみです。
}の第二版です。

あなたはきっと、これをEmacsのInfoモードのようなInfoハイパーテキストブラウザで読んで
いるのでしょう。もしかすると、{\TeX}で組版されたものを画面上で、または印刷して読んで
いるのかもしれませんね。もっとも、それは間抜けなことだと思いますが。それに、印刷するには
だいぶお金がかかりますよね。


\acronym{HTML}-\acronym{GIF}版は公式に無料で公開されているのですが、それを初めて
Unofficial Texinfo Format(非公式Texinfo版、\acronym{UTF})の初版としてLytha Aythが
個人的に変換したのは、2001年4月の長いEmacs Lovefest Weekendの間のことでした。



\acronym{UTF}は\acronym{HTML}版よりも検索が簡単です。また、あまりよくないコンピュータ
(たとえば寄付された386マシンのようなもの)を使っている人にとってもアクセスしやすいでしょう。
386マシンは、理論的には、Linux、Emacs、Schemeインタプリタを同時に実行できます。
しかし、多くの386マシンでは、Netscapeとそれに必要なX Window Systemの両方を動かそうとすると、
まだ始めたてでお金もない若いハッカーに\newterm{thrashing}(\jnewterm{スラッシング})という
概念を早い段階から教えるはめになるのがオチです。それに、UTF版なら圧縮なしで1.44\acronym{MB}
のフロッピーディスクに収まりますので、インターネットやLANへの接続環境のないPCに
インストールするのにも便利です。



Texinfoへの変換は、可能な範囲で直接的な翻字をしました。{\TeX}から\acronym{HTML}への
変換のように、これによってある程度内容が損なわれてしまいました。非公式TexInfo形式では、
図はいにしえの技術であるアスキーアートによって不格好に復活させられることになりました。
また、多量の上付き文字(`\^{}')と下付き文字(`\_')を変換するうちに、曖昧さによる変換ミスが
含まれてしまった可能性も大いにあります。どれが変換ミスかを当てるのは、読者への課題とします。
しかし、少なくとも私たちは、\emph{``より大きい''}という記号を\texttt{<u>\&gt;</u>}と符号化して
我らの勇敢な宇宙飛行士たちを危険にさらすようなことはしていません。



もしあなたが\texttt{sicp.texi}を変更して間違いを直したりアスキーアートを改善したりした場合、
\code{@set utfversion {utfversion}}の行を更新し、あなたの差分をを反映してください。
例えば、もしあなたがLythaのバージョン\code{1}から始めていて、あなたの名前がBobなら、改訂版には
\code{1.bob1}, \code{1.bob2}, \dots , \code{1.bob\textit{n}}のように名前をつけるのがいいでしょう。
また、\code{utfversiondate}も更新してください。もしあなたが自分の改訂版をWeb上で配布したいのなら、
文字列``sicp.texi''をファイルやWebページのどこかに埋め込んでおけば、Web検索エンジンから見つけ
やすくなるでしょう。




非公式Texinfo形式は、寛大にもフリーに配布されている\acronym{HTML}版の魂を引き継いで
いると信じられています。しかし、いつどこかの法律家の大艦隊が、何でもないような小さなことをめぐって
大騒ぎをしないとも限りません。ですから、あなたのフルネームを使ったり、あなたのアカウント名やマシン名を
含むかもしれないInfo, \acronym{DVI}, PostScript, \acronym{PDF}版を配布したりするのは
慎重に考えてからにしてください。

\noindent
\textit{Peath, Lytha Ayth}

\vspace{1.0em}
\noindent
\textbf{付録:}AbelsonとSussmanによる\acronym{SICP}のビデオレクチャーもご覧下さい。\\
\href{http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/}{\acronym{MIT CSAIL}}, 
\href{http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/}{\acronym{MIT OCW}}.

\vspace{0.5em}
\noindent 
\textbf{付録2:} 上記は2001年の元の\acronym{UTF}の紹介です。
10年後のいま、\acronym{UTF}は一変しました。数学上の記号と式は適切に組版され、図は
ベクターグラフィックにより描かれています。元のテキスト形式とアスキーアートの図
は今でもTexinfoのソースに残っていますが、Info形式にコンパイルした場合のみ
表示されます。電子書籍リーダーとタブレットの夜明け時代になって、
画面上で\acronym{PDF}を読むことは、もはやバカバカしいことではないとはっきり
言えるようになりました。
楽しんでください！

\vspace{0.5em}
\noindent
\textit{A.R, May, 2011}

%============================================================================================================
\chapter*{非公式日本語版}
\addcontentsline{toc}{chapter}{非公式日本語版}
\label{Unofficial Japanese Edition}

SICPはかつて第一版、第二版共に日本にて公式に翻訳が商業出版されていました。
第二版を出版していたピアソン桐原が2013年8月に
\href{http://slashdot.jp/story/13/08/09/0517250/}{ピアソングループから撤退し技術書の取扱を終了したため}、
日本語でSICPを読む機会は失われました。
このことがこの翻訳を行うことの契機となりました。

実際にはその後、2014年1月付近に、寛大にも第二版の訳者、和田英一先生がオンライン上にてSICPの訳書、
\href{http://sicp.iijlab.net/}{「計算機プログラムの構造と解釈」}全文を公開して下さいました。この時点でこの非公式日本語版の
価値は随分と小さくなりました。

しかし、その時、既に3章まで翻訳していたこと、そして非公式TexInfo版が2013年11月に大改訂を行い、
当初の日本語には正式に対応していないtexi2pdfから変更を行い、XeLaTeXを採用したために、
日本語でも美しい組版ができる可能性が出てきたことが、この原稿を廃棄することを押し止めました。

SICPのライセンスについてはインターネットアーカイブにて調べてみました。
2001年1月にMITがSICPを寛大にもオンラインで無料で読むことができるように公開された時にはライセンスが指定されていませんでした。

2008年4月にMITはSICPのライセンスをCC BY-NCと指定しました。その後ライセンスは2011年10月に一旦CC BY-SAに変更されます。
そして2年後の2013年9月に再びCC BY-NCへと戻されました。この事実がSICP原文のライセンスの解釈を難しくしています。
ライセンスの変更はオーナーの自由ですが、ライセンシーはコンテンツ取得時のライセンスを尊重すれば良いからです。

最初に非公式TexInfo版を作成したLytha Aythはライセンス指定の無いSICP公開をWeb文化に基づくものだと理解しました。
次にLaTeXの組版を開発したAndres RabaはCC BY-SAに基き正式な許諾の下、PDF版を作成しました。
私の翻訳はPDF版のライセンスであるCC BY-SAに従うことが求められます。しかし、現在のMITが非商業を求めて
いることを鑑みて、Raba氏に許可を頂いた上で非商業制約を追加した
\href{http://creativecommons.org/licenses/by-nc-sa/3.0/}{\acronym{CC BY-NC-SA} 3.0}
にてリリースすることにしました。

CC BY-NC、及びBY-SAは共に翻訳の許可を明記しています。従ってこの翻訳にはLythaが心配したような法的問題は
起こらないと信じています。しかし同時に、法的問題は常に一方的に起こされることがあることもまた現実です。
従って読者の皆様には常にネットワーク上のデータは(そしてプログラムも!)消えてなくなってしまうシャボン玉で
あることを忘れずに御用心願います。

TeX、LaTeX環境の日本語対応を進めて下さった全ての関係者の皆様に感謝します。
特に最新の情報を常に更新し続けて下さっている\href{http://oku.edu.mie-u.ac.jp/~okumura/texwiki/}{TeX Wiki}の奥村~晴彦氏、
W32TeXを自動でインストールし更新可能な
\href{http://www.math.sci.hokudai.ac.jp/~abenori/soft/abtexinst.html}{TeXインストーラ}作者の阿部~紀行氏、
XeLaTeX向け日本語パッケージ
\href{http://zrbabbler.sp.land.to/zxjatype.html}{``ZXjatype''}
を開発して下さった八登~崇之氏に感謝致します。

海外ではSICPの新しい形の開発が非常に盛んです。PDFはもちろん、epubやインタラクティブ版、Kindle版(mobi形式)、ClojureやJavaScriptに
よるSICP等が公開されています。この翻訳はCC BY-NC-SAですので非商業であればそのような
派生や翻案に利用することが可能です。日本でもSICPの世界が広がっていくことを期待しています。

\vspace{1em}
\noindent
※ 校正御協力者様 (順不同、敬称略)

\begin{itemize}

\item \href{https://github.com/kei-s}{Kei Shiratsuchi}

\item \href{https://github.com/kimurakoichi}{Kimura, Koichi}

\item \href{https://github.com/nna774}{のな}

\item \href{https://github.com/ainoya}{Naoki Ainoya}

\end{itemize}

%============================================================================================================
\chapter*{非公式日本語版 翻訳改訂版}
\addcontentsline{toc}{chapter}{非公式日本語版 翻訳改訂版}
\label{Unofficial Japanese Edition Revised Translation}
当面、非公式日本語版をもとに改訂作業を進めています。作業が終わり次第、翻訳改訂版についてのコメントを加える予定です。

%============================================================================================================


\chapter*{献辞}
\addcontentsline{toc}{chapter}{献辞}
\label{Dedication}



この本を、尊敬と賛美を込めて、コンピュータの中に住む妖精に捧げます。

\begin{quote}
``コンピュータサイエンスに関わる私たちにとって、コンピューティングを
楽しむことはとても大事だと私は思っています。コンピューティングの始まりの時期には、
それはとても楽しいことでした。
ご存知のとおり、お金を払うお客様たちが騙されるということがそこかしこで起こり、
それからしばらくして、私たちは彼らの不満を真面目に受け取るようになりました。
私たちは、あたかもコンピュータをきちんとエラーなしで完璧に使えるようにすることが
私たちの責任であるかのように考え始めてしまいました。
私はそうは思いません。
私たちは、コンピュータを発展させ、新しい方向に向かわせ、家の中で楽しめるように
しておくことについては責任があると思います。コンピュータサイエンスのその分野が、
ずっとその楽しさの感覚を失わないでくれればと願っています。特に、私たちが伝道師に
なったりしないことを望んでいます。聖書のセールスマンのような感覚を持たないでください。
そんな人たちは、もう世界に十分すぎるほどいます。あなたがコンピューティングについて
知っていることは、ほかの人たちも学ぶことができます。
コンピューティングをうまくやる鍵が、あなたの手の中にしかないとは思わないでください。
あなたの手の中にあるものは知性だと、私は思い、またそうであることを願っています。
それはつまり、あなたが出会ったマシンに対して、出会ったときよりも多くのものを見ることが
できる能力です。そして、それをそれ以上のものにすることができる能力です。''

\noindent
---Alan J. Perlis (April 1, 1922 -- February 7, 1990)
\end{quote}

%===========================================================================================================


\chapter*{前書き}
\addcontentsline{toc}{chapter}{前書き}
\label{Foreword}

\vspace{-0.6em}


教育者、将軍、栄養士、精神分析医、そして両親は、計画を立て(program)ます。
軍隊、学生、そして一部の社会は、計画によって動いています。
大きな問題を解決しようとするときは、一連の計画によって行います。
それらのほとんどは、途中でひょっこり現れてきたものです。
これらの計画は、いま取り組んでいる問題に特化した問題であふれているように見えます。
計画を立てることを、それ自身知的な活動として理解するためには、コンピュータ
プログラミングに目を向ける必要があります。つまり、コンピュータプログラムを読み書き
しなければいけないということです。それも、大量に。どういうプログラムか、
どういう実際の応用のためであるかはあまり関係ありません。重要なのは、それらが
どのようにふるまい、またより大きなプログラムを作る中でそれらがどれだけスムーズに
ほかのプログラムと協調できるかということです。プログラマは、部品の完全性と、
組み合わせたものの妥当性の、両方を追求しなければいけません。この本では、``プログラム''
というのは、Lispのある方言で書かれた、デジタルコンピュータ上で実行されることを前提とした
プログラムの、生成、実行、そして研究に焦点を当てています。Lispを使うことは、
プログラムの表記法についての制約を与えるだけで、何をプログラムするかには制約を与えません。


この本の主題について考えるうえで、3つの事象を考えることになります。
人間の心、コンピュータプログラムの集合、そしてコンピュータです。
コンピュータプログラムはすべて、実際のプロセスや精神的なプロセスのモデルで、
人間の心の中で生まれるものです。
これらのプロセスは、人間の経験と思考から浮かび上がってくるもので、数はとても多く、
細かいところまで入り組んでいて、いつでも部分的に理解することしかできません。
それらがコンピュータプログラムとして永遠に満足できるようにモデル化されるなんて
いうことは、めったにありません。ですから、私たちのプログラムは、注意深く工夫された
バラバラの記号の集合であり、絡まり合う関数の組み合わせでありながらも、絶えず
進化していきます。私たちのモデルに対する理解が深まったり、広がったり、一般化したり
するたびに、私たちはプログラムに手を加えていきます。最終的に、モデルは準安定状態に
達し、それは私たちが取り組む別のモデルの中に位置を占めることになります。
コンピュータプログラミングに関する興奮の源は、プログラムとして表現されたメカニズムが
私たちの心の中とコンピュータ上で絶え間なく広がっていくことであり、またそれが生み出す
知覚の爆発です。芸術が私たちの夢を解釈するものだとすると、コンピュータは夢を、
プログラムという形で実行するものなのです！


コンピュータは強力ですが、厳しい親方でもあります。プログラムは正しくなければ
ならず、伝えたいことは細かいところまで正確に伝えなければいけません。
ほかのすべての記号的な活動と同じく、プログラムが真であることは論証によって
知ることができます。Lispはそれ自身、意味論(これもまたモデルです)を割り当てることが
でき、そしてプログラムの仕様が、例えば述語論理などによって決められるのであれば、
論理学の証明方法によって、容認可能な正確性の論証をすることができます。
残念ながら、プログラムが大きく複雑になるにつれ(いつもそうなるのですが)、
仕様自体の妥当性、一貫性、正しさが疑わしいものになっていきます。そのため、
完全な形式的な正しさの論証というものが大きなプログラムについてくるということは
めったにありません。大きなプログラムは小さなものから成長していくものなので、
正しさについて確信を持てるような標準的なプログラム構造(これをイディオムと呼びます)
の武器庫を作り上げ、それらを定評のある組織化技術によってより大きな構造に
組み立てていくことを学ぶことが、決定的に重要になります。それらの技術については、
この本で詳細に扱いますが、それらを理解することは、プロメテウスのような創造的な営みで
あるプログラミングという分野に加わるために何よりも、不可欠なことです。何よりも、
強力な組織化の技術を発見し身につけることは、私たちが大きな、重要なプログラムを書くに
あたって必要な能力を育ててくれます。また、逆方向の流れとして、大きなプログラムを
書くということはとても大変なことなので、新しい方法を発明して、機能や詳細事項の山を
減らしてより大きなプログラムに組み込むことができるようにするように、私たちは促されて
います。


プログラムとは違って、コンピュータは物理法則に従わなければなりません。もし
素早く---状態遷移あたり数ナノ秒といったレベルで---動作したければ、電子をほんの
短い距離(せいぜい\(1{1\over2}\) フィートだけ)しか運ぶことができません。
空間的にぎっしり詰め込まれた、膨大な数のデバイスが発する熱は、取り除かなければ
いけません。高機能性とデバイス密度のバランスを取りながら、精緻な工学的技法が
発展してきました。いずれにせよ、ハードウェアは私たちがプログラムしようとしている
レベルよりもプリミティブなレベルで動いています。私たちのLispのプログラムを
``機械の''プログラムに変換する処理は、それ自身が抽象的なモデルで、それは
私たちがプログラムするものです。その研究と作成は、どんなモデルをプログラムするとき
にも関わってくるような組織的プログラムについて、多くの洞察を与えてくれます。
もちろん、コンピュータそれ自身もそのようにモデル化されています。考えてみてください。
一番小さい物理的なスイッチング素子は量子力学によってモデル化され、量子力学は
微分方程式によって記述され、微分方程式の詳細なふるまいは数値近似によって表され、
数値近似はコンピュータプログラムによって表現され、そのコンピュータプログラムは
コンピュータによって実行され、そのコンピュータを構成する素子は\( \dots \)！


3つの焦点を別々に設定することは、単なる方法上の便利さのためだけではありません。
よく「すべては頭の中のことだ」と言われますが、このように論理的に分けることによって、
これらの焦点の間の記号的通信を促進することができます。人間の経験の中で、これら3つの
豊かさ、生命力、潜在力を超えるものは、人生そのものの発展ぐらいです。これらの焦点の
間の関係は、せいぜい準安定状態です。コンピュータの容量の大きさや速さは、これで十分と
なることは決してありません。ハードウェア技術の進歩のたびに、より大きなプログラミング
の取り組み、新しい組織化原則、そして抽象モデルの発展が引き起こされます。読者は、
定期的に``どこに向かっているんだ? どこに向かっているんだ?''と自問しなければなりません。
---でも、あまり問いすぎないようにしましょう。そうでないと、ほろ苦い哲学的な便秘のために、
プログラミングの楽しさを見逃してしまうことになります。


私たちが書くプログラムの中で、一部のもの(しかし、決して十分にはならない)は、
並べ替え、数列の最大値を見つける、素数性判定、平方根の計算といった、精密な
数学的な関数を実行します。そのようなプログラムはアルゴリズムと呼ばれ、その最適な
ふるまいについては多くのこと(特に、実行時間とデータストレージの必要量という
二つのパラメータについて)が知られています。プログラマは、よいアルゴリズムと
イディオムを身につけなければいけません。プログラムの中には厳密な仕様が記述しにくい
ものもありますが、プログラマとしては責任を持ってパフォーマンスを推定し、また
常に改善しようとしなければなりません。


Lispは、``生き残ったもの''です。約四半世紀にわたって使われてきています。
活発なプログラミング言語の中で、これより長い時間を生きてきたものはFortranだけです。
どちらの言語も、重要な応用領域でのプログラミングの必要性を支えてきています。
Fortranは科学計算と工学計算を支え、Lispは人工知能を支えてきました。この二つの分野は
今でも重要であり続け、これらの分野のプログラマはLispとFortranという二つの言語に
力を注いでいるので、少なくとももうあと四半世紀の間活発に使われる言語であり続ける
ということは十分ありうることです。


Lispは変化します。このテキストで使っているScheme方言は、オリジナルのLispから進化
してきたもので、いくつかの重要な点で異なっています。例えば、変数束縛のための
静的スコーピングや、関数が関数を値として返すことを許可することなどです。構文的な
構造において、SchemeはAlgol 60に似ています。その近さは、Schemeと初期のLispとの
近さと同じ程度です。Algol 60は、もう活発な言語になることはないでしょうが、Schemeと
Pascalの遺伝子の中に生き続けています。これら二つの言語ほど、かけ離れた文化に
取り囲まれ、その流通貨幣となっているような二つの言語というのもなかなかないでしょう。
Pascalはピラミッドを建てるためのものです。雄大で、息をのむような、静的な構造物で、
軍隊が重い石を運び、所定の位置に押しこむことによって作られています。
Lispは有機体を作るためのものです。雄大で、息をのむような、動的な構造物で、小さな
チームが無数のより単純な揺れ動く有機物を所定の位置に入れることによって作られています。
どちらの場合にも、組織化のための原則は同じですが、ひとつだけ非常に重要な違いがあります。
個々のLispプログラマに委ねられたエクスポート可能な関数は、Pascal企業の中で見つけられる
ものより桁違いに多いのです。Lispのプログラムは、ライブラリを関数でいっぱいにします。
それらの関数は、それらを生んだアプリケーションを超えて使えるものです。リストという
Lispのネイティブデータ構造は、そのような実用性の成長の主な要因です。リストの単純な
構造と自然な適用可能性は、驚くほど普遍的な関数という形で表れてきます。Pascalでは、
宣言可能なデータ構造の多さが関数の専門化を引き起こし、気軽な連携は禁じられ、
ペナルティを与えられるものとなります。ひとつのデータ構造を扱う100の関数があるほうが、
10のデータ構造を扱う10の関数があるのよりもよいのです。結果として、ピラミッドは
千年もの間変化せずに存在しつづけなければならないのに対し、有機体は存在する限り
進化し続けなければなりません。進化を止めるということは滅びることを意味します。


この違いをはっきり知るためには、この本の中での教材と練習問題の扱いを、何でもいいので
Pascalを使った入門テキストと比べてみてください。このテキストは\acronym{MIT}でしか
消化できない、\acronym{MIT}に固有の種族のためのものだとかいった妄想は抱かないでください。
このテキストは、真面目なLispのプログラミングの本はどのようなものでなければいけないか
というところを形にしたものであって、学生が誰であるかとかどこで使われるかとかは
関係がありません。


ひとつ気をつけておいていただきたいのは、この本はプログラミングに関するテキストだと
いうことです。ほとんどのLispの本は人工知能に使うための準備となっていますが、この本は
違います。いずれにしても、対象となるシステムが大きくなるにつれ、ソフトウェア工学と
人工知能に関わる重要なプログラミング上の課題は融合していく傾向にあります。まさに
そのために、人工知能以外の領域でも、Lispに対してこれほどの関心が向けられているのです。


その目的とするところから予想できる通り、人工知能の研究は数多くの重要なプログラミングの
問題を生み出しています。ほかのプログラミング分野であれば、このような大量の問題に対しては
新しい言語が生み出されるところです。実際に、非常に大きなプログラミングのタスクにおいて、
組織化のために便利な方法のひとつは、新しい言語を発明して、タスクモジュールの中にやりとりを
閉じ込め、コントロールするということです。これらの言語は、私たちがよく扱うシステムの
辺縁に向かうにつれて、どんどんプリミティブでなくなっていく傾向があります。結果として、
そのようなシステムでは、複雑な言語処理の機能が何回も繰り返されることになります。
Lispは、非常に単純なシンタックスとセマンティクスを持つため、パージングは初歩的なタスクとして
扱うことができます。ですので、パージング技術はLispのプログラムの中でほとんど何の役割も
果たしません。また、大きなLispのシステムが成長し変化していく中で、言語処理系の構築が
その成長速度の妨げになることはめったにありません。最後に、まさにこのシンタックスと
セマンティクスの単純さこそが、すべてのLispプログラマが付き合うことになる重荷と自由の
源泉なのです。数行以上のLispプログラムを書こうとすると、それは必ず自由に使える関数で
いっぱいになります。発明し、組み込み(fit)ましょう。かんしゃくを起こし(have fits)、
再発明しましょう！ 括弧のネストの中に自分の考えを書いていくLispプログラマに乾杯。


\vspace{0.5em}
\noindent
Alan J. Perlis\\
New Haven, Connecticut

%=========================================================================================================


\chapter*{第二版~序文}
\addcontentsline{toc}{chapter}{第二版~序文}
\label{Preface}

\begin{quote}
ソフトウェアが、ほかの何にも似ていないということはあるでしょうか。それは捨てられる
ためのもので、常にシャボン玉のように見ることがすべてだと。

---Alan J. Perlis
\end{quote}

\vspace{0.7em}

\noindent
この本で扱われている題材は、1980年から\acronym{MIT}の入門レベルの計算機科学科目の基礎と
なってきました。初版の発売時点で、もうこの教材で4年間教えていました。それから、この第二版が
出てくるまでには、さらに12年が過ぎました。私たちの成果が広く受け入れられ、ほかのテキストにも
取り込まれていることについて、私たちはうれしく思っています。私たちは、学生たちがこの本に出てくる
考え方やプログラムを身につけ、それらを新しいコンピュータシステムやコンピュータ言語の核として
組み込むのを見てきました。古代のタルムードに出てくる言葉遊びを文字通り実現し、私たちの学生は
建築者になったのです。このような有能な学生、功績ある建築者を得ることができたのは幸運なことでした。


この版の準備にあたって、何百にものぼるわかりやすい説明を取り込みました。それらは、私たち自身の
教育経験や、\acronym{MIT}やほかの場所の同僚たちのコメントから得られたものです。この本に出てくる
主なプログラミングシステムのほとんどを再設計しました。それには一般計算システム、インタプリタ、
レジスタマシンシミュレータ、コンパイラが含まれます。さらに、プログラムの例をすべて書き換え、
\acronym{IEEE} Scheme標準(\link{IEEE 1990})に適合したScheme実装であればどんなものの上でも
コードを実行できるようにしました。


この版では、いくつかの新しいテーマに重点を置いています。これらの中で最も重要なものは、
複数の計算モデルの中で時間を扱う異なるアプローチの中心的な役割を果たしているものです。
それらは状態付きのオブジェクト、並行プログラミング、関数型プログラミング、遅延評価、そして
非決定性プログラミングです。並行性と非決定性については新たに節を設け、本全体を通して
このテーマを統合させるよう力を尽くしました。


この本の初版は、\acronym{MIT}の半期の科目のシラバスをなぞったものでした。第二版では、
多くの新しい題材を含めたため、半期ですべてをカバーするのは無理でしょう。ですので、
講師は教えるべき内容を選ぶ必要があります。私たち自身が講義をする際には、時々
論理プログラミング(\link{Section 4.4})を飛ばします。学生にはレジスタマシンのシミュレータを
使わせますが、その実装(\link{Section 5.2})はやりません。そして、コンパイラ(\link{Section 5.5})
はざっと概要を見るだけです。それでもなお、これは中身の濃い授業です。講師によっては、
最初の3章か4章だけをやって、残りの題材は次の科目に譲りたいという人もいるでしょう。


World-Wide-Webサイト \href{http://mitpress.mit.edu/sicp}{http://mitpress.mit.edu/sicp} は、
この本の読者へのサポートを提供します。それにはこの本に出てくるプログラム、プログラミング
練習問題のサンプル、補助教材、ダウンロード可能なLispのScheme方言の実装が含まれます。

%============================================================================================================

\chapter*{第一版~序文}
\addcontentsline{toc}{chapter}{第一版~序文}
\label{Preface 1e}

% \vspace{-0.6em}
\begin{quote}
コンピュータはバイオリンのようなものです。次のような場面を想像してみてください。
ある初心者の人が、まず蓄音機を動かしてみて、それから次にバイオリンを触ってみます。
その人は、バイオリンの音はひどいと言います。人間主義者たちや多くの計算機科学者から
私たちが聞く話はそういったものです。コンピュータのプログラムは特定の目的にはよいが、
柔軟ではないと。バイオリンやタイプライターだってそんなものです。使い方を学ばなければの
話ですが。

---Marvin Minsky, ``Why Programming Is a Good Medium for Expressing
Poorly-Understood and Sloppily-Formulated Ideas''
\end{quote}

\vspace{0.8em}

\noindent
``The Structure and Interpretation of Computer Programs''(SICP, 計算機プログラムの構造と解釈)は
マサチューセッツ工科大学(MIT)での入門者レベルの計算機科学の科目です。\acronym{MIT}
で電気工学や計算機工学を専攻する学生はすべて、4つある``共通コアカリキュラム''の
ひとつとして履修しなければなりません。残りは、回路と線形システムについての
科目2つと、デジタルシステム設計の科目ひとつです。私たちは、この科目の開発に1978年から
携わってきました。そして、1980年の秋からは、この教材の現在の形で毎年600人から700人の
学生を教えてきています。ほとんどの学生はコンピュータについてそれまでまったく秩序立った
トレーニングを受けていないか、受けていてもわずかなものでした。とはいえ、コンピュータで
ちょっと遊んだことのある学生は多くいましたし、プログラミングやハードウェア設計に相当な
経験のある学生も数人はいましたが。


私たちがこの計算機科学の入門科目の授業計画を策定するにあたって、二つの懸念点を
内容に反映させました。一つ目は、コンピュータ言語はただコンピュータに操作を
実行させる方法であるにとどまらず、方法論についての考え方を表現するための
今までにない形式的な媒体であるという考え方を打ち立てたいということでした。
ですから、プログラムは人間が読めるように書かなくてはならず、それがたまたま
機械によって実行できるというだけのことです。二つ目は、私たちがこのレベルの科目で
扱われるべき中心的な題材について信じていることです。教えるべきはことは、
特定のプログラミング言語の文法ではなく、また特定の関数を計算するための賢い
アルゴリズムでもなく、さらに言うとアルゴリズムの数学的解析やコンピューティングの
基礎ですらなく、重要なのは大きなソフトウェアシステムの知的複雑性をコントロールする
技術であるということです。


私たちの目標は、この科目を修了した学生たちが、プログラミングのスタイルと美学について、
基礎的な感覚を十分に身につけてくれることです。学生たちが、大きなシステムの複雑性を
コントロールするための主要な技術を使いこなせるようになること。模範的なスタイルで
書かれていれば、50ページにわたるプログラムでも読めるようになっていること。どんなときにも、
何を読むべきでないか、何を理解しないでもいいかを判断できるようになること。
また、プログラムを変更するにあたって、自信を持って、元の作者の意図とスタイルを保ったままで
変更を加えることができるようになっていること。


これらのスキルは、決してコンピュータプログラミングに特有のものではありません。
私たちが教え、また利用する技術は、すべての工学的設計に共通するものです。私たちは、
詳細な部分を隠す抽象化を適宜加えることによって、複雑性をコントロールします。
私たちは、共通のインターフェイスを確立し、標準的かつ中身のよくわかっている部品を
「うまく組み合わせる」やり方で、複雑性をコントロールします。私たちは、設計を
記述するためにさまざまな言語を作り出し、それぞれの言語が設計のある特定の側面を際立たせ、
それ以外の側面を目立たなくさせることによって、複雑性をコントロールします。


私たちのこの科目に対するアプローチの底にあるものは、``計算機科学''は科学ではなく、
その意義はコンピュータとほとんど関係がないという信念です。コンピュータ革命とは、
私たちの考え方と、考えを表現するやり方の革命です。この変化を象徴する出来事は、
\newterm{procedural epistemology}(\jnewterm{手続き的認識論})---古典的な数学的テーマで
取られるような宣言的な見方ではなく、命令的な見方による知識構造の研究---の出現でしょう。
数学は、``何であるか''という考えについて正確に扱う枠組みを提供します。計算機科学は、
``どうやるか''という考えについて正確に扱う枠組みを提供します。


この教材では、プログラミング言語Lispのひとつの方言を使います。言語を正式に
教えることはしません。その必要がないからです。普通に使っていくだけで、数日のうちに
学生は身につけます。これはLisp系の言語の大きな利点です。複合式を作るやり方は
ごくわずかで、構文構造はあってないようなものです。形式的な性質はすべて、一時間も
あればカバーできます。チェスのルールのようなものです。少ししたら、言語の
構文的な詳細について忘れてしまい(元からそんなものはないので)、実際の問題---
何を計算したいのか、どうやって問題を扱えるサイズの部品に分解するか、
それらの部品をどのように作っていくか---に取り組むことになります。
もうひとつのLispの利点は、私たちの知る限りほかのどんな言語よりも、プログラムを
モジュールに分解する大規模な戦略をサポートしてくれる(しかし強制はしない)という
ところです。手続きとデータの抽象化、一般的な使い方のための高階関数の使用、
代入とデータ変更による局所状態のモデル化、ストリームと遅延評価によるプログラム同士の
連携。さらに、組み込み言語の実装も簡単にできます。また、これらすべては、
インクリメンタルなプログラム設計、構築、テスト、デバッグに対する優れたサポートを
提供する対話的環境に埋め込まれています。これまでにないパワーと優美さを備えた
すばらしいツールを作り上げたJohn McCarthyをはじめ、これまでのすべての世代の
Lispウィザードたちに感謝の気持ちを捧げます。


Schemeは私たちが使うLispの方言なのですが、これはLispとAlgolのパワーと優美さを
ひとつにまとめようとしたものです。Lispからは、シンプルな構文によるメタ言語的なパワー、
プログラムをデータオブジェクトとして表す統一的なやり方、ガベージコレクション付きヒープへの
データ割り当てを取り込んでいます。Algolからは、レキシカルスコープとブロック構造を
取り込みました。これらは、Algol委員会のプログラミング言語設計の先駆者たちからの
贈り物です。チャーチの\( \lambda \)計算とプログラミング言語の構造との間の関係についての
洞察はJohn ReynoldsとPeter Landinによるものです。また、コンピュータが世界に現れる
何十年も前からこの領域を探索してきた数学者たちに対する恩義も感じています。
彼ら開拓者たちには、Alonzo Church, Barkley Rosser, Stephen Kleene, Haskell Curryなどが
含まれます。


%============================================================================================================

\chapter*{謝辞}
\addcontentsline{toc}{chapter}{謝辞}
\label{Acknowledgements}


この本とこのカリキュラムの開発を手助けしてくださった多くの方々に感謝いたします。


私たちの科目は、明らかに``6.231''の知的な系譜を継ぐものです。それは、1960年代後半に
\acronym{MIT}でJack WozencraftとArthur Evans, Jr.が担当していた、プログラミング言語学と
\( \lambda \)計算についてのすばらしい科目でした。


Robert Fanoが\acronym{MIT}の電気工学と計算機科学の入門カリキュラムを再編成し、
工学設計の原理に重点を置くようにしてくれたことに非常に感謝しています。
彼はこの取り組みを始めるよう私たちを導き、最初の科目ノートをまとめてくれました。
この本は、それをもとに発展してきたものです。


私たちが教えようとしているプログラミングのスタイルと美学は、その多くが
Guy Lewis Steele Jr.と連携して開発したものです。彼は、Gerald Jay Sussmanとともに
Scheme言語の初期の開発に携わりました。さらに、David Turner, Peter Henderson,
Dan Friedman, David Wise, Will Clingerは、この本に登場する関数プログラミング
コミュニティのテクニックを数多く教えてくれました。


Joel Mosesは、大きなシステムを構築する方法を教えてくれました。彼は、記号計算に使われる
Macsymaシステムでの開発経験を通して、制御の複雑性を回避して、モデル化しようとしている
世界の現実の構造を反映するようデータを体系化することに集中することが重要だということを
学んでいました。


Marvin MinskyとSeymour Papertは、プログラミングと、知的生活の中でそれをどのように
位置づけるかについて、私たちの姿勢の多くを形作ってくれました。コンピュータがなければ
正確に扱うには複雑すぎるような考えを探究するにあたって、コンピュータが表現手段を
与えてくれるということを理解できるようになったのは彼らのおかげです。彼らは、
学生のプログラムを書き、変更する能力が、自然活動を探究するための強力な方法になると
強調しています。


私たちはまた、プログラミングはとても楽しく、プログラミングの楽しみをサポートする
よう注意しなければいけないというAlan Perlisの考え方に強く同意します。この楽しみの
一部分は、偉大な職人たちの働いているところからも得ることができます。
Bill Gosper and Richard Greenblattのもとで見習いプログラマとして働けたことは
幸運なことでした。


私たちのカリキュラムの開発に貢献してくださったすべての方々について名前を挙げるのは
困難です。過去15年間私たちと共に働き、私たちの科目に多くの時間を費していただいた
すべての講師、口答の指導者、チューターたち、中でもBill Siebert,
Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn Stein,
Peter Szolovitsに感謝します。現在はウェルズリーにいるFranklyn Turbakに、教育上の
際立った貢献について特に感謝します。彼の学部生向けの授業は、私たち皆が目指す基準を
打ち立てました。Jerry SaltzerとJim Millerには、私たちが並行性のミステリーに取り組むのを
手助けしてくださったことを感謝します。そしてPeter SzolovitsとDavid McAllesterには、
\link{Chapter 4}における非決定性評価の説明に対する貢献に感謝します。


多くの方々が、他大学でこの資料を紹介するのに大きな努力を費してくださいました。
中でも私たちが緊密に連携していたのは、イスラエル工科大学のJacob Katzenelson、
カリフォルニア大学アーバイン校のHardy Mayer、オックスフォード大学のJoe Stoy、
パデュー大学のElisha Sacks、ノルウェー技術科学大学のJan Komorowskiです。
私たちは、他大学にこの科目を適合させることで主要な教育の賞を受けた同僚たちを
非常に誇りに思います。この中には、イェール大学のKenneth Yip、カリフォルニア大学
バークリー校のBrian Harvey、コーネル大学のDan Huttenlocherが含まれます。


Al Moy\'eは、ヒューレット・パッカードの技術者にこの教材を教え、その講義を
ビデオテープにすることを手配してくれました。これらのビデオを使った生涯教育の
コースを計画し、世界中の大学や企業で教えた有能な講師たち、特に
Jim Miller, Bill Siebert, Mike Eisenbergに感謝します。


第一版の翻訳には、ほかの国の多くの教育者が多大な労力をつぎ込んでくれました。
Michel Briand, Pierre Chamard, and Andr\'e Picはフランス語版を、
Susanne Daniels-Heroldはドイツ語版を、元吉文男は日本語版を製作しました。
中国語版は誰が製作したのかわかりませんが、``無許可''翻訳の題材として
選ばれたことを光栄に思います。


私たちが教育目的で使用するSchemeシステムの開発に技術的な貢献をしたすべての方々の
名前を挙げることは困難です。Guy Steeleのほかに、主なウィザードには
Chris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas, Stephen Adamsがいます。
ほかに多大な時間を費やしてくれた方々は、Richard Stallman, Alan Bawden,
Kent Pitman, Jon Taft, Neil Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee,
George Carrette, Soma Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz,
Wayne Noss, Todd Cass, Patrick O'Donnell, Kevin Theobald, Daniel Weise,
Kenneth Sinclair, Anthony Courtemanche, Henry M. Wu, Andrew Berlin, Ruth Shyu です。


\acronym{MIT}の実装を越えて、私たちは\acronym{IEEE}のScheme標準仕様に
取り組んでくれた多くの人々に感謝したいと思います。その中には\( \rm R^4RS \)を編集した
William ClingerとJonathan Rees、\acronym{IEEE}標準を準備したChris Haynes, David Bartley,
Chris Hanson, Jim Millerが含まれます。


Dan Friedmanは、長い間Schemeコミュニティのリーダーでした。コミュニティの広範な仕事は
言語設計の問題を越えて、Schemer's Inc.によるEdSchemeをもとにした高校生向けカリキュラムや、
Mike EisenbergやBrian HarveyとMatthew Wrightによるすばらしい本のような、意義深い
教育上のイノベーションまで含みます。


私たちは、このコースをちゃんとした本にすることを助けてくれた方々、
特に\acronym{MIT}出版のTerry Ehling, Larry Cohen, Paul Bethgeに感謝します。
Ella Mazelはすばらしい表紙絵を見つけてくれました。第二版については、
特にこの本のデザインを助けてくれたBernardとEllaのMazel夫妻、非凡な{\TeX}ウィザードである
David Jonesに感謝します。私たちはまた、新しいドラフトに対して洞察力のあるコメントを
してくださった読者の方々、Jacob Katzenelson, Hardy Mayer, Jim Millerに感謝します。
そして特にBrian Harveyには、Julieが彼の本\textit{Simply Scheme}にしたのと同じような貢献を
返してくれたことを感謝します。


最後に、この作品を何年にもわたって支持してくれた団体に感謝します。その中には、
Ira GoldsteinとJoel Birnbaumが実現してくれたヒューレット・パッカードからの支持と、
Bob Kahnが実現してくれた\acronym{DARPA}からの支持を含みます。
%2014/09/21 10:41


%============================================================================================================
%\pagenumbering{arabic}

\mainmatter


\chapter{手続きを用いた抽象化の構築}
\label{Chapter 1}

\begin{quote}
心が単純な考えについてその力を発揮する活動は、主に次の3つです。1. 単純な考えをひとつの
合成物に組み合わせること。すべての複雑な考えはこれによってできています。2. 二番目は、
単純なものでも複雑なものでも、二つの考えをひとつの場所に並べて置き、それらをひとつに
結合することなしに同時に眺めることです。これによって、心は関係性についての考えを
得ることができます。3. 三番目は、その考えの実在に伴うほかのすべての考えから、
その考えを切り離すことです。これは抽象化と呼ばれ、これによってすべての一般概念と
いうものはできています。
---John Locke, \emph{An Essay Concerning Human Understanding} (1690)
\end{quote}

\vspace{1.0em}

\noindent
私たちは、\newterm{computational process}(\jnewterm{演算プロセス})について学ぼうと
しています。演算プロセスというのは抽象的な存在で、コンピュータの中に生息しています。
それらが進化するにつれ、プロセスは\newterm{data}(\jnewterm{データ})と呼ばれる
また別の抽象物を操作します。プロセスの進化は、\newterm{program}(\jnewterm{プログラム})
と呼ばれる規則のパターンによって指揮されています。プログラムを作るのは、プロセスを
指揮するためです。実質的に、私たちは呪文を使ってコンピュータの妖精に魔法をかけるのです。


演算プロセスは、魔法使いが妖精について考えることと似ています。それは、見たり触れたり
することはできません。そもそも、物質によって作られていないのです。それでも、それは
とてもリアルな存在です。知的な作業を行うことができます。質問に答えることができます。
銀行のお金を支出したり、工場でロボットの腕を操作したりすることで、世界に影響を与える
こともできます。私たちがプロセスに魔法をかけるのに使うプログラムとは、魔法使いの
呪文のようなものです。それは難解で深遠な\newterm{programming languages}
(\jnewterm{プログラミング言語})による記号的表現によって慎重に組み立てられ、
プロセスに実行させたいタスクを指示します。


演算プロセスは、正しく動くコンピュータでは、プログラムを正確かつ精密に実行します。
そのため、魔法使いの見習いのように、初心者プログラマは魔法のもたらす結果を理解し、
予測することを学ばなければいけません。プログラムのほんの小さな間違い
(普通、\newterm{bugs}(\jnewterm{バグ})や\newterm{glitches}(\jnewterm{グリッチ}、誤作動)と
呼ばれます)も、複雑な予期しない結果を引き起こすことがあるのです。


運のいいことに、プログラムを学ぶことは魔法を学ぶことに比べるとずっと安全です。
私たちが扱う妖精は、都合のいいことに安全な方法で封じ込まれているからです。
しかし、現実世界のプログラミングでは、注意力、専門知識、そして知恵が必要となります。
例えば、CAD(計算機による設計支援)プログラムの小さなバグが、飛行機やダムの
破滅的な崩壊を引き起こしたり、産業ロボットの自己破壊を起こしたりするのです。


達人ソフトウェアエンジニアは、プログラムを構築する能力があり、結果となるプロセスが
意図するタスクを実行してくれることにある程度自信を持つことができます。彼らは、
システムの動作を前もって思い描くことができます。プログラムを構造化して、
予期しない問題が破滅的な結果を引き起こさないようにする方法を知っています。
そして、問題が起こってしまったときには、プログラムを\newterm{debug}(\jnewterm{デバッグ}、
バグ取り)することができます。うまく設計されたコンピュータシステムは、うまく設計された
自動車や原子炉のように、モジュール化して設計されていて、部品が別々に作成、置き換え、
デバッグできるようになっています。


\subsubsection*{Lispプログラミング}


プロセスを記述するのには、適切な言語が必要です。この目的のために、私たちはプログラミング言語
Lispを使うことにします。私たちの日々の考えが普通自然言語(英語やフランス語や日本語など)
によって表現されるように、そして定量的な現象の記述が数学的記法によって表現されるように、
私たちの手続き的な思考はLispによって表現されます。Lispは1950年代の後半に、
\newterm{recursion equations}(\jnewterm{再帰方程式})と呼ばれるある種の論理表現についての
推論を定式化するものとして発明されたものです。この言語はJohn McCarthyにより考え出され、
彼の論文``記号式の再帰方程式とそれらの機械による演算''(\link{McCarthy 1960})に基づいています。

数学的な定式化としての生まれにもかかわらず、Lispは実用的なプログラミング言語です。
Lisp\newterm{interpreter}(\jnewterm{インタプリタ})はLisp言語によって記述された
プロセスを実行する機械です。最初のLispインタプリタは、\acronym{MIT}研究所の
人工知能部門の同僚、学生に手伝ってもらいながら、McCarthyが実装したものです。
\footnote{
\textit{Lisp 1 Programmer's Manual}は1960年に登場し、
\textit{Lisp 1.5 Programmer's Manual} (\link{McCarthy et al. 1965})は1962年に出版
されました。Lispの初期の歴史は、\link{McCarthy 1978}で説明されています。}
Lispという名前はLIst Processing(リスト処理)の頭文字で、記号微分や代数式の積分のような
プログラミング状の問題に取り組むための記号操作能力を提供するために設計されました。
この目的のために、アトムとリストとして知られる新しいデータオブジェクトを導入しています。
この特徴が、Lispがその時代のほかの言語から際立ったものとなっている最大の特徴です。


Lispは、一致協力した設計の努力によってできたものではありません。そうではなく、
ユーザの必要とすることや実用的な実装の検討事項に応えるものとして、実験的な
やり方で非公式に進化してきたものです。Lispの非公式な進化は何年も続き、Lispユーザの
コミュニティは伝統的に、この言語の``公式な''定義を公布しようとすることに抵抗して
きました。この進化が言語の柔軟性と元々のエレガントさとと組み合わさって、
広く使われている言語としては二番目に古い(これより古いのはFortranだけです)言語である
Lispはずっと適応を続け、プログラム設計についての最新の考えを含むようになっています。
このため、今ではLispは方言の集まりで、元々の特徴の多くを共通して持ちながらも、
それぞれ大きく違うこともあるものとなっています。この本で使う方言はSchemeと呼ばれる
ものです。
\footnote{
1970年代に主要なLispプログラムの大部分に用いられた2つの方言は、\acronym{MIT}のプロジェクト
\acronym{MAC}で開発されたMacLisp (\link{Moon 1978}; \link{Pitman 1983})と、
Bolt Beranek and Newman Inc.とXerox Palo Alto研究センターで開発された
Interlisp (\link{Teitelman 1974})でした。Portable Standard Lisp (\link{Hearn 1969};
\link{Griss 1981})、異なるマシンの間で簡単に移植できるように設計されたLisp方言です。
MacLispは、カリフォルニア大学バークレー校で開発されたFranz Lispや、
\acronym{MIT}人工知能研究所がLispをとても効率良く実行できるよう設計した
特定目的プロセッサ(処理機)に基づくZetalisp (\link{Moon and Weinreb 1981})といった、
いくつかの下位方言を生みました。この本で使用するLisp方言はSheme
(\link{Steele and Sussman 1975})と呼ばれ、1975年に
\acronym{MIT}人工知能研究所のGuy Lewis Steele Jr.とGerald Jay Sussmanにより開発され、
のちに\acronym{MIT}で教育目的で再実装されたものです。
Common Lisp方言(\link{Steele 1982}, \link{Steele 1990})は、初期のLisp方言の
機能を組み合わせ、Lispの業界標準を作るためにLispコミュニティにより開発されました。
Common Lispは1994年に\acronym{ANSI}標準(\link{ANSI 1994})になりました。
}


実験的な性質を持ち、また記号操作に重点を置いているため、初期のLispは数値計算に
ついては、非常に非効率なものでした。少なくとも、Fortranと比べるとそうでした。
しかし、年を経るにつれ、プログラムを機械語に変換して、十分効率的に数値計算を
実行できるようにするLispコンパイラが開発されるようになりました。それに、
特別な応用に対しては、Lispは非常に有効に使われています。
\footnote{
そのような特別な応用のひとつは、自然科学的に重要な計算のブレークスルー---
太陽系の運動についての積分の精度を二桁近く上げ、太陽系の力学はカオス的であることを
示した---でした。この計算は、新しい積分アルゴリズム、専用コンパイラ、そして
専用コンピュータによるものですが、これらはすべてLispによって書かれたソフトウェア
ツールの助けによって実装されたものです。(\link{Abelson et al. 1992}; \link{Sussman and Wisdom 1992})}
今でもLispは、絶望的に非効率的だという昔からの評判を乗り越えられていませんが、
今ではLispは効率が最優先事項ではない数多くの応用に使われています。例えば、
LispはOSのシェル言語や、エディタやCADシステムの拡張言語として選ばれるものに
なっています。


Lispがメインストリームの言語でないとしたら、なぜそれをプログラミングの考察のための
枠組みとして使うのでしょうか。それは、この言語が独特な特徴を持っているため、
プログラミングの重要な構成とデータ構造について学び、それらを支える言語的特性と
結びつけるのにとても便利な媒体だからです。これらの特性の中でも最も意義深いものは、
プロセスのLispによる記述(これは\newterm{procedure}(\jnewterm{手続き})と呼ばれます)が、
それ自身Lispのデータとして表され、操作できるということです。これが重要なのは、
``受動的な''データと``能動的な''プロセスという伝統的な区別を曖昧にする能力を使った
強力なプログラム設計のテクニックが存在するからです。これから見ていくように、Lispは
手続きをデータとして扱う柔軟性のおかげで、これらのテクニックを探求するのに最も
便利な言語のひとつになっています。
手続きをデータとして表現する能力は、コンピュータ言語を支えるインタープリタや
コンパイラのような、ほかのプログラムをデータとして操作しなければならないプログラムを
書くのにも、Lispをとても優れたものにしています。
また、これらの考慮点を越えて、Lispでのプログラミングはとても楽しいのです。


\section{プログラミングの要素}
\label{Section 1.1}


強力なプログラミング言語は、コンピュータにタスクの実行を指示する道具というだけでは
ありません。言語は、私たちがプロセスについて考えをまとめる枠組みとしても役に立ちます。
そのため、言語を記述する際には、簡単な考えを組み合わせてより複雑な考えを作るために
その言語が提供する手段に対して特別な注意を払う必要があります。強力な言語は、
これを達成するために、3つのメカニズムを持っています。


\begin{itemize}

\item \textbf{基本式}は、
言語に関わる最も単純な実体を表します。

\item \textbf{組み合わせ方法}は、複合要素をより単純なものから構築する方法です。

\item \textbf{抽象化方法}は、複合要素に名前をつけ、単体として扱うための方法です。

\end{itemize}

\noindent
プログラミングでは、二つの要素を扱います。それは、手続きとデータです。
(のちに、それらがそんなにはっきり分かれるものでないということが
わかってきます。)大雑把に言うと、データは``物''で、私たちが操作したいものです。
手続きは、データを操作するためのルールを記述したものです。そのため、
強力なプログラミング言語はすべて、基本的なデータや基本的な手続きを記述することができ、
また手続きとデータを組み合わせ、抽象化する方法を備えていなければなりません。


この章では、手続きを構築するルールに焦点を当てるため、単純な数値データのみを
扱うことにします。
\footnote{数値を``単純なデータ''と見なすのは白々しいごまかしです。
実際のところは、数値の扱いは、どんなプログラミング言語でもかなり
トリッキーで混乱を招く一面となっています。いくつかの典型的な問題は
次のようなものです。コンピュータシステムによっては、
2のような\newterm{integers}(\jnewterm{整数})と2.71のような
\newterm{real numbers}(\jnewterm{実数})を別物として扱います。
実数2.00は整数2とは違うのでしょうか。整数に使われる算術演算は、
実数に使われるものと同じものでしょうか。6を2で割ると、答えは3でしょうか、
それとも3.0でしょうか? どれだけ大きな数値まで表現できるのでしょうか。
小数点以下は何桁まで表すのでしょうか。整数の範囲は実数と同じでしょうか。
これらの問題の先には、もちろん、丸め誤差や切り捨て誤差に関する問題の山が
横たわっています。それは、数値解析の科学そのものです。この本での焦点は
大規模プログラム設計であり、数値計算のテクニックではないので、これらの
問題は無視することにします。この章での数値演算の例では、
非整数の演算では有限の小数点以下の精度を保つ算術演算を使い、
そのような場合に使われる通常の丸めの挙動が反映されています。}
後の章では、複合データを扱う手続きを構築するのにも、これらの同じルールが使えるという
ことを見ていきます。


\subsection{式}
\label{Section 1.1.1}


プログラミングを始める簡単な方法のひとつとして、LispのScheme方言の
インタプリタと対話をしてみて、その結果を調べるというやり方があります。
コンピュータターミナルの前に座っているところを想像してみてください。
あなたが\newterm{expression}(\jnewterm{式})を入力すると、インタプリタは
その式の\newterm{evaluation}(\jnewterm{評価})の結果を表示することによって
応答します。


タイプできる基本的な式のひとつとして、数値があります。
(より正確に言うと、あなたがタイプする式は、10進数の数値を表す数値からなります。)
Lispに次の数値を入力すると、

\begin{scheme}
486
\end{scheme}

\noindent
インタプリタは以下の内容を表示することで応答します。
\footnote{この本を通して、ユーザの入力とインタプリタが表示した応答との違いを強調したい場合、
傾いた文字で表します。}

\begin{scheme}
~\textit{486}~
\end{scheme}

\noindent
数値を表す式は、基本的な手続きを表す式(例えば\code{+} や \code{*})と組み合わせることで
複合式を作り、数値に対し手続きを適用することを表します。
例えば:

\begin{scheme}
(+ 137 349)
~\textit{486}~
\end{scheme}

\begin{scheme}
(- 1000 334)
~\textit{666}~
\end{scheme}

\begin{scheme}
(* 5 99)
~\textit{495}~
\end{scheme}

\begin{scheme}
(/ 10 5)
~\textit{2}~
\end{scheme}

\begin{scheme}
(+ 2.7 10)
~\textit{12.7}~
\end{scheme}

\noindent
このような式は、括弧の中の式のリストを区切ることにより作られ、手続きの適用を意味するもので、
\newterm{combinations}(\jnewterm{組み合わせ})と呼ばれます。リストの左端の要素は
\newterm{operator}(\jnewterm{オペレータ}、\jnewterm{演算子})と呼ばれ、
ほかの要素は\newterm{operand}(\jnewterm{オペランド}、被演算数)と呼ばれます。
組み合わせの値は、演算子によって指定された手続きを、オペランドの値である
\newterm{arguments}(\jnewterm{引数(ひきすう))})に適用することによって得られます。


演算子をオペランドの左に置くというやり方は、\newterm{prefix notation}
(\jnewterm{前置記法})として知られているものですが、数学で慣例となっている
やり方とは大幅に違うので、最初は混乱するかもしれません。しかし、前置記法には
いくつかの利点があります。その中のひとつは、任意の数の引数を取る手続きにも
対応できるということです。例を以下に示します。

\begin{scheme}
(+ 21 35 12 7)
~\textit{75}~
\end{scheme}

\begin{scheme}
(* 25 4 12)
~\textit{1200}~
\end{scheme}

\noindent
演算子はいつでも左端の要素で、組み合わせ全体は括弧で区切られているので、
曖昧さの入り込む余地はありません。


前置記法の二つ目の利点は、単純に拡張して、組み合わせを\textit{nested}(ネスト、入れ子)
させることができるということです。つまり、組み合わせの要素がそれ自身組み合わせであるような
ものが作れるということです。

\begin{scheme}
(+ (* 3 5) (- 10 6))
~\textit{19}~
\end{scheme}

\noindent
このようなネストや、Lispインタプリタが評価できる式の全体としての複雑性には
(原則的には)制限がありません。次のような、まだ比較的単純な式に出会った場合、
混乱してしまうのは私たち人間のほうです。

\begin{scheme}
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
\end{scheme}

\noindent
インタプリタは、迷うことなく57だと評価するでしょう。このような式は、
次のような形で書くことで、私たち自身にわかりやすいようにできます。

\begin{scheme}
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
\end{scheme}

\noindent
\newterm{pretty-printing}(\jnewterm{プリティプリント}、整形)として知られる
フォーマットの慣習は、オペランドが垂直に揃うようにそれぞれの長い組み合わせを
書くというものなのですが、上の式はそれに従って書いたものです。
結果として、字下げが明確に式の構造を示すことになります。
\footnote{Lispシステムは、普通はユーザが式を整形しやすいようにする機構を
持っています。その中でも特に役に立つものが二つあります。ひとつは、
改行のタイミングで自動的に正しいプリティプリントの位置にインデントするというもので、
もうひとつは右括弧が入力されるたびにマッチする左括弧をハイライトするというものです。}


複雑な式でも、インタプリタはいつでも同じ基本的なサイクルで動作します。
式を端末から読み、式を評価し、結果を表示するというものです。この操作モードは
よく、インタプリタの\newterm{read-eval-print loop}(REPL:\jnewterm{レプル})モードと
呼ばれます。特に、結果を表示することをインタプリタに明示的に指示しなくてもいいという
ところに注意してください。
\footnote{Lispは、すべての式は値を持つという慣習に従っています。この慣習と、
Lispは非効率的な言語であるという昔からの評判を組み合わせて、
Alan PerlisはOscar Wildeのセリフをもじった次のような皮肉を言っています。
``Lispプログラマはすべての値を知っているが、コストについては何も知らない''}


\subsection{命名と環境}
\label{Section 1.1.2}
プログラミング言語の重要な特徴のひとつは、コンピュータ上のオブジェクトを指すために
名前を利用する手段を提供してくれるということです。
このことを、\newterm{value}(\jnewterm{値})がそのオブジェクトである
\newterm{variable}(\jnewterm{変数})を名前によって特定すると言います。


LispのScheme方言では、\code{define}(定義)によって対象に名前をつけます。以下のように入力すると、

\begin{scheme}
(define size 2)
\end{scheme}

\noindent
インタプリタは\code{size}という名前と2という値を関連づけます。
\footnote{この本では、定義を評価した後にインタプリタが返す応答を示すことはしません。
それは実装に強く依存するからです。}
\code{size}という名前が一度2という数値にに関連付づられると、2という値を名前によって
参照することができるようになります。

\begin{scheme}
size
~\textit{2}~
\end{scheme}

\begin{scheme}
(* 5 size)
~\textit{10}~
\end{scheme}

\noindent
\code{define}の使い方をさらに見ていきましょう。

\begin{scheme}
(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))
~\textit{314.159}~
(define circumference (* 2 pi radius))
circumference
~\textit{62.8318}~
\end{scheme}

\noindent
\code{define}は、この言語の持つ抽象化方法のうち、最も単純なものです。
これによって、上で計算した\code{circumference}(円周)のような複合演算の
結果を簡単な名前で参照することができます。一般的に、コンピュータ上の
オブジェクトというものはとても複雑な構造を持っているので、使うたびに
その細かいところを思い出して打ち直さないといけないとしたら、とんでもなく
不便だったことでしょう。インタプリタでは、この名前とオブジェクトの関連づけを
一連の対話を通して少しずつ作っていくことができるので、このような段階的な
プログラムの構築に特に便利です。この特徴は、プログラムの開発・テストを
少しずつ進めていくのに向いていて、Lispプログラムが一般的に大量の比較的単純な
手続きから構成されるということの大きな理由となっています。


当然のことですが、インタプリタが値と記号を関連づけ、後から取り出すことが
できるということは、名前とオブジェクトのペアを記録しておくために何らかのメモリを
持っておかないといけません。このメモリは\newterm{environment}(\jnewterm{環境})と
呼ばれます。(より正確には、\newterm{global environment}(\jnewterm{グローバル環境})です。
後で学ぶように、演算には複数の異なる環境が使われることもあるからです。)
\footnote{\link{Chapter 3}では、
インタプリタがどのように動作しているかを理解するため、またインタプリタを実装するために、
この環境という概念がキーポイントになることを示します。}


\subsection{組み合わせの評価}
\label{Section 1.1.3}
この章の目標のひとつは、手続き的に考えるうえでの問題点を分解することです。
とりあえず、組み合わせを評価するにあたって、インタプリタはそれ自身、手続きに
従っているということを考えてみましょう。

\begin{quote}
組み合わせを評価するため、以下のことをを行います。

\begin{enumerate}

\item
組み合わせの部分式を評価する

\item
部分式の左端(演算子)の値となっている手続きを、引数(オペランド)、つまり
部分式の残り値に適用する

\end{enumerate}
\end{quote}

\noindent
こんな単純なルールからも、手続き一般についてのいくつかの重要なポイントがわかります。
一つ目のステップは、組み合わせに対する手続きを評価するには、組み合わせのそれぞれの
要素に対する評価手続きを先にやらないといけないということを示しています。
そのため、評価ルールは本質的に\newterm{recursive}(\jnewterm{再帰})的なものになります。
これは、ステップのひとつとして、そのルール自身を呼び出さないといけないということです。
\footnote{評価ルールによると、一つ目のステップの一部として、組み合わせの左端の要素を
評価しなければいけないことになります。このことを奇妙に思われるかもしれません。
この時点では、左端の要素というと、\code{+}や\code{*}といった、足し算やかけ算のような
組み込みの基本的な手続きを表す演算子でしかありえないからです。のちに、
演算子がそれ自身組み合わせ式であるような組み合わせを使うことが便利だということを
学びます。}


再帰という考えが、深くネストした組み合わせ式をどれだけ簡潔に表現できるかという
ところに注目してください。再帰がなければ、かなり複雑な手続きになるところです。
例えば、次の式の評価する場合について考えます。

\begin{scheme}
(* (+ 2 (* 4 6))
   (+ 3 5 7))
\end{scheme}

\noindent
この式を評価するには、4つの異なる組み合わせに対して評価ルールを適用する必要があります。
この手続きは、\link{Figure 1.1}のように組み合わせを木の形で表すことによって
イメージできます。それぞれの組み合わせはノードとして表され、そこから組み合わせの
演算子とオペランドに対応する枝が生えています。終端ノード(そこから生えている
枝のないノード)は、演算子か数字を表しています。評価を木という形で見ることで、
オペランドの値が終端ノードから始まってそれぞれのレベルで組み合わさりながら
上に向かって伝わっていく様子がイメージできます。一般的に、階層的な木のような
オブジェクトを扱うためには、再帰はとても強力なテクニックです。この
``値を上に向かって伝える''という形の評価ルールは、\newterm{tree accumulation}
(\jnewterm{木の蓄積})として知られています。


\begin{figure}[tb]
\phantomsection\label{Figure 1.1}
\centering
\begin{comment}
\heading{Figure 1.1:} Tree representation, showing the value of each subcombination.

\begin{example}
   390
   /|\____________
  / |             \
 *  26            15
    /|\           /|\
   / | \         // \\
  +  2  24      / | | \
        /|\    +  3 5  7
       / | \
      *  4  6
\end{example}
\end{comment}
\includegraphics[width=31mm]{fig/chap1/Fig1.1g.pdf}
\par\bigskip
\noindent
\heading{Figure 1.1:} 部分組み合わせの値を示した木表現
\end{figure}

次に、一つ目のステップを繰り返して適用することで、ある点で評価する対象が、
組み合わせではなく数値や組み込み演算子やその他の名前といった
基本式になるというところに注目してください。このような基本的な場合については、
以下のように規定することによって扱います。

\begin{itemize}

\item
数字の値は、それが示す値である

\item
組み込み演算子の値は機械語の列で、それに対応する操作を実行する

\item
その他の名前の値は、現在の環境でその名前に関連づけられたオブジェクトである

\end{itemize}

\noindent
二つ目のルールは、三つ目のルールの特殊なケースと考えることができます。
このことは、\code{+}と\code{*}といった記号もグローバル環境に含まれていて、
一連の機械語命令がそれらの``値''として関係付けられていると
規定することによって可能になります。ここでキーになるのは、式に出てくる記号の
意味を決めるうえで環境の果たす役割です。Lispのような対話的な言語では、
\code{(+ x 1)}という式の値について考えるのは、\code{x}という記号に意味を
付与する環境についての情報がなければ意味がありません。\code{+}という
記号に対しても、意味を付与するのは環境です。\link{Chapter 3}で学ぶように、
評価を行う文脈を提供する存在としての環境という一般的概念は、プログラムの
実行について理解するうえで重要な役割を果たしています。

上に書いた評価ルールは、定義については扱っていないということに注意してください。
例えば、\code{(define x 3)}を評価する際には、記号\code{x}の値と3という
二つの引数に\code{define}を適用するということはしません。\code{define}の目的は、
まさに記号\code{x}と値を関連づけるということだからです。
(つまり、\code{(define x 3)}は複合式ではないということになります。)

このような、一般的評価ルールに対する例外は、\jnewterm{特殊形式}と呼ばれます。
ここまでの範囲では、\code{define}は特殊形式の唯一の例ですが、ほかのものも
もうすぐ見ていくことになります。それぞれの特殊形式は、固有の評価ルールを
持っています。それらのいろいろな種類の式(それぞれ関連づけられた評価ルールを持つ)は、
プログラミング言語の構文を構成します。ほかの多くのプログラミング言語と比べると、
Lispはとても単純な構文を持っています。それは、式の評価ルールはひとつの
単純な一般ルールと少数の特殊な形に対する特殊ルールからなるということです。
\footnote{統一された書き方でも書けるものに対して、便利さのために別の表面構造を
持たせるような特殊な構文形式は、Peter Landinの造語を使って
\newterm{syntactic sugar}(\jnewterm{シンタックスシュガー})と呼ばれることがあります。
ほかの言語の使用者と比べると、Lispプログラマは一般に、構文の問題をあまり
気にしていません。(これと対照的なのがPascalです。何でもいいのでPascalのマニュアルを
開いて、どれだけのページが構文の記述に充てられているか見てみてください。)
このように構文を軽視しているのは、ひとつは表面的な構文を変えやすいLispの柔軟性のためです。
もうひとつは、多くの``便利な''構文構造が言語の統一性を損ない、プログラムが大きく
複雑になるにつれ利点よりも欠点のほうが多くなるという観察結果のためです。
Alan Perilの言葉を借りると、``シンタックスシュガーはセミコロン(コロン(直腸)とかけている)の癌を引き起こす''ということです。}


\subsection{複合手続き}
\label{Section 1.1.4}
ここまでで、強力なプログラミング言語であれば必ず持っているようないくつかの要素について、それがLispにもあることを見てきました。

\begin{itemize}

\item
数値は基本データで、算術演算は基本手続きです。

\item
組み合わせをネストすることで、演算を組み合わせることができます。

\item
定義は名前と値を関連づけ、抽象化のためにある程度役に立ちます。

\end{itemize}

\noindent
ここでは、\newterm{procedure definitions}(\jnewterm{手続きの定義})について学びます。
これははるかに強力な抽象化のテクニックで、複合演算に名前をつけ、それにひとつの単位として参照できるようにするというものです。


まずは、``二乗の計算''とはどのように表現できるかを考えてみましょう。
例えば、``何かを二乗するには、その何かにその何か自身をかける''のようになるでしょう。
これは、私たちの言語では次のように表すことができます。

\begin{scheme}
(define (square x) (* x x))
\end{scheme}

\noindent
これは、次のように理解できます。

\begin{example}
(define (square    x)         (*      x         x))
  |        |       |           |      |         |
 定義    二乗する  xを       かける  xを       xで.
\end{example}

\noindent
ここでは、\newterm{compound procedure}(\jnewterm{複合手続き})を作り、
それに\code{square}という名前をつけています。この手続きは、何かに
それ自身をかけるという演算を表しています。かける数には\code{x}という名前を
つけていますが、これは自然言語で代名詞が果たすのと同じ役割を果たしています。
この定義を評価すると、この複合手続きを作成し、それを\code{square}という名前と
関連づけています。
\footnote{ここで、二つの異なる操作が組み合わされていることに気をつけてください。
まず手続きを作成して、それに\code{square}という名前をつけています。
手続きを名前をつけずに作るということと、すでに作られている手続きに名前をつけることということの、
二つの概念を区別することは可能であり、重要なことでもあります。そのやり方については
\link{Section 1.3.2}で見ていきます。}


手続き定義の一般形式は以下の通りです。

\begin{scheme}
(define (~\( \dark \langle\kern0.08em \)~~\var{\dark 名前}~~\( \dark \kern0.03em\rangle \)~ ~\( \dark \langle \)~~\var{\dark 仮引数}~~\( \dark \kern0.02em\rangle \)~) 
  ~\( \dark \langle\kern0.08em \)~~\var{\dark 本体}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
\( \langle\hbox{\sl 名前}\kern0.08em\rangle \)は、環境の中で手続きに関連づける
記号です。
\footnote{この本全体を通して、式の一般的な構文について記述する際には、山括弧で
くくったイタリックの記号
---例えば、 \( \langle \)\var{name}\( \kern0.08em\rangle \)---を使って、
それらの式を実際に使うときに埋めなければならない``スロット''を表します。}
\( \langle\hbox{\sl 仮引数}\kern0.08em\rangle \)は、手続きの本体の中で
対応する引数を参照するために使う名前です。
\( \langle\hbox{\sl 本体}\kern0.08em\rangle \)は、その中に出てくる仮引数を
その手続きが適用される実際の引数で置き換えた場合に、手続き適用後の値を
返すような式です。
\footnote{もう少し一般化な言い方をすると、手続きの本体は式の列にもなりえます。
その場合、インタプリタは列のそれぞれの式を順番に評価し、最後の式の値を
手続き適用の値として返します。}
\( \langle \)\var{名前}\( \kern0.08em\rangle \)と
\( \langle \)\var{仮引数}\( \kern0.08em\rangle \)は、定義する手続きを
実際に呼び出すときと同じように、括弧でくくります。


\code{square}を定義したので、もうそれを使うことができます。

\begin{scheme}
(square 21)
~\textit{441}~
(square (+ 2 5))
~\textit{49}~
(square (square 3))
~\textit{81}~
\end{scheme}

\noindent
\code{square}は、ほかの手続きを定義するための構成部品として使うこともできます。
例えば、 \( x^2 + y^2 \)は次のように表現できます。

\begin{scheme}
(+ (square x) (square y))
\end{scheme}

\noindent
二つの数値が引数として与えられたときにその二乗の和を求める\code{sum\-/of\-/squares}
という手続きも、簡単に定義することができます。

\begin{scheme}
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
~\textit{25}~
\end{scheme}

\noindent
これで、\code{sum\-/of\-/squares}をさらに別の手続きの構成部品として使うこともできるようになります。

\begin{scheme}
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
(f 5)
~\textit{136}~
\end{scheme}

\noindent
複合手続きは、基本手続きとまったく同じように使うことができます。
実際に、上に書いた\code{sum\-/of\-/squares}の定義を見ても、
\code{square}が\code{+}や\code{*}のような組み込み手続きなのか、
複合手続きとして定義されたものなのか、見分けることはできないでしょう。


\subsection{手続き適用の置換モデル}
\label{Section 1.1.5}
演算子が複合手続きを指すような組み合わせを評価するときインタプリタは、
\link{Section 1.1.3}で説明した、演算子が基本手続きを指す組み合わせを評価する場合と
ほぼ同じような手順をたどります。つまり、インタプリタは組み合わせの各要素を評価し、
手続き(組合せの演算子の値)を引数(組合せのオペランドの値)に適用するということです。


基本手続きを引数に適用する仕組みは、インタプリタに組み込まれていると考えることができます。
複合手続きについては、その適用手順は次のようになります。

\begin{quote}
複合手続きを引数に適用するには、手続きの本体に出てくる仮引数を対応する引数で置き換えて、それを評価する。
\end{quote}


\noindent
この手順の例として、次の組み合わせを評価してみましょう。

\begin{scheme}
(f 5)
\end{scheme}

\noindent
ここで、\code{f}は\link{Section 1.1.4}で定義した手続きです。 まず、\code{f}の本体を取得することから始めます。

\begin{scheme}
(sum-of-squares (+ a 1) (* a 2))
\end{scheme}

\noindent
次に、仮引数である\code{a}を、引数5で置き換えます。

\begin{scheme}
(sum-of-squares (+ 5 1) (* 5 2))
\end{scheme}

\noindent
これによって、問題は二つのオペランドと\code{sum\-/of\-/squares}という演算子の
組み合わせの評価ということになります。
この組み合わせの評価は、三つの部分問題を持っています。適用する手続きを得るためには
演算子を評価する必要があり、引数を得るためには二つのオペランドを評価しなければ
なりません。ここで、\code{(+ 5 1)}の結果は6で、\code{(* 5 2)}の結果は10なので、
\code{sum\-/of\-/squares}という手続きを6と10に適用することになります。
これらの値によって\code{sum\-/of\-/squares}の本体に出てくる仮引数\code{x}と\code{y}を
置き換えて、次の式を得ます。

\begin{scheme}
(+ (square 6) (square 10))
\end{scheme}

\noindent
\code{square}の定義を使うと、これは次の式になります。

\begin{scheme}
(+ (* 6 6) (* 10 10))
\end{scheme}

\noindent
かけ算によって、次のようになります。

\begin{scheme}
(+ 36 100)
\end{scheme}

\noindent
そして、最終的には次のようになります。

\begin{scheme}
136
\end{scheme}

\noindent
ここまでで説明した手順は、手続き適用の\newterm{substitution model}(\jnewterm{置換モデル})
と呼ばれます。これは、この章に出てくる手続きに限ると、手続き適用の``意味''を
決めるモデルとして捉えることができます。しかし、二つ強調しておくことがあります。

\begin{itemize}

\item
置換の目的は、手続き適用について考えやすくするためのもので、インタプリタが
実際にどのように動いているかについて記述したものではありません。
インタプリタは普通、手続き適用の評価にあたって、手続きのテキストを操作して
仮引数を値で置き換えるということはしません。実際には、この``置換''は
仮引数のために局所環境を使うことによって実現します。このことについては、
\link{Chapter 3}と\link{Chapter 4}で、インタプリタの実装について詳しく調べながら
見ていきます。

\item
この本を通して、インタプリタの動作について、だんだん精巧になっていく一連の
モデルを提示していきます。最終的には、\link{Chapter 5}でインタプリタと
コンパイラの完全な実装にまで到達します。置換モデルは、これらのモデルの
最初のひとつ---評価手順について形式的に考えるための最初の一歩となるもの---
に過ぎません。一般に、科学や工学で現象をモデル化するときには、単純化した不完全な
モデルから始めます。物事を詳細に調べていくにつれ、これらの単純なモデルは
不適切になり、より精密なモデルで置き換えなければならなくなります。
置換モデルも例外ではありません。特に、\link{Chapter 3}で``可変データ''を持つ
手続きについて考える場合に、置換モデルが破綻してもっと複雑な手続き適用モデルによって
置き換えなければならないことがわかります。
\footnote{置換という考えは、置換手順の厳密な数学的定義をしようとすると
驚くほど複雑になるということがわかっています。この問題は、手続きの仮引数に
使われる名前と、手続きを適用する式で使われている(同じである可能性のある)名前とを
混同する可能性から来ています。実際に、論理学とプログラミング意味論の文献においては、
\jnewterm{置換}の間違った定義に関する長い歴史があります。
置換に関する精密な考察については、\link{Stoy 1977}を参照してください。}

\end{itemize}

\subsubsection*{適用順序と通常順序}
\link{Section 1.1.3}での評価の記述によると、インタプリタはまず演算子とオペランドを
評価し、評価結果として返される手続きを評価結果として返される引数に適用します。
これは、評価を行うための唯一のやり方ではありません。考えられるほかの評価モデルとしては、
値が必要になるまでオペランドを評価しないというものがあります。その代わりに、
まずオペランドの式を基本演算子しか出てこない式になるまで置き換えてから
評価を行います。この方法を使うと、\code{(f 5)}の評価は次のような展開の連続によって進みます。

\begin{scheme}
(sum-of-squares (+ 5 1) (* 5 2))
(+   (square (+ 5 1))      (square (* 5 2))  )
(+   (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
\end{scheme}

\noindent
それから、次のように簡約されます。


\begin{scheme}
(+      (* 6 6)      (* 10 10))
(+         36           100)
                136
\end{scheme}

\noindent
この方法でも前の評価モデルと同じ値が得られますが、手順が違います。
特に、こちらでは\code{(+ 5 1)}と\code{(* 5 2)}の評価がそれぞれ二回行われます。
これは、式\code{(* x x)}の\code{x}を、それぞれ\code{(+ 5 1)}と\code{(* 5 2)}で
置き換えることに対応しています。

この``完全に展開してから簡約する''というもうひとつの評価方法は、\jnewterm{通常順序評価}
として知られています。それに対して、インタプリタが実際に使っている
``引数を評価してから適用する''という方法は、\jnewterm{適用順序評価}と呼ばれます。
置換によってモデル化でき(この本の最初の二章の手続きはすべてそうです)、
かつ正当な値を返す手続き適用については、通常順序評価と適用順序評価は
同じ値になるということが証明できます。(通常順序評価と適用順序評価が
同じ値にならない``不当な''値の例については、\link{Exercise 1.5}を参照してください。)


Lispは適用順序評価を使っています。理由のひとつは、上で見た\code{(+ 5 1)} と \code{(* 5 2)}
のような複数回の評価を避けることによる性能の向上です。そして、もっと大きな理由としては、
置換によってモデル化できる手続きの範囲を超えると通常順序評価がとても複雑になるという
ことがあります。一方で、通常順序評価は非常に価値のあるツールにもなりえます。
そのことについては、\link{Chapter 3} と \link{Chapter 4}で一部見ていきます。
\footnote{\link{Chapter 3}では\jnewterm{ストリーム処理}を導入します。これは、
限定された形の通常順序評価を組み入れることで、``無限''に見えるデータ構造を
扱うという手法です。\link{Section 4.2}では、Schemeインタプリタに手を加え、
Schemeの通常順序バージョンを作成します。}


\subsection{条件式と述語}
\label{Section 1.1.6}

この時点で私たちが定義できる種類の手続きは、表現力がとても乏しいものです。
というのは、検査を行う方法がなく、また検査の結果によって異なる演算を行う
ということもできないからです。例えば、次のようなルールに従って、
数値が正か負かゼロかを検査して絶対値を求めるという手続きを定義することはできません。
\begin{comment}

\begin{example}
      /
      |   x  if x > 0
|x| = <   0  if x = 0
      |  -x  if x < 0
      \
\end{example}

\end{comment}
\begin{displaymath}
 |x| = \left\{ \begin{array}{r@{\quad \mathrm{if} \quad}l}	 	 
        x  &  x > 0, \\
	0  &  x = 0, \\
  \!\! -x  &  x < 0. \end{array} \right. 
\end{displaymath}
この構造は\newterm{case analysis}(\jnewterm{場合分け})と呼ばれるもので、Lispには
そのような場合分けを記述するための特殊な形式があります。それは\code{cond}
(``conditional''(条件的)の略)と呼ばれ、次のように使います。

\begin{scheme}
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
\end{scheme}

\noindent
条件式の一般形式は以下の通りです。

\begin{scheme}
(cond (~\( \dark \langle{p_1}\kern0.08em\rangle \)~ ~\( \dark \langle{e_1}\kern0.08em\rangle \)~)
      (~\( \dark \langle{p_2}\kern0.08em\rangle \)~ ~\( \dark \langle{e_2}\kern0.08em\rangle \)~)
      ~\( \dots \)~
      (~\( \dark \langle{p_n}\kern0.08em\rangle \)~ ~\( \dark \langle{e_n}\kern0.08em\rangle \)~))
\end{scheme}

\noindent
これは、記号\code{cond}に続く、\newterm{clause}(\jnewterm{節})と呼ばれる括弧でくくった式の
ペアの列によって構成されます。節の形式は次のようになります。

\begin{scheme}
(~\( \dark \langle{p}\kern0.08em\rangle \)~ ~\( \dark \langle{e}\kern0.08em\rangle \)~)
\end{scheme}

\noindent
それぞれのペアの最初の式は、\newterm{predicate}(\jnewterm{述語})---値が真か偽の
どちらかとして解釈される式---です。
\footnote{``真か偽のどちらかとして解釈される''とは、以下のことを意味します。
Schemeでは、二つの特殊な値が存在し、\code{\#t}、\code{\#f}という定数として
表されます。インタプリタが述語の値をチェックするとき、\code{\#f}を偽として
解釈します。ほかの値はすべて真として扱われます。(つまり、論理的に言うと
\code{\#t}を定義する必要はないところですが、あったほうが便利です。)
この本では、\code{\#t}と\code{\#f}にそれぞれ関連づけた名前として、
\code{true}と\code{false}を使います。
}


条件式は、次のように評価されます。まず、述語\( \langle{p_1}\kern0.08em\rangle \)が評価されます。
もしその値が偽なら、\( \langle{p_2}\kern0.08em\rangle \)が評価されます。
もし\( \langle{p_2}\kern0.08em\rangle \)の値も偽なら、次は\( \langle{p_3}\kern0.08em\rangle \)が
評価されます。この手順は、値が真である述語が見つかるまで続きます。見つかると、インタプリタは
その節に対応する\newterm{consequent expression}(\jnewterm{結果式})
\( \langle{e}\kern0.08em\rangle \)の値を返します。
\( \langle{p}\kern0.08em\rangle \)がどれも真でない場合、\code{cond}の値は未定義となります。


\jnewterm{述語}という単語は、真か偽のどちらかに評価される式だけでなく、真か偽の
どちらかを返す手続きについても使われます。絶対値の手続き\code{abs}は、
\code{>}, \code{<}, \code{=}という基本述語を使っています。
\footnote{\code{abs}は、このほかに``マイナス''演算子\code{-}も使っています。
これは、\code{(- x)}のようにオペランドをひとつ取り、符号の反転を表します。}
これらは、二つの数値を引数として取り、最初の数が二番目の数に比べて
大きいか、小さいか、同じかという検査を行い、その結果に従って真か偽かを返すというものです。


絶対値の手続きは、次のように書くこともできます。

\begin{scheme}
(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))
\end{scheme}

\noindent
これは、日本語で言うと``もし\( x \)がゼロより小さいければ\( -x \)を返す。
そうでなければ\( x \)を返す''となります。\code{else}は特殊な記号で、
\code{cond}の最後の節の\( \langle{p}\kern0.08em\rangle \)
の代わりに使うことができます。これを使うと、それまでのすべての節がスキップされた
ときに、これに対応する\( \langle{e}\kern0.08em\rangle \)を\code{cond}の値として
返すようにできます。実は、値が常に真として評価される式であれば何でも、
ここの\( \langle{p}\kern0.08em\rangle \)として使うことができます。


次は、また別の絶対値の手続きの書き方です。

\begin{scheme}
(define (abs x)
  (if (< x 0)
      (- x)
      x))
\end{scheme}

\noindent
ここでは、\code{if}という特殊形式を使っています。これは、場合分けがちょうど二つの場合から
なる場合に使える、制約付きの条件式です。\code{if}式の一般形式は以下の通りです。


\begin{scheme}
(if ~\( \dark \langle\kern0.07em \)~~\var{\dark predicate}~~\( \dark \kern0.06em\rangle \)~ ~\( \dark \langle\kern0.07em \)~~\var{\dark consequent}~~\( \dark \kern0.05em\rangle \)~ ~\( \dark \langle\kern0.06em \)~~\var{\dark alternative}~~\( \dark \kern0.06em\rangle \)~)
\end{scheme}

\noindent
\code{if}式を評価するにあたって、インタプリタは最初に
式の\( \langle \)\var{predicate}\( \kern0.08em\rangle \)の部分を評価します。
もし\( \langle \)\var{predicate}\( \kern0.08em\rangle \)の評価結果が真である場合、
インタプリタは\( \langle \)\var{consequent}\( \kern0.08em\rangle \)を評価し、その値を返します。
そうでなければ\( \langle \)\var{alternative}\( \kern0.08em\rangle \)を評価し、その値を返します。
\footnote{\code{if} と \code{cond}のちょっとした違いとして
\code{cond}の各節の\( \langle{e}\kern0.08em\rangle \)は式の列であってもいいという
ことがあります。対応する\( \langle{p}\kern0.08em\rangle \)が真になる場合、
\( \langle{e}\kern0.08em\rangle \)内の式は順番に評価され、
列の最後の式の値が\code{cond}の値として返されます。しかし、\code{if}式の中では
\( \langle \)\var{consequent}\( \kern0.08em\rangle \)と
\( \langle \)\var{alternative}\( \kern0.08em\rangle \)は単一の式でなければなりません。}


\code{<}や\code{=}, \code{>}のような基本述語に加えて、複合述語を構築するための
論理複合演算というものがあります。
次の三つは、最もよく使われるものです。

\begin{itemize}

\item
\( \hbox{\tt(and }\langle{e_1}\rangle\;\;\dots\;\;\langle{e_n}\rangle\hbox{\tt)} \)

インタプリタは式\( \langle{e}\kern0.08em\rangle \)を左から右にひとつずつ評価します。
\( \langle{e}\kern0.08em\rangle \)のどれかが偽と評価されると、
\code{and}式の値は偽となり、残りの\( \langle{e}\kern0.08em\rangle \)は評価されません。
すべての\( \langle{e}\kern0.08em\rangle \)が真と評価されると、\code{and}式の値は
最後の式の値になります。

\item
\( \hbox{\tt(or }\langle{e_1}\rangle\;\;\dots\;\;\langle{e_n}\rangle\hbox{\tt)} \)

インタプリタは式 \( \langle{e}\kern0.08em\rangle \)を左から右にひとつずつ評価します。
\( \langle{e}\kern0.08em\rangle \)のどれかが真と評価されると、その値が\code{or}式の
値として返され、残りの\( \langle{e}\kern0.08em\rangle \)は評価されません。
すべての\( \langle{e}\kern0.08em\rangle \)が偽と評価されると、\code{or}式の値は
偽となります。

\item
\( \hbox{\tt(not }\langle{e}\rangle\hbox{\tt)} \)

\code{not}式の値は、式\( \langle{e}\kern0.08em\rangle \)が偽と評価される場合は真になり、
そうでなければ偽となります。

\end{itemize}

\noindent
\code{and}と\code{or}が特殊形式で、手続きではないということに注意してください。
これは、部分式がすべて評価されるとは限らないからです。\code{not}は通常の手続きです。


これらをどのように使うかというひとつの例として、数値\( x \)が\( 5 < x < 10 \)という値域に
あるかという条件を次のように表現することができます。

\begin{scheme}
(and (> x 5) (< x 10))
\end{scheme}

\noindent
もうひとつの例として、ある数値がもうひとつの数値と比べて等しいかより大きいかということを
検査する述語を、以下のように定義することができます。

\begin{scheme}
(define (>= x y) (or (> x y) (= x y)))
\end{scheme}

\noindent
または、次のように書くこともできます。

\begin{scheme}
(define (>= x y) (not (< x y)))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.1}Exercise 1.1:}
以下の一連の式について、それぞれの式に対するインタプリタの応答として
表示される結果はどうなるか。式の列は、下記に示した順に評価されるとする。

\begin{scheme}
10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (> b a) (< b (* a b)))
    b
    a)
\end{scheme}

\begin{scheme}
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
\end{scheme}

\begin{scheme}
(+ 2 (if (> b a) b a))
\end{scheme}

\begin{scheme}
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.2}Exercise 1.2:} 以下の式を前置記法に書き換えよ。
\begin{comment}

\begin{example}
5 + 4 + (2 - (3 - (6 + 4/5)))
-----------------------------
       3(6 - 2)(2 - 7)
\end{example}

\end{comment}
\begin{displaymath}
{5 + 4 + (2 - (3 - (6 + {4\over5})))\over3(6 - 2)(2 - 7)}\,.
\end{displaymath}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.3}Exercise 1.3:} 三つの数値を引数として取り、
そのうち大きいほうから二つの数値の二乗の和を返す手続きを定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.4}Exercise 1.4:} 我々の評価モデルでは、
演算子が複合式であるような組み合わせが作れるということを観察せよ。
この観察結果を使って、次の手続きのふるまいを説明せよ。


\begin{scheme}
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.5}Exercise 1.5:} Ben Bitdiddleは、
自分が対面しているインタプリタが適用順序評価と通常順序評価のどちらを使っているかを
調べるテストを発明した。彼は、以下の2つの手続きを定義する。

\begin{scheme}
(define (p) (p))
(define (test x y)
  (if (= x 0) 0 y))
\end{scheme}



それから、以下の式を評価する。

\begin{scheme}
(test 0 (p))
\end{scheme}



適用順序評価を使うインタプリタでは、Benはどのようなふるまいを観察するだろうか。
通常順序評価を使うインタプリタでは、どのようなふるまいを観察するだろうか。
あなたの回答を説明せよ。(特殊形式である\code{if}の評価ルールは、
インタプリタが適用順序評価でも通常順序評価でも同じであると仮定せよ。
述語式が最初に評価され、その結果によってconsequentとalternativeの
どちらを評価するかが決まる。)


\end{quote}

\subsection{例: ニュートン法による平方根}
\label{Section 1.1.7}


ここまでで見てきた通り、手続きは普通の数学の関数にとても似ています。
どちらも、ひとつ以上の引数によって決定される値を記述します。
しかし、数学の関数とコンピュータの手続きの間には、ひとつの
重要な違いがあります。手続きは、実効的なものでなければなりません。


一例として、平方根を計算問題について考えてみましょう。
square-root関数は、以下のように定義できます。
\begin{comment}

\begin{example}
sqrt(x) = the y such that y >= 0 and y^2 = x
\end{example}

\end{comment}
\begin{displaymath}
\sqrt{x}\;\; = {\rm\;\; the\;\;} y 
{\rm\;\; such\;\; that\;\;} y \ge 0 {\rm\;\; and\;\;} y^2 = x.
\end{displaymath}
これは、完全に正当な数学関数です。これを使って、ある数値がほかの数値の平方根かどうか
わかりますし、平方根というもの全般についての事実を導出することもできます。
一方で、この定義は手続きを記述するものではありません。ある数値の平方根を
実際にどうやって求めるかということについては、ほとんど何も教えてくれません。
この定義をLispっぽく書き換えてもどうにもなりません。

\begin{scheme}
(define (sqrt x)
  (the y (and (>= y 0) 
              (= (square y) x))))
\end{scheme}

\noindent
これは、ただの循環論法です。


関数と手続きの違いは、物事の属性について説明することと、
どうやって物事を行うかについて説明することの一般的な違いを反映したものです。
これは、宣言的知識と命令的知識の違いと言われることもあります。
数学では普通、宣言的な(何であるか)記述が関心の対象ですが、コンピュータサイエンスでは
普通、命令的な(どうやるか)記述が関心の対象です。
\footnote{宣言的記述と命令的記述は、数学とコンピュータサイエンスのように
密接に関係しています。例えば、プログラムによって計算された答えが``正しい''か
どうかを決めるには、そのプログラムについての宣言的な文を作ります。
これまでに、プログラムの正しさを証明する技術を確立することを目的とした膨大な量の
研究がありますが、このテーマの技術的な難しさは、命令的な文(それによってプログラムを
構築する)と宣言的な文(物事を推理する)との間の移行について、うまく折り合いをつける
ということに関するものです。関連する話として、プログラミング言語設計の
現在の重要な領域のひとつは、いわゆる超高水準言語についての調査です。
そのような言語では、宣言的な文によって実際にプログラミングを行います。
その発想となるものは、インタプリタを十分に高性能なものにして、
``何であるか''という知識がプログラマによって与えられると、``どうやるか''に
ついての知識を自動的に生成できるようにしようというものです。
これは一般的には不可能ですが、進歩のある重要な領域もあります。
この発想については、\link{Chapter 4}で再度触れることにします。
}


平方根は、どうやって計算するのでしょうか。最も一般的な方法は、
ニュートンの逐次近似法を使うというものです。それによると、
数値\( x \)の平方根の推定値として\( y \)があるとき、
\( y \)と\( x / y \)の平均を取るという単純な操作を行うことで
より良い推定値(実際の平方根により近い値)が得られます。
\footnote{この平方根アルゴリズムは、実際にはニュートン法の特殊なケースです。
ニュートン法は、方程式の根を求めるための一般的な技法です。平方根アルゴリズム自体は、
アレキサンドリアのヘロンにより\acronym{A.D.}1世紀に開発されたものです。
一般的なニュートン法をどのようにLispの手続きとして表すかについては、
\link{Section 1.3.4}で見ていきます。}
例えば、2の平方根は以下のように計算できます。
推定値の初期値を1とします。

\begin{smallexample}
推定値    商                     平均
1         (2/1) = 2              ((2 + 1)/2) = 1.5
1.5       (2/1.5) = 1.3333       ((1.3333 + 1.5)/2) = 1.4167
1.4167    (2/1.4167) = 1.4118    ((1.4167 + 1.4118)/2) = 1.4142
1.4142    ...                    ...
\end{smallexample}

\noindent
この手順を続けると、平方根の近似解をどんどん良くしていくことができます。


さて、この手順を手続きという形で定式化してみましょう。まず、
被開平数(平方根を計算したい数値)と推定値から始めます。
推定値が目的に十分な程度によければ、そこで終わりです。
そうでなければ、改善した推定値を使って手順を繰り返す必要があります。
この基本戦略を、次のような手続きとして書きます。

\begin{scheme}
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
\end{scheme}

\noindent
推定値を改善するには、古い推定値と、被開平数を古い推定値で割ったものとの平均を取ります。

\begin{scheme}
(define (improve guess x)
  (average guess (/ x guess)))
\end{scheme}

\noindent
averageは以下のように定義します。

\begin{scheme}
(define (average x y)
  (/ (+ x y) 2))
\end{scheme}

\noindent
ここで、``十分によい''ということの定義も決める必要があります。
次の方法は説明のためには十分ですが、本当はあまりよいテストではありません。
(\link{Exercise 1.7}を参照してください)その発想は、答えの二乗と被開平数の差が
事前に決めておいた許容誤差(ここでは0.001とします)よりも小さくなるぐらいに
答えが近くなるまで、答えの改善を続けるというものです。
\footnote{普通述語には、述語であるということがわかりやすいように、
疑問符で終わる名前をつけます。これはただのスタイル上の慣例です。
インタプリタにとっては、疑問符はただの通常の文字です。}

\begin{scheme}
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
\end{scheme}

\noindent
最後に、始めるための方法が必要です。例えば、任意の数値の平方根について、1という
推定値を与えることもできます。
\footnote{推定値の初期値を1ではなく1.0と表現していることに注意してください。
多くのLispの実装では、この二つの間に何の違いもありません。
しかし、\acronym{MIT} Schemeは整数と小数を区別し、整数同士の割り算は小数ではなく
有理数を返します。例えば、10を6で割ると5/3になりますが、10.0を6.0で割ると
1.6666666666666667になります。(有理数の演算をどのように実装するかについては、
\link{Section 2.1.1}で学びます。)もしsquare-rootプログラムの初期推定値を1として、
\( x \)が整数である場合、square-rootの計算でその後生成される値はすべて、
小数ではなく有理数になります。有理数と小数の混合演算は常に小数になるので、
初期推定値を1.0として始めると、その後計算される値はすべて強制的に小数になります。}

\begin{scheme}
(define (sqrt x)
  (sqrt-iter 1.0 x))
\end{scheme}

\noindent
これらの定義をインタプリタに入力すると、\code{sqrt}をほかの手続きと同じように
使えるようになります。

\begin{scheme}
(sqrt 9)
~\textit{3.00009155413138}~

(sqrt (+ 100 37))
~\textit{11.704699917758145}~

(sqrt (+ (sqrt 2) (sqrt 3)))
~\textit{1.7739279023207892}~

(square (sqrt 1000))
~\textit{1000.000369924366}~
\end{scheme}

\noindent
\code{sqrt}プログラムは、ここまでで紹介した単純な手続き型言語が、
例えばCやPascalで書けるようなものであれば、どんな純粋な数値計算のプログラムでも
書けるということを示しています。これにはびっくりされるかもしれません。
この言語には、コンピュータに何かを繰り返し実行させる繰り返し(ループ)の構造を
含めていないのですから。それに対して\code{sqrt\-/iter}は、繰り返しを達成することは
手続きを呼ぶという通常の能力だけでできるということの実例となっています。
\footnote{繰り返しを実装するために手続き呼び出しを使うことの効率の問題について
心配されている読者の方は、\link{Section 1.2.1}の``末尾再帰''についての説明を見てください。}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.6}Exercise 1.6:} Alyssa P. Hackerは、なぜ
\code{if}が特殊形式として提供される必要があるのか理解できなかった。
``\code{cond}を使って普通の手続きとして定義したらいいんじゃないの''と彼女は質問した。
Alyssaの友達であるEva Lu Atorは、これは実際にできると主張し、\code{if}の新しいバージョンを
定義した。

\begin{scheme}
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
\end{scheme}

EvaはAlyssaにプログラムのデモを行った。

\begin{scheme}
(new-if (= 2 3) 0 5)
~\textit{5}~
(new-if (= 1 1) 0 5)
~\textit{0}~
\end{scheme}

喜びながら、Alyssaは\code{new\-/if}を使ってsquare-rootプログラムを書き直した。

\begin{scheme}
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
\end{scheme}


Alyssaが平方根の計算するのにこれを使おうとすると、何が起こるだろうか。説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.7}Exercise 1.7:}
平方根の計算に使った\code{good\-/enough?}テストは、とても小さい数値の平方根を
求めるのにはあまり効率的ではないだろう。また、実際のコンピュータでは、数値演算
はほとんど必ず有限の有効数字で行われることになる。この問題があるので、
とても大きい数に対しては、我々のテストは不適切なものになる。これらの言明について、
小さい数と大きい数でテストがうまくいかない例を使って説明せよ。\code{good\-/enough?}
を実装するためのもうひとつの戦略としては、\code{guess}が繰り返しごとにどれだけ変化するかを
確認して、差分が推定値に対してとても小さいものになったら止めるというものもある。
これは、小さい数値や大きい数値に対して、よりうまくいくだろうか。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.8}Exercise 1.8:} 立方根に対する
ニュートン法は、\( y \)が\( x \)の立方根の近似値である場合、次の値によって
よりよい近似を求めることができるという事実に基づいている。
\begin{comment}

\begin{example}
x/y^2 + 2y
----------
    3
\end{example}

\end{comment}
\begin{displaymath}
{{x / y^2} + 2y\over 3}.
\end{displaymath}
この式を使って、square-rootと同じような仕組みのcube-root手続きを実装せよ。
(\link{Section 1.3.4}では、これらのsquare-rootとcube-rootを抽象化したものとして、
一般的なニュートン法をどのように実装するかを見ていきます。)
\end{quote}

\subsection{ブラックボックス抽象化としての手続き}
\label{Section 1.1.8}


\code{sqrt}は、相互に定義された手続きのセットとして定義されるプロセスの最初の例です。
\code{sqrt\-/iter}の定義が\newterm{recursive}(\jnewterm{再帰的})であることに
注意してください。再帰的というのは、手続きがそれ自身を使って定義されているということです。
手続きを定義するのにその手続き自身を使えるという考えには不安になるかもしれません。
そんな``循環的な''定義が意味を持つのかわからないし、そんなものでコンピュータが実行できるような
明確に定義されたプロセスを記述できるのかというところがはっきりしないように思えるかも
しれません。このことについては、\link{Section 1.2}でもっと詳しく見ていくことにします。
ここでは、\code{sqrt}の例からわかる、ほかのいくつかの重要な点について考えてみましょう。


平方根を計算するという問題が、自然にいくつかの部分問題に分解されているということに
注意してください。推定値が十分によいかどうやって判断するか、どうやって推定値を
改善するか、などです。これらのタスクは別々の手続きによって成し遂げられます。
\code{sqrt}プログラム全体は、\link{Figure 1.2}に示すような手続きの塊として
見ることができます。この構造は、問題を部分問題に分解する様子を反映しています。

\begin{figure}[tb]
\phantomsection\label{Figure 1.2}
\centering
\begin{comment}
\heading{Figure 1.2:} Procedural decomposition of the \code{sqrt} program.
\end{comment}
\begin{example}
                       sqrt
                        |
                    sqrt-iter
                    /       \
            good-enough    improve
              /     \          \
          square    abs      average
\end{example}

\begin{quote}
\heading{Figure 1.2:} \code{sqrt}プログラムの手続き分解
\end{quote}
\end{figure}

この分解戦略の重要な点は、プログラムを部品に分けるというだけのことではありません。
分けるだけなら、どんな大きなプログラムでも分解はできます---最初の10行、次の10行、
その次の10行、といったやり方で。そうではなく、重要なのは、それぞれの手続きが
特定のタスクを成し遂げていて、それがほかの手続きを定義する際にもモジュールとして
使えるようになっているということなのです。例えば、\code{good\-/enough?}手続きを
\code{square}を使って定義するとき、\code{square}手続きは``ブラックボックス''と
見なせます。その時点では、その手続きが\strong{どうやって}結果を計算するのかには
関心がありません。関心があるのは、それが二乗を計算するという事実だけです。
二乗がどのように計算されるかという詳細は隠しておいて、後で考えることにすることが
できます。実際、\code{good\-/enough?}手続きに関しては、\code{square}は手続きというより
手続きを抽象化したもの、いわゆる\jnewterm{抽象手続き}と考えることができます。
この抽象レベルでは、二乗を計算するものであればどんな手続きでも同じことです。


そのため、返り値だけを考えると、二乗を計算する以下の二つの手続きは区別不可能である
べきです。どちらもひとつの数値を引数として取り、その数値の二乗を返り値として
生成します。\footnote{どちらの手続きがより効率的な実装であるかということさえ、
はっきりとはわかりません。それは利用できるハードウェアによります。機械によっては、
``自明な''実装が非効率的なものになることもあります。対数と逆対数の巨大なテーブルを
非常に効率的に格納している機械があると考えてみるのもよいでしょう。}

\begin{scheme}
(define (square x) (* x x))
(define (square x) (exp (double (log x))))
(define (double x) (+ x x))
\end{scheme}

\noindent
ですから、手続き定義は詳細を隠せるようになっていなければなりません。手続きを使う人は
自分でその手続きを書いたのではなく、別のプログラマからブラックブックスとして取得した
のかもしれないのです。手続きを使う人が、それがどうやって実装されているかについての
知識を求められるべきではありません。


\subsubsection*{ローカル名}


手続きを使う人が気にしないでいいようになっていなければならない実装上の詳細としては、
手続きを実装した人が仮引数の名前に何を選んだかということがあります。
そのため、次の二つの手続きは区別不可能であるべきです。


\begin{scheme}
(define (square x) (* x x))
(define (square y) (* y y))
\end{scheme}

\noindent
この原則---手続きの意味はその作者が使った仮引数の名前とは独立であるべきということ---は、
ちょっと見ると自明なことのように思えますが、その影響範囲は広範にわたります。最も単純な
影響としては、手続きの仮引数の名前は手続き本体にローカルなものであるべきだということです。
例えば、平方根手続きの中で、\code{good\-/enough?}の定義に\code{square}を使いました。

\begin{scheme}
(define (good-enough? guess x)
  (< (abs (- (square guess) x))
     0.001))
\end{scheme}

\noindent
\code{good\-/enough?}の作者の意図は、第一引数の二乗が第二引数と比べて
許容差の範囲であるかを決定するということです。\code{good\-/enough?}の作者が、
第一引数を参照するのに\code{guess}という名前を使い、第二引数を参照するのに\code{x}
という名前を使っていることがわかります。\code{square}の引数は\code{guess}です。
\code{square}の作者が(上の例のように)その引数を参照するのに\code{x}を使った場合、
\code{good\-/enough?}の\code{x}は\code{square}の\code{x}とは別の\code{x}でなければならない
ということがわかります。手続き\code{square}の実行は、\code{good\-/enough?}で使われている
\code{x}の値に影響を与えてはいけません。その\code{x}の値は、\code{square}が計算を終えた後にも
\code{good\-/enough?}に必要かもしれないからです。


仮引数がそれぞれの手続きの本体にローカルでなかったとすると、\code{square}の
仮引数\code{x}は、\code{good\-/enough?}の仮引数\code{x}と混同される可能性があるので、
\code{good\-/enough?}のふるまいが、どのバージョンの\code{square}を利用するかに
依存することになります。つまり、\code{square}は私たちが望むようなブラックボックスでは
なくなるでしょう。


手続きの仮引数は、その名前が何であってもかまわないという点で、手続きの定義に
とても特別な役割を果たしています。そのような名前は\newterm{bound variable}
(\jnewterm{束縛変数})と呼ばれ、手続き定義は仮引数を\newterm{bind}(\jnewterm{束縛})すると
いった言い方をします。束縛変数が手続き定義の中で一貫性を持って改名された場合、
手続きの意味は変わりません。
\footnote{一貫性のある改名という概念は、実際には扱いにくく、形式的な定義が難しいものです。
有名な論理学者たちも、この点について恥ずかしい間違いを犯してきました。}
もし変数が束縛されていなければ、それは\newterm{free}(\jnewterm{自由})であると言います。
束縛によって名前が定義される式のセットは、その名前の\newterm{scope}(\jnewterm{スコープ})と
呼ばれます。手続き定義においては、その手続きの仮引数として宣言された束縛変数は、
その手続きの本体をスコープとして持っています。


上記の\code{good\-/enough?}の定義の中で、\code{guess}と\code{x}は束縛変数ですが、
\code{<}, \code{-}, \code{abs}, \code{square}は自由変数です。\code{good\-/enough?}の
\code{guess}と\code{x}の代わりにどんな名前を選んだとしても、それらが
\code{<}, \code{-}, \code{abs}, \code{square}と違うもので区別可能である限り、
\code{good\-/enough?}の意味とは独立しています。(仮に、\code{guess}を\code{abs}と
改名したとすると、変数\code{abs}を\newterm{capturing}(\jnewterm{キャプチャ})
するというバグを入れてしまったことになります。そうすると、\code{abs}が自由変数から
束縛変数に変わってしまいます。)
しかし、\code{good\-/enough?}の意味は、それが使う自由変数の名前と独立ではありません。
その意味は、記号\code{abs}が数値の絶対値を求める手続きを指しているという(この定義の外部の)
事実に実際に依存しています。\code{good\-/enough?}の定義の中で、\code{abs}を
\code{cos}によって置き換えたとすると、違う関数を計算することになります。


\subsubsection*{内部定義とブロック構造}


ここまでで、名前を分離する方法を一種類手に入れました。手続きの仮引数はその手続きの
本体にローカルになるというものです。square-rootプログラムは、名前の使い方を
コントロールするやり方をもうひとつ示してくれます。現在のプログラムは、次のような
別々の手続きからなります。

\begin{scheme}
(define (sqrt x)
  (sqrt-iter 1.0 x))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
(define (improve guess x)
  (average guess (/ x guess)))
\end{scheme}

\noindent
このプログラムの問題は、\code{sqrt}を使う人にとって重要な手続きは\code{sqrt}だけだということです。
ほかの手続き(\code{sqrt\-/iter}, \code{good\-/enough?}, \code{improve})は余計なもので、集中を
妨げるだけです。また、平方根プログラムと組み合わせて動かす別のプログラムの部品として
\code{good\-/enough?}という手続きを定義することもできなくなります。\code{sqrt}が使っているからです。
この問題は、個別に働く多くのプログラマによって大きなシステムを構築する際に、特に深刻な
ものになります。例えば、数値演算手続きの大きなライブラリを作るときに、多くの数値関数は
逐次近似法で計算され、そのために補助手続きとして\code{good\-/enough?}や\code{improve}といった
手続きを持っているかもしれません。ここは、サブ手続きを局所化して\code{sqrt}の中に隠し、
\code{sqrt}がほかの逐次近似法の手続き(それぞれ自分のプライベートな\code{good\-/enough?}手続きを
持っている)と共存できるようにしたいところです。これを可能にするために、手続きがローカルな
内部定義を持てるようにします。例えば、平方根プログラムは次のように書けます。

\begin{scheme}
(define (sqrt x)
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess x) (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))
\end{scheme}

\noindent
このような定義のネストは\newterm{block structure}(\jnewterm{ブロック構造})と呼ばれます。
これは、基本的には最も単純な名前パッケージング問題の正しい解決方法です。しかし、ここには
もっといいアイデアが隠れています。補助手続きの定義を内部化することに加えて、それらを
単純にすることもできます。\code{x}は\code{sqrt}に束縛されているので、\code{sqrt}の
内部で定義された\code{good\-/enough?}, \code{improve}, \code{sqrt\-/iter}は\code{x}の
スコープ内にあります。つまり、\code{x}をこれらの手続きに明示的に渡す必要はないということです。
そうする代わりに、次に示すように内部定義では\code{x}を自由変数にします。そうすると、\code{x}の
値は、それを囲む手続きである\code{sqrt}の引数から取ってくることができます。このような規定は
\newterm{lexical scoping}(\jnewterm{レキシカルスコーピング})と呼ばれます。
\footnote{レキシカルスコーピングにおいては、手続きの自由変数はその手続きを包む手続き定義の
束縛を参照すると規定します。つまり、手続きが定義された環境での探索が行われるということです。
Chapter 3で、環境とインタプリタの詳細なふるまいについて学ぶときに、この仕組みがどう働くのか
詳細に見ていくことにします。
}

\begin{scheme}
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
\end{scheme}

\noindent
この本では、大きなプログラムを扱いやすい部品に分割しやすいように、ブロック構造を
どんどん使っていきます。
\footnote{組み込み定義は、手続き本体の最初に来なければなりません。
定義とその使用をごちゃごちゃに混ぜたようなプログラムの実行については責任を負いかねます。}
ブロック構造という考え方は、プログラミング言語Algol 60に端を発します。
ブロック構造はほとんどの先進的なプログラミング言語に存在し、大きなプログラムの
構築を体系化するための重要なツールとなっています。


\section{手続きとそれが生成するプロセス}
\label{Section 1.2}


ここまでで、プログラミングの要素について考えてきました。基本的な算術演算を使い、
その演算を組み合わせ、その組み合わせた演算を複合手続きと定義して抽象化を行いました。
しかし、それだけではプログラミングのやり方を知っているとは言えません。私たちの状況は、
チェスの駒がどう動くかというルールを覚えたものの、定跡や戦術、戦略については何も知らない
人と同じです。チェスの初心者のように、そのドメイン内でのよくあるパターンについてまだ
知らないということです。私たちは、どの手を指すのがいい手なのか(どの手続きを定義するのが
いいのか)という知識を持っていません。指し手(手続きの実行)の結果を予想する経験も
足りません。


考慮中のアクションについて結果を思い描く能力は、達人プログラマになるために決定的に
重要なことです。統合的・創造的な活動であれば、何でもそうです。例えば、
熟練した写真家になるためには、シーンの見方を学び、露出と現像の条件の選び方によって
それぞれ領域がどれだけの濃さで写真に表れるかを学ばなければなりません。そうすることによって
初めて、望む効果を得るためにはフレーム、光の当て方、現像などをどのように計画すればいいかを
逆算することができるようになるのです。それはプログラミングでも同じことです。
プログラミングにおいては、プロセスが取るべき処理の流れを計画し、プログラムという手段で
プロセスをコントロールします。達人になるためには、さまざまなタイプの手続きが生み出す
プロセスを思い描けるようになる必要があります。そのようなスキルを身につけて初めて、
望むふるまいをするプログラムを確実に構築できるようになるのです。


手続きは、計算プロセスの\newterm{local evolution}(\jnewterm{局所展開})のための
パターンです。それは、プロセスの各段階が、どのように前の段階の上に構築される
かを記述するものです。プロセスの局所展開は手続きによって記述されるものですが、
できればプロセスの全体的なふるまい、別の言い方をすると\newterm{global}
(\jnewterm{グローバル})なふるまいについても何か言えるようになりたいところです。
これは、一般的にはとても難しいことです。
しかし、プロセスの展開のよくあるパターンについての説明を試みるぐらいはできるでしょう。


この節では、単純な手続きによって作られたプロセスの、いくつかの一般的な``形''について
見ていきます。また、これらのプロセスが時間や空間といった重要な計算リソースをどういった
比率で消費していくのかについても調べていきます。ここで考える手続きはとても単純なものです。
これは、写真撮影でテストパターンが果たす役割と同じ役割を果たしています。つまり、
独立した実用的な例というよりは、極度に単純化したプロトタイプパターンです。


\subsection{線形再帰と反復}
\label{Section 1.2.1}


始めに、階乗関数について考えることから始めましょう。定義は次の通りです。
\begin{comment}

\begin{example}
n! = n * (n - 1) * (n - 2) ... 3 * 2 * 1
\end{example}

\end{comment}
\begin{displaymath}
n! = n \cdot (n - 1) \cdot (n - 2) \cdots 3 \cdot 2 \cdot 1.
\end{displaymath}
階乗を計算する方法は数多くあります。ひとつの方法は、任意の正の整数
\( n \)に対して、\( n! \)は\( n \)と\( (n - 1)! \)をかけたものと
等しいということを利用したものです。
\begin{comment}

\begin{example}
n! = n * [(n - 1) * (n - 2) ... 3 * 2 * 1] = n * (n - 1)!
\end{example}

\end{comment}
\begin{displaymath}
n! = n \cdot [(n - 1) \cdot (n - 2) \cdots 3 \cdot 2 \cdot 1] = n \cdot (n - 1)!.
\end{displaymath}
そのため、\( (n - 1)! \)を計算し、その答えに\( n \)をかけることで\( n! \)を計算することが
できます。そこに1!は1に等しいという規定を加えると、このことは直接手続きに変換できます。

\begin{scheme}
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
\end{scheme}

\noindent
この手続きが6!の計算を実行する様子を観察するのに、\link{Section 1.1.5}の置換モデルを
使うことができます。そうすると、\link{Figure 1.3}のようになります。

\begin{figure}[tb]
\phantomsection\label{Figure 1.3}
\centering
\begin{comment}
\heading{Figure 1.3:} A linear recursive process for computing 6!.

\begin{example}
(factorial 6)        ----------------
(* 6 (factorial 5))                   \
(* 6 (* 5 (factorial 4)))               \
(* 6 (* 5 (* 4 (factorial 3))))           \
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))       \
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))             /
(* 6 (* 5 (* 4 (* 3 2))))                 /
(* 6 (* 5 (* 4 6)))                     /
(* 6 (* 5 24))                        /
(* 6 120)                           /
720          <---------------------
\end{example}
\end{comment}
\includegraphics[width=82mm]{fig/chap1/Fig1.3c.pdf}
\par\bigskip
\noindent
\heading{Figure 1.3:} 6!を求めるための線形再帰プロセス
\end{figure}

ここで、階乗計算を別の角度から見てみましょう。\( n! \)の計算ルールとして、最初に
1×2を行い、それから答えに3をかけ、それから4をかけ、nまで続けるというものに決める
こともできます。もう少し形式的に書くと、計算中の積と、1から\( n \)まで数え上げていく
カウンタとの両方を保存するということです。計算については、次のルールに従って
カウンタと積がステップごとに同時に変化するというように記述できます。

\begin{scheme}
product ~\( \dark \gets \)~ counter * product
counter ~\( \dark \gets \)~ counter + 1
\end{scheme}

\noindent
そして、\( n! \)とはカウンタが\( n \)を越えた時点での積の値であると規定します。


\begin{figure}[tb]
\phantomsection\label{Figure 1.4}
\centering
\begin{comment}
\heading{Figure 1.4:} A linear iterative process for computing 6!.

\begin{example}
(factorial 6)   -----.
(fact-iter   1 1 6)  |
(fact-iter   1 2 6)  |
(fact-iter   2 3 6)  |
(fact-iter   6 4 6)  |
(fact-iter  24 5 6)  |
(fact-iter 120 6 6)  |
(fact-iter 720 7 6)  V
720
\end{example}
\end{comment}
\includegraphics[width=36mm]{fig/chap1/Fig1.4c.pdf}
\par\bigskip
\noindent
\heading{Figure 1.4:} 6!を求めるための線形反復プロセス
\end{figure}


ここでまた、問題の記述を階乗計算の手続きとして書き直します。
\footnote{実際のプログラムでは、前の節で紹介したブロック構造を使って
\code{fact\-/iter}の定義を隠すところです。

\begin{smallscheme}
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
\end{smallscheme}

ここでは、一度に考えることを最小限にするためにそうしませんでした。}


\begin{scheme}
(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
\end{scheme}

\noindent
前回と同じく、6!の演算プロセスを視覚化するために置換モデルを使い、\link{Figure 1.4}として示します。


2つのプロセスを比べてみましょう。ある観点からは、ほとんど違いがないように見えます。
どちらも、同じ定義域の同じ数学関数を計算しています。\( n! \)を求めるのに\( n \)に
比例したステップ数が必要だという点も同じです。それどころか、どちらのプロセスも
同じ順番のかけ算を行い、同じ順番で部分積を得ます。一方で、プロセスの``形''について考えると、
これらがまったく違う展開の仕方をしていることがわかります。

一つ目のプロセスについて考えてみましょう。置換モデルは、\link{Figure 1.3}の矢印で
示されるような、展開に続く収縮という形を表しています。展開は、プロセスが
\newterm{deferred operations}(\jnewterm{遅延演算})の連鎖(ここではかけ算の連鎖)を構築する際に
起こります。収縮は、演算が実際に行われる際に起こります。
遅延演算の連鎖によって特徴付けられるこのタイプのプロセスは、
\newterm{recursive process}(\jnewterm{再帰プロセス})と呼ばれます。このプロセスを実行するには、
インタプリタは後で実行する演算について記録しておく必要があります。\( n! \)の計算では、
遅延乗算の連鎖の長さ、またそれを記録するために必要な情報の量は、\( n \)に対して線形に
(\( n \)に比例して)増加します。ステップ数も、同じように線形に増加します。
このようなプロセスは、\newterm{linear recursive process}(\jnewterm{線形再帰プロセス})と呼ばれます。


それとは対照的に、二つ目のプロセスは伸びたり縮んだりしません。各ステップで記録しておく
必要があるのは、どんな\( n \)に対しても、変数\code{product}, \code{counter}, \code{max\-/count}
の現在の値だけです。これは\newterm{iterative process}(\jnewterm{反復プロセス})と呼びます。
一般的に、反復プロセスとは状態が限られた数の\newterm{state variables}(\jnewterm{状態変数})に
集約されるようなプロセスです。それに、プロセスの状態が変化するとともに状態変数が
どのように更新されるかという固定したルールと、どのような条件でプロセスを停止するかを
定めた(必須ではない)終了テストが加わります。\( n! \)の計算では、必要なステップ数は
\( n \)に対して線形に増加します。このようなプロセスは、
\newterm{linear iterative process}(\jnewterm{線形反復プロセス})と呼ばれます。


この二つのプロセスの違いは、別の見方もできます。反復プロセスの場合、プログラムの変数は
どの時点でもプロセスの状態を完全に記述しています。ステップの間で計算を止めたとして、
計算を再開するのに必要なのは、三つのプログラム変数の値をインタプリタに与えることだけです。
再帰プロセスではそうはいきません。この場合、インタプリタに保持されていてプログラム変数には
含まれていない、いくつかの``隠された''情報が追加で存在し、遅延演算の連鎖を扱ううえで
``プロセスがどの地点にいるか''を指し示しています。連鎖が長くなると、保持するべき情報も
それにつれて大きくなります。
\footnote{\link{Chapter 5}でレジスタマシン上での手続きの実装について考えるとき、
再帰プロセスはどんなものであっても、固定のレジスタセットを持ち
補助メモリを持たない機械として``ハードウェアで''実現できるということを見ていきます。
それに対し、再帰プロセスを実現するには\newterm{stack}(\jnewterm{スタック})として知られる
補助的なデータ構造が必要です。}


反復と再帰を比較する際に、再帰\jnewterm{プロセス}という概念と再帰\jnewterm{手続き}
という概念を混同しないように気をつける必要があります。手続きについて再帰と言うときは、
その手続きの定義が(直接または間接的に)その手続き自身を参照しているという
構文的事実を指しています。しかし、プロセスが例えば線形再帰パターンになっていると言う場合は、
どのようにプロセスが展開するかということであって、手続きがどのように書かれているかという
構文の問題ではありません。\code{fact\-/iter}のような再帰手続きについて、それが
反復プロセスを生成すると言うのは、ちょっと気になるかもしれません。しかし、このプロセスは
実際に反復的です。状態は三つの状態変数によって完全に表され、プロセスを実行するために
インタプリタは三つの変数を記録しておくだけで十分です。


プロセスと手続きの区別が厄介なのは、一般的な言語(AdaやPascal、C言語を含む)のほとんどの実装では、
再帰手続きの解釈には必ず手続き呼び出しの回数に比例してメモリを消費するように設計されているから
です。その手続きが原理的に反復的である場合であっても、そうなってしまいます。その結果、
そのような言語では、反復手続きを記述するには専用の``ループ構造''に頼らなければなりません。
\code{do}, \code{repeat}, \code{until}, \code{for}, \code{while}などがその例です。
\link{Chapter 5}で考えるSchemeの実装には、この欠点がありません。反復プロセスは、
再帰手続きとして記述されていても、固定の空間で実行できます。この性質を持った実装は
\newterm{tail-recursive}(\jnewterm{末尾再帰})と呼ばれます。末尾再帰の実装では、
反復は普通の手続き呼び出しメカニズムを使って表現できるので、特別な反復構造は必要なく、
シンタックスシュガーとして役に立つ程度です。
\footnote{末尾再帰は、コンパイラの最適化トリックとして長い間知られてきました。
Carl \link{Hewitt (1977)}は、末尾再帰に一貫した意味論上の基礎を与えました。
その説明は、``メッセージパッシング''という計算モデルによるもので、それについては
\link{Chapter 3}で考察します。これに影響を受けて、Gerald Jay SussmanとGuy Lewis Steele Jr.
(\link{Steele and Sussman 1975}参照)はSchemeのための末尾再帰インタプリタを構築しました。
Steeleは後に、末尾再帰が手続き呼び出しを自然にコンパイルすることの結果であることを示しました
(\link{Steele 1977})。Schemeの\acronym{IEEE}規格は、Schemeの実装が末尾再帰であることを
要求しています。}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.9}Exercise 1.9:} 次の二つの手続きは、
どちらも\code{inc}, \code{dec}という手続きによって二つの正の整数を加算する方法を定義している。
手続き\code{inc}は引数を1増やし、\code{dec}は引数を1減らす。

\begin{scheme}
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))
\end{scheme}


置換モデルを使って、それぞれの手続きが\code{(+ 4 5)}の際に生成するプロセスを図示せよ。
これらのプロセスは反復だろうか、それとも再帰だろうか。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.10}Exercise 1.10:} 次の手続きは、
アッカーマン関数と呼ばれる数学の関数を計算する。

\begin{scheme}
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
\end{scheme}


以下の式の値は何になるか。

\begin{scheme}
(A 1 10)
(A 2 4)
(A 3 3)
\end{scheme}


\code{A}が上で定義された手続きであるとき、以下の手続きについて考えよ。

\begin{scheme}
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
\end{scheme}


手続き\code{f}, \code{g}, \code{h}によって、正の整数\( n \)に対して計算される関数に
対し、簡潔な数学的定義を与えよ。例えば、\code{(k n)}は\( 5n^2 \)を計算する。

\end{quote}


\subsection{木の再帰}
\label{Sec. 1.2.2}
\label{Section 1.2.2}
計算するうえでよく使われるパターンとして、ここでは新たに
\newterm{tree recursion}(\jnewterm{木の再帰})を紹介します。
例として、フィボナッチ数列の計算について考えてみましょう。
この数列では、それぞれの数値はその直前にある二つの数値の合計になっています。

\begin{comment}
0, 1, 1, 2, 3, 5, 8, 13, 21, \( \dots \)
\end{comment}
\begin{displaymath}
 0,\; 1,\; 1,\; 2,\; 3,\; 5,\; 8,\; 13,\; 21,\; \dots. 
\end{displaymath}
一般に、フィボナッチ数は次のようなルールで定義できます。
\begin{comment}

\begin{example}
         /
         |  0                        if n = 0
Fib(n) = <  1                        if n = 1
         |  Fib(n - 1) + Fib(n - 2)  otherwise
         \
\end{example}

\end{comment}
\begin{displaymath}
 {\rm Fib}(n) = 
\begin{cases}	
        \; 0 & {\rm if} \;\; n=0, \\
	\; 1 & {\rm if} \;\; n=1, \\
	\; {\rm Fib}(n-1) + {\rm Fib}(n-2) \quad & {\rm otherwise}. 
\end{cases} 
\end{displaymath}
この定義は、フィボナッチ数列を計算する再帰手続きに直接変換できます。

\begin{scheme}
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
\end{scheme}

\noindent
この計算のパターンについて考えてみます。\code{(fib 5)}を計算するには、\code{(fib 4)}と
\code{(fib 3)}を計算します。\code{(fib 4)}を計算するには、\code{(fib 3)}と
\code{(fib 2)}を計算します。一般に、展開されたプロセスは、\link{Figure 1.5}で示すように
木のような形をしています。枝は、(底以外の)それぞれのレベルで二つに分かれています。
これは、\code{fib}手続きが呼ばれるたびに自身を二回呼び出すということを反映しています。


この手続きは、木の再帰のプロトタイプになっていますので、学習のためには役に立ちます。
しかし、フィボナッチ数を計算する方法としてはひどいものです。余計な計算が多すぎるからです。
\link{Figure 1.5}で、\code{(fib 3)}の計算が---それは全体の半分ぐらいの仕事ですが---
完全に重複してしまっていることがわかるでしょうか。さらに言うと、この手続きが
\code{(fib 1)}や\code{(fib 0)}を計算する回数(一般に、上記の木の中での葉の数)が
正確にFib(\( n+1 \))になることは簡単に示せます。このやり方がどれだけひどいかということは、
Fib(\( n \))の値が\( n \)に対して指数的に増えるということを考えればわかるでしょう。
より正確には、Fib(\( n \))は\( \varphi^n / \sqrt{5} \)に最も近い整数になります(\link{Exercise 1.13}参照)。\( \varphi \)は次の値です。
\begin{comment}

\begin{example}
[phi] = (1 + [sqrt]5)/2 ~= 1.6180
\end{example}

\end{comment}
\begin{displaymath}
\varphi = {1 + \sqrt{5}\over2} \approx 1.6180 
\end{displaymath}
\( \varphi \)は\newterm{golden ratio}(\jnewterm{黄金比})で、次の等式を満たします。
\begin{comment}

\begin{example}
[phi]^2 = [phi] + 1
\end{example}

\end{comment}
\begin{displaymath}
\varphi^2 = \varphi + 1. 
\end{displaymath}

\begin{figure}[tb]
\phantomsection\label{Figure 1.5}
\centering
\begin{comment}
\heading{Figure 1.5:} The tree-recursive process generated in computing \code{(fib 5)}.

\begin{example}

                   ..<............ fib5   <.......... 
                ...     ___________/  \___________   .  
             ...       /       . .....            \    . 
           ..       fib4     .        . . . .     fib3  .  
         ..     ____/. \____  ..             .  __/  \__  .  
       ..      /  . .  ..   \    .        ..   /  . .   \   . 
     ..     fib3 .       .  fib2 .        . fib2 .   .  fib1 .
   ..      / . \  .     .   /  \  .      .  /  \ ...  .  |  .
 ..       / . . \   .  .   /  . \   .  .   / .  \   .  . 1 .
.      fib2 . . fib1.  .fib1 .  fib0 . .fib1. . fib0 .  .  .
.      /  \  . . |  .  . |  .  . |   . . |   . . |   .   .>
V     /  . \   . 1  .  . 1  .  . 0  .  . 1  .  . 0  ..
.  fib1 .. fib0..  .   .   .   .   .   V   .   ..  . 
.   |  .  . |  . .>     .>.     . .    ..>.      .>
.   1 .   . 0  .      
 .   .     .  .       
  .>.       ..        

\end{example}
\end{comment}
\includegraphics[width=90mm]{fig/chap1/Fig1.5c.pdf}
\begin{quote}
\heading{Figure 1.5:} \code{(fib 5)}の計算時に生成される木の再帰プロセス
\end{quote}
\end{figure}

そのため、このプロセスのステップ数は、入力に対して指数的に増加します。一方で、
必要な空間は入力に対して線形にしか増加しません。計算のどの時点でも、木の中で
上にあるノードだけを記録しておけばいいからです。一般に、木の再帰のプロセスで
必要なステップ数は木のノード数に比例し、必要な空間は木の最大の深さに比例します。


フィボナッチ数の計算は、反復プロセスとして定式化することもできます。
考え方は、\( a \)と\( b \)という整数のペアを使い、Fib(1) = 1, Fib(0) = 0と初期化して、
次の変換を同時に適用することを繰り返すというものです。
\begin{comment}

\begin{example}
a <- a + b
b <- a
\end{example}

\end{comment}
\begin{displaymath}
% \eqalign{a &\gets a + b, \cr 
% b &\gets a. \cr}
\begin{array}{l@{\quad\gets\quad}l}
  a & a + b, \\ 
  b & a.
\end{array}
\end{displaymath}
この変換を\( n \)回適用した後、\( a \)と\( b \)がそれぞれFib(\( n+1 \))とFib(\( n \))に
等しくなるということは簡単に示せます。つまり、以下の手続きによって、
フィボナッチ数を反復的に計算できるということです。

\begin{scheme}
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
\end{scheme}

\noindent

こちらの、Fib(\( n \))を計算する二つ目の方法は線形反復です。二つの方法で必要なステップ数の
違いは---ひとつは\( n \)に対して線形、もうひとつはFib(\( n \))そのものと同じ割合---
小さな入力でも、とても大きなものになります。


このことから、木の再帰のプロセスが役に立たないと結論づけてはいけません。数値ではなく、
階層的な構造を持つデータを操作するプロセスについて考える場合、木の再帰は自然で強力な
ツールだということがわかります。
\footnote{\link{Section 1.1.3}では、この例がちらっと出ていました。インタプリタ自身、
式を評価するのに木の再帰のプロセスを使っています。}
しかし、数値演算の場合であっても、木の再帰のプロセスはプログラムを理解し、設計するのに
役に立ちます。例えば、一つ目の\code{fib}手続きは二つ目よりずっと非効率的ですが、
ずっと素直な書き方で、ほとんどフィボナッチ数列の定義をLispに変換しただけのようなものです。
反復アルゴリズムを定式化するのは、計算が三つの状態変数を使った反復として書き直せることに
気づく必要があります。

\subsubsection*{例: 両替パターンの計算}

反復的フィボナッチアルゴリズムを思いつくには、ほんのちょっとの工夫で十分でした。
それに対して、次の問題を考えてみてください。1ドルを両替するやり方はいくつあるでしょうか。
使うのは、50セント、25セント、10セント、5セント、1セントのコインです。より一般的には、
任意の金額に対して、両替のパターン数を計算する手続きを書くことはできるでしょうか。


この問題には、再帰手続きによる簡単な解き方があります。使えるコインの種類が、
何らかの決まった順番を持つとしましょう。すると、次の関係が成り立ちます。


\( n \)種類のコインを使って金額\( a \)を両替するやり方のパターン数は、以下の合計となる。

\begin{itemize}

\item
一つ目の種類のコイン以外のすべての種類のコインを使って金額\( a \)を両替するやり方のパターン数。

\item
\( n \)種類の硬貨すべてを使って、金額\( a - d \)を両替するやり方のパターン数。\( d \)は、一つ目の種類のコインの額面とする。

\end{itemize}

\noindent
どうしてこれが言えるのかを考えるには、両替のやり方が二つのグループに分けられることに
注目します。一つ目の種類のコインを使わないものと、使うものです。そのため、ある金額に
対する両替のパターン数は、一つ目の種類のコインを使わないでその金額を両替するやり方の数と、
一つ目の種類のコインを使って両替するやり方の数の合計になります。しかし、後者のパターン数は、
最初の種類のコインを一枚使った後の、残りの金額に対する両替のパターン数と等しくなります。


このようにすると、ある金額に対する両替の問題を、より小さな金額をより少ない種類のコインで
両替する問題に再帰的に小さくしていくことができます。この小さくするルールを注意深く考えてみて、
次の単純な場合について決めておけば、それがアルゴリズムの記述に使えるということを
確認してください。
\footnote{例えば、10セントの両替を5セントと1セントを使って行う場合、小さくするルールが
どのように適用されるか、詳細にやってみてください。}

\begin{itemize}

\item
もし\( a \)がちょうど0なら、両替パターンは1と数える。

\item
もし\( a \)が0未満なら、両替パターンは0と数える。

\item
もし\( n \)が0なら、両替パターンは0と数える。

\end{itemize}

\noindent
この記述は、再帰手続きに簡単に翻訳できます。

\begin{scheme}
(define (count-change amount) (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination 
                         kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
\end{scheme}

\noindent
(\code{first\-/denomination}手続きは、利用可能な硬貨の種類の数を入力として、
一つ目の種類のコインの額面を返します。ここでは、硬貨は額面の大きなものから小さなものという
順番で並んでいるとしていますが、どのような順番でも同じようにうまくいきます)
これで、1ドルの両替という元々の質問に答えることができます。

\begin{scheme}
(count-change 100)
~\textit{292}~
\end{scheme}

\noindent
\code{count\-/change}は、\code{fib}の一つ目の実装同様、冗長な木の再帰のプロセスを生成します
(292の計算にはかなりの時間がかかるでしょう)。一方で、答えを計算するためのよりよい
アルゴリズムをどう設計するかというのは自明ではありません。この問題は、読者への宿題とします。
木の再帰のプロセスはとても非効率になりうるものの、記述と理解が簡単であることが多いので、
``賢いコンパイラ''を設計して、木の再帰のプロセスを同じ結果を計算するより効率的な手続きに
変換できるようにしたら両者のいいとこ取りができるんじゃないかという提案がされています。
\footnote{冗長な計算に対処するひとつのアプローチは、値が計算されるときに自動的にテーブルが
構築されるようにするというものです。ある引数に手続きを適用するよう要求されるたびに、
まずその値がすでにテーブルに格納されているか確認します。格納されていれば、冗長な計算を
実行しないようにします。この戦略は、\newterm{tabulation}(\jnewterm{テーブル化})や
\newterm{memoization}(\jnewterm{メモ化})として知られるもので、素直に実装することができます。
テーブル化は、(\code{count\-/change}のような)指数的なステップ数の必要なプロセスを、
必要な時間と空間が入力に対して線形に増加するプロセスに変換するのにも時々使われます。
\link{Exercise 3.27}参照。}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.11}Exercise 1.11:} 関数\( f \)は次のように定義される。

\begin{displaymath}
f(n) = 
\begin{cases} 
\;\; n \quad \text{if \; \( n < 3 \),} \\ 
\;\; f(n-1) + 2\kern-0.08em f(n-2) + 3\kern-0.08em f(n-3) \quad \text{if \; \( n \ge 3 \).}
\end{cases}
\end{displaymath}

\( f \)を演算する手続きを再帰プロセスによって書け。また、\( f \)を演算する手続きを
反復プロセスによって書け。
\end{quote}

\newpage

\begin{quote}
\heading{\phantomsection\label{Exercise 1.12}Exercise 1.12:} 以下の数値のパターンは
\newterm{Pascal's triangle}(\jnewterm{パスカルの三角形})と呼ばれる。

\begin{example}
        1
      1   1
    1   2   1
  1   3   3   1
1   4   6   4   1
      . . .
\end{example}


三角形の辺の数値は全て1で、三角形内部の数値は、それぞれその上にある2つの数値の合計となっている。
\footnote{パスカルの三角形の要素は\newterm{binomial coefficients}(二項係数)と
呼ばれます。これは、\( n \)番目の行が\( (x + y)^n \)を展開したときの各項の係数と
なっているからです。この係数計算のパターンは、Blaise Pascalが1653年に書いた
確率理論の偉大な論文である \textit{Trait\'e du triangle arithm\'etique}に書かれたものです。
\link{Knuth (1973)}によると、同様のパターンは1303年に中国の数学者朱世傑により出版された
\textit{Szu-yuen Y\"u-chien} (四元玉鑑)や、12世紀のペルシャの詩人であり数学者でもあった
Omar Khayyamの著作や、12世紀インドの数学者Bh\'ascara \'Ach\'aryaの著作にも現れるということです。}
パスカルの三角形の要素を再帰プロセスによって求める手続きを書け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.13}Exercise 1.13:} Fib(\( n \))が
\( \varphi^n / \sqrt{5} \)に最も近い整数であることを証明せよ。
\( \varphi = (1 + \sqrt{5}) / 2 \)とする。ヒント：\( \psi = (1 - \sqrt{5}) / 2 \)と置く。
帰納法とフィボナッチ数の定義(\link{Section 1.2.2}参照)を使って、
Fib(\( n \)) = \( (\varphi^n - \psi^n) / \sqrt{5} \)であることを証明せよ。
\end{quote}

\subsection{増加オーダー}
\label{Section 1.2.3}


前節の例は、プロセスが計算リソースを消費する量の増え方に大幅に差が出ることがあるということを
示しています。この違いを記述する便利な方法のひとつとして、\newterm{order of growth}
(\jnewterm{増加オーダー})という概念によって、入力が増えるに従ってプロセスが必要とする
リソースがどの程度になるかについての大雑把な感覚をつかむということがあります。


問題の大きさを測るパラメータを\( n \)として、大きさ\( n \)の問題について
プロセスが必要とするリソースの量を\( R(n) \)とします。前節の例では、
ある関数が計算を行う対象とする数値を\( n \) としましたが、ほかの可能性もあります。
例えば、もし目的がある数値の平方根の近似値を求めることであれば、
求める精度の桁数を\( n \)とするのもいいでしょう。行列のかけ算であれば、
\( n \) を行列の行数としてもいいかもしれません。一般に、問題というものは、
プロセスについて分析するために都合のいい属性をいくつか持っているものです。
同じように、\( R(n) \)は使用される内部ストレージのレジスタ数であったり、
実行される基本的な機械語命令数であったりします。一度に決まった数の
命令しか実行しないコンピュータでは、実行時間は実行する基本的な機械語命令数に
比例します。


任意の十分に大きな\( n \)に対して、\( n \)と独立な正の定数\( k_1 \)と\( k_2 \)が
存在し、\( k_1f(n) \le R(n) \le k_2f(n) \)を満たすとき、\( R(n) \)は増加オーダーが
\( \Theta(f(n)) \)であると言い、\( R(n) \) = \( \Theta(f(n)) \)(``シータ\( f(n) \)''と読む)と
書きます。(別の言い方をすると、大きな\( n \)に対して、\( R(n) \)の値は
\( k_1f(n) \)と\( k_2f(n) \)で挟まれるということです)


例えば、\link{Section 1.2.1}で記述した階乗を求める線形再帰プロセスでは、ステップ数は
入力\( n \)に比例します。つまり、このプロセスに必要なステップ数は\( \Theta(n) \)で
増加します。必要な空間も\( \Theta(n) \)で増加するということを確認しています。
反復による階乗計算では、ステップ数は依然として\( \Theta(n) \)ですが、
空間は\( \Theta(1) \)---つまり、定数です。
\footnote{この書き方の背後には、非常に多くの過度の単純化が隠れています。
例えば、プロセスのステップ数を``機械語命令''で数えるとすると、例えばかけ算を
実行するのに必要な機械語命令の数はかける数値の大きさと独立であると想定しています。
これは、数値が十分に大きければ成り立ちません。空間の見積もりについても同じようなことが
言えます。プロセスの設計や記述と同じように、プロセスの分析もさまざまな抽象化レベルで
行うことができます。}
木の再帰によるフィボナッチ数の計算は、\( \Theta(\varphi^n) \)ステップと空間\( \Theta(n) \)を
必要とします。ここで、\( \varphi \)は\link{Section 1.2.2}で示した黄金比です。


増加オーダーは、プロセスのふるまいについて大雑把な記述をするだけです。
例えば、\( n^2 \)が必要なプロセス、\( 1000n^2 \)が必要なプロセス、
\( 3n^2 + 10n + 17 \)ステップが必要なプロセスは、すべては\( \Theta(n^2) \)という
増加オーダーになります。一方で、問題の大きさを変えた場合のプロセスのふるまいを
どう予測するかということについては、増加オーダーは役に立つ指標となります。
\( \Theta(n) \)の(線形の)プロセスはで、問題の大きさを2倍にすると、使うリソースも
だいたい2倍になります。指数的プロセスは、問題サイズが1増えるたびに、リソース使用量は
定数倍になります。\link{Section 1.2}の残りで、増加オーダーが対数的であり、
問題の大きさが2倍になると必要リソースが定数量だけ増える2つのアルゴリズムを見ていきます。

\begin{quote}
\heading{\phantomsection\label{Exercise 1.14}Exercise 1.14:} \link{Section 1.2.2}の
\code{count\-/change}手続きによって11セントに対する両替のやり方を求める際に生成される
プロセスを図示する木を描け。両替する金額の増加に対して、このプロセスが使う空間とステップ数は
どのような増加オーダーになるか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.15}Exercise 1.15:} (ラジアンで指定される)
角度の正弦は、\( x \)が十分に小さいとき\( \sin x  \approx x \)
の近似式によって計算できる。また、次の三角法の恒等式によって、sinの引数の大きさを小さくすることができる。
\begin{comment}

\begin{example}
               x             x
sin x = 3 sin --- - 4 sin^3 ---
               3             3
\end{example}

\end{comment}
\begin{displaymath}
\sin x = 3\sin {x\over3} - 4\sin^3 {x\over3} 
\end{displaymath}

(この練習問題では、角が``十分に小さい''とはその大きさが0.1ラジアン以下であることとする)
これらの考えは、以下の手続きに組み込まれている。

\begin{scheme}
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
   (if (not (> (abs angle) 0.1))
       angle
       (p (sine (/ angle 3.0)))))
\end{scheme}

\begin{enumerate}[a]

\item
\code{(sine 12.15)}を評価する際に、手続き\code{p}は何回適用されるか。

\item
\code{(sine a)}が評価される際に\code{sine}手続きによって生成されるプロセスが使用する
空間とステップ数の増加オーダーを(\( a \)の関数として)求めよ。

\end{enumerate}
\end{quote}


\subsection{指数計算}
\label{Section 1.2.4}


与えられた数値の指数を求める問題について考えましょう。基数\( b \)と正の整数の指数\( n \)を
引数に取り、\( b^n \)を求める手続きということになります。ひとつのやり方として、これは次のように
再帰的定義によって定義できます。
\begin{comment}

\begin{example}
b^n = b * b^(n - 1)
b^0 = 1
\end{example}

\end{comment}
\begin{displaymath}
% \eqalign{b^n &= b\cdot b^{n-1}, \cr 
% b^0 &= 1, \cr} 
\begin{array}{l@{{}={}}l}
  b^n & b\cdot b^{n-1}, \\ 
  b^0 & 1,
\end{array}
\end{displaymath}
これは、すぐに次の手続きに変換できます。

\begin{scheme}
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
\end{scheme}

\noindent
これは線形再帰プロセスで、\( \Theta(n) \)のステップ数と\( \Theta(n) \)の空間を
必要とします。階乗と同じように、等価な線形反復としてすぐに定式化することができます。

\begin{scheme}
(define (expt b n)
  (expt-iter b n 1))
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product))))
\end{scheme}

\noindent
こちらのバージョンは、\( \Theta(n) \)のステップ数と\( \Theta(1) \)の空間を必要とします。


指数は、二乗を連続して使うことによって、より少ないステップ数で計算できます。
例えば、\( b^8 \)を次のように計算するのではなく、

\begin{comment}

\begin{example}
b * (b * (b * (b * (b * (b * (b * b))))))
\end{example}

\end{comment}
\begin{displaymath}
 b\cdot (b\cdot (b\cdot (b\cdot (b\cdot (b\cdot (b\cdot b))))))\,, 
\end{displaymath}
3回の乗算で求めることができます。
\begin{comment}

\begin{example}
b^2 = b * b
b^4 = b^2 * b^2
b^8 = b^4 * b^4
\end{example}

\end{comment}
\begin{displaymath}
% \eqalign{	b^2 &= b\cdot b, \cr
%		b^4 &= b^2\cdot b^2, \cr
%		b^8 &= b^4\cdot b^4. \cr} 
\begin{array}{l@{{}={}}l}
  b^2 & b\cdot b, \\
  b^4 & b^2\cdot b^2, \\
  b^8 & b^4\cdot b^4.
\end{array}
\end{displaymath}
この方法は、指数が2の冪乗である場合にうまくいきます。また、次のルールを使うことで、
一般的な指数計算に二乗の連続を使うことができるようになります。
\begin{comment}

\begin{example}
b^n = (b^(n/2))^2    if n is even
b^n = b * b^(n - 1)  if n is odd
\end{example}

\end{comment}
\begin{displaymath}
% \eqalign{b^n &= (b^{n / 2})^2 \qquad \;\, {\rm if\;} n {\rm\; is\; even}, \cr
% b^n &= b\cdot b^{n-1} \qquad {\rm if\;} n {\rm\; is\; odd}. \cr} 
\begin{array}{l@{{}={}}lr@{\ n\ }l}
  b^n & (b^{n / 2})^2  \;\; & \mbox{　\,} & \mbox{\,が偶数の場合}, \\
  b^n & b\cdot b^{n-1} \;\; & \mbox{　\,} & \mbox{\,が奇数の場合}.
\end{array}
\end{displaymath}
この方法は、手続きとして表現できます。

\begin{scheme}

(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))
\end{scheme}

\noindent
ここで、ある整数が偶数かどうかをテストする述語は、基本手続きの\code{remainder}
(割り算の余り)を使って次のように定義します。

\begin{scheme}
(define (even? n)
  (= (remainder n 2) 0))
\end{scheme}

\noindent
\code{fast\-/expt}により展開されるプロセスは、空間・ステップ数ともに、\( n \)に対して
対数的に増加します。このことは、\code{fast\-/expt}を使って\( b^{2n} \)を計算するのは
\( b^n \)の計算よりかけ算を1回多く実行するだけだということからわかります。このため、
かけ算の回数が1回増えるたびに、計算できる指数の大きさは(ほぼ)倍になります。したがって、
\( n \)乗の計算をするのに必要なかけ算の回数は、だいたい2を底をした\( n \)の対数と
同じぐらいの速さで増加することになります。このプロセスは\( \Theta(\log n) \)の
増加オーダーを持っています。
\footnote{より正確には、必要なかけ算の回数は、底を2とした\( n \)の対数から1を引いたものに
\( n \)の二進数表現での1の数を足したものになります。この合計は、底を2とした\( n \)の対数
の2倍より常に小さくなります。オーダー記法の定義には\( k_1 \)と\( k_2 \)という
任意の定数が出てきますが、このことは対数的なプロセスについて対数の底は問題にならないという
ことを意味します。そのため、対数的プロセスはすべて\( \Theta(\log n) \)として記述されます。}


\( \Theta(\log n) \)での増加と\( \Theta(n) \)での増加の違いは、\( n \)が大きくなるにつれて
驚くようなものになります。例えば、\code{fast\-/expt}は\( n \) = 1000に対して14回の乗算しか
必要としません。
\footnote{1000乗の計算なんか誰もしないだろうとお考えかもしれません。\link{Section 1.2.6}を
参照してください。}
二乗の連続という考え方を使って、対数的ステップ数で指数を計算する反復アルゴリズムを
作ることもできます(\link{Exercise 1.16}参照)。しかし、反復アルゴリズムにはよくあることですが、
再帰アルゴリズムほど素直に書き下すことはできません。
\footnote{この反復アルゴリズムは古代から存在します。紀元前200年より前に\'Ach\'arya Pingala
によって書かれた\textit{Chandah-sutra}に記載されています。\link{Knuth 1981}の4.6.3節には、
この方法を含むさまざまな指数関数の計算方法についての詳細な考察と分析があります。}


\begin{quote}
\heading{\phantomsection\label{Exercise 1.16}Exercise 1.16:}
\code{fast\-/expt}と同じように二乗の連続を使って、指数計算を対数的ステップ数で
実行する反復的プロセスを生成する手続きを設計せよ。
(ヒント:\( (b^{n / 2})^2 = (b^2)^{n / 2} \)を使い、指数\( n \)、基数\( b \)のほかに
追加の状態変数\( a \)を持ち、積\( ab^n \)が各状態を通して一定であるような状態変換を定義せよ。
プロセスの最初では\( a \)は1とし、答えはプロセス終了時の\( a \)の値として得られる。
一般的に、各状態を通して一定であるような\newterm{invariant quantity}(\jnewterm{不変量})を
定義するというテクニックは、反復アルゴリズムを設計するうえで強力な方法である。
)

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.17}Exercise 1.17:} この節の
指数計算アルゴリズムは、指数をかけ算の繰り返しによって計算することを
基本としている。同じような方法で、整数のかけ算を足し算の繰り返しによって
実行することもできる。次のかけ算手続き(私たちの言語では足し算しかできず、
かけ算ができないと仮定して)は\code{expt}手続きと同じような仕組みになっている。

\begin{scheme}
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
\end{scheme}

このアルゴリズムは、\code{b}に対して線形のステップ数を取る。ここで、足し算のほかに、
整数を倍にする\code{double}という演算と、(偶数の)整数を2で割る\code{halve}という
演算があるとする。これらを使って、\code{fast\-/expt}と同じような仕組みで
対数的ステップ数を取るかけ算手続きを設計せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.18}Exercise 1.18:} \link{Exercise 1.16}と
\link{Exercise 1.17}の結果を使って、足し算、double、halveによって、かけ算を
対数的ステップ数で実行する反復的プロセスを生成する手続きを考えよ。
\footnote{このアルゴリズムは、``ロシア農民法''と呼ばれることもあるかけ算の方法で、
古くから存在します。その使用例は、最も古い二つの数学文献のひとつ、リンド数学パピルスにも
見られます。これは、紀元前1700年ごろにエジプトの書記官 A'h-moseによって書かれた
(それも、より古い文献から写本された)ものです。}

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.19}Exercise 1.19:} フィボナッチ数を
対数的ステップ数で計算する巧妙なアルゴリズムがある。\link{Section 1.2.2}の
\code{fib\-/iter}プロセスでの状態変数 \( a \)と\( b \)の変換、
\( a \gets a + b \)、\( b \gets a \)を思い出そう。
この変換を\( T \)と呼ぶことにする。すると、1と0から始めて\( T \)を繰り返し\( n \)回
適用するとFib(\( n+1 \))とFib(\( n \))というペアができることになる。
言い換えれば、フィボナッチ数はペア(1, 0)に対して\( T^n \)(変換\( T \)の\( n \)乗)を
適用することで求められるということだ。ここで、
\( (a, b) \)というペアを\( a \gets bq + aq + ap \) と \( b \gets bp + aq \)に変換する
ような変換族\( T_{pq} \)の特殊な場合(\( p=0 \)、\( q=1 \))として\( T \)を考えることにする。
このような変換\( T_{pq} \)を二回適用すると、その効果は同じ形式を持つ \( T_{p'q'} \)を一回
適用するのと同じであることを示し、\( p \)と\( q \)に対する\( p' \) と \( q' \)を求めよ。
こうすると、この種の変換に対する二乗を明示的に行うことができるようになり、\code{fast\-/expt}
手続きと同じように、\( T^n \)を二乗の連続によって求められるようになる。
これらをすべて組み合わせて、対数的ステップ数で動く次の手続きを完成させよ。
\footnote{この練習問題はJoe Stoyによって提案されたもので、\link{Kaldewaij 1990}での例をもとにしています}

\begin{scheme}
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~   ~\textrm{; \textit{p}' を計算する }~
                   ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~   ~\textrm{; \textit{q}' を計算する }~
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
\end{scheme}
\end{quote}

\subsection{最大公約数}
\label{Section 1.2.5}

2つの整数\( a \)と\( b \)のGreatest Common divisor(\acronym{GCD}:最大公約数)は
\( a \)と\( b \)の両方をぴったり割り切れる最大の整数と定義されます。例えば、16と28
の\acronym{GCD}は4です。\link{Chapter 2}で、有理数演算をどのように実装方法するかを
検討する際に、有理数を既約にするために\acronym{GCD}の計算が必要になります。
(有理数を既約にするためには、分母と分子をそれらの\acronym{GCD}で割ります。例えば、
16/28は4/7になります) 2つの整数の\acronym{GCD}を求める方法のひとつとしては、それらを
素因数分解して共通の素因数を探すというものがありますが、それよりずっと効率的な有名な
アルゴリズムが存在します。


そのアルゴリズムの考え方は、\( r \)が\( a \)を \( b \)で割った余りであれば、
\( a \)と\( b \)の公約数は\( b \)と\( r \)の公約数とまさに同じものになるという
観察に基づいています。このため、次の等式

\begin{example}
GCD(a,b) = GCD(b,r)
\end{example}

\noindent
によって、\acronym{GCD}を計算する問題を、より小さな整数ペアの\acronym{GCD}を計算する
問題へと連続的に簡約していくことができます。例えば、

\begin{example}
GCD(206,40) = GCD(40,6)
            = GCD(6,4)
            = GCD(4,2)
            = GCD(2,0)
            = 2
\end{example}


\noindent
この例では\acronym{GCD}(206, 40)を\acronym{GCD}(2, 0)まで簡約しています。その答えは2です。
任意の2つの正の整数から始めても、繰り返し簡約していくことで最終的には必ず2つ目の数値が0である
ペアにすることができるということが証明可能です。そのとき、\acronym{GCD}はペアのもう1つの値です。
\acronym{GCD}を求めるこの方法は、\newterm{Euclid's Algorithm}(\jnewterm{ユークリッドの互除法})と
して知られています。
\footnote{ユークリッドの互除法は、ユークリッドの\textit{Elements}(紀元前300年ごろ、第7巻)に
出てきたためにそう呼ばれます。\link{Knuth (1973)}によると、自明でないアルゴリズムとしては
知られている限り最古のものと考えられるそうです。(\link{Exercise 1.18})で出てきた古代エジプトの
かけ算方法は確かにこれよりも古いのですが、Knuthが説明するように、ユークリッドのアルゴリズムは、
具体例の集まりとしてではなく一般的なアルゴリズムとして示されたものとしては最古のものです。}

ユークリッドの互除法は、手続きとして簡単に表現できます。

\begin{scheme}
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
\end{scheme}

\noindent
これは反復プロセスを生成し、ステップ数は計算する数値に対して対数的に増加します。


ユークリッドの互除法が必要とするステップ数が対数的に増加するという事実は、
フィボナッチ数と興味深い関係を持っています。

\begin{quote}
\heading{Lam\'eの定理:}ユークリッドの互除法によって、ある数値ペアの\acronym{GCD}を
計算するのに\( k \)ステップを必要とする場合、ペアの小さいほうの数値は\( k \)番目の
フィボナッチ数以上である。
\footnote{この定理は、1845年にGabriel Lam\'eによって証明されたものです。彼はフランスの
数学者かつエンジニアで、主に数理物理学への貢献で知られています。この定理を証明するには、
ユークリッドの互除法が\( k \)ステップで停止する、\( a_k \ge b_k \)であるペア(\( a_k, b_k \))に
ついて考えます。証明は\( (a_{k+1}, b_{k+1}) \to (a_k, b_k) \to (a_{k-1}, b_{k-1}) \)が
簡約プロセスの中の連続する3つのペアである場合、必ず\( b_{k+1} \ge b_k + b_{k-1} \)である
という主張に基づいています。この主張を証明するには、簡約ステップが
\( a_{k-1} = b_k, b_{k-1} =  \)``\( a_k \)を\( b_k \)で割った余り''という変換を適用すること
として定義されていることについて考えます。2つ目の等式は、\( a_k = qb_k + b_{k-1} \)が成り立つ
ある正の整数\( q \)が存在することを意味しています。ここで、\( q \)は最小でも1なので、
\( a_k = qb_k + b_{k-1} \ge b_k + b_{k-1} \)が成り立ちます。しかし、一つ前のの簡約ステップから、
\( b_{k+1} = a_k \)です。そのため、\( b_{k+1} = a_k \ge b_k + b_{k-1} \)が成り立ちます。
これで主張は証明できました。ここで、アルゴリズムが停止するのに必要なステップ数である\( k \)
に対して数学的帰納法を使うことで定理が証明できます。\( k = 1 \)のとき、これは\( b \)が
Fib(1) = 1以上であればよいので、真です。次に、\( k \)以下のすべての整数について定理が真であると
仮定し、\( k + 1 \)の場合について導きます。\( (a_{k+1}, b_{k+1}) \to (a_k, b_k) \to
(a_{k-1}, b_{k-1}) \)が簡約プロセスにおける連続するペアであるとします。数学的帰納法の
仮定より、\( b_{k-1} \ge {\rm Fib}(k - 1) \)と\( b_k \ge {\rm Fib}(k) \)が成り立ちます。
ここで、先ほど証明した主張とフィボナッチ数の定義を適用すると、\( b_{k+1} \ge b_k + b_{k-1} \ge
{\rm Fib}(k) + {\rm Fib}(k-1) = {\rm Fib}(k+1) \)が導けます。これでLam\'eの定理の
証明が完成します。
}
\end{quote}

\noindent
この定理を使って、ユークリッドの互除法の増加オーダーを得ることができます。
手続きの\( n \)を二つの入力のうちの小さいほうだとします。プロセスが\( k \)ステップ
かかるとすると、\( n \ge {\rm Fib}(k) \approx \varphi^k / \sqrt{5} \)が必ず成り立ちます。
したがって、ステップ数\( k \)は\( n \)に対して(\( \varphi \)を底とする)対数的に増加します。
つまり、増加オーダーは\( \Theta(\log n) \)となります。


\begin{quote}
\heading{\phantomsection\label{Exercise 1.20}Exercise 1.20:}ある手続きが生成するプロセスは、
もちろん、インタプリタのルールによって異なる。例として、上で説明した反復\code{gcd}手続きに
ついて考える。この手続きを、\link{Section 1.1.5}で考察した通常順序評価によって解釈するとする
(\code{if}に対する通常順序評価のルールは\link{Exercise 1.5}に記述されている)。
置換法を(正規順序に対して)使って、\code{(gcd 206 40)}を評価する際に生成されるプロセスを
図示し、実際に実行される\code{remainder}演算を示せ。\code{(gcd 206 40)}の通常順序評価では、
\code{remainder}演算は何回実行されるだろうか。適用順序評価ではどうだろうか。
説明せよ。


\end{quote}


\subsection{例: 素数判定}
\label{Section 1.2.6}


この節では、整数\( n \)が素数性をチェックする二つの方法について記述します。
ひとつは増加オーダーが\( \Theta(\sqrt{n}) \)で、もうひとつは増加オーダーが\( \Theta(\log n) \)の
``確率的''なアルゴリズムです。節末の練習問題では、これらのアルゴリズムに基づいた
プログラミングのプロジェクトを提案します。

\subsubsection*{約数を探す}


古代から、数学者は素数に関する問題に魅了されてきました。そして、多くの人々が
数値が素数であるかテストする方法に取り組んできました。ある数値が素数であるか
テストする方法のひとつとして、その数値の約数を探すというものがあります。
次のプログラムは、ある数値\( n \)をちょうど割り切る(1以上の)最も小さな数を
見つけます。このプログラムは、2から始まる一連の数字\( n \)について割り切れるか
どうかを調べるという素直な方法でそれを行っています。

\begin{scheme}
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))
\end{scheme}

\noindent
数値が素数であるかは次のようにテストできます: \( n \)は、\( n \)自身がその最小の約数である
場合、かつその場合に限り、素数である。

\begin{scheme}
(define (prime? n)
  (= n (smallest-divisor n)))
\end{scheme}

\noindent
\code{find\-/divisor}の終了条件は、もし\( n \)が素数でないならば、
それは\( \sqrt{n} \)以下の約数を持つという事実に基づいています。
\footnote{もし\( d \)が\( n \)の約数であれば、\( n / d \)も約数になります。
しかし、\( d \)と\( n / d \)の両方とも\( \sqrt{n} \)より大きいということはありえません。}
つまり、このアルゴリズムは、1から\( \sqrt{n} \)までの約数についてだけテストすればよいと
いうことです。そのため、\( n \)が素数であるかを判定するのに必要なステップ数は、増加オーダーが
\( \Theta(\sqrt{n}) \)となります。

\subsubsection*{フェルマーテスト}


\( \Theta(\log n) \)の素数判定は、フェルマーの小定理として知られる整数論の結果に
基づいています。\footnote{Pierre de Fermat (1601-1665)は、近代整数論の創始者と
考えられています。彼は多くの重要な整数論上の結果を発見しましたが、彼は普通
その結果だけを公表し、証明を与えませんでした。フェルマーの小定理は、彼が1640年に
書いた手紙に記録されています。最初の公開された証明は、オイラーによって1736年に
与えられました(また、それより早い同じ証明がライプニッツの未発表の草稿に発見されています
)。フェルマーの結果の中で最も有名なものは---フェルマーの最終定理として知られているものですが---
1637年に、彼の持っていた(3世紀のギリシャ人数学者Diophantusによる)\textit{Arithmetic}という
本に``私は真に驚くべき証明を発見したが、書き残すにはこの余白は狭すぎる''という注記をつけて
メモされていたものです。フェルマーの最終定理の証明を見つけることは、整数論の中で
最も有名な課題のひとつとなりました。完全な解答は、1995年にプリンストン大学のAndrew Wilesに
よってついに与えられました。}

\begin{quote}
\heading{フェルマーの小定理:} \( n \)が素数で、\( a \)が\( n \)より小さい任意の正の整数
であるとき、\( a \)の\( n \)乗は法\( n \)に関して\( a \)と合同である。
\end{quote}

\noindent
(二つの数値は、その両方を\( n \)で割ったときの余りが同じになる場合、
\newterm{congruent modulo} \( n \)(\jnewterm{法\( n \)に関して合同})と言います。
また、\( a \)を\( n \)で割ったときの余りは\jnewterm{法\( n \)に関する \( a \) の剰余}、
または単純に\( a \) \newterm{modulo} \( n \)と呼ばれます。)


もし\( n \)が素数でなければ、一般に\( a < n \)であるほとんどの\( a \)は上記の関係を満たしません。
このことから、次の素数判定アルゴリズムが導かれます。ある数値 \( n \)が与えられたとき、
\( a < n \) である適当な数値 \( a \) を取り、法\( n \)に関する\( a^n \)の剰余を求めます。
もし結果が\( a \)と等しくなければ、\( n \)は確実に素数ではありません。もし\( a \)と
等しければ、\( n \)は素数かもしれません。今度は、別の適当な数値\( a \)を取り、同じ方法で
テストを行います。それもまた等式を満たせば、\( n \)が素数であることについてより確信が持てる
ようになります。たくさんの\( a \)について試験を行っていくことで、結果についての確信を
増やしていくことができます。このアルゴリズムは、フェルマーテストとして知られています。


フェルマーテストを実装するには、ある数値の冪乗の、別のある数値を法とした剰余を求める
手続きが必要です。

\begin{scheme}
(define (expmod base exp m)
  (cond ((= exp 0) 
         1)
        ((even? exp)
         (remainder 
          (square 
           (expmod base (/ exp 2) m))
          m))
        (else
         (remainder
          (* base 
             (expmod base (- exp 1) m))
          m))))

\end{scheme}

\noindent
これは、\link{Section 1.2.4}の\code{fast\-/expt}手続きにそっくりです。二乗の連続を使っている
ため、ステップ数は指数に対して対数的に増加します。
\footnote{指数\( e \)が1より大きい場合の簡約ステップは、任意の整数\( x \),\( y \), \( m \)に
対して、(\( xy \) modulo \( m \) を求めるためには \( x \) modulo \( m \)と\( y \) modulo \( m \)を
別々に求め、これらをかけ算し、その結果の法\( m \)に関する剰余を求めればいいという事実に
基づいています。例えば、\( e \)が偶数であれば\( b^{e / 2} \) modulo \( m \)を求め、
それを二乗し、法\( m \)に関する剰余を取ります。このテクニックを使うと、計算する際に
\( m \)よりずっと大きな数値を扱わないですませられるので便利です。
(\link{Exercise 1.25}と比較すること)}


フェルマーテストは、1以上\( n-1 \)以下のランダムな数値\( a \)を選び、\( a \)の\( n \)乗の
modulo \( n \)が\( a \)に等しいかをチェックすることで行います。ランダムな数値\( a \)は
手続き\code{random}を使って選びます。\code{random}はSchemeの基本手続きに含まれていると
します。\code{random}は、受け取った整数よりも小さい非負整数を返します。そのため、
1から\( n-1 \)の乱数を得るために\code{random}に\( n-1 \)を渡し、返り値に1を足します。

\begin{scheme}
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
\end{scheme}

\noindent
次の手続きは、引数で与えられた数値の回数だけテストを実行します。
テストがすべて成功すればtrueを、そうでなければfalseを返します。

\begin{scheme}
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))
\end{scheme}

\subsubsection*{確率的手法}


ほとんどの馴染みのあるアルゴリズムは正しいことが保証された答えを返すものですが、
フェルマーテストはその点で性質が異なります。フェルマーテストでは、得られた答えは
答えの正しさは確率的なものでしかありません。より正確には、\( n \)がフェルマーテストに
失敗すれば、\( n \) が素数でないことは確実です。しかし、\( n \)がテストをパスするという
ことは、非常に強い指標ではありますが、それでも\( n \)が素数であるという保証にはなりません。
ここで主張したいと思っていることは、任意の数値\( n \)について、十分な回数のテストを
行って\( n \)がすべてのテストをパスすることが確認できれば、この素数判定が間違う確率を
好きなだけ小さくできるということです。


残念ながら、この主張はあまり正しくありません。フェルマーテストを騙してしまう
数というものは存在します。素数でない数値\( n \)で、\( a < n \)であるすべての整数
\( a \) について、\( a^n \)が\( n \)を法として\( a \)に合同となってしまうものです。
そのような数は非常にまれなので、フェルマーテストは実用的にはかなり信頼できます。
\footnote{\label{Footnote 1.47} フェルマーテストを騙してしまう数は
\newterm{Carmichael numbers}(\jnewterm{カーマイケル数})と呼ばれ、非常にまれであると
いうこと以外はあまりよくわかっていません。100,000,000より小さい数には255の
カーマイケル数が存在します。最小のものからいくつか挙げると、561, 1105, 1729,
2465, 2821, 6601となっています。ランダムに選ばれた巨大数の素数性をテストする際に
たまたまフェルマーテストを騙す数値にぶつかってしまう確率は、``正確な''アルゴリズムを
実行する際に宇宙放射線がコンピュータのエラーを引き起す確率よりも低いのです。
一つ目の理由からアルゴリズムを不適切だと考え、二つ目の理由からはそう考えないというのは、
数学と工学の違いを示しています。}


騙されないフェルマーテストの変種もあります。そのテストでは、フェルマーテストと同様に、
整数\( n \)の素数判定を行うのに\( a < n \)である整数\( a \)を選び、\( n \)と\( a \)に
依存するある条件についてチェックします(\link{Exercise 1.28}で、そのようなテストの
例が出てきます)。一方、フェルマーテストと違って、任意の\( n \)に対し、\( n \)が素数でない
限り\( a < n \)であるほとんどの整数\( a \)についてその条件が成立しないことが証明できます。
そのため、もし\( n \)がランダムに選んだ数\( a \)についてテストを通過するなら、\( n \)が
素数である確率は半々より高くなります。もし\( n \)がランダムに選んだ\( a \)の値二つに対して
そのテストを通過するなら、\( n \)が素数である確率は4分の3より高くなります。このテストを
ランダムに選んだ数\( a \)について繰り返していくと、間違いの確率を好きなだけ低くすることが
できます。


間違いの確率が好きなだけ小さくなることが証明できるテストの存在は、この種類の
アルゴリズムへの関心を引き起こしました。今では、そのようなアルゴリズムは
\newterm{probabilistic algorithms}(\jnewterm{確率的アルゴリズム})と
呼ばれるようになっています。この領域では多くの研究が行われていて、
確率的アルゴズムは多くの領域に適用され、成果をもたらしてきました。
\footnote{確率的素数判定のもっとも著しい応用は暗号分野です。
現在、適当な200桁の数値を因数分解するというのは計算量的にできそうにありませんが、
そのような数値の素数性チェックはフェルマーテストによって数秒で行えます。
この事実が、\link{Rivest et al. (1977)}によって提案された``解読不能な符号''を
構築する技術の基礎となっています。その結果として生まれた\jnewterm{RSAアルゴリズム}は、
電子通信のセキュリティを強化する技術として広く使われるようになっています。
一時は、素数の研究というものは``純粋''数学トピックの典型例で、研究のための研究のように
思われていましたが、RSAアルゴリズムとその関連研究の進展によって、暗号学、
電子送金、情報検索において重要な実用的応用があることがわかりました。}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.21}Exercise 1.21:}\code{smallest\-/divisor}手続きを
使って次の数値の最小の約数を求めよ。199, 1999, 19999.
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.22}Exercise 1.22:} ほとんどのLisp実装は
\code{runtime}という基本手続きを持っていて、システムが動いた時間を整数
(例えば、マイクロ秒で計測したもの)として返す。次の\code{timed\-/prime\-/test}
手続きは、整数\( n \)を引数として呼ばれると、\( n \)を表示し、\( n \)が素数であるか
チェックする。\( n \)が素数であれば、手続きは3つのアスタリスクと、テスト実行にかかった
時間を表示する。

\begin{scheme}
(define (timed-prime-test n)
  (newline) (display n) (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n) 
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ") (display elapsed-time))
\end{scheme}

この手続きを使って、指定した範囲の連続した奇数について素数判定を行う手続き
\code{search\-/for\-/primes}を書け。その手続きを使って、1000, 10,000, 100,000
より大きな素数をそれぞれ3つ見つけよ。判定アルゴリズムは\( \Theta(\sqrt{n}) \)の
増加オーダーを持っているので、10,000あたりの判定には1000あたりの\( \sqrt{10} \)倍程度の
時間がかかるはずである。あなたの計測データはこれを裏付けているだろうか。
100,000や1,000,000のデータは、\( \Theta(\sqrt{n}) \)という予想はどれだけ当たっているだろうか。
あなたの結果は、演算に必要なステップ数に比例して実行時間が増えるという概念に矛盾していない
だろうか。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.23}Exercise 1.23:} この節の最初で示した
\code{smallest\-/divisor}手続きは、必要のないテストを数多く行っている。
数値が2で割り切れるかチェックした後に、それより大きな偶数で割り切れるかをチェックする
ことに意味はない。このことは、\code{test\-/divisor}に使われる値は2, 3, 4, 5, 6, \( \dots \)
ではなく、2, 3, 5, 7, 9, \( \dots \)であるべきだということを示している。この変更を
実装するために、入力が2であれば3を返し、そうでなければ入力に2を足したものを返す手続き
\code{next}を定義せよ。\code{smallest\-/divisor}手続きを、\code{(+ test\-/divisor 1)}
の代わりに\code{(next test\-/divisor)}を使うように修正せよ。この変更したバージョンの
\code{smallest\-/divisor}手続きを組み込んだ\code{timed\-/prime\-/test}を使い、
\link{Exercise 1.22}で見つけた12個の素数についてテストを実行せよ。
この変更はテストのステップ数を半分にするため、2倍の速度で実行できると予想できる。
この予想は確認できただろうか。そうでなければ、二つのアルゴリズムの観測された速度の比率は
どうなっていて、それが2でないという事実をどのように説明できるだろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.24}Exercise 1.24:} \link{Exercise 1.22}の
\code{timed\-/prime\-/test}手続きを\code{fast\-/prime?}(フェルマー法)を使うように修正し、
\link{Exercise 1.22}で見つけた12個の素数をそれぞれテストせよ。フェルマーテストは
\( \Theta(\log n) \)で増加するが、1,000,000に近い素数をテストするのにかかる時間は
1000に近い素数をテストするのに必要な時間と比べてどの程度になると予想できるか。
実際とのずれがあれば、それを説明できるだろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.25}Exercise 1.25:} Alyssa P. Hackerは、
\code{expmod}を書くのにだいぶ余計な手間がかかったと愚痴をこぼした。
どうせ指数の計算のやり方はわかっているんだから、単純にこんなふうに書いたら
よかったんじゃないの、と。

\begin{scheme}
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
\end{scheme}

彼女は正しいだろうか。高速素数判定にこの手続きを使っても同じようにうまく行くだろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.26}Exercise 1.26:} Louis Reasonerは
\link{Exercise 1.24}を解くのにだいぶ苦労している。彼の\code{fast\-/prime?}
テストは、彼の\code{prime?}テストよりだいぶ遅いようだ。Louisは友達のEva Lu Atorに
見てもらうことにした。二人でLouisのコードをよく見てみると、\code{expmod}手続きで
\code{square}手続きを呼ぶのでなく、明示的にかけ算を使うように書き換えていることが
わかった。

\begin{scheme}
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base 
                       (expmod base (- exp 1) m))
                    m))))
\end{scheme}


Louisは、「何も違わないように見えるけど」と言っている。Evaは、
「いや、違うって。手続きの書き方のせいで、\( \Theta(\log n) \)の
プロセスが\( \Theta(n) \)のプロセスになっちゃったんだよ。」と言う。

説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.27}Exercise 1.27:} \link{Footnote 1.47}で
挙げたカーマイケル数が実際にフェルマーテストを騙すということを実験せよ。
それはつまり、整数\( n \)を取り、すべての\( a < n \)について\( a^n \)が法\( n \)に
関して\( a \)と合同になるかテストする手続きを書き、与えられたカーマイケル数に対して
その手続きを試すということになる。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.28}Exercise 1.28:} 騙すことができない
フェルマーテストの変種のひとつに\newterm{Miller-Rabin test} (\link{Miller 1976};
\link{Rabin 1980})がある。これは、次のようなフェルマーの小定理の別の形から始める。
\( n \)が素数で、かつ\( a \)が\( n \)以下の任意の正の整数であれば、\( a \)の
\( (n-1) \)乗は法\( n \)に関して1と合同であるというものだ。
Miller-Rabinテストで数値\( n \)の素数性をテストするには、\( a < n \)である
適当な\( a \)を選び、\code{expmod}手続きを使って\( a \)の\( (n-1) \)乗の
\( n \)を法とする剰余を求める。しかし、\code{expmod}手続きの中で二乗を行うステップで、
毎回``法\( n \)に関する自明でない1の平方根''を見つけたかチェックする。これは、
1とも\( n-1 \)とも等しくない数値で、その二乗が法\( n \)に関して1に等しい数値である。
そのような自明でない1の平方根が存在すれば\( n \)は素数ではないということは証明できる。
また、もし\( n \)が素数でない奇数であれば、少なくとも\( a < n \)である\( a \)のうち
半分は、このように\( a^{n-1} \)を演算すると、法\( n \)に関する自明でない1の平方根が
現れるということも証明できる(このため、Miller-Rabinテストは騙すことができない)。
\code{expmod}手続きを変更し、自明でない1の平方根を見つけるとシグナルを送るようにして、
それを使って\code{fermat\-/test}と同じような手続きとしてMiller-Rabinテストを実装せよ。
既知の素数、非素数を使ってその手続きをチェックせよ。ヒント：\code{expmod}にシグナルを
送らせる簡単な方法のひとつとして、0を返すようにするというものがある。

\end{quote}

\vspace{0.5em}
\section{高階手続きによる抽象の定式化}
\label{Section 1.3}

ここまでで、手続きは事実上、数値に対する複合演算を特定の数値から独立した形で
記述する抽象化であることを見てきました。例えば、次の手続きを見てみましょう。

\begin{scheme}
(define (cube x) (* x x x))
\end{scheme}

\noindent
ここで扱っているのは、特定の値の三乗ではなく、任意の数値の三乗を得るやり方です。
もちろん、この手続きを定義しないでも、毎回次のような式を書くこともできます。

\begin{scheme}
(* 3 3 3)
(* x x x)
(* y y y)
\end{scheme}

\noindent
こうすると、明示的に\code{cube}について書く必要はありません。しかし、このやり方では
とても不利なことになります。たまたま言語が基本演算として持っていた特定の演算
(この場合、かけ算)のレベルでずっと作業しなければならず、高レベルの演算が使えないからです。
プログラムは三乗を計算することができても、三乗という概念を表現する能力を言語内で
持てないことになります。強力なプログラミング言語であれば、よくあるパターンに名前をつけて
抽象化し、その抽象化したものを直接使って作業ができる能力が求められるところです。
手続きは、この能力を提供します。このため、極度に原始的なもの以外のすべての
プログラミング言語は、手続きを定義する仕組みを持っています。

しかし、数値計算であっても、もし引数が数値であるような手続きしか作れないとしたら、抽象化の
能力は非常に限定されたものになるでしょう。同じプログラミングパターンがいくつもの異なる
手続きに利用されるということはよくあります。そのようなパターンを概念として表現するには、
手続きを引数として受け取ったり、引数を返り値として返したりできる手続きを作れる必要が
あります。手続きを操作する手続きは、\newterm{higher-order procedures}(\jnewterm{高階手続き})
と呼ばれます。この節では、高階手続きが言語の表現力を大幅に高める強力な抽象化メカニズムで
あることを示します。


\subsection{引数としての手続き}
\label{Section 1.3.1}


次の3つの手続きについて考えてみましょう。一つ目は、\code{a}から\code{b}まで整数の和を
計算するものです。

\begin{scheme}
(define (sum-integers a b)
  (if (> a b) 
      0
      (+ a (sum-integers (+ a 1) b))))
\end{scheme}

\noindent
二つ目は、範囲内の整数について、三乗の和を計算します。

\begin{scheme}
(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a)
         (sum-cubes (+ a 1) b))))
\end{scheme}

\noindent
三つ目は、次のような級数の和を計算します。
\begin{comment}

\begin{example}
  1       1       1
----- + ----- + ------ + ...
1 * 3   5 * 7   9 * 11
\end{example}

\end{comment}
\begin{displaymath}
 {1\over1\cdot 3} +  {1\over5\cdot 7} + {1\over9\cdot 11} + \dots, 
\end{displaymath}
これは、\( \pi / 8 \)に(非常にゆっくり)収束します。\footnote{この級数はLeibnizによるもので、
普通は
\( {\pi\over4} = 1 - {1\over3} + {1\over5} - {1\over7} + \dots \)
という等価な形で書かれます。\link{Section 3.5.3}では、これを基礎とした面白い数学上の
トリックを紹介します。}

\begin{scheme}
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2)))
         (pi-sum (+ a 4) b))))
\end{scheme}

\noindent
これらの三つの手続きの背後には、明らかに共通のパターンがあります。それらはほとんどの部分が
同じもので、違うのは手続き名や、足し合わせる各項を計算するために使われる\code{a}の関数、
\code{a}の次の値を求める関数ぐらいです。それぞれの手続きは、同じひな形の穴を埋めることで
生成できそうです。

\begin{scheme}
(define (~\( \dark \langle \)~~\var{\dark name}~~\( \dark \rangle \)~ a b)
  (if (> a b)
      0
      (+ (~\( \dark \langle \)~~\var{\dark term}~~\( \dark \rangle \)~ a)
         (~\( \dark \langle \)~~\var{\dark name}~~\( \dark \rangle \)~ (~\( \dark \langle \)~~\var{\dark next}~~\( \dark \rangle \)~ a) b))))
\end{scheme}

\noindent
こういった共通パターンがあるということは、便利な抽象化が潜んでいて、見つけ出されるのを
待っているということの強力な証拠です。実際に、大昔の数学者たちは
\newterm{summation of a series}(\jnewterm{級数の総和})という抽象化を発見し、
``シグマ記法''を発明しました。例えば、次のような書き方でこの概念を表現します。
\begin{comment}

\begin{example}
  b
 ---
 >    f(n) = f(a) + ... + f(b)
 ---
 n=a
\end{example}

\end{comment}
\begin{displaymath}
 \sum_{n=a}^b f(n) = f(a) + \ldots + f(b), 
\end{displaymath}
シグマ記法の力によって、数学者は特定の値の総和についてだけでなく、総和という概念そのものを
扱えるようになりました。例えば、特定の級数から独立して、総和についての一般的な結果について
定式化できるようになったのです。

同様に、プログラムの設計者である私たちとしては、私たちの使う言語が特定の総和を計算する
手続きだけでなく、総和という概念そのものを表現する手続きを書けるぐらいには強力であって
ほしいと思うところです。私たちの手続き言語を使うと、上に書いた共通のひな形を持ってきて、
その``穴''を仮引数に変えるだけですぐにできます。

\begin{scheme}
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
\end{scheme}

\noindent
\code{sum}が、下限と上限である\code{a}, \code{b}のほかに、手続き\code{term}(項), \code{next}を
取ることに注意してください。\code{sum}は、ほかの手続きとまったく同じように使えます。
例えば、それを使って(引数に1を足す手続き\code{inc}も加えて)\code{sum\-/cubes}を定義することが
できます。

\begin{scheme}
(define (inc n) (+ n 1))
(define (sum-cubes a b)
  (sum cube a inc b))
\end{scheme}

\noindent
これを使うと、1から10までの整数の三乗の和を計算できます。

\begin{scheme}
(sum-cubes 1 10)
~\textit{3025}~
\end{scheme}

\noindent
項を計算するのにidentity(恒等)手続きを使うと、\code{sum}によって\code{sum\-/integers}を
定義できます。

\begin{scheme}
(define (identity x) x)
(define (sum-integers a b)
  (sum identity a inc b))
\end{scheme}

\noindent
こうすると、1から10までの整数の合計が求められます。

\begin{scheme}
(sum-integers 1 10)
~\textit{55}~
\end{scheme}

\noindent
\code{pi\-/sum}も、同じようにして定義できます。
\footnote{ブロック構造(\link{Section 1.1.8})を使って\code{pi\-/sum}の中に
\code{pi\-/next}と\code{pi\-/term}の定義を埋め込んでいることに注意してください。
これらの手続きは、ほかの手続きの役には立ちそうにないからです。
この二つを厄介払いするやり方については、\link{Section 1.3.2}で見ていきます。}

\begin{scheme}
(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
\end{scheme}

\noindent
これらの手続きを使うと、\( \pi \)の近似値が計算できます。

\begin{scheme}
(* 8 (pi-sum 1 1000))
~\textit{3.139592655589783}~
\end{scheme}

\noindent
\code{sum}を手に入れたことで、それを構築用ブロックとして使って、また別の概念を定式化
することができます。例えば、関数\( f \)の範囲\( a \)から\( b \)の定積分は、小さな
\( dx \)の値を使い、次の式によって数値的に近似できます。
\begin{comment}

\begin{example}
/b     /  /     dx \    /          dx \    /           dx \      \
|  f = | f| a + -- | + f| a + dx + -- | + f| a + 2dx + -- | + ...| dx
/a     \  \     2  /    \          2  /    \           2  /      /
\end{example}

\end{comment}
\begin{displaymath}
{\int_a^b \!\!\! f} \, = {\left[\;f\!\left(a + {dx\over 2}\right) 
		+ f\!\left(a + dx + {dx\over 2}\right) 
		+ f\!\left(a + 2dx + {dx\over 2}\right) + \,\dots \;\right] \! dx} 
\end{displaymath}
これは、手続きとしてそのまま表現できます。

\begin{scheme}
(define (integral f a b dx)
  (define (add-dx x) 
    (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b) 
     dx))

(integral cube 0 1 0.01)
~\textit{.24998750000000042}~

(integral cube 0 1 0.001)
~\textit{.249999875000001}~
\end{scheme}

\noindent
(\code{cube}を0から1の範囲で定積分したとき、その正確な値は1/4です。)

\begin{quote}
\heading{\phantomsection\label{Exercise 1.29}Exercise 1.29:} シンプソンの公式は、
上で示したものより正確な数値積分の方法である。シンプソンの公式では、
関数\( f \)の範囲\( a \)から\( b \)の定積分は次のように近似される。
\begin{comment}

\begin{example}
h
- (y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + ... + 2y_(n-2) + 4y_(n-1) + y_n)
3
\end{example}

\end{comment}
\begin{displaymath}
 {h\over 3}(y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + \ldots + 2y_{n-2} + 4y_{n-1} + y_n), 
\end{displaymath}
ここで、nを適当な偶整数として\( h = (b - a) / n \)で、\( y_k = f(a + kh) \)である。
(\( n \)を大きくすると近似の精度が上がる)。
\( f \), \( a \), \( b \), \( n \)を引数に取り、シンプソンの公式によって計算した
定積分の値を返す手続きを定義せよ。その手続きを使い、(\( n = 100 \) と\( n = 1000 \)で)
\code{cube}の範囲0から1の定積分を求め、上で示した\code{integral}手続きと結果を比較せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.30}Exercise 1.30:}上で挙げた\code{sum}手続きは
線形再帰を生成する。この手続きは、総和計算が反復的に行われるように書き直すことができる。
次の定義の中で欠けている式を埋め、そのやり方を示せ。

\begin{scheme}
(define (sum term a next b)
  (define (iter a result)
    (if ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
        ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
        (iter ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
  (iter ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.31}Exercise 1.31:} \begin{enumerate}[a]

\item
\code{sum}手続きは、高階手続きとして表せる数多くの似たような抽象化の中で、最も単純なものに
すぎない。\footnote{\link{Exercise 1.31}から\link{Exercise 1.33}は、
たくさんの一見ばらばらの演算をまとめるために適切な抽象化を使うことで、どれだけの表現力が
得られるかということを示すためのものです。しかしながら、集積やフィルタというのは
洗練された考え方ではあるのですが、この時点でそれらを使うのは、両手を縛られているようなものです。
これらの抽象化を組み合わせる適切な手段となるデータ構造をまだ手に入れていないからです。
\link{Section 2.2.3}で、フィルタと集積を組み合わせるインターフェイスとして
\newterm{sequences} (\jnewterm{列})を使うやり方を学んだのち、この考え方に戻ってきます。
そこでは、プログラムを設計する強力で洗練されたアプローチとしてこれらの手法が本領を発揮する
ことになります。}特定範囲の点における関数の値の積を返す似たような仕組みの手続きを、
\code{product}という名前で書け。\code{product}を使って\code{factorial}を定義するやり方を示せ。
また、次の公式\footnote{この公式は、17世紀のイギリス人数学者John Wallisによって発見されたものです。}を使って、\code{product}によって\( \pi \)の近似値を計算せよ。
\begin{comment}

\begin{example}
pi   2 * 4 * 4 * 6 * 6 * 8 ...
-- = -------------------------
 4   3 * 3 * 5 * 5 * 7 * 7 ...
\end{example}

\end{comment}
\begin{displaymath}
 {\pi\over 4} = {2\cdot 4\cdot 4\cdot 6\cdot 6\cdot 8\dots\over 
		   3\cdot 3\cdot 5\cdot 5\cdot 7\cdot 7\dots}\,. 
\end{displaymath}
\item
あなたが書いた\code{product}手続きが再帰プロセスを生成するのであれば、線形プロセスを
生成するものを書け。線形プロセスを生成するのであれば、再帰プロセスを生成するものを書け。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.32}Exercise 1.32:} \begin{enumerate}[a.]

\item
\code{sum}と\code{product} (\link{Exercise 1.31})は、どちらも\code{accumulate}(集積)
というより一般的な概念の特殊なケースであることを示せ。集積とは、次のような一般的な
集積関数を使って複数の項を組み合わせるものである。


\begin{scheme}
(accumulate combiner null-value term a next b)
\end{scheme}


\code{accumulate}は、\code{sum}や\code{product}と同じく項と範囲指定の引数を取り、
それに加えて、それまでの項の集積と現在の項をどうやって結合するかを指定する
\code{combiner}手続き(2引数)と、項がなくなったときにどのような基本値を使うかを
指定する\code{null\-/value}を引数に取る。\code{accumulate}を書き、
\code{sum}と\code{product}の両方を\code{accumulate}への単純な呼び出しとして定義できる
ことを示せ。

\item
あなたが書いた\code{accumulate}が再帰プロセスを生成するのであれば、線形プロセスを
生成するものを書け。線形プロセスを生成するのであれば、再帰プロセスを生成するものを書け。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.33}Exercise 1.33:}
結合する項に対する\newterm{filter}(\jnewterm{フィルタ})という概念を導入することで、
さらに一般的なバージョンの\code{accumulate} (\link{Exercise 1.32})を手に入れることができる。
指定された条件を満たす範囲内の値から導出される項だけを結合するというものだ。
結果となる\code{filtered\-/accumulate}抽象は、\code{accumulate}と同じ引数に加えて、
フィルタを指定する1引数の述語を取る。\code{filtered\-/accumulate}を手続きとして書け。
次のものを\code{filtered\-/accumulate}を使ってどのように表現するかを示せ。

\begin{enumerate}[a]

\item
\( a \)から\( b \)の区間の素数の二乗の和(すでに\code{prime?}述語を書いているとする)

\item
\( n \)と互いに素である\( n \)未満のすべての正の整数
(つまり、\( {\rm GCD}(i, n) = 1 \)となるすべての整数\( i < n \))の積

\end{enumerate}
\end{quote}


\subsection{\code{lambda}を使って手続きを構築する}
\label{Section 1.3.2}


\code{sum}を使用する際に、\link{Section 1.3.1}でやったように、高階手続きの引数として
使うためだけに\code{pi\-/term}や\code{pi\-/next}のような些細な手続きを定義しないと
いけないというのは、とんでもなく不格好に思えます。\code{pi\-/next}や\code{pi\-/term}を
定義するより、``入力に4を足したものを返す手続き''や``入力と入力に2を足したものの積の
逆数を返す手続き''を直接指定する方法があったほうが便利ではないでしょうか。これは、
手続きを作る\code{lambda}という特殊形式を導入することでできるようになります。
\code{lambda}を使うと、やりたいことはそれぞれ次のように記述できます。

\begin{scheme}
(lambda (x) (+ x 4))
\end{scheme}

\begin{scheme}
(lambda (x) (/ 1.0 (* x (+ x 2))))
\end{scheme}

\noindent
こうすると、\code{pi\-/sum}手続きは次のように補助手続きをまったく定義しないで
表現できます。

\begin{scheme}
(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))
\end{scheme}

\noindent
同様に、\code{lambda}を使うことで、\code{integral}手続きも補助手続き\code{add\-/dx}を
定義しないで書けます。

\begin{scheme}
(define (integral f a b dx)
  (* (sum f
          (+ a (/ dx 2.0))
          (lambda (x) (+ x dx))
          b)
     dx))
\end{scheme}

\noindent
一般的に、\code{lambda}は\code{define}同様、手続きを作るために使われますが、
その手続きに名前を指定しないという点が違います。

\begin{scheme}
(lambda (~\( \dark \langle \)~~\var{\dark formal-parameters}~~\( \dark \rangle \)~) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
作られる手続きは、\code{define}によって作られるものと同じく、普通の手続きです。
唯一の違いは、環境の中で名前と関連づけられていないということだけです。

\begin{scheme}
(define (plus4 x) (+ x 4))
\end{scheme}

\noindent
これは、以下と同値です。

\begin{scheme}
(define plus4 (lambda (x) (+ x 4)))
\end{scheme}

\noindent
\code{lambda}式は、次のように読むことができます。\yakuchu{
日本語では語順が異なるため、前から読み下すことはできません。意味は、「引数xを取り、xと4を足す手続き」です。
}

\begin{scheme}
(lambda                     (x)     (+   x     4))
    |                        |       |   |     |
the procedure of an argument x that adds x and 4
\end{scheme}

\noindent
値として手続きを持つほかの式と同じように、\code{lambda}式は次のように複合式の中で
演算子として使うことができます。

\begin{scheme}
((lambda (x y z) (+ x y (square z)))
 1 2 3)
~\textit{12}~
\end{scheme}

\noindent
というよりも、さらに一般的に言うと、通常手続き名を使うようなどんな文脈でも使えます。
\footnote{\code{lambda}という名前ではなく、\code{make\-/procedure}(手続き作成)のような
当たり前の名前をつけたほうが、Lispを勉強する人にわかりやすく、怖そうな感じを
与えないですんだかもしれません。しかし、この慣習は深く根を下ろしたものです。
この記法は、数理論理学者のAlonzo \link{Church (1941)}によって導入された
\( \lambda \)計算という数学的形式主義から取られています。
Churchは、関数と関数適用の概念を研究する厳密な基礎として\( \lambda \)計算を
開発しました。\( \lambda \)計算は、プログラミング言語の意味論を数学的に
研究するための基礎的な道具となっています。}

\subsubsection*{\code{let}を使ってローカル変数を作る}


\code{lambda}の別の使い方として、ローカル変数を作るというものがあります。
手続きの中で、仮引数として束縛されたもの以外のローカル変数を使いたいという
ことはよくあることです。たとえば、次の関数を計算したいとします。

\begin{comment}

\begin{example}
f(x,y) = x(1 + xy)^2 + y(1 - y) + (1 + xy)(1 - y)
\end{example}

\end{comment}
\begin{displaymath}
 f(x,y) = x(1 + xy)^2 + y(1 - y) + (1 + xy)(1 - y), 
\end{displaymath}
これは、次のように表現することもできます。
\begin{comment}

\begin{example}
     a = 1 + xy
     b = 1 - y
f(x,y) = xa^2 + yb + ab
\end{example}

\end{comment}
\begin{displaymath}
% \eqalign{	a 	&= 1 + xy, \cr
% 		b 	&= 1 - y,  \cr
% 		f(x,y) 	&= xa^2 + yb + ab. \cr}
\begin{array}{r@{{}={}}l}
  a 	  &  1 + xy, \\
  b 	  &  1 - y,  \\
  f(x,y)  &  xa^2 + yb + ab.
\end{array}
\end{displaymath}
\( f \)を計算する手続きを書く際には、\( x \)と\( y \)だけでなく、\( a \)や\( b \)と
いった計算過程の値の名前もローカル変数として持っておきたいところです。これを
実現するひとつの方法は、ローカル変数を束縛するために補助手続きを使うというものです。

\begin{scheme}
(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))
\end{scheme}

\noindent
もちろん、\code{lambda}式を使って、ローカル変数を束縛するための無名手続きを指定する
こともできます。そうすると、\code{f}の本体はその手続きの呼び出しひとつだけになります。

\begin{scheme}
(define (f x y)
  ((lambda (a b)
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))
\end{scheme}

\noindent
この概念は便利なので、\code{let}という特殊形式でさらに手軽に使えるようになっています。
\code{let}を使うと、手続き\code{f}は次のように書けます。

\begin{scheme}
(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
\end{scheme}

\noindent
\code{let}式の一般形式は次のようになります。

\begin{scheme}
(let ((~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~)
      (~\( \dark \langle \)~~\( \dark var_2 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_2 \)~~\( \dark \rangle \)~)
      ~\( \dots \)~
      (~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~))
   ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
これは、次のように考えることができます。\yakuchu{
ここでも、日本語では語順が異なります。「\( \langle \)\var{body}\( \rangle \)の中で、
\( \langle \)\( var_1 \)\( \rangle \)には\( \langle \)\( exp_1 \)\( \rangle \)、
\( \langle \)\( var_2 \)\( \rangle \)には\( \langle \)\( exp_2 \)\( \rangle \)…
という値を持たせる」という意味です。}


\begin{scheme}
let ~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ have the value ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~ and
    ~\( \dark \langle \)~~\( \dark var_2 \)~~\( \dark \rangle \)~ have the value ~\( \dark \langle \)~~\( \dark exp_2 \)~~\( \dark \rangle \)~ and
    ~\( \dots \)~
    ~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~ have the value ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~
in  ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~
\end{scheme}

\noindent
\code{let}式の最初の部分は、名前・式というペアのリストです。\code{let}が評価されるとき、
それぞれの名前は対応する式の値と関連づけられます。\code{let}の本体は、これらの名前が
ローカル変数として束縛された状態で評価されます。これは、\code{let}式が以下のものの
別の文法として評価されているということです。

\begin{scheme}
((lambda (~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~)
    ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
 ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~
 ~\( \dots \)~
 ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
ローカル変数を提供するのに、インタプリタの新しい仕組みは必要ありません。\code{let}式は、
その裏にある\code{lambda}適用に対するシンタックスシュガーにすぎません。

この等価関係から、\code{let}式で指定された変数のスコープが\code{let}の本体であるという
ことがわかります。ここから、次のようなことを導くことができます。

\begin{itemize}

\item
\code{let}を使うと、変数を可能な限りローカルに使用箇所に束縛することができます。
例えば、もし\code{x}の値が5であれば、次の式の値は38になります。

\begin{scheme}
(+ (let ((x 3))
     (+ x (* x 10)))
   x)
\end{scheme}

\noindent
ここで、\code{let}の本体の中では\code{x}は3なので\code{let}式の値は33になります。
それに対して、一番外側の\code{+}の第二引数である\code{x}は5のままです。

\item
変数の値は、\code{let}の外側で計算されます。ローカル変数の値を提供する式が
ローカル変数自身と同じ名前を持った変数に依存している場合には、このことが
関係してきます。例えば、\code{x}の値が2であれば、次の式の値は12になります。

\begin{scheme}
(let ((x 3)
      (y (+ x 2)))
  (* x y))
\end{scheme}

\noindent
これは、\code{let}の本体の中では\code{x}は3になり、\code{y}は4(つまり、外側の\code{x}に
2を足したもの)になっているからです。

\end{itemize}

\noindent
\code{let}と同じ結果を得るために、内部定義が使えることもあります。例えば、上の手続き
\code{f}は次のように定義することもできました。

\begin{scheme}
(define (f x y)
  (define a (+ 1 (* x y)))
  (define b (- 1 y))
  (+ (* x (square a))
     (* y b)
     (* a b)))
\end{scheme}

\noindent
しかし、私たちはこのような状況では\code{let}を使い、\code{define}は内部手続きの定義に
限定して使うようにしています。
\footnote{内部定義を十分に理解し、望むとおりの意味をプログラムに確実に持たせられるように
なるには、この章で紹介したものよりも精巧な評価プロセスのモデルが必要です。しかし、
手続きの内部定義ではこの微妙な問題は起こりません。\link{Section 4.1.6}で評価について
より深く学んだのちに、この問題に戻ってきます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.34}Exercise 1.34:} 次の手続きを定義するとする。

\begin{scheme}
(define (f g) (g 2))
\end{scheme}

すると、次のような結果になる。

\begin{scheme}
(f square)
~\textit{4}~
(f (lambda (z) (* z (+ z 1))))
~\textit{6}~
\end{scheme}


もしここで、インタプリタに\code{(f f)}という組み合わせを評価させるという(ひねくれた)
ことをすると、どのような結果が起こるだろうか。
\end{quote}


\subsection{汎用手法としての手続き}
\label{Section 1.3.3}


\link{Section 1.1.4}では、数値計算のパターンを抽象化するメカニズムとしての複合手続きを
導入し、パターンを特定の数値から独立したものにしました。\link{Section 1.3.1}の
\code{integral}手続きのような高階手続きでは、さらに強力な抽象化に足を踏み入れ、
特定の関数から独立した計算の汎用手法を表現するために使われる手続きというものを
見てきました。この節では、もう二つの精巧な例、関数の零点と不動点を見つける汎用手法
ついて検討し、これらが手続きとして直接表現できるということを示します。

\subsubsection*{区間二分法によって方程式の根を求める}

\newterm{half-interval method}(\jnewterm{区間二分法})とは、\( f \)という連続関数に
ついて方程式\( f(x) = 0 \)の根を求めるための単純ながら強力なテクニックです。
考え方は、\( f(a) < 0 < f(b) \)となる点\( a \)と\( b \)があるとき、
\( f \)は\( a \)と\( b \)の間に少なくともひとつの零点を持つというものです。
零点を特定するためには、\( a \)と\( b \)の平均を\( x \)として\( f(x) \)を計算します。
もし\( f(x) > 0 \)なら、\( f \)は\( a \)と\( x \)の間に零点を持つことになります。
もし\( f(x) < 0 \)なら、\( f \)は\( x \)と\( b \)の間に零点を持ちます。
この方法を続けると、\( f \)が零点を持つ区間をどんどん狭めていくことができます。
区間が十分狭くなったら、処理は停止します。不確定区間は処理の各ステップごとに
半分に縮まっていくので、必要なステップ数の増加オーダーは、元の区間の長さを\( L \)、
許容誤差(``十分に小さい''と見なす区間の大きさ)を\( T \)として、
\( \Theta(\log(L / T)) \)になります。この戦略を実装した手続きを次に示します。

\begin{scheme}
(define (search f neg-point pos-point)
  (let ((midpoint (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond ((positive? test-value)
                 (search f neg-point midpoint))
                ((negative? test-value)
                 (search f midpoint pos-point))
                (else midpoint))))))
\end{scheme}

\noindent
関数\( f \)と、それの値が負と正になる二つの点は、最初に与えられるものとします。
まず、二つの与えられた点の中間点を求めます。次に、与えられた区間が十分に小さいかを
チェックし、小さければ中間点を答えとして返します。そうでない場合、中間点での
\( f \)の値を計算し、それをテスト値とします。テスト値が正であれば、元々の
負の点から中間点までを新しい区間として、処理を続けます。もしテスト値が負であれば、
中間点から正の点を区間として続けます。最後に、テスト値が0である可能性がありますが、
その場合は中間点そのものが探索対象の根ということになります。

両端が``十分に近い''かどうかをテストするには、\link{Section 1.1.7}で平方根を
求めるために使ったのと同じような手続きが使えます。
\footnote{ここでは、0.001を代表的な``小さな''値とし、計算の許容誤差を示すものとして
使っています。実際の計算における適切な許容誤差は、解くべき問題や、コンピュータや
アルゴリズムの制約によって変わります。これは非常に繊細な考慮が必要な問題となる
ことが多く、数値解析の専門家その他の魔法使いの助けが必要になることもあります。}

\begin{scheme}
(define (close-enough? x y) (< (abs (- x y)) 0.001))
\end{scheme}

\noindent
\code{search}を直接使うと、ちょっと面倒なことがあります。うっかり\( f \)の値が
符号の条件を満たさないような点を与えてしまうかもしれないということです。
その場合、間違った答えになってしまいます。そうする代わりに、以下に示す手続きを
経由して\code{search}を使うことにしましょう。これは、どちらの端点が負の関数値を持ち、
どちらが正の関数値を持つかを調べ、それに応じて\code{search}手続きを呼ぶというものです。
関数が二つの与えられた点で同じ符号を持つ場合は、区間二分法は使えませんので、
手続きはエラーのシグナルを送ります。
\footnote{これは、ひとつの引数を取り、それをエラーメッセージとして表示する
\code{error}を使って達成できます。
}

\begin{scheme}
(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond ((and (negative? a-value) (positive? b-value))
           (search f a b))
          ((and (negative? b-value) (positive? a-value))
           (search f b a))
          (else (error "Values are not of 
                        opposite sign" a b)))))
\end{scheme}

\noindent
次の例では、\( \pi \)を近似するのに、区間二分法を使って\( \sin x = 0 \)の
2と4の間にある根として求めています。

\begin{scheme}
(half-interval-method sin 2.0 4.0)
~\textit{3.14111328125}~
\end{scheme}

\noindent
もうひとつ例を挙げます。区間二分法を使って方程式\( x^3 - 2x - 3 = 0 \)の
1から2の間の根を探すというものです。

\begin{scheme}
(half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                      1.0
                      2.0)
~\textit{1.89306640625}~
\end{scheme}

\subsubsection*{関数の不動点を求める}

数値\( x \)が方程式\( f(x) = x \)を満たすとき、\( x \)は関数\( f \)の
\newterm{fixed point}(\jnewterm{不動点})と呼ばれます。
関数\( f \)によっては、最初の推定値から始めて、値があまり変わらなくなるまで
\( f \)を繰り返し適用していくというやり方で不動点を求めることができます。
\begin{comment}

\begin{example}
f(x), f(f(x)), f(f(f(x))), ...
\end{example}

\end{comment}
\begin{displaymath}
 f(x),\quad f(f(x)),\quad f(f(f(x))), \quad\dots, 
\end{displaymath}
この考え方を使って、関数と初期推定値を入力として、その関数の不動点の近似値を
生成する手続きを作ることができます。前もって決めておいた許容範囲に収まるような
二つの値が得られるまで、関数を繰り返し適用していきます。

\begin{scheme}
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
\end{scheme}

\noindent
例えば、初期近似値の1から始めてコサイン関数の不動点を近似するのにこの方法が使えます。
\footnote{退屈な授業の間に、計算機をラジアンモードに設定し、不動点が得られるまで
\code{cos}ボタンを連打するということをやってみてください。
}

\begin{scheme}
(fixed-point cos 1.0)
~\textit{.7390822985224023}~
\end{scheme}

\noindent
同様に、次の方程式の解を見つけることもできます。
\( y = \sin y + \cos y \):

\begin{scheme}
(fixed-point (lambda (y) (+ (sin y) (cos y))) 1.0)
~\textit{1.2587315962971173}~
\end{scheme}

\noindent
不動点処理は、\link{Section 1.1.7}で平方根を求めるのに使った処理と似たところがあります。
どちらも、解が何らかの基準を満たすようになるまで繰り返し改善していくという考えに
基づいています。実際に、平方根の計算は不動点探索としてすぐに形式化できます。
ある数値\( x \)の平方根を求めるには、\( y^2 = x \)となるような\( y \)を探す
必要があります。この方程式を等価な形である\( y = x / y \)に変えると、
\footnote{\( \mapsto \) (``maps to''(写像する)と読む)は、\code{lambda}の
数学者式の書き方です。\( y \mapsto x / y \)は\code{(lambda (y) (/ x y))}
という意味で、つまり\( y \)での値が\( x / y \)となるような関数を表します。}
求めるものが\( y \mapsto x / y \)の不動点であることがわかります。
そのため、平方根は次のような計算で求められないか試してみることができます。

\begin{scheme}
(define (sqrt x)
  (fixed-point (lambda (y) (/ x y)) 1.0))
\end{scheme}

\noindent
残念ながら、この不動点探索は収束しません。最初の推測値を\( y_1 \)とします。
次の推測値は\( y_2 = x / y_1 \)となり、その次は
\( y_3 = x / y_2 = x / (x / y_1) = y_1 \)です。結果として、
\( y_1 \)と\( y_2 \)という二つの推測値をずっと繰り返し、
答えの両側で振動を続ける無限ループになります。

このような振動をコントロールする方法のひとつとして、推測値の大きな変化を
防ぐということがあります。答えは常に推測値\( y \)と\( x / y \)の間に
あるはずなので、\( y \)と\( x / y \)の平均を取ることで、新しい推測値を
\( y \)からも\( x / y \)からもあまり遠くないものにすることができます。
つまり、\( y \)の次の推測値は\( {1\over2}(y + x / y) \)となります。

\begin{scheme}
(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y))) 1.0))
\end{scheme}

\noindent
(\( y = {1\over2}(y + x / y) \)が方程式\( y = x / y \)を単純に変形したものである
ことに注意してください。方程式の両辺に\( y \)を足し、2で割ることで得られます。)

この修正を加えると、平方根の手続きがうまくいくようになります。実は、定義を
外して中を見ていくと、ここで生成されている平方根の近似列が、\link{Section 1.1.7}
の元の平方根手続きによって生成されるものと完全に同じであることがわかります。
解に対する連続した近似値の平均を取るというこのアプローチは、
\newterm{average damping}(\jnewterm{平均緩和法})と呼ばれるテクニックで、
不動点探索の収束に役に立つことがよくあります。

\begin{quote}
\heading{\phantomsection\label{Exercise 1.35}Exercise 1.35:} 黄金比
\( \varphi \)(\link{Section 1.2.2})が\( x \mapsto 1 + 1 / x \)という変形の
不動点であることを示し、そのことを利用して\( \varphi \)を\code{fixed\-/point}
手続きによって求めよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.36}Exercise 1.36:} \code{fixed\-/point}を
修正し、\link{Exercise 1.22}で示した\code{newline}と\code{display}という
基本手続きを使って、生成する近似値列を表示するようにせよ。次に、
\( x \mapsto \log(1000) / \log(x) \)の不動点を求めることによって
\( x^x = 1000 \)の解を求めよ(自然対数を計算するSchemeの基本手続き
\code{log}を利用せよ)。
平均緩和法を使う場合と使わない場合のステップ数を比較せよ。
(\code{fixed\-/point}を開始するのに、1という推定値が使えないことに注意。
1を使うと、\( \log(1) = 0 \)による割り算が発生してしまう。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.37}Exercise 1.37:} \begin{enumerate}[a]

\item
無限\newterm{continued fraction}(\jnewterm{連分数})とは、以下のような形の式である。
\begin{comment}

\begin{example}
           N_1
f = ---------------------
               N_2
    D_1 + ---------------
                   N_3
          D_2 + ---------
                D_3 + ...
\end{example}

\end{comment}
\begin{displaymath}
 {f} = {N_1 \over {D_1 + {N_2 \over {D_2 + {N_3 \over D_3 + \dots}}}}}\,. 
\end{displaymath}
ひとつの例として、\( N_i \)と\( D_i \)がすべて1の無限連分数は\( 1 / \varphi \)
になるということが示せる。ここで、\( \varphi \)は(\link{Section 1.2.2}で説明した)
黄金比である。無限連分数の近似値を求める方法のひとつは、与えられた項数で
展開を打ち切るというものである。このように展開を打ち切ったもの---
いわゆる\newterm{\textit{k}-term finite continued fraction}
(\jnewterm{\textit{k}項有限連分数})---は、以下のような形になる。
\begin{comment}

\begin{example}
       N_1
-----------------
          N_2
D_1 + -----------
      ...    N_K
          + -----
             D_K
\end{example}

\end{comment}
\begin{displaymath}
 {N_1 \over {D_1 + {N_2 \over {\ddots + {N_k \over D_k}}}}}\,. 
\end{displaymath}
\code{n}と\code{d}を1引数(項の添字\( i \))の手続きとし、それぞれ連分数の項
\( N_i \)\( D_i \)を返すとする。
\code{(cont\-/frac n d k)}を評価すると\textit{k}項有限連分数の値を計算するような
手続き\code{cont\-/frac}を定義せよ。
一連の\code{k}の値に対し、以下によって\( 1 / \varphi \)の近似を求め、その手続きをチェックせよ。

\begin{scheme}
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
\end{scheme}

\noindent
小数点以下4桁の精度の近似を得るには、\code{k}をどれだけ大きくしなければならないだろうか。

\item
あなたが書いた\code{cont\-/frac}が再帰プロセスを生成するのであれば、線形プロセスを
生成するものを書け。線形プロセスを生成するのであれば、再帰プロセスを生成するものを書け。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.38}Exercise 1.38:} スイスの数学者
レオンハルト・オイラーは、1737年に\textit{De Fractionibus Continuis}という
学術報告を発表した。それには、\( e - 2 \)(\( e \)は自然対数の底)の連分数展開が
含まれていた。この分数では、\( N_i \)はすべて1で、\( D_i \)は
1, 2, 1, 1, 4, 1, 1, 6, 1, 1,\( \dots \)という数列である。オイラーの連分数展開を
もとに、\link{Exercise 1.37}の\code{cont\-/frac}手続きを使って\( e \)を近似する
プログラムを書け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.39}Exercise 1.39:} 正接(タンジェント)
関数の連分数表現は、1770年にドイツの数学者ヨハン・ハインリッヒ・ランベルトによって
発表された。
\begin{comment}

\begin{example}
              x
tan x = ---------------
                x^2
        1 - -----------
                  x^2
            3 - -------
                5 - ...
\end{example}

\end{comment}
\begin{displaymath}
 {\tan x} = {x \over {1 - {x^2 \over {3 - {x^2 \over 5 - \dots}}}}}\,, 
\end{displaymath}
ここで、\( x \)はラジアンで表したものである。ランベルトの式をもとに、正接関数の
近似値を求める手続き\code{(tan\-/cf x k)}を定義せよ。\code{k}は、
\link{Exercise 1.37}同様、計算する項の数を指定する。
\end{quote}

\label{Section 1.3.4}
\subsection{返り値としての手続き}


ここまでの例では、手続きを引数として渡す能力が私たちのプログラミング言語の表現力を
大幅に拡張するということを見てきました。この表現力は、返り値自身が手続きであるような
手続きを作成することによって、さらに強力なものにすることができます。

この考えを理解するために、\link{Section 1.3.3}の最後で説明した不動点の例を
もう一度見てみましょう。この例では、\( \sqrt{x} \)は\( y \mapsto x / y \)関数の
不動点であるという観察結果からスタートして、不動点探索という形で
\code{square\-/root}手続きの新しいバージョンを定式化しました。
次に、平均緩和法を使って近似値が収束するようにしました。平均緩和法は、それ自体
便利な汎用テクニックです。平均緩和法では、関数\( f \)が与えられたとき、それに対応する
別の関数を考えます。その関数は、\( x \)における値が\( x \)と\( f(x) \)の平均となる
ようなものです。

平均緩和法の考え方は、次の手続きによって表現することができます。

\begin{scheme}
(define (average-damp f) (lambda (x) (average x (f x))))
\end{scheme}

\noindent
\code{average\-/damp}は、引数として手続き\code{f}を取り、(\code{lambda}で生成された)
手続きを返り値とする手続きです。返り値となる手続きは、数値\code{x}に適用すると
\code{x}と\code{(f x)}の平均を返すというものです。例えば、\code{average\-/damp}を
\code{square}手続きに適用すると、\( x \)での値が\( x \)と\( x^2 \)の平均であるような
手続きを返します。この返された手続きに10を適用すると、10と100の平均、つまり55を
返します。\footnote{これは、演算子自身が複合式であるような複合式です。
そのような複合式が作れるということは、\link{Exercise 1.4}ですでに見ていますが、
そこでの例はおもちゃのようなものでした。ここからは、そういった複合式が実際に必要に
なるような場合---高階手続きの返り値となる手続きを適用するとき---について
見ていくことになります。
}

\begin{scheme}
((average-damp square) 10)
~\textit{55}~
\end{scheme}

\noindent
\code{average\-/damp}を使うと、\code{square\-/root}手続きは次のように定式化し直すことができます。

\begin{scheme}
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y))) 1.0))
\end{scheme}

\noindent
この定式化は、この手法の三つの考え方を明確に示しています。
不動点探索、平均緩和法、そして関数\( y \mapsto x / y \)です。
このsquare-rootの手法の定式化を\link{Section 1.1.7}の元のバージョンと比べると
学ぶところがあるでしょう。これらの手続きは同じプロセスを表現しているということに
気をつけて、これらの抽象化を使って表現することでどれだけ考え方が明確になっているかを
見てください。一般的に、プロセスを手続きとして定式化するやり方はいくつもあります。
経験豊富なプログラマであれば、手続きによる定式化の方法から、特に明快で、
プロセスの要素が独立した実態としてほかのアプリケーションで再利用可能である
ようなものを選ぶことができます。再利用の単純な例として、\( x \)の三乗根が
\( y \mapsto x / y^2 \)の不動点であり、そのため私たちのsquare-root手続きは
すぐに立方根を求めるものに拡張可能だということがあります。
\footnote{さらなる一般化については、\link{Exercise 1.45}を参照してください。}


\begin{scheme}
(define (cube-root x)
  (fixed-point (average-damp (lambda (y) (/ x (square y))))
               1.0))
\end{scheme}

\subsubsection*{ニュートン法}


\link{Section 1.1.7}で初めてsquare-root手続きを導入したとき、それが
\newterm{Newton's method}(\jnewterm{ニュートン法})の特別な場合だということに
触れました。\( x \mapsto g(x) \)が微分可能な関数であるとき、方程式
\( g(x) = 0 \)の解は、以下に示す関数\( x \mapsto f(x) \)の不動点となります。
\begin{comment}

\begin{example}
           g(x)
f(x) = x - -----
           Dg(x)
\end{example}

\end{comment}
\begin{displaymath}
 {f(x) = x} - {g(x)\over Dg(x)} 
\end{displaymath}
ここで、\( Dg(x) \)は\( g \)の導関数を\( x \)で評価したものです。
ニュートン法は、上で見た不動点探索法を利用して、関数\( f \)の不動点を探すこと
によって方程式の解を近似するというものです。
\footnote{微積分の入門書では、ニュートン法は普通、
\( x_{n+1} = x_n -g(x_n) / Dg(x_n) \)という近似列として記述されています。
私たちはプロセスに関して語る言語を持っているため、不動点の考えを使って
手法の記述を簡単にすることができます。}

多くの関数\( g \)と、十分によい初期推測値\( x \)に対して、ニュートン法は
\( g(x) = 0 \)の解に急速に収束します。\footnote{ニュートン法は必ず解に収束する
わけではありませんが、うまくいく場合は繰り返しごとに解の近似値の精度の桁数が
倍になるということが示せます。そのような場合は、ニュートン法は区間二分法より
ずっと速く収束します。}

ニュートン法を手続きとして実装するには、まず微分という考え方を表現する必要が
あります。``微分''というものは、平均緩和法と同様に、ある関数を別の関数に
変形するものだということに注目してください。例えば、関数\( x \mapsto x^3 \)を
微分したものは\( x \mapsto 3x^2 \)です。

一般的に、\( g \)が関数で\( dx \)が小さな値であるとき、\( g \)を微分した
\( Dg \)は、任意の数値\( x \)における値が(\( dx \)を極小にしたときに)
次のようになる関数です。
\begin{comment}

\begin{example}
        g(x + dx) - g(x)
Dg(x) = ----------------
               dx
\end{example}

\end{comment}
\begin{displaymath}
 {Dg(x)} = {g(x + {\it dx}) - g(x) \over {\it dx}}\,. 
\end{displaymath}
このため、微分という考え方は(例えば\( dx \)を0.00001として)次のような
手続きとして表現できます。

\begin{scheme}
(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
\end{scheme}

\noindent
次の定義も加えます。

\begin{scheme}
(define dx 0.00001)
\end{scheme}

\noindent
\code{average\-/damp}同様、\code{deriv}は手続きを引数に取り手続きを返り値とする
手続きです。例えば、\( x \mapsto x^3 \)を微分したものの5での値(正確な値は75です)
の近似値を求めるには、次の式を評価します。

\begin{scheme}
(define (cube x) (* x x x))
((deriv cube) 5)
~\textit{75.00014999664018}~
\end{scheme}

\noindent

\code{deriv}の助けを借りると、ニュートン法は不動点探索プロセスとして表現できます。

\begin{scheme}
(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))
\end{scheme}

\noindent
\code{newton\-/transform}手続きはこの節の最初の式を表現しており、
\code{newtons\-/method}はそれを使ってすぐに定義できます。
引数として、零点を見つけたい関数を計算する手続きと初期推測値を取ります。
例えば、\( x \)の平方根は、初期推測値1から初めて、\( y \mapsto y^2 - x \)関数の
零点をニュートン法によって求めることによって求められます。
\footnote{平方根を求める場合、どんな初期値から初めても、ニュートン法は急速に
正しい解に収束します。}

このことから、平方根手続きをまた別の形で書くことができます。

\begin{scheme}
(define (sqrt x)
  (newtons-method
   (lambda (y) (- (square y) x)) 1.0))
\end{scheme}

\subsubsection*{抽象化とファーストクラス手続き}


ここまで、平方根計算をより一般的な手法の具体例として表現する二つの方法を見てきました。
ひとつは不動点探索で、もうひとつはニュートン法です。ニュートン法はそれ自身
不動点プロセスとして表現されているので、実際には平方根を不動点として計算する
二つの方法を見てきたことになります。どちらもある関数から始め、その関数を
変形したものの不動点を求めます。この一般的な考え方自体、手続きとして表現できます。

\begin{scheme}
(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))
\end{scheme}

\noindent

このとても一般的な手続きは、引数として手続き\code{g}(何らかの関数を計算する)、
\code{g}を変形する手続き、初期推測値を取ります。返り値は変形された関数の不動点です。

この抽象化によって、この節の最初の(\( y \mapsto x / y \)の平均緩和バージョンに対して
不動点を求める)平方根計算を、この一般的な方法の一例として書き直すことができます。

\begin{scheme}
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (/ x y)) average-damp 1.0))
\end{scheme}

\noindent
同じようにして、この節の二つ目の(\( y \mapsto y^2 - x \)のニュートン変形の不動点を
求める)平方根計算は、次のように表現できます。

\begin{scheme}
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (- (square y) x)) newton-transform 1.0))
\end{scheme}

\noindent
\link{Section 1.3}は、複合手続きが非常に重要な抽象化メカニズムであるという
観察結果から始めました。複合手続きは、私たちのプログラミング言語の中で、
一般的な計算手法を明示的な要素として表現することを可能にするものだからです。
ここでは、高階手続きを使うことによって、これらの一般的な手法を組み合わせて
さらなる抽象化を生み出していけるということを見てきました。

プログラマである私たちは、プログラムに潜んでいる抽象化を見つけ、それらの抽象化を
使ってプログラムを構築し、さらに強力な抽象化を生み出すためにそれらを一般化する
機会を見逃さないようにしなければいけません。これは、いつでも可能な限り抽象的に
プログラムを書かなければいけないということではありません。熟練プログラマであれば、
タスクに対して適切な抽象レベルを選べるものです。しかし、新しい状況でも適用できる
ように、このような抽象化によって考えられるようになっておくことは重要です。
高階手続きが重要なのは、これらの抽象化を明示的に私たちのプログラミング言語で
表現することを可能にし、ほかの計算の要素と同じように扱えるようにしてくれるからです。

一般的に、プログラミング言語は計算要素の操作方法に制約を課すものです。
制約が最も少ない要素は、\newterm{first-class}(\jnewterm{ファーストクラス})の
地位を持つと言います。ファーストクラス要素の``権利と特権''のいくつかを
次に示します。\footnote{プログラミング言語の要素についてのファーストクラスの
地位という概念は、イギリスの計算機科学者Christopher Strachey (1916-1975)に
よるものです。}

\begin{itemize}

\item
変数によって名前をつけることができる。

\item
手続きに引数として渡すことができる。

\item
手続きの返り値になることができる。

\item
データ構造に組み込むことができる。\footnote{
この実例は、\link{Chapter 2}でデータ構造を紹介した後に見ていきます。}

\end{itemize}

\noindent
Lispは、ほかの一般的なプログラミング言語と違い、手続きに完全なファーストクラスの
地位を与えています。このことは効率的な実装をするうえでの課題となりますが、
そのおかげで非常に強い表現力を手にすることができます。
\footnote{ファーストクラス手続きの実装コストのうち主要なものとして、
手続きを返り値とすることができるようにするには手続きの自由変数の領域を
手続きが実行中でないときにも予約しておかなければいけないということがあります。
\link{Section 4.1}で学ぶSchemeの実装では、これらの変数は手続きの環境に保存されます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.40}Exercise 1.40:}
次のような形の式で\code{newtons\-/method}手続きと組み合わせて使えるような手続き
\code{cubic}(三次方程式)を定義せよ。

\begin{scheme}
(newtons-method (cubic a b c) 1)
\end{scheme}

\noindent
これを使って、三次方程式\( x^3 + ax^2 + bx + c = 0 \)の零点の近似値を求めよ。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.41}Exercise 1.41:}
引数がひとつの手続きを引数として取り、その手続きを二回適用する手続きを返す
手続き\code{double}を定義せよ。
例えば、\code{inc}が引数に1を足す手続きであれば、\code{(double inc)}は2を足す
手続きになる。次の式はどんな値を返すだろうか。

\begin{scheme}
(((double (double double)) inc) 5)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.42}Exercise 1.42:}
\( f \)と\( g \)を二つの1引数関数とする。
\( g \)に\( f \)を\newterm{composition}(\jnewterm{合成})するということを、
関数\( x \mapsto f(g(x)) \)として定義する。合成を実装する手続き\code{compose}を
定義せよ。例えば\code{inc}が引数に1を足す手続きであれば、以下のようになる。

\begin{scheme}
((compose square inc) 6)
~\textit{49}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.43}Exercise 1.43:}
\( f \)が数値関数で\( n \)が正の整数であれば、\( f \)の\( n \)回適用という
ものを作ることができ、それは\( x \)での値が\( f(f(\dots (f(x))\dots )) \)で
ある関数として定義できる。
例えば、\( f \)が関数\( x \mapsto x + 1 \)であれば、\( f \)の\( n \)回適用は
関数\( x \mapsto x + n \)となる。もし\( f \)が数値を二乗する演算であれば、
\( f \)の\( n \)回適用は、引数を\( 2^n \)乗する関数になる。入力として
\( f \)を計算する手続きと正の整数\( n \)を取り、\( f \)の\( n \)回適用を
計算する手続きを返す手続きを書け。
その手続きは、以下のように使えるはずである。

\begin{scheme}
((repeated square 2) 5)
~\textit{625}~
\end{scheme}

ヒント：\link{Exercise 1.42}の\code{compose}を使うと便利かもしれない。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.44}Exercise 1.44:} 
 関数の\newterm{smoothing}(\jnewterm{平滑化})は、信号処理において重要な概念である。
\( f \)が関数で\( dx \)がある小さな値であるとき、\( f \)を平滑化したものは
\( x \)での値が\( f(x - dx) \), \( f(x) \), \( f(x + dx) \)の平均となる関数である。
入力として\( f \)を計算する手続きを取り、\( f \)を平滑化したものを計算する手続きを
返す手続き\code{smooth}を書け。時には、関数を繰り返し平滑化する(つまり、平滑化した
関数をさらに平滑化することを続ける)ことによって
\newterm{\textit{n}-fold smoothed function}(\jnewterm{\textit{n}重平滑化関数})
を得ることが役に立つこともある。\code{smooth}と\link{Exercise 1.43}の\code{repeated}
を使って任意の関数の\textit{n}重平滑化関数を生成するやり方を示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.45}Exercise 1.45:}
\link{Section 1.3.3}では、単純に\( y \mapsto x / y \)の不動点を探すことによって
平方根を計算しようとすると収束しないということと、それを平均緩和法によって
解決できるということを見た。三乗根の計算にも同じ方法を使うことができ、
\( y \mapsto x / y^2 \)を平均緩和したものの不動点として求めることができる。
残念ながら、このプロセスは四乗根ではうまくいかない。\( y \mapsto x / y^3 \)を
収束させるのに、平均緩和を一回するだけでは十分ではない。一方、平均緩和を
二回行う(つまり、\( y \mapsto x / y^3 \)の平均緩和の平均緩和を使う)と、
不動点探索は収束するようになる。\( y \mapsto x / y^{n-1} \)を繰り返し平均緩和した
ものに対する不動点探索によって\( n^{\mathrm{th}} \)を計算する場合、何回の平均緩和が
必要となるか実験せよ。その結果を利用し、\link{Exercise 1.43}の\code{fixed\-/point},
\code{average\-/damp}, \code{repeated}手続きを使って\( n \)乗根を計算する単独の
手続きを実装せよ。必要な数値演算は基本手続きとして利用できるとする。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.46}Exercise 1.46:}
この章で記述した数値計算法のいくつかは、\newterm{iterative improvement}
(\jnewterm{反復改良法})と呼ばれる非常に汎用的な計算戦略の実例である。
反復改良法というのは、何かを計算するにあたって、答えに対する初期推測値から始めて、
その推測値が十分によいかテストし、よくなければ推測値を改良し、改良した推測値を
新しい推測値としてそのプロセスを続けるというものである。二つの手続きを引数として
取る手続き\code{iterative\-/improve}を書け。引数はそれぞれ、推測値が十分によいか
判断する手続きと、推測値を改良する手続きとする。\code{iterative\-/improve}の
返り値は、引数として初期推測値を取り、それが十分によくなるまで改良を続ける手続きと
する。
\link{Section 1.1.7}の\code{sqrt}手続きと\link{Section 1.3.3}の
\code{fixed\-/point}手続きを\code{iterative\-/improve}によって書き直せ。
\end{quote}

%=======================================================================================================

\chapter{データを用いた抽象化の構築}
\label{Chapter 2}

\begin{quote}
私たちはここで、数学的抽象化の決定的なステップに到達しました。
記号の意味について忘れるのです。\( \dots \)[数学者]はだらだらしていなくても
大丈夫です。これらの記号を使ってできる演算はいくらでもあります。何を意味して
いるのか調べる必要はありません。

---Hermann Weyl, \textit{The Mathematical Way of Thinking}
\end{quote}

\vspace{1.0em}

\noindent
\link{Chapter 1}では、計算プロセスと、プログラム設計における手続きの役割に
焦点を合わせました。基本データ(数値)と基本演算(数値演算)の使い方、
組み合わせや条件式や引数の使用によって手続きを組み合わせて複合手続きを作る方法、
\code{define}を使って手続きを抽象化する方法について見てきました。また、
プロセスの局所展開のパターンとして手続きを捉えることができるということも
学びました。さらに、手続きという形で具体化されたプロセスのいくつかの共通パターンに
ついて分類や論証を行い、また簡単なアルゴリズム的解析をしました。高階手続きによって
計算上の一般的手法を扱うことができ、またそれらを使って考えることができるように
なるため、私たちの言語を強力なものにしてくれるということも見てきました。
これは、プログラミングの本質の大きな部分を占めています。

この章では、さらに複雑なデータについて見ていきます。第一章での手続きはすべて
単純な数値データを処理するものでしたが、私たちがコンピュータで解決したいと
思っている問題の多くでは、単純なデータは十分ではありません。プログラムは
普通、複雑な現象をモデル化するように設計されるものです。いくつもの側面を持つ
実世界の現象をモデル化するために、いくつもの部品を持つコンピュータ上の
オブジェクトを作る必要に迫られることはよくあります。そのため、第一章での
焦点が手続きを組み合わせて複合手続きを作ることによって抽象化を構築することで
あったのに対して、この章では、どんなプログラミング言語についても言える、もう
ひとつの重要な側面に目を向けます。データオブジェクトを組み合わせて
\newterm{compound data}(\jnewterm{複合データ})を作るためにプログラミング言語が提供する
手段です。

なぜプログラミング言語に複合データが必要なのでしょうか。複合手続きが必要なのと
同じ理由です。プログラムを設計する概念レベルを引き上げ、設計のモジュール性を
高め、言語の表現力を強くしたいからです。手続きを定義できることによって
基本演算よりも高い概念レベルで手続きを扱えるようになるように、複合データ
オブジェクトを構築できることによって、言語の基本データオブジェクトよりも
高い概念レベルでデータを扱えるようになります。

有理数を使って計算を実行するシステムを設計するというタスクについて考えてみましょう。
例えば、二つの有理数を取って和を返す\code{add\-/rat}という演算を考えることが
できます。単純なデータを使うと、有理数は分母と分子という二つの整数として
考えられます。そのため、有理数が二つの整数(分母と分子)として表され、
\code{add\-/rat}が二つの手続き(ひとつは和の分子を返し、もうひとつは分母を返す)
として実装されるようにプログラムを設計することができます。しかし、
これは不格好です。こうすると、どの分子がどの分母に対応するのか明示的に
記録しておかないといけないからです。たくさんの有理数演算を実行するような
システムでは、そんな簿記みたいな細かい処理があるとプログラムがとても
読みにくくなってしまいますし、人間の心に与える影響も言うまでもありません。
分母と分子を``くっつけて''、ペア---\newterm{compound data object}
(\jnewterm{複合データオブジェクト})---にすることができれば、状況は
ずっとよくなります。そうすると、有理数をひとつの概念単位として捉えるという
考え方に近いやり方でプログラムから扱うことができます。

複合データを使うと、プログラムのモジュール性を上げることもできます。
有理数を一人前のオブジェクトとして直接操作することができれば、プログラムの中で
有理数を有理数として扱う部分を、有理数を例えば整数のペアとしてどうやって
表すかといった細部から分離することができるようになります。プログラムの中の
データオブジェクトをどうやって表すかを扱う部分と、データオブジェクトを
どうやって使うかを扱う部分とを分離するという汎用的なテクニックは、
\newterm{data abstraction}(\jnewterm{データ抽象化})と呼ばれる
強力な設計手法です。ここでは、データ抽象化によってプログラムの設計・保守・修正が
どれだけ簡単になるかということを見ていきます。

複合データを使うことによって、私たちのプログラミング言語の表現力は
実際に向上します。``線形結合''\( ax + by \)を作ることを考えてみましょう。
書き方はいろいろ考えられますが、例えば\( a \), \( b \), \( x \), \( y \)を
引数として取り、\( ax + by \)の値を返す手続きを書くとします。
引数が数値であれば、何も難しいことはありません。すぐに次のような手続きを定義できます。

\begin{scheme}
(define (linear-combination a b x y)
  (+ (* a x) (* b y)))
\end{scheme}

\noindent
しかし、扱いたいものが数値だけでないとするとどうでしょう。加算と乗算さえ
定義されていれば、有理数でも複素数でも多項式でも何でも線形結合が作れるという
考え方を、手続きという形で表現したいという場合について考えてみます。
これは、次のような形の手続きとして表現できます。

\begin{scheme}
(define (linear-combination a b x y)
  (add (mul a x) (mul b y)))
\end{scheme}

\noindent

ここで、\code{add}と\code{mul}は基本手続き\code{+}と\code{*}ではなく、
\code{a}, \code{b}, \code{x}, \code{y}という引数として渡すデータに対して、
その種類に応じて適切な演算を行うという、より複雑な何かです。
ここでキーとなるのは、\code{linear\-/combination}が\code{a}, \code{b},
\code{x}, \code{y}について、手続き\code{add}と\code{mul}が適切な演算を
行ってくれるはずだということだけ知っておけばいいということです。
手続き\code{linear\-/combination}から見ると、\code{a}, \code{b}, \code{x}, \code{y}が
何であるかはどうでもいいことで、それらが基本データを使ってどういう形で表現されることに
なっているかというのはもっとどうでもいいことです。この同じ例は、なぜ私たちの
プログラミング言語が複合データを直接扱う能力を提供してくれないといけないのかを
教えてくれます。その能力がないと、\code{linear\-/combination}のような手続きが、
内部構造を知らないまま、引数を\code{add}と\code{mul}に渡すということを行う方法が
ありません。
\footnote{
これは、手続きを直接操作する能力がプログラミング言語の表現力を向上させるというのと
似たようなものです。例えば、\link{Section 1.3.1}では\code{sum}という手続きを導入
しましたが、これは手続き\code{term}を引数として取り、ある指定した区間での\code{term}の
値の和を求めるというものでした。\code{sum}を定義するためには、\code{term}のような
手続きについて、それがより基本的な演算によってどのように表現されているかという
ことと関係なく、独立した実体として考えることができるということが決定的に
重要です。もし``手続き''という概念がなかったら、\code{sum}のような演算が
定義できるという可能性を考えることさえできなかったかもしれません。それに、
総和計算の実行ということに関する限り、\code{term}がより基本的な演算によって
どのように構築されているかという細かいところはどうでもいいことです。}

この章は、上で述べた有理数計算システムの実装から始めます。これによって、
複合データやデータ抽象化について考察する基礎ができます。複合手続きの
場合と同じように、対象とする主な問題は、複雑性をうまく扱うテクニックと
しての抽象化です。ここでは、データ抽象化によって、プログラムの部品間に
適切な\newterm{abstraction barriers}(\jnewterm{抽象化の壁})を建てられるように
なるということを見ていきます。

複合データを形成するうえで鍵となることは、データオブジェクトを組み合わせて
複雑なデータオブジェクトを形成できるように、プログラミング言語がある種の
``糊''を提供しなければいけないということです。糊として使うものには、いろいろな
種類のものがありえます。実際に、特別な``データ''操作をまったく使わずに、
手続きだけを使って複合データを作ることができるということを見ていきます。
このことによって、第一章の末尾ですでに曖昧になってきていた``手続き''と
``データ''との境界線は、さらに曖昧なものになっていきます。また、
列や木を表現するための確立されたテクニックについても見ていきます。
複合データを扱ううえで鍵となる考え方のひとつは、
\newterm{closure}(\jnewterm{クロージャ})という概念です。これは、私たちが
データオブジェクトを組み合わせるのに使う糊は、基本データオブジェクトだけでなく、
複合データオブジェクトも組み合わせられるようになっていなければいけないという
ことです。もうひとつの鍵となる考え方は、部品を組み立てるようにプログラムの
モジュールを組み立てるうえで、複合データが\newterm{conventional interfaces}
(\jnewterm{確立されたインターフェイス})として使えるということです。
これらの考え方の一部については、クロージャを使う簡単なグラフィック言語によって
図解することにします。

また、\newterm{symbolic expressions}(\jnewterm{記号式})---要素が数値だけでなく
任意の記号からなるデータ---を導入することで、私たちの言語の表現力を強化します。
さらに、オブジェクトの集合を表現するうえでのいろいろなやり方について詳しく
見ていきます。ある数値関数を計算するのにいろいろな計算プロセスが考えられるのと
同じように、あるデータ構造をより単純なオブジェクトによって表すのにもいろいろな
やり方があり、その表現をどう選ぶかということが、そのデータを扱うプロセスが
必要とする時間や空間に大きな影響を与えうるということがわかります。
これらの考え方については、記号微分、集合の表現、情報のエンコードといった文脈で
検討していきます。

その次に、プログラムのいろいろな部分で異なる形で表現されているデータを扱うという
問題を取り上げます。このためには、異なるデータ型を処理する
\newterm{generic operations}(\jnewterm{総称演算})というものを実装しなければなりません。
総称演算というものがある状況でモジュール性を維持するには、単純なデータ抽象化だけの
場合に比べて、より強力な抽象化の壁が必要になります。具体的には、
\newterm{data-directed programming}(\jnewterm{データ主導プログラミング})という
テクニックを導入します。これは、それぞれのデータ表現を独立して設計し、
それらを\newterm{additively}(\jnewterm{加法的})に(つまり、修正なしに)組み合わせ
られるようにするものです。
システム設計におけるこのアプローチの力を示すために、そこまでで学んだことを
多項式上での記号演算を実行するパッケージの実装に適用することで、この章の
締めくくりとします。ここでの多項式の係数は、整数、有理数、複素数、さらには
ほかの多項式となることもあります。

\section{データ抽象化入門}
\label{Section 2.1}

\link{Section 1.1.8}では、ある手続きをより複雑な手続きの要素として使うとき、
その手続きは特定の演算の集合としてだけでなく、手続きの抽象化として見ることも
できるということに触れました。つまり、手続きがどうやって実装されているかという
細かいところは隠しておくことができ、その特定の手続き自身、同じような全体的な
ふるまいを持つ別の任意の手続きによって置き換えることができるということです。
別の言い方をすると、手続きがどのように使われるかというところを、その手続きが
より基本的な手続きによってどのように実装されているかといった細かいところから
分離するという抽象化ができるということになります。
複合データについての同じような概念は、\newterm{data abstraction}
(\jnewterm{データ抽象化})と呼ばれます。データ抽象化は、複合データオブジェクトが
どう使われるかというところを、それがより基本的なデータオブジェクトによって
どのように構築されているかといった細かいところから分離することを可能にする
方法です。

データ抽象化の基本的な考え方は、複合データオブジェクトを使うようなプログラムを
構築する際に、``抽象データ''を扱うようにするということです。これは、プログラムで
データを扱うときに、手元のタスクを実行するのに絶対に必要とは言えないような
想定をしないようにするということです。また、``具体的な''データ表現は、
そのデータを使うプログラムとは独立に定義されます。私たちのシステムのこれら
二つの部品をつなぐインターフェイスの役割を担うのは一組の手続きで、それらは
\newterm{selectors}(セレクタ)と\newterm{constructors}(コンストラクタ)と
呼ばれます。これらが抽象的なデータを具体的な表現によって実装することになります。
このテクニックの説明のために、有理数を扱う手続きの集合をどのように設計するかという
ことを考えていきます。


\subsection{例: 有理数の数値演算}
\label{Section 2.1.1}

有理数を使って数値演算を行いたいという場合について考えてみましょう。
行いたい演算は、足し算、引き算、かけ算、割り算や、二つの有理数が
等しいかどうかテストするといったものになるでしょう。

まずは、分子と分母から有理数を構築する方法はすでに持っていると仮定しましょう。
また、有理数が与えられたときに、その分子と分母を抽出(セレクト)する方法も
あるとします。さらに、コンストラクタとセレクタは次のように手続きとして
使うことができるとします。

\begin{itemize}

\item
\( \hbox{\tt(make-rat}\;\langle{n}\kern0.08em\rangle\;\langle{d}\kern0.06em\rangle\hbox{\tt)} \)は、分子が整数\( \langle{n}\kern0.08em\rangle \)で分母が整数\( \langle{d}\kern0.06em\rangle \)である有理数を返す。

\item
\( \hbox{\tt(numer}\;\;\langle{x}\kern0.08em\rangle\hbox{\tt)} \)は、有理数\( \langle{x}\kern0.08em\rangle \)の分子を返す。

\item
\( \hbox{\tt(denom}\;\;\langle{x}\kern0.08em\rangle\hbox{\tt)} \)は、有理数\( \langle{x}\kern0.08em\rangle \)の分母を返す。

\end{itemize}

\noindent
ここでは、プログラムを合成していくうえでの強力な戦略である
\newterm{wishful thinking}(\jnewterm{希望的思考})を使っています。
有理数をどうやって表現するのか、\code{numer}, \code{denom}, \code{make\-/rat}
という手続きをどう実装するのか、まだ何も言っていません。それでも、
もしこれらの手続きを持っていたとすると、足し算、引き算、かけ算、割り算、
等価性のテストは、次のような関係を使って実行できます。
\begin{comment}

\begin{example}
n_1   n_2   n_1 d_2 + n_2 d_1
--- + --- = -----------------
d_1   d_2        d_1 d_2

n_1   n_2   n_1 d_2 - n_2 d_1
--- - --- = -----------------
d_1   d_2        d_1 d_2

n_1   n_2   n_1 n_2
--- * --- = -------
d_1   d_2   d_1 d_2

n_1 / d_1   n_1 d_2
--------- = -------
n_2 / d_2   d_1 n_2

n_1   n_2
--- = ---  if and only if n_1 d_2 = n_2 d_1
d_1   d_2
\end{example}

\end{comment}
\begin{align*}
  {n_1 \over d_1} + {n_2 \over d_2} 	&= {n_1 d_2 + n_2 d_1 \over d_1 d_2}, \\
  {n_1 \over d_1} - {n_2 \over d_2} 	&= {n_1 d_2 - n_2 d_1 \over d_1 d_2}, \\
  {n_1 \over d_1} \cdot {n_2 \over d_2}	&= {n_1 n_2 \over d_1 d_2}, \\
  {n_1 / d_1} \over {n_2 / d_2} 	&= {n_1 d_2 \over d_1 n_2}, \\
  {n_1 \over d_1} 			&= {n_2 \over d_2} \quad 
						{\rm\ if\ and\ only\ if\quad} 
						n_1 d_2 = n_2 d_1.
\end{align*}
これらのルールは、手続きとして表現できます。

\begin{scheme}
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))

\end{scheme}
これで、有理数の演算が\code{numer}, \code{denom}, \code{make\-/rat}という
セレクタ手続きとコンストラクタ手続きによって定義できました。
しかし、セレクタ手続きとコンストラクタ手続きは定義していません。
ここで、分母と分子を組み合わせて有理数を作るために何らかの方法が必要になります。

\subsubsection*{ペア}

テータ抽象化の具体的なレベルを実装することを可能にするために、私たちの言語は
\newterm{pair}(\jnewterm{ペア})という複合構造を用意しています。これは、
\code{cons}という基本手続きによって構築できます。この手続きは二つの引数を取り、
それら二つの引数を部品として含む複合データオブジェクトを返します。ペアがあるとき、
それらの部品は\code{car}と\code{cdr}という基本手続きを使って取り出すことができます。
\footnote{\code{cons}という名前は``construct''を表しています。\code{car}と
\code{cdr}という名前は、IBM 704上での最初のLisp実装に由来します。この機械は
メモリ位置の``アドレス''と``デクリメント''という部分が参照できるような
アドレス方式を持っていました。\code{car}は
``Contents of Address part of Register''(レジスタのアドレス部分の中身)を表し、
\code{cdr}(``クダー''と読みます)は``Contents of Decrement part of Register''
(レジスタのデクリメント部分の中身)を表しています。}
そのため、\code{cons}, \code{car}, \code{cdr}は次のような使い方ができます。

\begin{scheme}
(define x (cons 1 2))
(car x)
~\textit{1}~
(cdr x)
~\textit{2}~
\end{scheme}

\noindent
ペアは、基本データオブジェクトと同じように、名前をつけて操作することができる
データオブジェクトです。さらに、\code{cons}は要素がペアであるペアや、またそれが
要素となるペアといったものを作ることもできます。

\begin{scheme}
(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))
(car (car z))
~\textit{1}~
(car (cdr z))
~\textit{3}~
\end{scheme}

\noindent
\link{Section 2.2}では、ペアを組み合わせるこの能力が、ペアというものを
すべての複雑なデータ構造を作るための汎用ブロックとして使えるものにしている
ということを学びます。手続き\code{cons}, \code{car}, \code{cdr}によって
実装される、唯一の基本複合データである\newterm{pair}\jnewterm{ペア}は、
私たちが必要とするただひとつの糊です。ペアによって構築されるデータオブジェクトは
\newterm{list-structured}(\jnewterm{リスト構造})のデータと呼ばれます。

\subsubsection*{有理数を表現する}

有理数システムを作るのに必要な残りの部分を補うために、ペアは自然なやり方を
提供してくれます。単純に、分子と分母という二つの整数のペアとして有理数を
表現すればいいのです。そうすると、\code{make\-/rat}, \code{numer}, \code{denom}は
すぐに次のように実装することができます。


\footnote{
セレクタとコンストラクタは次のように実装することもできます。

\begin{smallscheme}
(define make-rat cons)
(define numer car)
(define denom cdr)
\end{smallscheme}

一つ目の定義は\code{make\-/rat}という名前を、式\code{cons}の値である、ペアを構築する
基本手続きに関連づけるというものです。こうすると、\code{make\-/rat}と\code{cons}は
同じ基本コンストラクタに対する名前になります。

セレクタとコンストラクタをこのやり方で定義すると、効率はよくなります。
\code{make\-/rat}が\code{cons}を\strong{呼び出す}のではなく、
\code{make\-/rat}は\code{cons}\strong{である}ため、\code{make\-/rat}が呼ばれるときに
呼ばれる手続きは、二つではなくひとつになります。一方で、このやり方をしてしまうと、
手続き呼び出しを追跡したり手続き呼び出しにブレークポイントを置いたりといった
デバッグ手段が使い物にならなくなってしまいます。\code{make\-/rat}手続きの
呼び出しを監視したいという場合はあるかもしれませんが、\code{cons}のすべての
呼び出しを監視するなんてことはしたくないはずです。

この本では、この定義スタイルは使わないことにしました。}

\begin{scheme}
(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))
\end{scheme}

\noindent
また、計算結果を表示するために、有理数を分子、スラッシュ、分母として表示する
ことにします。
\footnote{
\code{display}はデータを表示するSchemeの基本要素です。Schemeの基本要素
\code{newline}は改行を行います。これらの手続きは、どちらも意味のある値は返しません。
そのため、以下での\code{print\-/rat}の使用例では、\code{print\-/rat}が表示するもの
のみを示し、インタプリタが\code{print\-/rat}の返り値として表示するものは
示さないことにします。}

\begin{scheme}
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
\end{scheme}

\noindent
これで、有理数手続きを試してみることができます。

\begin{scheme}
(define one-half (make-rat 1 2))
(print-rat one-half)
~\textit{1/2}~
(define one-third (make-rat 1 3))
(print-rat (add-rat one-half one-third))
~\textit{5/6}~
(print-rat (mul-rat one-half one-third))
~\textit{1/6}~
(print-rat (add-rat one-third one-third))
~\textit{6/9}~
\end{scheme}

\noindent
最後の例からわかるように、この有理数計算の実装は有理数を既約のものに簡約して
くれません。これを直すには、\code{make\-/rat}を修正します。\link{Section 1.2.5}で
扱ったような、二つの整数の最大公約数を返す\code{gcd}手続きがあれば、ペアを構築する
前に\code{gcd}を使って分子と分母を既約にすることができます。

\begin{scheme}
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
\end{scheme}

\noindent
こうすることで、次のように望む結果が得られます。

\begin{scheme}
(print-rat (add-rat one-third one-third))
~\textit{2/3}~
\end{scheme}

\noindent
この修正はコンストラクタ\code{make\-/rat}の変更だけで完了し、
実際の演算を実装する(\code{add\-/rat}や\code{mul\-/rat}といった)手続きは
どれも変更する必要がありませんでした。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.1}Exercise 2.1:}
正と負の両方の引数を扱うことができる改良版\code{make\-/rat}を定義せよ。
\code{make\-/rat}は符号を正規化し、正の有理数であれば分子と分母の両方が正となり、
負の有理数であれば分子のみが負になるようにする。
\end{quote}

\subsection{抽象化の壁}
\label{Section 2.1.2}

複合データとデータ抽象化の例を続けて見ていく前に、有理数の例で出てきたいくつかの
問題について考えてみましょう。有理数演算を定義するのに、私たちはコンストラクタ
である\code{make\-/rat}とセレクタである\code{numer}、\code{denom}を使いました。
一般的に、データ抽象化の底にある考え方は、それぞれのデータオブジェクトの型に対して、
それさえあればその型に対するどんな演算も行えるような基本演算セットを特定し、
その後はデータを操作するのにそれらの演算しか使わないようにするというものです。

有理数システムの構造は、\link{Figure 2.1}のようにイメージすることができます。
水平線は、システムの異なる``レベル''を分離する\newterm{abstraction barriers}
(\jnewterm{抽象化の壁})を表しています。有理数を使うプログラムは、有理数パッケージに
よって``公共用''として提供された手続きである\code{add\-/rat}, \code{sub\-/rat},
\code{mul\-/rat}, \code{div\-/rat}, \code{equal\-/rat?} だけを使って有理数を操作します。
これらの手続きはというと、コンストラクタとセレクタである\code{make\-/rat},
\code{numer}, \code{denom}だけを使って実装されていますが、コンストラクタとセレクタは
というと、これらはペアによって実装されています。ペアは、\code{cons}, \code{car},
\code{cdr}によって操作することさえできれば、どのように実装されているかは
有理数パッケージの残りの部分とは無関係です。実質的に、それぞれのレベルの手続きは、
抽象化の壁を定義し、異なるレベルをつなぐインターフェイスとなっています。

この単純な考え方には、いろいろないいところがあります。そのひとつは、プログラムを
保守したり修正したりするのが簡単になるということです。どんな複雑な構造でも、
プログラミング言語によって提供される基本データ構造を使って、いろいろな方法で
表すことができます。もちろん、どういう表し方を選ぶかということは、それを
扱うプログラムに影響を与えます。そのため、後になってどこかの時点で表現方法を
変えることになったら、それらのプログラムはすべてそれに合わせて修正しないと
いけなくなるかもしれません。もし表現方法への依存がごく少数のプログラムモジュールに
制限されるように設計されていなければ、大きなプログラムではこの作業は時間とコストが
かかるものになるでしょう。

\begin{figure}[tb]
\phantomsection\label{Figure 2.1}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.1:} Data-abstraction barriers in the rational-number package.

\begin{example}
        +------------------------------------+
--------| Programs that use rational numbers |--------
        +------------------------------------+
          Rational numbers in problem domain
            +---------------------------+
------------|   add-rat  sub-rat  ...   |-------------
            +---------------------------+
   Rational numbers as numerators and denominators
              +------------------------+
--------------| make-rat  numer  denom |--------------
              +------------------------+
              Rational numbers as pairs
                  +----------------+
------------------| cons  car  cdr |------------------
                  +----------------+
            However pairs are implemented
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=91mm]{fig/chap2/Fig2.1c.pdf}
\par\bigskip
\noindent
\heading{Figure 2.1:} 有理数パッケージ内の抽象化の壁
\end{figure}

例えば、有理数を既約に簡約する問題の別の解き方として、簡約を実行するタイミングを、
有理数の構築時でなく、有理数の部品へのアクセス時にするというやり方があります。
この場合、コンストラクタとセレクタは違ったものになります。

\begin{scheme}
(define (make-rat n d) (cons n d))
(define (numer x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (car x) g)))
(define (denom x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (cdr x) g)))
\end{scheme}

\noindent
この実装と前の実装との違いは、いつ\code{gcd}を計算するかというところです。
プログラムを普通に使う際に、同じ有理数の分子や分母に何回もアクセスするので
あれば、\code{gcd}は有理数の構築時に計算したほうがいいでしょう。そうでなければ、
\code{gcd}の計算はアクセス時まで遅らせたほうがいいかもしれません。どちらを
選ぶにしても、実装を切り替える場合に、\code{add\-/rat}, \code{sub\-/rat}などは
まったく修正する必要がありません。

表現方法への依存を少しだけのインターフェイス手続きに限定することは、
プログラムの修正時だけでなく、プログラムの設計時にも役に立ちます。
そうしておくと、別の実装を考慮するための柔軟性を維持することができるからです。
上の単純な例を引き続き使って、有理数パッケージを設計するにあたって、
\code{gcd}を実行するタイミングを構築時にするか選択時にするかを最初の段階で
決められないとします。データ抽象化という方法を使うことによって、その決定を後回しに
しつつ、システムのほかの部分の開発を進めるということができるようになります。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.2}Exercise 2.2:} 平面上の線分を
表現するという問題について考える。それぞれの線分は、始点と終点という点のペア
として表す。コンストラクタ\code{make\-/segment}とセレクタ\code{start\-/segment},
\code{end\-/segment}を定義せよ。
さらに、点は\( x \)座標と\( y \)座標という数値のペアとして表現できる。
最後に、定義したセレクタとコンストラクタによって、線分を引数として取り
その中点(両端点の座標を平均した座標を持つ点)を返す\code{midpoint\-/segment}
手続きを定義せよ。手続きをチェックするためには、例えば次のようにして
点を表示することが必要となるだろう。

\begin{scheme}
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.3}Exercise 2.3:} 平面上の長方形の
表現を実装せよ(ヒント:\link{Exercise 2.2}を利用するといいかもしれない)。
そのコンストラクタとセレクタを使って、ある長方形の外周の長さと面積を計算する
手続きを書け。次に、長方形の異なる表現を実装せよ。適切な抽象化の壁を使って
システムを設計し、外周と面積を求める同じ手続きがどちらの表現によっても動く
ようにできるだろうか。

\end{quote}

\subsection{データとは何か}
\label{Section 2.1.3}

\link{Section 2.1.1}での有理数の実装では、有理数演算\code{add\-/rat}, \code{sub\-/rat}
等を、\code{make\-/rat}, \code{numer}, \code{denom}という仕様の決まっていない三つの
手続きによって実装することから始めました。その時点では、それらの演算は
データオブジェクト---分子、分母、有理数---によって定義され、
データオブジェクトのふるまいは後者の三つの手続きによって規定されると
考えることができました。

しかし、\newterm{data}(\jnewterm{データ})とは正確には何を意味しているのでしょうか。
``あるセレクタとコンストラクタによって実装される何か''と言うだけでは十分では
ありません。明らかに、任意の3つの手続きのセットがすべて有理数の実装に対する
適切な基礎としての役割を果たせるわけではありません。有理数\code{x}を\code{n}と\code{d}
という整数のペアによって構築する場合、\code{x}の\code{numer}と\code{denom}を取り出して
割り算を行ったものが、\code{n}を\code{d}で割るのと同じ結果になるということを保証する
必要があります。別の言い方をすると、\code{make\-/rat}, \code{numer}, \code{denom}は、
任意の整数\code{n}とゼロでない整数\code{d}に対し、\code{x}が\code{(make\-/rat n d)}で
あるとき、次の条件を満たす必要があります。
\begin{comment}

\begin{example}
(numer x)    n
--------- = ---
(denom x)    d
\end{example}

\end{comment}
\begin{displaymath}
 {\hbox{\tt(numer x)} \over \hbox{\tt(denom x)}} = {{\tt n} \over {\tt d}}\,.  
\end{displaymath}

実際のところ、これは\code{make\-/rat}, \code{numer}, \code{denom}が有理数表現の
基礎となるために満たさないといけないただひとつの条件です。一般的に、データという
ものは、何らかのセレクタとコンストラクタの集合に加え、それらが有効な表現となるために
満たさなければならないと規定された条件によって定義されるものと考えることができます。
\footnote{意外なことに、この考え方は厳密に定式化することが非常に難しいものです。
そのような定式化には二つのアプローチがあります。ひとつはC. A. R. \link{Hoare (1972)}
が開拓したもので、\newterm{abstract models}(\jnewterm{抽象モデル})という手法として
知られています。この手法では、上の有理数の例で要点を述べた``手続きと条件''という
仕様を定式化するものです。有理数表現での条件は整数に関する事実(等価性と割り算)
によって記述されています。一般的に、抽象モデルではそれまでに定義されたデータ
オブジェクトの型によって新しい種類のデータオブジェクトを定義します。そのため、
データオブジェクトに関する表明は、それまでに定義済みのデータオブジェクトに関する
表明に書き換えてチェックすることができます。もうひとつのアプローチは、
\acronym{MIT}のZillesとIBMのGoguen, Thatcher, Wagner, Wright
(\link{Thatcher et al. 1978}参照)や、トロント大学のGuttag(\link{Guttag 1977}参照)
によって導入されたもので、\newterm{algebraic specification}(\jnewterm{代数的仕様})
と呼ばれます。代数的仕様では、``手続き''を抽象代数システムの要素と見なし、
そのふるまいは、ここでの``条件''に相当する公理によって規定されるとし、
データオブジェクトに関する表明には抽象代数の技法を使います。どちらの技法も、
\link{LiskovとZillesの論文(1975)}で調査されています。}

この見方は、有理数のような``高レベル''のデータオブジェクトを定義する場合だけでなく、
低レベルなオブジェクトに対しても使えます。有理数の定義する際に使った、ペアという
概念について考えてみましょう。ペアとは何かということについてはこれまで触れず、
言語がペアを操作する手続きとして\code{cons}, \code{car}, \code{cdr}を用意して
くれているということだけを述べてきました。しかし、これら三つの操作について
知らなければいけないことは、二つのオブジェクトを\code{cons}によってくっつけたら、
それらのオブジェクトを\code{car}と\code{cdr}によって取得できるということだけです。
つまり、それらの操作は、任意のオブジェクト\code{x}と\code{y}に対して、
もし\code{z}が\code{(cons x y)}であるなら\code{(car z)}は\code{x}であり、
\code{(cdr z)}は\code{y}であるという条件を満たすということです。
これら三つの手続きが私たちの言語に基本要素として含まれるということについては
すでに触れたとおりですが、上の条件を満たすものであれば、どんな三つの手続きで
あってもペアを実装する基礎として使うことができます。この点については、
\code{cons}, \code{car}, \code{cdr}を実装するのに、何のデータ構造も使わずに、
手続きだけによってそれができるということが鮮やかに示してくれます。
以下はその定義です。

\begin{scheme}
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1: CONS" m))))
  dispatch)
(define (car z) (z 0))
(define (cdr z) (z 1))
\end{scheme}

\noindent
このような手続きの使い方は、データというものがどういうものかという私たちの
直感的な概念とまったく対応していません。それでも、これらの手続きが上の
条件を満たすということさえ確認できれば、これがペアを表現する有効なやり方である
ということが示せます。

ここで注意すべき微妙なところは、\code{(cons x y)}に返される値は手続き---
具体的には、内部で定義された手続き\code{dispatch}---だということです。
\code{dispatch}は、ひとつの引数を取り、その引数が0か1かによって
\code{x}か\code{y}かを返します。それに対応して、\code{(car z)}は\code{z}に
0を適用するように定義されています。よって、もし\code{z}が\code{(cons x y)}に
よって作られた手続きであれば、\code{z}を0に適用すると\code{x}を返します。
こうして、\code{(car (cons x y))}が期待通り\code{x}を返すということが示せました。
同様に、\code{(cdr (cons x y))}は\code{(cons x y)}の返り値となる手続きを1に適用し、
\code{y}を返します。このため、この手続きによるペアの実装は有効な実装であり、
\code{cons}, \code{car}, \code{cdr}だけを使ってペアにアクセスするのであれば、
この実装を``本物の''データ構造を使う実装と区別することはできません。

手続きによるペアの実装の実例を示したことのポイントは、私たちの言語がこういうふうに
動いているというわけではなく(Schemeを含め、Lispシステムは一般的に、効率上の理由から
ペアを直接的に実装しています)、こういうふうに動くこともできるということです。
手続きによる表現はわかりにくいですが、ペアが満たす必要のある条件を満たしているため、
ペアを表現する完全に適切な方法と言えます。ここでの例は、手続きをオブジェクトとして
操作する能力は自動的に複合データを表現する能力を提供するということも示しています。
これは、今の段階ではただの面白い考え方のように思えるかもしれませんが、手続きによる
データの表現というものは、私たちのプログラミングのレパートリーの中で中心的な役割を
果たしています。このプログラミングスタイルはよく\newterm{message passing}
(\jnewterm{メッセージパッシング})と呼ばれ、\link{Chapter 3}でモデリングと
シミュレーションの問題を扱う際には、これを基本的な道具として使うことになります。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.4}Exercise 2.4:}
次に示すものは、手続きによるペアの表現の別のやり方である。この表現で、
任意のオブジェクト\code{x}と\code{y}に対して、\code{(car (cons x y))}が
\code{x}を返すことを確認せよ。

\begin{scheme}
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
\end{scheme}

対応する\code{cdr}の定義はどうなるだろうか。(ヒント：これが動作することを
確認するには\link{Section 1.1.5}の置換モデルを利用する)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.5}Exercise 2.5:}
\( a \)と\( b \)のペアを積\( 2^a 3^b \)の整数で表現することによって、
非負整数のペアを数値と数値演算だけを使って表現できるということを示せ。

それに対応する\code{cons}, \code{car}, \code{cdr}手続きを定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.6}Exercise 2.6:}
ペアを手続きとして表現するという考え方で頭がごちゃごちゃになっていないとしたら、
次のようなことを考えてみよう。手続きを扱うことができる言語では、
(少なくとも、非負整数に関する限りは)数値なしでもやっていける。
そのためには、0と、1を足すという演算を次のように実装する。

\begin{scheme}
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
\end{scheme}

この表現は、発明者のAlonzo Churchにちなんで\newterm{Church numerals}
(\jnewterm{チャーチ数})として知られている。Alonzo Churchは
\( \lambda \)-演算を発明した論理学者である。

\code{one}と\code{two}を直接(\code{zero}と\code{add\-/1}を使わずに)定義せよ
(ヒント：置換を使って\code{(add\-/1 zero)}を評価する)。
加算手続きの直接的な定義\code{+}(\code{add\-/1}の繰り返し適用は用いない)を与えよ。
\end{quote}


\subsection{発展問題: 区間演算}
\label{Section 2.1.4}

Alyssa P. Hackerは工学上の問題の解決を助けるシステムを設計しています。
システムで提供したい機能のひとつとして、精度のわかっている不正確な量
(例えば物理装置の測定値)を扱う能力があります。そのような近似値を使って
計算を行った場合、結果が精度つきの数値となるようにしたいということです。

電気技師はAlyssaのシステムを使って電気に関するいろいろな値を計算します。
その際に、二つの抵抗\( R_1 \), \( R_2 \)の並列に等価な抵抗値\( R_p \)
を次の式によって計算することが必要になるときがあります。

\begin{comment}

\begin{example}
            1
R_p = -------------
      1/R_1 + 1/R_2
\end{example}

\end{comment}
\begin{displaymath}
 R_p = {1 \over 1 / R_1 + 1 / R_2}\,.  
\end{displaymath}
抵抗値は普通、抵抗の製造者によって保証された何らかの許容誤差の範囲内であることしか
わかりません。例えば、``10\%の許容誤差で6.8Ω''というラベルのついた抵抗を買うと、
その抵抗の抵抗値は\( 6.8 - 0.68 = 6.12 \)から\( 6.8 + 0.68 = 7.48 \)Ωの間である
ということしか確かには言えません。そのため、6.8Ω 10\%の抵抗と4.7Ω 5\%の抵抗を
並列に接続すると、その組み合わせの抵抗は約2.58Ω(二つの抵抗が下限値である場合)から
約2.97Ω(二つの抵抗が上限値である場合)までの範囲になります。

Alyssaのアイデアは、``区間''(不正確な量の取り得る値の範囲を表すオブジェクト)を
組み合わせる数値演算のセットとして``区間演算''を実装するというものでした。
二つの区間を足し算、引き算、かけ算、割り算した結果は、それ自身が区間であり、
結果の範囲を表します。

Alyssaは、下限と上限という二つの端点を持つ``区間''という抽象オブジェクトがあると
仮定しました。また、区間の両端点が与えられれば、データコンストラクタ
\code{make\-/interval}を使って区間を構築できるとしました。Alyssaはまず、
二つの区間を足す手続きを書きます。彼女は、和が取り得る最小値は二つの下限の和であり、
最大値は二つの上限の和だろうと推論します。

\begin{scheme}
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
\end{scheme}

\noindent

またAlyssaは、両端点の積の最小値と最大値を求め、それらを答えとなる区間の
下限と上限とすることによって、二つの区間の積を計算しました
(\code{min}と\code{max}は、任意の数の引数の最小値と最大値を見つける基本要素です)。

\begin{scheme}
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
\end{scheme}

\noindent
二つの区間の割り算は、一つ目に二つ目の逆数をかけることにします。区間の逆数の
下限と上限は、上限の逆数と下限の逆数という順番になることに気をつけてください。

\begin{scheme}
(define (div-interval x y)
  (mul-interval 
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.7}Exercise 2.7:}
区間の抽象化の実装を規定していないため、Alyssaのプログラムは未完成である。
区間のコンストラクタの定義は以下のようになる。

\begin{scheme}
(define (make-interval a b) (cons a b))
\end{scheme}

セレクタ\code{upper\-/bound}と\code{lower\-/bound}を定義し、実装を完成させよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.8}Exercise 2.8:} Alyssaと
同じような推論を使って、二つの区間の差をどのように計算するかを記述せよ。
それに対応する引き算の手続き\code{sub\-/interval}を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.9}Exercise 2.9:}
区間の\newterm{width}(\jnewterm{幅})は、上限と下限の差の半分である。
幅は、区間によって規定される数値の不確かさの程度である。いくつかの
数値演算では、二つの区間を組み合わせた結果の幅は、引数の区間の幅のみによる
関数となるが、それら以外の演算では、組み合わせたものの幅は、引数の幅の
関数とはならない。二つの区間の和(または差)の幅は、足される(または引かれる)
区間の幅の関数となることを示せ。これが乗算と除算については正しくないということを
例を挙げて示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.10}Exercise 2.10:} エキスパートシステム
プログラマのBen Bitdiddleは、Alyssaの肩越しにのぞいてきて、長さがゼロの
区間で割るということの意味がはっきりしていないとコメントした。
Alyssaのコードを修正し、この条件についてチェックして、もしこれが起こればエラーの
シグナルを送るようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.11}Exercise 2.11:}
ついでにBenはまた謎めいたコメントを残した。``区間の両端点の符号をテストすると
\code{mul\-/interval}は9パターンに場合分けできて、2回以上のかけ算が必要になるのは
その中のひとつだけだよ。'' Benの提案に従って、この手続きを書き直せ。

\end{quote}
\noindent
プログラムをデバッグしてから、Alyssaはユーザ候補の一人にそれを見せた。
彼は、このプログラムは解いている問題が違うと言う。ほしいのは中央値と
許容誤差で表される数値を扱うプログラムだ。例えば\( 3.5 \pm 0.15 \)の
ような区間を使って作業をしたいのであって、[3.35, 3.65]ではない。
Alyssaは自分のデスクに戻って、別のコンストラクタと別のセレクタを提供する
ことによってこの問題を解決した。

\begin{scheme}
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
\end{scheme}
\noindent
運の悪いことに、Alyssaのユーザのほとんどは技師です。実際の工学の現場では、
測定値の誤差は小さなもので、区間の中央値に対する幅の割合として表されます。
技師は普通、上で書いた抵抗のスペックのように、装置のパラメタに対する
パーセント許容誤差を規定するものです。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.12}Exercise 2.12:}
中央値とパーセント許容誤差を取り、求める範囲を返すコンストラクタ
\code{make\-/center\-/percent}を定義せよ。また、与えられた区間に対して
パーセント許容誤差を返すセレクタ\code{percent}も定義しなければならない。
\code{center}セレクタは上に書いたものと同じである。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.13}Exercise 2.13:}
パーセント許容誤差が小さいという前提のもとでは、二つの区間の積のパーセント許容誤差を
因数の許容誤差の積によって近似する簡単な式が存在することを示せ。
すべての数値は正であると仮定して問題を単純化してもよい。
\end{quote}

\noindent
かなりの作業ののちに、Alyssa P. Hackerは完成したシステムを納品しました。
数年後、そのことをすっかり忘れていたころ、怒り狂ったユーザLem E. Tweakitから
興奮した口調の電話がかかってきました。どうもLemは、並列抵抗の式が
代数的に等価な二つの方法で書けることに気づいたようです。
\begin{comment}

\begin{example}
 R_1 R_2
---------
R_1 + R_2
\end{example}

\end{comment}
\begin{displaymath}
 R_1 R_2 \over R_1 + R_2 
\end{displaymath}
\noindent
と、
\begin{comment}

\begin{example}
      1
-------------
1/R_1 + 1/R_2
\end{example}

\end{comment}
\begin{displaymath}
 {1 \over 1 / R_1 + 1 / R_2}\,. 
\end{displaymath}
彼は以下の二つのプログラムを書きました。それぞれ、並列抵抗の式を別々のやり方で計算します。

\begin{scheme}
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
\end{scheme}

\begin{scheme}
(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval 
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))
\end{scheme}

\vspace{0.3em}

Lemは、Alyssaのプログラムが二つの計算方法で違う値を返すと苦情を言います。
これは深刻な苦情です。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.14}Exercise 2.14:}
Lemが正しいことを示せ。いろいろな数値演算の式についてこのシステムの挙動を
調査せよ。何らかの区間\( A \)と\( B \)を作成し、それらを使って
式\( A /\! A \)と\( A / B \)を計算せよ。中央値に対して小さなパーセンテージの幅を
持つ区間について調べると得られるところが大きいだろう。中央値-パーセント形式
(\link{Exercise 2.12}参照)の計算結果を調べよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.15}Exercise 2.15:}
別のユーザEva Lu Atorも、代数的に等価な異なる式によって計算すると
異なる区間になることに気がついた。彼女は、不確定な数値を表す変数が
繰り返し出てこないように書けば、より厳密な誤差限界を返すようにできると言う。
つまり、並列抵抗を計算するのに\code{par2}は\code{par1}よりも``よりよい''
プログラムだと言うのだ。彼女は正しいだろうか。また、それはなぜだろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.16}Exercise 2.16:}
一般的に、なぜ代数的に等価な式が異なる答えになることがあるのかを説明せよ。
この欠点のない区間演算パッケージを開発することはできるだろうか。
または、このタスクは不可能なのだろうか。(警告：この問題はとても難しい)
\end{quote}

%=======================================================================================================

\section{階層データと閉包性}
\label{Section 2.2}

ここまでで見てきたように、ペアは私たちが複合データオブジェクトを構築する
基本的な``糊''となってくれます。\link{Figure 2.2}は、ペア---この場合は
\code{(cons 1 2)}で作られるペア---を図示する標準的なやり方を示しています。
この表現は\newterm{box-and-pointer notation}(\jnewterm{箱とポインタ記法})と
呼ばれるもので、それぞれのオブジェクトは箱への\newterm{pointer}
(\jnewterm{ポインタ})として表わされます。基本オブジェクトの箱には
オブジェクトの表現が入っています。例えば、数値の箱には数字が入っています。
ペアの箱は実際には二つの箱で、左の箱にはペアの\code{car}(へのポインタ)
が入り、右の箱には\code{cdr}が入ります。

\code{cons}は、数値だけでなくペアも結合できるということについてはすでに見ました
(\link{Exercise 2.2}と\link{Exercise 2.3}を解く際には、この事実を使ったか、
使わざるを得なかったでしょう)。結果として、ペアはどんな種類のデータ構造でも
構築することができる汎用ブロックとなってくれます。\link{Figure 2.3}は
ペアを使って数値1, 2, 3, 4を組み合わせる二つの方法を示しています。

\begin{figure}[tb]
\phantomsection\label{Figure 2.2}
\centering
\begin{comment}
\heading{Figure 2.2:} Box-and-pointer representation of \code{(cons 1 2)}.

\begin{example}
     +---+---+     +---+
---->| * | *-+---->| 2 |
     +-|-+---+     +---+
       |
       V
     +---+
     | 1 |
     +---+
\end{example}
\end{comment}
\includegraphics[width=34mm]{fig/chap2/Fig2.2c.pdf}
\par\bigskip
\noindent
\heading{Figure 2.2:} \code{(cons 1 2)}の箱とポインタ表現
\end{figure}

\begin{figure}[tb]
\phantomsection\label{Figure 2.3}
\centering
\begin{comment}
\heading{Figure 2.3:} Two ways to combine 1, 2, 3, and 4 using pairs.

\begin{example}
     +---+---+     +---+---+         +---+---+     +---+
---->| * | *-+---->| * | * |    ---->| * | *-+---->| 4 |
     +-|-+---+     +-|-+-|-+         +-|-+---+     +---+
       |             |   |             |
       V             V   V             V
   +---+---+      +---+ +---+      +---+---+     +---+---+
   | * | * |      | 3 | | 4 |      | * | *-+---->| * | * |
   +-|-+-|-+      +---+ +---+      +-|-+---+     +-|-+-|-+
     |   |                           |             |   |
     V   V                           V             V   V
  +---+ +---+                      +---+        +---+ +---+
  | 1 | | 2 |                      | 1 |        | 2 | | 3 |
  +---+ +---+                      +---+        +---+ +---+

  (cons (cons 1 2)                 (cons (cons 1
        (cons 3 4))                            (cons 2 3))
                                         4)
\end{example}
\end{comment}
\includegraphics[width=96mm]{fig/chap2/Fig2.3c.pdf}
\begin{quote}
\heading{Figure 2.3:} ペアを使って1,2,3,4を組み合わせる二つの方法
\end{quote}
\end{figure}

ペアを要素とするペアを作る能力は、表現ツールとしてのリスト構造の持つ重要性の
本質となるものです。この能力のことを、\code{cons}の\jnewterm{閉包性}
(closure property)と呼びます。一般的に、データオブジェクトを組み合わせる操作は、
その演算による組み合わせの結果自身が同じ演算によって組み合わせることができるので
あれば、閉包性を満たします。
\footnote{
ここでの``閉包''という言葉は抽象代数から来ています。
抽象代数では、集合の要素に演算を適用して得られるものがまたその集合の要素であるなら、
それらの要素の集合はその演算のもとで閉じていると言います。Lispコミュニティでも
(不幸なことに)``閉包''という言葉を使うのですが、まったく関係のない概念の記述に
使っていて、その場合の閉包とは自由変数を持つ手続きを表現する実装上のテクニックを
指しています。この本では、二番目の意味での``閉包''は使いません。}
閉包は、どんな組み合わせ手段であっても、表現力の鍵となるものです。それによって、
\newterm{hierarchical}(\jnewterm{階層})構造---部品によって作られ、その部品も
また部品によって作られ\( \dots \)という構造---を作ることが可能になるからです。

\link{Chapter 1}の初めから、手続きを扱う際には本質的に閉包を使ってきました。
とても単純なプログラム以外は、組み合わせの要素はそれ自身組み合わせとなりうる
という事実に依存しているからです。この節では、複合データの閉包もたらす結果に
ついて扱います。ペアを使って列や木を表現するいくつかの確立されたテクニックに
ついて説明し、閉包を鮮やかに図解してくれるグラフィック言語を示します。
\footnote{
組み合わせ手段は閉包性を満たすべきだという概念は素直な考え方です。残念なことに、
一般的に使われる言語の多くでは、データ結合手段として提供されているものが
閉包性を満たさなかったり、閉包を使うのが面倒だったりします。FortranやBASICでは、
普通は配列にまとめて入れることでデータを組み合わせます。しかし、要素がそれ自身
配列であるような配列は作れません。PascalとCでは、要素が構造体であるような
構造体を認めています。しかし、これをするためにはプログラマが明示的にポインタを
扱わなければならず、またプログラマは構造体の各フィールドが前もって決められた形の
要素しか持つことができないという制約に従わなければなりません。これらの言語は、
Lispがペアとして提供しているような、複合データを統一的な方法で簡単に操作できる
ビルトインの汎用の糊を持っていません。この制約が、Alan Perlisがこの本の前書きで
コメントしたことの背景にあります。``Pascalでは、宣言可能なデータ構造の多さが
関数の専門化を引き起こし、気軽な連携は禁じられ、ペナルティを与えられるものとなります。
ひとつのデータ構造を扱う100の関数があるほうが、10のデータ構造を扱う10の関数が
あるのよりもよいのです。''}

\subsection{列の表現}
\label{Section 2.2.1}

ペアを使って構築できる便利な構造のひとつは、\newterm{sequence}(\jnewterm{列})---
データオブジェクトの順序つき集合---です。もちろん、ペアを使って列を表すやり方は
いろいろあります。\link{Figure 2.4}には、特に素直な表現方法のひとつを示しています。
このやり方では、1, 2, 3, 4という列はペアのチェーンとして表されます。それぞれのペアの
\code{car}はチェーン内の対応する項で、ペアの\code{cdr}はチェーン内の次のペアです。
最後のペアの\code{cdr}は、ペアでない特別な値を指すことによって、列の終端である
ことを伝えます。その値は、箱-ポインタ図では斜線として表され、プログラムでは
変数\code{nil}という値として表されます。列全体は、入れ子の\code{cons}演算によって
構築されます。

\begin{scheme}
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 2.4}
\centering
\begin{comment}
\heading{Figure 2.4:} The sequence 1, 2, 3, 4 represented as a chain of pairs.

\begin{example}
     +---+---+     +---+---+     +---+---+     +---+---+
---->| * | *-+---->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+     +-|-+---+
       |             |             |             |
       V             V             V             V
     +---+         +---+         +---+         +---+
     | 1 |         | 2 |         | 3 |         | 4 |
     +---+         +---+         +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=76mm]{fig/chap2/Fig2.4c.pdf}
\par\bigskip
\noindent
\heading{Figure 2.4:} ペアの鎖として表現された列1, 2, 3, 4
\end{figure}

入れ子の\code{cons}によって作られるこのようなペアの列は\newterm{list}
(\jnewterm{リスト})と呼ばれます。Schemeは、リスト構築を便利にする
\code{list}という基本手続きを提供しています。
\footnote{この本では、\newterm{list}(\jnewterm{リスト})という言葉はリスト終端
マーカーで終わるペアのチェーンという意味で使います。それに対して、
\newterm{list structure}(\jnewterm{リスト構造})という用語は、リストに限らず、
ペアによって作られた任意のデータ構造を指します。}
上の列は、\code{(list 1 2 3 4)}によって生成することができます。
一般的に、

\begin{scheme}
(list ~\( \dark \langle \)~~\( \dark a_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark a_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark a_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
は次のものと等価です。

\begin{scheme}
(cons ~\( \dark \langle \)~~\( \dark a_1 \)~~\( \dark \rangle \)~
      (cons ~\( \dark \langle \)~~\( \dark a_2 \)~~\( \dark \rangle \)~
            (cons ~\( \dots \)~
                  (cons ~\( \dark \langle \)~~\( \dark a_n \)~~\( \dark \rangle \)~
                        nil)~\( \dots \)~)))
\end{scheme}

\noindent
Lispシステムは、慣例的にリストを括弧でくくられた要素の列として表示します。
そのため、\link{Figure 2.4}のデータオブジェクトは\code{(1 2 3 4)}と表示されます。

\begin{scheme}
(define one-through-four (list 1 2 3 4))
one-through-four
~\textit{(1 2 3 4)}~
\end{scheme}

\noindent
式\code{(list 1 2 3 4)}と、その式を評価した結果として得られるリスト
\mbox{\code{(1 2 3 4)}}を混同しないように気をつけてください。
式\code{(1 2 3 4)}を評価しようとすると、インタプリタは手続き\code{1}を
引数\code{2}, \code{3}, \code{4}に適用しようとして、エラーを起こします。

\code{car}はリストの最初の項を選択し、\code{cdr}は最初の項以外のすべてからなる
サブリストを選択するものであると考えることもできます。
\code{car}と\code{cdr}を入れ子で適用していくと、リストの二つ目、三つ目、それから
それに続く項を取り出すことができます。\footnote{
\code{car}と\code{cdr}の入れ子適用は書くのが面倒なので、Lispの諸方言はそれらの
省略形を提供しています。例えば、

\begin{smallscheme}
(cadr ~\( \dark \langle \)~~\( \dark arg \)~~\( \dark \rangle \)~) = (car (cdr ~\( \dark \langle \)~~\( \dark arg \)~~\( \dark \rangle \)~))
\end{smallscheme}

このような手続きの名前はすべて\code{c}で始まり\code{r}で終わります。間の\code{a}は
\code{car}演算を表し、\code{d}は\code{cdr}演算を表し、名前の中での順番と同じ順番で
適用されます。\code{cadr}のような単純な組み合わせが発音可能になるように、
\code{car}と\code{cdr}の名前を残しています。}
コンストラクタ\code{cons}は、元のリストと同じリストに最初にひとつ項が加わったものを
作ります。

\begin{scheme}
(car one-through-four)
~\textit{1}~
(cdr one-through-four)
~\textit{(2 3 4)}~
(car (cdr one-through-four))
~\textit{2}~
(cons 10 one-through-four)
~\textit{(10 1 2 3 4)}~
(cons 5 one-through-four)
~\textit{(5 1 2 3 4)}~
\end{scheme}

\noindent
\code{nil}という値はペアのチェーンを終了させるために使うものですが、これを
要素のない列\newterm{empty list}(\jnewterm{空リスト})と考えることもできます。
\newterm{nil}という単語は、``無''を意味するラテン語の単語\emph{nihil}を短くした
ものです。
\footnote{Lispの諸方言の標準化にあたって、どれだけのエネルギーが文字通り
無に消えたかというのは特筆すべきことです。\code{nil}は普通の名前であるべきか?
 \code{nil}の値は記号であるべきか? リストであるべきか? ペアであるべきか?
Schemeでは\code{nil}は普通の名前で、この節では値がリスト終端マーカーであるような
変数として使います(\code{true}が真の値を持つ普通の変数であるのと同じです)。
Common LispなどのLisp方言では、\code{nil}を特別な記号として扱います。
この本の著者たちは言語標準化で多くの争いを経験してきたので、この問題そのものを
避けたいと思っています。\link{Section 2.3}でクォートを導入したら、空リストを
\code{'()}として示し、完全に変数\code{nil}を使わないですむようにします。}

\subsubsection*{リスト演算}

ペアを使って要素の列をリストとして表現するやり方は、リストを
``\code{cdr}ダウン''していくという確立されたプログラミングテクニックと
セットになっています。例えば、\code{list\-/ref}手続きは引数として
リストと数値\( n \)を取り、リストの\( n \)番目のものを返します。
リストの要素の番号は0から始めるのが慣例となっています。
\code{list\-/ref}を計算する方法は以下の通りです。

\begin{itemize}

\item
\( n = 0 \)であれば、\code{list\-/ref}はリストの\code{car}を返す。

\item
そうでなければ、\code{list\-/ref}はリストの\code{cdr}の\( (n - 1) \)番目のものを返す。

\end{itemize}

\begin{scheme}
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))
(list-ref squares 3)
~\textit{16}~
\end{scheme}

\noindent
リスト全体を\code{cdr}ダウンすることもよくあります。それをやりやすくするために
Schemeは基本述語\code{null?}を持っています。これは、引数が空リストかどうか
テストするものです。\code{length}というリストの要素数を返す手続きは、
その典型的な使用パターンを示しています。

\begin{scheme}
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5 7))
(length odds)
~\textit{4}~
\end{scheme}

\noindent
手続き\code{length}は、単純な再帰計画を実装しています。簡約ステップは以下の通りです。

\begin{itemize}

\item
任意のリストの\code{length}は、リストの\code{cdr}の\code{length}に1を足した値である。

\end{itemize}

\noindent
これは、次の基本ケースに着くまで連続的に適用される。

\begin{itemize}

\item
空リストの\code{length}は0である。

\end{itemize}

\noindent
\code{length}は、反復スタイルで計算することもできます。

\begin{scheme}
(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
\end{scheme}

\noindent
もうひとつの確立されたプログラミングテクニックは、リストを\code{cdr}ダウンしながら
答えのリストを``\code{cons}アップ''するというものです。これは、次の\code{append}
手続きで使われます。\code{append}手続きは、二つのリストを引数として取り、
要素を連結して新しいリストを作ります。

\begin{scheme}
(append squares odds)
~\textit{(1 4 9 16 25 1 3 5 7)}~
(append odds squares)
~\textit{(1 3 5 7 1 4 9 16 25)}~
\end{scheme}

\noindent
\code{append}も再帰計画を使って実装されています。
リスト\code{list1}と\code{list2}を\code{append}するには、次のようにします。

\begin{itemize}

\item
もし\code{list1}が空リストであれば、結果は単に\code{list2}である。

\item
そうでなければ、\code{list1}の\code{cdr}と\code{list2}を\code{append}し、その結果に
\code{list1}の\code{car}を\code{cons}する。

\end{itemize}

\begin{scheme}
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.17}Exercise 2.17:} 与えられた(空でない)
リストの最後の要素のみを持つリストを返す手続き\code{last\-/pair}を定義せよ。

\begin{scheme}
(last-pair (list 23 72 149 34))
~\textit{(34)}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.18}Exercise 2.18:}リストを引数として取り、
同じ要素を逆順に持つリストを返す手続き\code{reverse}を定義せよ。

\begin{scheme}
(reverse (list 1 4 9 16 25))
~\textit{(25 16 9 4 1)}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.19}Exercise 2.19:}
\link{Section 1.2.2}の両替パターン数計算プログラムについて考える。
プログラムで使う通貨を変えられるようにして、例えばイギリスポンドの両替パターン数を
計算できるようになると便利だろう。現状のプログラムでは、通貨についての知識は
一部は\code{first\-/denomination}に、一部は\code{count\-/change}
(アメリカには5種類のコインがあるということを知っている)に分散されている。
両替に使うコインのリストを与えられるようになればもっとよくなるだろう。

手続き\code{cc}を書き直して、二つ目の引数として取るものを、どのコインを使うかを
指定する整数ではなく、使うコインの値のリストとなるようにしたい。それから、
それぞれの通貨の種類を定義するリストを次のように持っておく。

\begin{scheme}
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
\end{scheme}

そして、\code{cc}は次のように呼び出すことにしよう。

\begin{scheme}
(cc 100 us-coins)
~\textit{292}~
\end{scheme}

このためには、プログラム\code{cc}に対して何らかの変更を加える必要がある。
プログラムの形は同じだが、二つ目の引数に対するアクセスの仕方が次のように
変わる。

\begin{scheme}
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination 
                 coin-values))
            (cc (- amount
                   (first-denomination 
                    coin-values))
                coin-values)))))
\end{scheme}

リスト構造に対する基本演算によって、手続き\code{first\-/denomination},
\code{except\-/first\-/de- nomination}, and \code{no\-/more?}を定義せよ。
リスト\code{coin\-/values}の順序は、\code{cc}によって返される解答に影響を与える
だろうか、それとも与えないだろうか。それはどうしてだろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.20}Exercise 2.20:}
手続き\code{+}, \code{*}, \code{list}は任意の数の引数を取る。このような手続きを定義する
方法のひとつとして、\code{define}で\newterm{dotted-tail notation}
(\jnewterm{ドット末尾記法})を使うというものがある。手続きの定義の中で、
仮引数リストの最後の仮引数名の前にドットのあるものは、手続きが呼ばれるときに、
前のほうの仮引数は(もしあれば)通常通り前のほうの引数の値を持つことになるが、
最後の仮引数の値は残りの引数すべての\jnewterm{リスト}となる。
例えば、次のような定義の場合、

\begin{scheme}
(define (f x y . z) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
手続き\code{f}は、二つ以上の引数で呼び出すことができる。次のものを評価すると、

\begin{scheme}
(f 1 2 3 4 5 6)
\end{scheme}

\noindent
\code{f}の本体では、\code{x}は1となり、\code{y}は2で、\code{z}はリスト\mbox{\code{(3 4 5 6)}}となる。
次の定義の場合、

\begin{scheme}
(define (g . w) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
手続き\code{g}は0個以上の引数で呼び出すことができる。次のものを評価すると、

\begin{scheme}
(g 1 2 3 4 5 6)
\end{scheme}

\noindent
\code{g}の本体では、\code{w}はリスト\code{(1 2 3 4 5 6)}となる。
\footnote{
\code{lambda}を使って\code{f}と\code{g}を定義する場合、次のように書けます。

\begin{smallscheme}
(define f (lambda (x y . z) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~))
(define g (lambda w ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~))
\end{smallscheme}
}

\code{same\-/parity}は、ひとつ以上の整数を引数として取り、最初の引数と同じ
偶奇性を持つ引数すべてのリストを返す手続きとする。例えば、次のようになる。

\begin{scheme}
(same-parity 1 2 3 4 5 6 7)
~\textit{(1 3 5 7)}~
(same-parity 2 3 4 5 6 7)
~\textit{(2 4 6)}~
\end{scheme}
\end{quote}

上記の記法を使ってこの手続きを書け。

\subsubsection*{リストに対するマップ}

非常に便利な演算として、リストのそれぞれの要素に何らかの変換を適用し、
結果のリストを返すというものがあります。例えば、次の手続きはリストの
それぞれの数値を与えられた係数倍します。

\begin{scheme}
(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items) 
                        factor))))
(scale-list (list 1 2 3 4 5) 10)
~\textit{(10 20 30 40 50)}~
\end{scheme}

\noindent
\link{Section 1.3}でやったように、この一般的な考え方を抽象化し、高階手続きによって
表現される共通パターンとして捉えることができます。ここでの高階手続きは、
\code{map}と呼ばれるものです。\code{map}は、1引数の手続きとリストを引数として取り、
リストのそれぞれの要素に手続きを適用した結果のリストを返します。
\footnote{\label{Footnote 12}
Schemeは、ここで記述したものよりも汎用的な\code{map}手続きを標準で提供しています。
そのより汎用的な\code{map}は、引数として\( n \)引数の手続きと\( n \)個のリストを取り、
手続きを、すべてのリストの一つ目の要素、すべてのリストの二つ目の要素\( \dots \)に対して
適用していき、結果のリストを返します。例えば、次のようになります。

\begin{smallscheme}
(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
~\textit{(741 852 963)}~
(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
~\textit{(9 12 15)}~
\end{smallscheme}
}

\begin{scheme}
(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11.6 17))
~\textit{(10 2.5 11.6 17)}~
(map (lambda (x) (* x x)) (list 1 2 3 4))
~\textit{(1 4 9 16)}~
\end{scheme}

\noindent
これで、\code{map}を使って\code{scale\-/list}の新しい定義を書くことができます。

\begin{scheme}
(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
\end{scheme}

\noindent
\code{map}は重要な概念ですが、これが共通パターンを捉えているという理由からだけでは
ありません。\code{map}はリストを扱ううえでのより高いレベルの抽象化を達成するからです。
元の\code{scale\-/list}の定義では、プログラムは再帰構造になっていて、リストの
要素ごとの処理に注意が向くようになっていました。\code{map}によって\code{scale\-/list}を
定義すると、そのレベルの細かいことは隠されて、係数倍というものが要素のリストを結果の
リストに変換するものであるというところが強調されます。二つの定義の違いは、コンピュータが
異なるプロセスを実行しているというところではなく(プロセスは同じものです)、私たちがプロセスを
異なるやり方で考えるというところにあります。実際に\code{map}は、リストを変形する手続きの
実装を、リストの要素をどうやって取り出して結合していくかという細かいところから切り離す
抽象化の壁を作ることを助けてくれます。\link{Figure 2.1}で示した壁のように、
この抽象化を使うことで、列を列に変形するという概念的な演算フレームワークを保ったままで、
列がどのように実装されているかという低レベルな細かいところを変更できる柔軟性が得られます。
\link{Section 2.2.3}では、列をプログラム組織化のフレームワークとするという
この使い方についてさらに詳しく説明します。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.21}Exercise 2.21:}
手続き\code{square\-/list}は、引数として数値のリストを取り、それらの数値の二乗の列を
持つリストを返す。

\begin{scheme}
(square-list (list 1 2 3 4))
~\textit{(1 4 9 16)}~
\end{scheme}

次に二つの異なる\code{square\-/list}の定義を示す。書けた部分を埋め、二つとも完成させよ。

\begin{scheme}
(define (square-list items)
  (if (null? items)
      nil
      (cons ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
(define (square-list items)
  (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.22}Exercise 2.22:}
Louis Reasonerは\link{Exercise 2.21}の一つ目の\code{square\-/list}手続きを書き直し、
反復プロセスを展開するようにしようとしている。

\begin{scheme}
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
\end{scheme}

残念ながら、このように\code{square\-/list}を定義すると、答えとなるリストは
望むものの逆順になってしまう。なぜだろうか。

それから、Louisは\code{cons}の引数を逆順にしてバグを直そうとした。

\begin{scheme}
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
\end{scheme}

これもうまくいかない。説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.23}Exercise 2.23:} 手続き
\code{for\-/each}は\code{map}に似ている。引数として手続きと要素のリストを取る。
しかし、結果のリストを生成するのではなく、\code{for\-/each}は手続きを
それぞれの要素に左から右に順番に手続きを適用していくだけである。手続きを
要素に適用して返される値はまったく使わない---\code{for\-/each}は、
表示のような、何かのアクションを実行する手続きとともに使う。例えば次の例で、

\begin{scheme}
(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
~\textit{57}~
~\textit{321}~
~\textit{88}~
\end{scheme}

\code{for\-/each}への呼び出し(上では示していないが)に返される値は何でもよく、
例えば真の値などでもよい。\code{for\-/each}を実装せよ。
\end{quote}

\subsection{階層構造}
\label{Section 2.2.2}

リストによる列の表現は、要素がそれ自身列であるような列を表現するように自然に
一般化できます。例えば、次の式によって構築されるオブジェクト\code{((1 2) 3 4)}は、

\begin{scheme}
(cons (list 1 2) (list 3 4))
\end{scheme}

\noindent
三つの項目のリストとして見ることができます。最初の項目はそれ自身が\code{(1 2)}という
リストとなります。実際、このことはインタプリタによって表示される結果の形からも見て取る
ことができます。\link{Figure 2.5}は、この構造のペアによる表現を示しています。

\begin{figure}[tb]
\phantomsection\label{Figure 2.5}
\centering
\begin{comment}
\heading{Figure 2.5:} Structure formed by \code{(cons (list 1 2) (list 3 4))}.

\begin{example}
                                          (3 4)
                                            |
                                            V
((1 2) 3 4)  +---+---+                  +---+---+     +---+---+
        ---->| * | *-+----------------->| * | *-+---->| * | / |
             +-|-+---+                  +-|-+---+     +-|-+---+
               |                          |             |
               V                          V             V
      (1 2)  +---+---+     +---+---+    +---+         +---+
        ---->| * | *-+---->| * | / |    | 3 |         | 4 |
             +-|-+---+     +-|-+---+    +---+         +---+
               |             |
               V             V
             +---+         +---+
             | 1 |         | 2 |
             +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=91mm]{fig/chap2/Fig2.5c.pdf}
\begin{quote}
\heading{Figure 2.5:} \code{(cons (list 1 2) (list 3 4))}によって作られる構造
\end{quote}
\end{figure}

要素が列であるような列は、\newterm{trees}(\jnewterm{木})として考えることもできます。
列の要素は木の枝で、それ自身が列である要素は部分木となります。
\link{Figure 2.6}に、\link{Figure 2.5}を木として見た構造を示します。

\begin{figure}[tb]
\phantomsection\label{Figure 2.6}
\centering
\begin{comment}
\heading{Figure 2.6:} The list structure in \link{Figure 2.5} viewed as a tree.

\begin{example}
 ((1 2) 3 4)
     /\\
    /  | \
(1 2)  3 4
 / \
 1 2
\end{example}
\end{comment}
\includegraphics[width=22mm]{fig/chap2/Fig2.6a.pdf}
\par\bigskip
\noindent
\heading{Figure 2.6:} \link{Figure 2.5}のリスト構造を木として見たもの
\end{figure}

再帰は木構造を扱う自然なツールです。再帰を使うことで、木への演算をその枝に対する
演算に還元し、それを今度は枝の枝に対する演算に還元し\( \dots \)と続けて
いくことで木の葉にたどり着く、というようにできることがよくあります。ひとつの
例として、\link{Section 2.2.1}の\code{length}手続きと、木の葉の総数を返す
\code{count\-/leaves}手続きを比べてみましょう。

\begin{scheme}
(define x (cons (list 1 2) (list 3 4)))
(length x)
~\textit{3}~
(count-leaves x)
~\textit{4}~
(list x x)
~\textit{(((1 2) 3 4) ((1 2) 3 4))}~
(length (list x x))
~\textit{2}~
(count-leaves (list x x))
~\textit{8}~
\end{scheme}

\noindent
\code{count\-/leaves}を実装するために、\code{length}の計算で使った再帰計画を
思い出してみましょう。

\begin{itemize}

\item
リスト\code{x}の\code{length}は、\code{x}の\code{cdr}の\code{length}に1を足した値である。

\item
空リストの\code{length}は0である。

\end{itemize}

\noindent
\code{count\-/leaves}も似たようなものになります。空リスト場合の値は同じです。

\begin{itemize}

\item
空リストの\code{count\-/leaves}は0である。

\end{itemize}

\noindent
しかし、リストの\code{car}を取り外す還元ステップでは、その\code{car}自身が木であって、
その葉の数も数えなければいけないかもしれないということを考える必要があります。
そのため、適切な還元ステップは次のようになります。

\begin{itemize}

\item
木\code{x}の\code{count\-/leaves}は、\code{x}の\code{car}の\code{count\-/leaves}と
\code{x}の\code{cdr}の\code{count\-/leaves}を足した値である。

\end{itemize}

\noindent
最後に、\code{car}を取っていくと実際の葉に到達するので、基本ケースがもうひとつ必要になります。

\begin{itemize}

\item
葉の\code{count\-/leaves}は1である。

\end{itemize}

\noindent
木に対する再帰手続きが書きやすくなるように、Schemeは\code{pair?}という基本述語を
提供しています。これは、引数がペアであるかどうかをテストするものです。以下に
完成した手続きを書きます。
\footnote{
\code{cond}の一番目と二番目の節は、この順番でなければいけません。空リストは
\code{null?}を満たし、またペアでもないからです。
}

\begin{scheme}
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.24}Exercise 2.24:} 式
\code{(list 1 (list 2 (list 3 4)))}を評価するとする。インタプリタの表示する
結果、それに対応する箱-点構造、木としての解釈(\link{Figure 2.6}で示したようなもの)を示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.25}Exercise 2.25:}
以下のそれぞれのリストから7を取り出す\code{car}と\code{cdr}の組み合わせを書け。

\begin{scheme}
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.26}Exercise 2.26:}
二つのリスト\code{x}と\code{y}を定義するとする。

\begin{scheme}
(define x (list 1 2 3))
(define y (list 4 5 6))
\end{scheme}

次のそれぞれの式を評価すると、インタプリタはどのような結果を表示するだろうか。

\begin{scheme}
(append x y)
(cons x y)
(list x y)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.27}Exercise 2.27:}
\link{Exercise 2.18}の\code{reverse}手続きを修正し、\code{deep\-/reverse}という
手続きを書け。\code{deep\-/reverse}は、ひとつのリストを引数として取り、要素が逆順で、
サブリストもすべて要素が逆順になっているリストを返す手続きである。
例えば、次のようになる。

\begin{scheme}
(define x (list (list 1 2) (list 3 4)))
x
~\textit{((1 2) (3 4))}~
(reverse x)
~\textit{((3 4) (1 2))}~
(deep-reverse x)
~\textit{((4 3) (2 1))}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.28}Exercise 2.28:}
リストとして表現された木を引数として取り、その木のすべての葉を左から右の順で
要素として持つリストを返す手続き\code{fringe}を書け。例えば、次のようになる。

\begin{scheme}
(define x (list (list 1 2) (list 3 4)))
(fringe x)
~\textit{(1 2 3 4)}~
(fringe (list x x))
~\textit{(1 2 3 4 1 2 3 4)}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.29}Exercise 2.29:}
二枝モビールは、左の枝と右の枝のという二つの枝から構成されている。
それぞれの枝はある長さを持つ棒で、おもりか別の二進モビールがぶら下がっている。
二枝モビールは、二つの枝によって構成することで、(例えば\code{list}を使って)
複合データによって表現できる。

\begin{scheme}
(define (make-mobile left right)
  (list left right))
\end{scheme}

枝は、長さ\code{length}(必ず数値)と構造\code{structure}からなり、
\code{structure}は数値(単純なおもりを表す)か、または別のモビールである。

\begin{scheme}
(define (make-branch length structure)
  (list length structure))
\end{scheme}

\begin{enumerate}[a]

\item
これに対応する、モビールの枝を返すセレクタ\code{left\-/branch}と
\code{right\-/branch}、枝の構成要素を返す\code{branch\-/length}と
\code{branch\-/structure}を書け。

\item
これらのセレクタを使って、モビールの総重量を返す手続き\code{total\-/weight}を
定義せよ。

\item
モビールについて、\newterm{balanced}(\jnewterm{バランスが取れている})というのは、
一番上の左枝にかかるトルク(回転力)が一番上の右の枝にかかるトルクと
等しく(つまり、左の棒の長さとかかる重さの積が、右の棒についてのその積と等しい)
、かつ両枝からぶら下がっている各部分モビールのバランスが取れている状態について言う。
ある二枝モビールがバランスが取れているかどうかテストする述語を設計せよ。

\item
モビールの表現を変更し、以下のようなコンストラクタにする。

\begin{scheme}
(define (make-mobile left right) (cons left right))
(define (make-branch length structure)
  (cons length structure))
\end{scheme}

あなたのプログラムを新しい表現に移行するにはどの程度の変更が必要だろうか。

\end{enumerate}
\end{quote}

\subsubsection*{木に対するマップ}

\code{map}は列を扱うための強力な抽象化ですが、それと同じように、\code{map}に
再帰を組み合わせたものは木を扱うための強力な抽象化です。例えば、
\code{scale\-/tree}という手続きは、\link{Section 2.2.1}の\code{scale\-/list}と
似たようなものですが、引数としては、数値の係数と、葉が数値である木を取ります。
返り値は同じ形の木で、それぞれの数値が計数倍されたものとなります。
\code{scale\-/tree}の再帰計画は、\code{count\-/leaves}のものに似ています。

\begin{scheme}
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
~\textit{(10 (20 (30 40) 50) (60 70))}~
\end{scheme}

\noindent

\code{scale\-/tree}の別の実装方法として、木を部分木の列と見なして\code{map}を
使うというものがあります。列にマップを行い、それぞれの部分木を順番に係数倍し、
結果のリストを返すということになります。木が葉である基本ケースでは、
単純に係数倍します。

\begin{scheme}
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
\end{scheme}

\noindent
木の操作の多くは、列の操作と再帰を組み合わせて同じように実装することができます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.30}Exercise 2.30:}
\link{Exercise 2.21}の\code{square\-/list}と似たような手続き\code{square\-/tree}を
定義せよ。
\code{square\-/tree}は以下のように動作する。

\begin{scheme}
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
~\textit{(1 (4 (9 16) 25) (36 49))}~
\end{scheme}
直接的な(つまり、高階手続きをまったく使わない)やり方と、\code{map}と再帰を使う
やり方の両方で、\code{square\-/tree}を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.31}Exercise 2.31:} 
\link{Exercise 2.30}の解答を抽象化し、手続き\code{tree\-/map}を作れ。
\code{square\-/tree}が\code{tree\-/map}によって以下のように定義できるようにせよ。

\begin{scheme}
(define (square-tree tree) (tree-map square tree))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.32}Exercise 2.32:}
集合は、それぞれ異なる要素を持つリストとして表現できる。また、集合の
すべての部分集合の集合は、リストのリストとして表現できる。例えば、
集合が\code{(1 2 3)}の場合、すべての部分集合の集合は
\code{(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))}となる。
以下に、集合のすべての部分集合の集合を生成する手続きを示す。
これを完成させ、なぜそれが動作するのかを明確に説明せよ。

\begin{scheme}
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ rest)))))
\end{scheme}
\end{quote}

\subsection{標準インターフェイスとしての列}
\label{Section 2.2.3}

ここまで複合データについて見てきましたが、その中では、データ抽象化のおかげで
データ表現の細かいところに煩わされることなくプログラムが設計できるということ、
また抽象化によってほかの表現を実験する柔軟性を確保できるということを
強調してきました。この節では、データ構造を扱ううえでのもうひとつの強力な設計原則を
導入します。
それは、\newterm{conventional interfaces}(\jnewterm{標準インターフェイス})の使用です。

\link{Section 1.3}では、数値を扱うプログラムについて、プログラムの抽象化を
高階手続きとして実装することによって共通のパターンを捉えることができるという
ことを見てきました。複合データについて同じような演算を定式化する能力は、
私たちがデータ構造を操作するスタイルに決定的に依存します。例えば、次の
手続きについて考えてみます。これは\link{Section 2.2.2}の\code{count\-/leaves}と
同じような仕組みで、木を引数に取り、奇数の葉の二乗の合計を計算するというものです。

\begin{scheme}
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
\end{scheme}

\noindent
表面的には、この手続きは以下に示す手続きとまったく違うように見えます。
以下の手続きは、与えられた整数\( n \)以下の\( k \)について、
フィボナッチ数\( {\rm Fib}(k) \)のうち偶数のもののリストを構築するというものです。

\begin{scheme}
(define (even-fibs n)
  (define (next k)
    (if (> k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
\end{scheme}

\noindent
これら二つの手続きは構造的には大きく違いますが、二つの計算をより抽象的に
記述すると、とても似通っていることが明らかになります。最初のプログラムが
していることは、以下のように書くことができます。

\begin{itemize}

\item
木の葉を列挙し、

\item
フィルタによって奇数を選び、

\item
選ばれた数の二乗を求め、

\item
\code{+}を使って、0から始めて結果を集積する。

\end{itemize}

\noindent
二つ目のプログラムは、以下の通りです。

\begin{itemize}

\item
0から\( n \)までの数値を列挙し、

\item
それぞれの整数に対するフィボナッチ数を求め、

\item
フィルタによって偶数を選び、

\item
\code{cons}を使って、空リストから始めて結果を集積する。

\end{itemize}

\noindent
信号処理のエンジニアであれば、\link{Figure 2.7}に示したように、
直列につながれたいくつかの段階を通る信号の流れとしてこれらのプロセスを
概念化するのが自然だと思うでしょう。\code{sum\-/odd\-/squares}は
\newterm{enumerator}(\jnewterm{列挙})から始まります。この列挙は、
与えられた木が持つ葉からなる``信号''を生成します。この信号は
\newterm{filter}(\jnewterm{フィルタ})に渡され、奇数要素以外がすべて
取り除かれます。その結果となる信号は、今度は\newterm{map}(\jnewterm{マップ})に
渡されます。このマップは、それぞれの要素に\code{square}を適用する``変換器''です。
マップの出力は、それから\newterm{accumulator}(\jnewterm{集積機})に
与えられ、集積機は0から始めて要素を\code{+}によって組み合わせます。
\code{even\-/fibs}の図式も、同じような仕組みです。

残念ながら、上に示した二つの手続きの定義は、この信号の流れという構造を
見せることができていません。例えば、\code{sum\-/odd\-/squares}を
詳しく見てみると、列挙の処理は、一部は\code{null?}と\code{pair?}という
テストによって実装され、一部は木の再帰という手続きの構造によって実装されています。
同じように、集積の処理の一部はテストのところにあり、一部は再帰の中で使われている
足し算のところにあります。全体的に、どちらの手続きにも、信号の流れという描写の
中の要素に対応するはっきりとした部分というものはありません。この二つの手続きでは、
計算過程を違う方法で分解しています。列挙処理をプログラム全体に広げ、それを
マップ、フィルタ、集積の処理と混ぜ合わせているのです。信号の流れという構造が
手続きの中で明確に見て取れるようにプログラムを構成することができれば、
結果となるコードの概念的な明確さを高めることができるでしょう。

\begin{figure}[tb]
\phantomsection\label{Figure 2.7}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.7:} The signal-flow plans for the
procedures \code{sum\-/odd\-/squares} (top) and \code{even\-/fibs} (bottom) reveal
the commonality between the two programs.

\begin{example}
+-------------+   +-------------+   +-------------+   +-------------+
| enumerate:  |-->| filter:     |-->| map:        |-->| accumulate: |
| tree leaves |   | odd?        |   | square      |   | +, 0        |
+-------------+   +-------------+   +-------------+   +-------------+

+-------------+   +-------------+   +-------------+   +-------------+
| enumerate:  |-->| map:        |-->| filter:     |-->| accumulate: |
| integers    |   | fib         |   | even?       |   | cons, ()    |
+-------------+   +-------------+   +-------------+   +-------------+
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=111mm]{fig/chap2/Fig2.7d.pdf} 
\begin{quote}
\heading{Figure 2.7:} 手続き\code{sum\-/odd\-/squares}(上)と\code{even\-/fibs}(下)を
信号の流れという図式によって表現すると、二つのプログラムの共通性が明らかになる。
\end{quote}
\end{figure}

\subsubsection*{列の演算}

信号の流れという構造をより明確に反映するようにプログラムを構成するうえでのポイントは、
処理の中で各段階の間を流れる``信号''に集中するということです。これらの信号を
リストとして表現するなら、各段階のの処理を実装するのにリスト演算を使うことができます。
例えば、信号の流れ図の中でのマップ段階は、\link{Section 2.2.1}の\code{map}手続きを
使って実装できます。

\begin{scheme}
(map square (list 1 2 3 4 5))
~\textit{(1 4 9 16 25)}~
\end{scheme}

\noindent
列をフィルタリングして与えられた述語を満足する要素だけを選択するのは、
次のようにすればできます。

\begin{scheme}
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
\end{scheme}

\noindent
例えば、次のようになります。

\begin{scheme}
(filter odd? (list 1 2 3 4 5))
~\textit{(1 3 5)}~
\end{scheme}

\noindent
集積は、次のように実装できます。

\begin{scheme}
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(accumulate + 0 (list 1 2 3 4 5))
~\textit{15}~
(accumulate * 1 (list 1 2 3 4 5))
~\textit{120}~
(accumulate cons nil (list 1 2 3 4 5))
~\textit{(1 2 3 4 5)}~
\end{scheme}

\noindent
後は、信号の流れ図を実装するのに足りないものは、処理する要素の列を列挙する
ことだけです。\code{even\-/fibs}の場合、生成するものは与えられた範囲の
整数列で、次のように実装できます。

\begin{scheme}
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
(enumerate-interval 2 7)
~\textit{(2 3 4 5 6 7)}~
\end{scheme}

\noindent
木の葉の列挙は、次のようにします。\footnote{これは、実際は\link{Exercise 2.28}の
\code{fringe}手続きそのものです。ここでは、この手続きが汎用的な列操作手続きに
属するものであることを強調するために名前をつけ替えています。}

\begin{scheme}
(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
~\textit{(1 2 3 4 5)}~
\end{scheme}

\noindent
これで、\code{sum\-/odd\-/squares}と\code{even\-/fibs}を、信号の流れ図として
示したような形で定式化し直すことができます。
\code{sum\-/odd\-/squares}のほうは、木の葉の列を列挙し、これをフィルタにかけて
列の奇数だけが残るようにし、それぞれの要素を二乗し、結果を合計します。

\begin{scheme}
(define (sum-odd-squares tree)
  (accumulate
   + 0 (map square (filter odd? (enumerate-tree tree)))))
\end{scheme}

\noindent
\code{even\-/fibs}のほうでは、0から\( n \)までの整数を列挙し、これらの整数の
それぞれに対するフィボナッチ数を生成し、結果の列をフィルタにかけて偶数の要素
だけが残るようにし、結果をリストに集積します。

\begin{scheme}
(define (even-fibs n)
  (accumulate
   cons
   nil
   (filter even? (map fib (enumerate-interval 0 n)))))
\end{scheme}

\noindent
プログラムを列の演算として表すことの利点は、モジュール化された形での
プログラムの設計がやりやすくなるということにあります。モジュール化とは、
比較的独立した部品を組み立ててプログラムを構築する設計のことです。
標準コンポーネントのライブラリとともに、コンポーネントを柔軟に接続できる
標準インターフェイスを提供することで、モジュール化された設計を促すことが
できます。

モジュールによる設計は、工学の設計において複雑性をコントロールする強力な
戦略です。例えば、実際の信号処理の応用では、標準化されたフィルタや
変換器から要素を選び、それを直列につなぐことによってシステムを構築すると
いうことを、設計者は日常的に行っています。同じように、列の演算は
自由に組み合わせられる標準的なプログラムの要素のライブラリを提供します。
例として、最初の\( n + 1 \)個のフィボナッチ数の二乗のリストを構築する
プログラムを作るのに、\code{sum\-/odd\-/squares}手続きと\code{even\-/fibs}
手続きの部品を再利用することができます。

\begin{scheme}
(define (list-fib-squares n)
  (accumulate
   cons
   nil
   (map square (map fib (enumerate-interval 0 n)))))
(list-fib-squares 10)
~\textit{(0 1 1 4 9 25 64 169 441 1156 3025)}~
\end{scheme}

\noindent
部品を配置し直して、整数列の中の奇数ものの二乗の積を計算するために
使うこともできます。

\begin{scheme}
(define (product-of-squares-of-odd-elements sequence)
  (accumulate * 1 (map square (filter odd? sequence))))
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
~\textit{225}~
\end{scheme}

\noindent
一般的なデータ処理アプリケーションを列の演算として定式化することもできます。
人事記録の列があるとして、最も給料の高いプログラマの給料を見つけたいと
します。ある人事記録に含まれる給料を返す\code{salary}というセレクタと、
ある人事記録がプログラマのものであるかをチェックする\code{programmer?}という
セレクタが用意されているとします。すると、次のように書くことができます。

\begin{scheme}
(define (salary-of-highest-paid-programmer records)
  (accumulate 
   max 0 (map salary (filter programmer? records))))
\end{scheme}

\noindent
これらの例は、列の演算として表すことができる広範囲な演算のごく一部を垣間見たに
すぎません。
\footnote{
Richard \link{Waters (1979)}は、伝統的なFortranプログラムを自動的に解析し、
プログラムをマップ、フィルタ、集積の組み合わせとして見ることができるように
するプログラムを開発しました。すると、Fortran科学サブルーチンパッケージの
実に90\%が、このパラダイムにうまくはまることがわかりました。Lispがプログラミング
言語として成功した理由のひとつには、順序つきのコレクションを表現する標準的な
手段がリストとして提供され、高階演算によって操作ができるということがあります。
プログラミング言語APLも同じような選択をして、それが力と魅力の大きな源となっています。
APLでは、すべてのデータは配列として表され、配列のさまざまな演算ができる
普遍的で便利な汎用演算子セットが提供されています。}

ここでリストとして実装した列というものは、処理モジュールを接続できるようにする
標準インターフェイスとして使うことができます。また、構造を列として統一的に表現する
ときに、プログラム中でのデータ構造の依存関係が少ない数の列の演算に局所化されるように
しています。これらを変えることで、プログラムの全体的な設計に手を加えずに、列の表現方法を
いろいろ試してみることができます。\link{Section 3.5}で、無限列を扱えるように列処理の
パラダイムを一般化する際に、この能力を利用することになります。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.33}Exercise 2.33:}
基本的なリスト操作のいくつかを集積として定義したものを以下に示す。
欠けている式を埋めて、完成させよ。

\begin{scheme}
(define (map p sequence)
  (accumulate (lambda (x y) ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~) nil sequence))
(define (append seq1 seq2)
  (accumulate cons ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))
(define (length sequence)
  (accumulate ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ 0 sequence))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.34}Exercise 2.34:} 
ある\( x \)の値によって\( x \)の多項式を評価することは集積として定式化できる。
次の多項式について考える。
\begin{comment}

\begin{example}
a_n x^n + a_(n-1) x^(n-1) + ... + a_1 x + a_0
\end{example}

\end{comment}
\begin{displaymath}
 a_n x^n + a_{n-1} x^{n-1} + \ldots + a_1 x + a_0 
\end{displaymath}

この多項式を\newterm{Horner's rule}(\jnewterm{ホーナー法})というアルゴリズムによって評価する。ホーナー法では、この計算を以下のような構造にする。
\begin{comment}

\begin{example}
(... (a_n x + a_(n-1)) x + ... + a_1) x + a_0
\end{example}

\end{comment}
\begin{displaymath}
 (\ldots (a_n x + a_{n-1}) x + \ldots + a_1) x + a_0. 
\end{displaymath}
つまり、\( a_n \)から始めて、それに\( x \)をかけ、\( a_{n-1} \)を足し、\( x \)をかけ\( \dots \)ということを、\( a_0 \)まで繰り返す。
\footnote{\link{Knuth 1981}によると、この方法は19世紀始めにW. G. Hornerによって定式化されたということですが、実際は100年以上前にニュートンによって使われていました。
ホーナー法のやり方では、直接的なやり方(まず\( a_n x^n \)を計算し、\( a_{n-1}x^{n-1} \)を足し\( \dots \))よりも少ない回数の和と積によって多項式を評価します。実際に、
任意の多項式を評価するどんなアルゴリズムも、少なくともホーナー法以上の和と積を
使う必要があり、ホーナー法が多項式評価のための最適なアルゴリズムであるという
ことが証明可能です。このことは、(和の回数については)1954年のA. M. Ostrowskiの
論文で証明され、それが実質的に最適アルゴリズムの現代的研究の始まりとなりました。
積の回数についての同じような証明は、1966年にV. Y. Panによってなされました。
\link{Borodin and Munro (1975)}の本では、これらを含めた最適アルゴリズムについて
概観しています。}

以下のひな形を埋め、多項式をホーナー法によって評価する手続きを作れ。
多項式の係数\( a_0 \ldots a_n \)は列として並んでいるとする。

\begin{scheme}
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)
              0
              coefficient-sequence))
\end{scheme}

例えば、\( x = 2 \)のときの\( 1 + 3x + 5x^3 + x^5 \)を計算するには、次を評価する。

\begin{scheme}
(horner-eval 2 (list 1 3 0 5 0 1))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.35}Exercise 2.35:} 
\link{Section 2.2.2}の\code{count\-/leaves}を集積として再定義せよ。

\begin{scheme}
(define (count-leaves t)
  (accumulate ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.36}Exercise 2.36:} 
手続き\code{accumulate\-/n}は\code{accumulate}に似ているが、三番目の引数として
列の列を取る(要素となる列の長さは一定であるとする)という違いがある。
この手続きは、指定された集積手続きを適用してそれぞれの列の最初の要素を結合したもの、
それぞれの列の二番目の要素を結合したもの\( \dots \)を返り値とする。例えば、
\code{s}が \code{((1 2 3) (4 5 6) (7 8 9) (10 11 12))}という四つの列を持つ列
であるときに\code{(accumulate\-/n + 0 s)}の値が\code{(accumulate\-/n + 0 s)}
になるようにする。次の\code{accumulate\-/n}の定義に欠けている式を埋めよ。

\begin{scheme}
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)
            (accumulate-n op init ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.37}Exercise 2.37:}
ベクトル\( {\bf v} = (v_i) \)を数値の列として表現し、行列\( {\bf m} = (m_{ij}) \)を
ベクトル(行列の行)の列として表現するとする。例えば、以下の行列は
\begin{comment}

\begin{example}
+-         -+
|  1 2 3 4  |
|  4 5 6 6  |
|  6 7 8 9  |
+-         -+
\end{example}

\end{comment}
\begin{displaymath}
%  
% \left(\matrix{	1 & 2 & 3 & 4 \cr
% 		4 & 5 & 6 & 6 \cr
% 		6 & 7 & 8 & 9 \cr }\right) 
\left(
\begin{array}{cccc}
  1 & 2 & 3 & 4 \\
  4 & 5 & 6 & 6 \\
  6 & 7 & 8 & 9 
\end{array}
\right) 
\end{displaymath}
\noindent
列\code{((1 2 3 4) (4 5 6 6) (6 7 8 9))}として表現される。この表現を使うと、
列操作によって基本的な行列とベクトルの演算を簡潔に表現することができる。
これらの(どんな行列演算の本にも書いてある)演算は、次のようなものである。
\begin{comment}

\begin{example}
                                       __
(dot-product v w)      returns the sum >_i v_i w_i

(matrix-*-vector m v)  returns the vector t,
                                   __
                       where t_i = >_j m_(ij) v_j

(matrix-*-matrix m n)  returns the matrix p,
                                      __
                       where p_(ij) = >_k m_(ik) n_(kj)

(transpose m)          returns the matrix n,
                       where n_(ij) = m_(ji)
\end{example}

\end{comment}
\begin{displaymath}
%  
% \eqalign{ 
% 	\hbox{\tt (dot-product v w)} 		&\; {\rm returns\;the\;sum\;} 
% 		\Sigma_i v_i w_i, \cr
% 	\hbox{\tt (matrix-*-vector m v)} 	&\; {\rm returns\;the\;vector\;} {\bf t}, 
% 		\; {\rm where\;} t_i = \Sigma_j m_{ij} v_j, \cr
% 	\hbox{\tt (matrix-*-matrix m n)} 	&\; {\rm returns\;the\;matrix\;} {\bf p},
% 		\; {\rm where\;} p_{ij} = \Sigma_k m_{ik} n_{kj}, \cr
% 	\hbox{\tt (transpose m)} 			&\; {\rm returns\;the\;matrix\;} {\bf n}, 
% 		\; {\rm where\;} n_{ij} = m_{ji}. \cr
% } 
\begin{array}{rl}
	\hbox{\tt (dot-product v w)} 		&\; \mbox{総和}
		\Sigma_i v_i w_i \mbox{を返す}  \\
	\hbox{\tt (matrix-*-vector m v)} 	&\; t_i = \Sigma_j m_{ij} v_j \mbox{であるような} \\ 
		&\; \mbox{ベクトル} \hbox{\bf t} \mbox{を返す} \\
	\hbox{\tt (matrix-*-matrix m n)} 	&\; p_{ij} = \Sigma_k m_{ik} n_{kj} \mbox{であるような} \\
		&\; \mbox{行列} \hbox{\bf p} \mbox{を返す} \\
	\hbox{\tt (transpose m)} 		&\; n_{ij} = m_{ji} \mbox{であるような} \\
		&\; \mbox{行列} \hbox{\bf n} \mbox{を返す}
\end{array}
\end{displaymath}
内積は、次のように定義できる。\footnote{この定義では、\link{Footnote 12}で説明した
拡張バージョンの\code{map}を使っています。}

\begin{scheme}
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
\end{scheme}


ほかの行列演算を計算する以下の手続きについて、欠けた式を補え
(手続き\code{accumulate\-/n}は\link{Exercise 2.36}で定義されている)。

\begin{scheme}
(define (matrix-*-vector m v)
  (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ m))
(define (transpose mat)
  (accumulate-n ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ m)))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.38}Exercise 2.38:} 
\code{accumulate}手続きは、列の最初の要素と、右のすべての要素を組み合わせた結果とを
組み合わせるため、\code{fold\-/right}としても知られている。\code{fold\-/left}という
ものもあり、これは\code{fold\-/right}に似ているが、要素の組み合わせを逆方向に
行うという点が違う。

\begin{scheme}
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
\end{scheme}


以下の式の値はいくらか。

\begin{scheme}
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
\end{scheme}

\code{fold\-/right}と\code{fold\-/left}が任意の列に対して同じ値を返すことを
保証するために、\code{op}はどのような性質を満たさなければならないだろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.39}Exercise 2.39:} 
以下の\code{reverse}(\link{Exercise 2.18})手続きの定義を、
\link{Exercise 2.38}の\code{fold\-/right}と\code{fold\-/left}によって
完成させよ。

\begin{scheme}
(define (reverse sequence)
  (fold-right (lambda (x y) ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~) nil sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~) nil sequence))
\end{scheme}
\end{quote}

\subsubsection*{マップのネスト}

列というパラダイムを拡張して、普通はネストしたループによって表現されるような
多くの計算に適用することができます。
\footnote{このマップのネストというやり方は、David Turnerによって示されたものです。
彼が開発した言語のKRCとMirandaでは、これらの概念を扱うエレガントな形式が
用意されています。この節の例(と\link{Exercise 2.42})は、\link{Turner 1981}を
アレンジしたものです。\link{Section 3.5.3}では、このやり方が無限の長さの列に対して
一般化できることを学びます。}次の問題について考えてみましょう。正の整数\( n \)が与えられたとき、\( 1 \le j < i \le n \)で、かつ\( i + j \)が素数となるような異なる正の整数
\( i \)と\( j \)のすべての順序つきペアを見つけよ。例えば、\( n \)が6のとき、ペアは
以下のようになる。
\begin{comment}

\begin{example}
  i   | 2 3 4 4 5 6 6
  j   | 1 2 1 3 2 1 5
------+---------------
i + j | 3 5 5 7 7 7 11
\end{example}

\end{comment}
\begin{displaymath}
\vbox{
\offinterlineskip
\halign{
\strut \hfil \quad #\quad \hfil & \vrule 
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil \cr

$i$ 	& 2 & 3 & 4 & 4 & 5 & 6 & 6 \cr
$j$ 	& 1 & 2 & 1 & 3 & 2 & 1 & 5 \cr
\noalign{\hrule}
$i + j$	& 3 & 5 & 5 & 7 & 7 & 7 & 11 \cr}
}
\end{displaymath}
この計算の自然な構築方法として、\( n \)以下の正の整数からな、大きい順に並んだ
すべてのペアの列を生成し、フィルタによって合計が素数となるペアを選択し、それから
フィルタを通過したそれぞれの\( (i, j) \)のペアに対して\( (i, j, i + j) \)という
三つ組みを作るというものがあります。

ペアの列を生成する方法としては、すべての整数\( i \le n \)に対して整数\( j < i \)を
列挙し、そのような\( i \)と\( j \)すべてに対して\( (i, j) \)を生成するという
ものがあります。列の演算を使って、\code{(enumerate\-/interval 1 n)}という列に
マップを行います。この列のそれぞれの\( i \)に対して、
\code{(enumerate\-/interval 1 (- i 1))}という列にマップを行います。
この後者の列のそれぞれの\( j \)に対して、\code{(list i j)}というペアを生成します。
これによって、それぞれの\( i \)に対するペアの列ができます。すべての\( i \)に対して、
すべての列を(\code{append}で集積して)組み合わせることで、求めるペアの列ができます。
\footnote{ここではペアを、Lispのペアとしてではなく、二つの要素のリストとして
表現しています。このため、``ペア''\( (i, j) \)は\code{(list i j)}で、
\code{(cons i j)}ではありません。}

\begin{scheme}
(accumulate
 append nil (map (lambda (i)
                   (map (lambda (j) (list i j))
                        (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n)))
\end{scheme}

\noindent
マップと集積を\code{append}によって組み合わせることは、この種のプログラムでは
とてもよくあることですので、独立した手続きとして分離することにします。

\begin{scheme}
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
\end{scheme}

\noindent
次に、このペアの列をフィルタして、和が素数となるものを探します。フィルタの述語は、
列のそれぞれの要素に対して呼ばれます。述語の引数はペアで、述語はペアから整数を
取り出す必要があります。そのため、列のそれぞれの要素に適用する述語は次のように
なります。

\begin{scheme}
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
\end{scheme}

\noindent
最後に、フィルタを通ったペアの列に対して次の手続きでマップして、結果の列を生成します。
手続きは、ペアの二つの要素とその合計からなる三つ組を構築するものです。

\begin{scheme}
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
\end{scheme}

\noindent
これらのステップすべてを組み合わせると、完全な手続きになります。

\begin{smallscheme}
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))
\end{smallscheme}

\noindent
マップのネストは、区間の列挙以外の列に対しても役に立ちます。
ある集合\( S \)に対して、そのすべての順列を生成したいとします。つまり、集合の
項目を並べる方法をすべて生成するということになります。例えば、\( \{1, 2, 3\} \)の
順列は、\( \{1, 2, 3\} \), \( \{1, 3, 2\} \), \( \{2, 1, 3\} \), \( \{2, 3, 1\} \),
\( \{3, 1, 2\} \), \( \{3, 2, 1\} \)です。集合\( S \)の順列を生成するための計画として、
\( S \)のすべての項目\( x \)に対して、\( S - x \)の順列の列を生成し、
\footnote{集合\( S - x \)は、\( S \)のすべての要素から\( x \)を除いた集合です。}
それぞれの先頭に\( x \)を置くというやり方が使えます。
こうすると、\( S \)の\( x \)それぞれに対して、\( x \)から始まる\( S \)の順列の列が
得られます。すべての\( x \)に対するこれらの列を組み合わせると、\( S \)の順列すべてが
得られます。
\footnote{Schemeのコードでは、セミコロンは\newterm{comments}(\jnewterm{コメント})
を入れる場合に使います。セミコロンから行末までにあるものはすべてインタプリタに
無視されます。この本ではあまりコメントを使っていません。プログラムに対して
説明的な名前を付けることで、プログラム自身がドキュメント化されたものとなるよう
努力しています。}

\begin{scheme}
(define (permutations s)
  (if (null? s)              ~\textrm{; 集合は空か?}~
      (list nil)             ~\textrm{; 空集合を持つ列}~
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
\end{scheme}

\noindent
この戦略によって、\( S \)の順列を求める問題を、\( S \)よりも要素数の少ない
集合の順列を求める問題に縮約していることに注意してください。最終的には、
要素のない集合を表す空リストに到達します。この場合、\code{(list nil)}という
ひとつの項目からなる列、つまり空集合を生成します。\code{permutations}で
使われる\code{remove}手続きは、与えられた列から与えられた項目を除いたすべての
項目を返します。これは単純なフィルタとして表現できます。

\begin{scheme}
(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.40}Exercise 2.40:}
整数\( n \)に対し、\( 1 \le j < i \le n \)となるペア\( (i, j) \)の列を
生成する手続き\code{unique\-/pairs}を定義せよ。\code{unique\-/pairs}を使って
上の\code{prime\-/sum\-/pairs}の定義を簡単にせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.41}Exercise 2.41:} 
ある整数\( n \)以下の異なる正の整数が大小順に並んだ三つ組
\( i \), \( j \), \( k \)の中で、合計がある整数\( s \)となるものすべてを
見つける手続きを書け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.42}Exercise 2.42:} 

\begin{figure}[tb]
\phantomsection\label{Figure 2.8}
\centering
\begin{comment}
\heading{Figure 2.8:} A solution to the eight-queens puzzle.

\begin{example}
+---+---+---+---+---+---+---+---+
|   |   |   |   |   | Q |   |   |
+---+---+---+---+---+---+---+---+
|   |   | Q |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| Q |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   | Q |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   | Q |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   | Q |
+---+---+---+---+---+---+---+---+
|   | Q |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   | Q |   |   |   |   |
+---+---+---+---+---+---+---+---+
\end{example}
\end{comment}
\includegraphics[width=48mm]{fig/chap2/Fig2.8c.pdf}      % 73mm
\par\bigskip
\noindent
\heading{Figure 2.8:} 8クイーンパズルのひとつの解
\end{figure}

``8クイーンパズル''とは、どのクイーンもほかのクイーンの利き筋に入らない
(つまり、同じ行・列・対角線の上に二つのクイーンがあるということがないようにする)
ように8個のクイーンをチェス盤の上に置く方法を問うものである。\link{Figure 2.8}に
考えられる解のひとつを示す。このパズルを解くひとつのやり方として、各列にひとつの
クイーンを置きながらチェス盤を横に移動していくというものがある。\( k - 1 \)個の
クイーンを置いた状態では、\( k \)個目のクイーンは、すでに盤上にあるどのクイーンも
利き筋に入らない位置に置く必要がある。この解き方は再帰的に定式化できる。
最初の\( k - 1 \)列に\( k - 1 \)個のクイーンを置くパターンをすべて生成済みだと
想定する。それぞれのパターンに対して、\( k \)列目のそれぞれの行にクイーンを置いて
いって、位置の集合を拡張したものを生成する。次にこれらをフィルタして、\( k \)列目の
クイーンがほかのクイーンに利かないものだけを残す。こうすると、最初の\( k \)列に
\( k \)個のクイーンを置くすべてのパターンの列ができる。このプロセスを続けると、
パズルの解答のひとつだけではなく、すべての解答が得られる。

この解き方を\code{queens}という手続きとして実装し、\( n \times n \)のチェス盤に
\( n \)個のクイーンを置くという問題に対するすべての答えの列を返すようにする。
\code{queens}は、盤の最初の\( k \)列にクイーンを置く全てのパターンの列を返す
内部手続き\code{queen\-/cols}を持っている。

\begin{scheme}
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row 
                                    k 
                                    rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
\end{scheme}

この手続きの中で、\code{rest\-/of\-/queens}は最初の\( k - 1 \)列に\( k - 1 \)個の
クイーンを置くパターンのひとつで、\code{new\-/row}は\code{k}列目のクイーンを
置く候補となる行である。盤上の位置集合に対する表現方法と、
位置集合に新しい行-列の位置を追加する\code{adjoin\-/position}手続きと
位置の空集合を表す\code{empty\-/board}を実装し、プログラムを完成させよ。
また、位置集合に対して、\code{k}列目のクイーンがほかのクイーンに利いていないかを
調べる\code{safe?}手続きも書く必要がある(新しいクイーンの利きだけをチェックすればいい
ということに注意。ほかのクイーンは互いに利いていないことが保証済みである)。
。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.43}Exercise 2.43:} 
Louis Reasonerは\link{Exercise 2.42}を解くのにだいぶ苦労している。
彼が書いた\code{queens}手続きは動いてはいるようだが、非常に遅いのだ
(\( 6\times6 \)の場合でも、Louisは待ちきれなくなってしまう)。
LouisがEva Lu Atorに見てくれるよう頼むと、彼女はLouisが\code{flatmap}内の
マップのネストの順番を次のように逆にしてしまっていることを指摘した。

\begin{scheme}
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
\end{scheme}

逆にするとなぜプログラムの実行が遅くなるのか説明せよ。\link{Exercise 2.42}の
プログラムが8クイーンパズルを解く時間を\( T \)として、Louisのプログラムが
パズルを解くのにかかる時間を見積もれ。
\end{quote}

\subsection{例: 図形言語}
\label{Section 2.2.4}


この節では、図形を描く簡単な言語を紹介し、それによって抽象と閉包の持つ力を示し、
また高階手続きの本質的な部分を利用します。この言語は、\link{Figure 2.9}のような、
要素をずらしたり拡大縮小したりしたものによって構成されるパターンについての実験が
やりやすいように設計されています。
\footnote{この図形言語は、M.C. Escherの``Square Limit''
(\link{Henderson 1982}参照)という木版画のような画像を構築するためにPeter Hendersonが
作成した言語をもとにしています。この木版画は、この節の\code{square\-/limit}手続きによって
描かれるものと似た、拡大縮小した繰り返しパターンを含んでいます。}
この言語では、組み合わされるデータオブジェクトは、リスト構造ではなく手続きとして
表現されます。閉包性を満たす\code{cons}によってどんな複雑なリスト構造でも簡単に
構築できるのと同じように、この言語の演算も閉包性を満たしていて、どんな複雑な
パターンでも簡単に構築できます。

\subsubsection*{図形言語}

\link{Section 1.1}でプログラミングの学習を始めたとき、言語を記述する際には
言語の基本要素、組み合わせ方法、抽象化方法にフォーカスを当てることが
重要だということを強調してきました。ここでもその枠組みに従います。

\begin{figure}[tb]
\phantomsection\label{Figure 2.9}
\centering
\begin{comment}
\heading{Figure 2.9:} Designs generated with the picture language.

[two graphic images not included]
\end{comment}
\includegraphics[width=111mm]{fig/chap2/Fig2.9-bigger.png}
\par\bigskip
\noindent
\heading{Figure 2.9:} 図形言語によって生成されたデザイン
\end{figure}

\begin{figure}[tb]
\phantomsection\label{Figure 2.10}
\centering
\begin{comment}
\heading{Figure 2.10:} Images produced by the \code{wave}
painter, with respect to four different frames.  The frames, shown with dotted
lines, are not part of the images.

[four graphic images not included]
\end{comment}
\includegraphics[width=50mm]{fig/chap2/Fig2.10.pdf}
\par\bigskip
\noindent
\heading{Figure 2.10:} \code{wave}によって生成された画像
\end{figure}

この図形言語のエレガントさの一部は、\newterm{painter}(\jnewterm{ペインタ})という
一種類の要素しかないというところにあります。ペインタは、指定された平行四辺形型の
枠にフィットするように画像をずらしたり拡大縮小したりしたものを描画します。
例えば、\code{wave}という基本ペインタがあり、\link{Figure 2.10}のような
粗い線画を描きます。実際の線画の形は枠によって変わります---\link{Figure 2.10}の
四つの画像は同じ\code{wave}ペインタによって生成されたものですが、それぞれ
違った枠に対して描かれています。もっと手の込んだペインタもあります。\code{rogers}
という基本ペインタは、\link{Figure 2.11}に示すように、\acronym{MIT}創設者の
William Barton Rogersの絵を描きます。
\footnote{
William Barton Rogers (1804-1882)は\acronym{MIT}の創設者で、また初代学長でもあります。
地質学者であり、才能あふれる教師でもあった彼は、ウィリアム・アンド・メアリー大学と
バージニア大学で教鞭をとっていました。1859年にはボストンに移り、それまでより研究の
時間が持てるようになって、「工科大学」を設立する計画に取りかかりました。また、
マサチューセッツ州で初めてのガスメータの州検査官も務めました。

1861年に\acronym{MIT}が創設されたとき、Rogersは最初の学長に選ばれました。
Rogersは「役に立つ学習」という理想を信奉していましたが、それは当時の
大学教育とは異なるものでした。当時の大学教育は古典を過度に重視していて、
彼の書くところによると「より幅広く高度で実用的な自然・社会科学の
教育や訓練を行ううえでの障害となっている」ものでした。
彼はまた、そこでの教育は職業専門学校の狭い教育とも異なるものにしようと
思っていました。Rogerの言葉によると、

\begin{quote}
世間が押しつけてくるような、実務者と科学者の区別というのはまったく不毛なものだ。
現代の経験はすべて、そのような区別が完全に無益だということを示している。
\end{quote}

Rogersは1870年に健康上の理由で辞任するまで\acronym{MIT}の学長を務めました。
1873年恐慌による財政危機とハーバード大学による併合の試みをはねのける
という重圧から二代目の\acronym{MIT}学長John Runkleが1878年に辞職すると、
Rogerは学長職に戻り、1881年まで務めました。

Rogersは1882年の卒業式で\acronym{MIT}の卒業生に演説をしているときに倒れ、
亡くなりました。Runkleは、同年の弔辞の中で、Rogerの死に際の言葉を引用しています。

\begin{quote}
``本日ここに立ち、本校の現状を見ると\( \dots \) 科学の始まりのことが頭に浮かびます。
記憶によると、150年前にStephen Halesが灯用ガスを主題にした小論文を発表しました。
その中で彼は、彼の研究が示すところによると128グレインの瀝青炭-- '' ``瀝青炭''というのが、
この世界での彼の最後の言葉でした。ここで彼は前のめりになり、まるで目の前の台に
置いてあるメモを確認するかのようでしたが、それからゆっくりと直立の姿勢に戻り、
両手を上げ、そしてこの世の仕事と業績から``死の明日''へと送られたのです。
そこでは人生の謎は解決され、肉体から解放された魂は、新しく未だ計り知れない
永遠の未来の謎について考え続けることに終わりのない満足を得るのです。
\end{quote}

Francis A. Walker(\acronym{MIT}の三代目の学長)によると、

\begin{quote}
彼は人生を通して誠実かつ勇敢に行動し、騎士であれば必ず望んだような
よい死の迎え方をした。職務中に、持ち場について、公務を果たすちょうどそのときに
亡くなったのだ。
\end{quote}
}
\link{Figure 2.11}の4つの画像は、\link{Figure 2.10}の\code{wave}の画像と
同じ4つの枠に対して描いたものです。

\begin{figure}[tb]
\phantomsection\label{Figure 2.11}
\centering
\begin{comment}
\heading{Figure 2.11:} Images of William Barton Rogers,
founder and first president of \acronym{MIT}, painted with respect to the same
four frames as in \link{Figure 2.10} (original image reprinted with the
permission of the \acronym{MIT} Museum).

[four graphic images not included]
\end{comment}
\includegraphics[width=48mm]{fig/chap2/Fig2.11.pdf}
\par\bigskip
\noindent
\begin{quote}
\heading{Figure 2.11:} \acronym{MIT}創設者・初代学長William Barton Rogersの画像。\link{Figure 2.10}と同じ4つの枠に対して描いたもの。(元の画像は\acronym{MIT}博物館の許諾を得て
複製した)
\end{quote}
\end{figure}

画像を結合するには、与えられたペインタから新しいペインタを構築するいろいろな演算を
使います。例えば、\code{beside}演算は二つのペインタを引数に取り、枠の左半分に
一つ目のペインタの画像を描き右半分に二つ目のペインタの画像を描く新しい複合ペインタを
作ります。同じように、\code{below}は二つのペインタを引数に取り、二つ目のペインタの
画像の下に一つ目のペインタの画像を描く複合ペインタを作ります。単独のペインタを
変形して別のペインタを作る演算もあります。例えば、\code{flip\-/vert}はひとつの
ペインタを引数に取り、その画像を上下逆に描くプリンタを作ります。また、
\code{flip\-/horiz}は元のペインタの画像を左右逆に描くプリンタを作ります。

\code{wave}から始めて、二段階を経て構築した\code{wave4}というペインタの描く画像を
\link{Figure 2.12}に示します。

\begin{scheme}
(define wave2 (beside wave (flip-vert wave)))
(define wave4 (below wave2 wave2))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 2.12}
\centering
\begin{comment}
\heading{Figure 2.12:} Creating a complex figure, starting
from the \code{wave} painter of \link{Figure 2.10}.

[two graphic images not included]

\begin{scheme}
(define wave2                      (define wave4
  (beside wave (flip-vert wave)))    (below wave2 wave2))
\end{scheme}
\end{comment}
\includegraphics[width=50mm]{fig/chap2/Fig2.12.pdf}
\begin{quote}
\heading{Figure 2.12:} \link{Figure 2.10}の\code{wave}ペインタから始めて複雑な図を作る
\end{quote}
\end{figure}

複雑な画像をこの方法で構築する際に、ペインタがこの言語の結合手段について閉じている
ということを利用しています。二つのペインタの\code{beside}や\code{below}は、
それ自身ペインタになります。そのため、より複雑なペインタを作るのに、
それを要素として使うことができます。リスト構造を\code{cons}を使って構築する場合と
同じように、データが結合手段について閉じているということは、少しの演算によって
複雑な構造を作る能力を実現するうえで決定的に重要なことです。

ペインタを結合することができるとなると、よくある結合パターンを抽象化したく
なるところです。ここで、ペインタ演算をSchemeの手続きとして実装することにします。
つまり、この図形言語のための特別な抽象化メカニズムというものは必要ないという
ことです。結合手段は普通のScheme手続きなので、手続きについてできることは
何でもペインタ演算についてもできる能力が自動的に得られることになります。
例えば、\code{wave4}に出てくるパターンは次のように抽象化できます。

\begin{scheme}
(define (flipped-pairs painter)
  (let ((painter2 (beside painter (flip-vert painter))))
    (below painter2 painter2)))
\end{scheme}

\noindent
そして、\code{wave4}はこのパターンの具体例として定義します。

\begin{scheme}
(define wave4 (flipped-pairs wave))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 2.13}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.13:} Recursive plans for \code{right\-/split} and \code{corner\-/split}.

\begin{example}
+-------------+-------------+    +------+------+-------------+
|             |             |    | up-  | up-  |             |
|             | right-split |    | split| split| corner-split|
|             |             |    |      |      |             |
|             |     n-1     |    |  n-1 |  n-1 |     n-1     |
|             |             |    |      |      |             |
|  identity   +-------------+    +------+------+-------------+
|             |             |    |             | right-split |
|             | right-split |    |             |     n-1     |
|             |             |    |  identity   +-------------+
|             |     n-1     |    |             | right-split |
|             |             |    |             |     n-1     |
+-------------+-------------+    +-------------+-------------+

       right-split n                    corner-split n
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=111mm]{fig/chap2/Fig2.13a.pdf}
\par\bigskip
\noindent
\heading{Figure 2.13:} \code{right\-/split}と\code{corner\-/split}の再帰計画
\end{figure}

また、再帰演算を定義することもできます。以下に示すものは、\link{Figure 2.13}と
\link{Figure 2.14}に示すような、右方向に枝分かれしていくペインタを作る
再帰演算です。

\begin{scheme}
(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))
\end{scheme}

\noindent
右方向だけでなく上方向にも枝分かれさせることで、バランスの取れたパターンを
作ることもできます(問題\link{Exercise 2.44}と、図\link{Figure 2.13}・
\link{Figure 2.14}参照)。

\begin{scheme}
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))
\end{scheme}

\noindent
\code{corner\-/split}の四つのコピーを適切に配置することによって、\code{square\-/limit}
というパターンを得ることができます。それを\code{wave}と\code{rogers}に適用したものを
\link{Figure 2.9}に示してあります。

\begin{scheme}
(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.44}Exercise 2.44:} 
\code{corner\-/split}で使われている\code{up\-/split}手続きを定義せよ。
\code{right\-/split}に似ているが、\code{below}と\code{beside}の役割を
入れ替えている。
\end{quote}

\begin{figure}[tbp]
\phantomsection\label{Figure 2.14}
\centering
\begin{comment}
\heading{Figure 2.14:} The recursive operations \code{right\-/split} and \code{corner\-/split} applied to the painters \code{wave} and \code{rogers}.  Combining four \code{corner\-/split} figures produces symmetric \code{square\-/limit} designs as shown in \link{Figure 2.9}.

[two graphic images not included]

\begin{scheme}
(right-split wave 4)         (right-split rogers 4)
\end{scheme}

[two graphic images not included]

\begin{scheme}
(corner-split wave 4)        (corner-split rogers 4)
\end{scheme}
\end{comment}
\includegraphics[width=91mm]{fig/chap2/Fig2.14b.pdf}
\begin{quote}
\heading{Figure 2.14:} 再帰演算\code{right\-/split}と\code{corner\-/split}をペインタ\code{wave}と\code{rogers}に適用したもの。\code{corner\-/split}した四つの図を組み合わせると、\link{Figure 2.9}に示すような対照的な\code{square\-/limit}のデザインになる。
\end{quote}
\end{figure}

\subsubsection*{高階演算}

ペインタを組み合わせるパターンを抽象化するだけでなく、より高いレベルで、
ペインタ演算を組み合わせるパターンを抽象化することもできます。つまり、
ペインタ演算を操作対象の要素として扱い、それらの要素を組み合わせる手段
---ペインタ演算を引数として取り、新しいペインタ演算を作るような手続き---
を書くことができるということです。

例えば、\code{flipped\-/pairs}と\code{square\-/limit}はどちらも、あるペインタの
画像を四つ正方形のパターンに並べるもので、違うのはそれぞれの画像の向きだけです。
このペインタの組み合わせパターンを抽象化する方法のひとつを次の手続きに示します。
この手続きは、四つの一引数ペインタ演算を引数として取り、ある与えられたペインタを
これらの四つの演算によって変形したものを正方形に配置するペインタ演算を作るという
ものです。\code{tl}, \code{tr}, \code{bl}, \code{br}は、それぞれ左上、右上、
左下、右下の画像に適用する変換です。

\begin{scheme}
(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) (tr painter)))
          (bottom (beside (bl painter) (br painter))))
      (below bottom top))))
\end{scheme}

\noindent
こうすると、\code{flipped\-/pairs}は\code{square\-/of\-/four}によって以下のように定義できます。
\footnote{
等価な書き方として、次のように書くこともできます。

\begin{smallscheme}
(define flipped-pairs
  (square-of-four identity flip-vert identity flip-vert))
\end{smallscheme}
}

\begin{scheme}
(define (flipped-pairs painter)
  (let ((combine4 (square-of-four identity flip-vert
                                  identity flip-vert)))
    (combine4 painter)))
\end{scheme}

\noindent
また、\code{square\-/limit}は次のように表現できます。
\footnote{\code{Rotate180}はペインタを180度回転するものです(\link{Exercise 2.50}参照)。
\code{rotate180}の代わりに、\link{Exercise 1.42}の\code{compose}手続きを使って
\code{(compose flip\-/vert flip\-/horiz)}と書くこともできます。
}

\begin{scheme}
(define (square-limit painter n)
  (let ((combine4 (square-of-four flip-horiz identity
                                  rotate180 flip-vert)))
    (combine4 (corner-split painter n))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.45}Exercise 2.45:} 
\code{right\-/split}と\code{up\-/split}は、汎用の分割演算の具体例として表現できる。
以下の式を評価したとき、

\begin{scheme}
(define right-split (split beside below))
(define up-split (split below beside))
\end{scheme}

\noindent
すでに定義したのものと同じふるまいを持つ手続き\code{right\-/split}と\code{up\-/split}が
得られるように、\code{split}手続きを定義せよ。
\end{quote}

\subsubsection*{枠}
ペインタやペインタの組み合わせ手段をどのように実装するかを示す前に、まず枠について
考える必要があります。枠は三つのベクトルとして記述することができます---
原点ベクトルと、二つの辺ベクトルです。原点ベクトルは、平面上のどこかにある絶対原点
からの枠の原点の相対位置を指定します。辺ベクトルは、枠の角について、枠の原点からの
相対位置を指定します。もし二つの辺が垂直であれば、枠は長方形になります。そうでない
場合、枠はより一般的な平行四辺形になります。

\link{Figure 2.15}は、枠とそれに関連づけられたベクトルを示しています。
データ抽象化の原則通り、枠がどのように表現されているかについて
ここではまだ特定する必要がありません。三つのベクトルを引数に取り枠を作る
コンストラクタ\code{make\-/frame}と、それに対応する三つのセレクタ
\code{origin\-/frame}, \code{edge1\-/frame}, \code{edge2\-/frame}があるという
だけで十分です(\link{Exercise 2.47}参照)。

\begin{figure}[tb]
\phantomsection\label{Figure 2.15}
\centering
\begin{comment}
\heading{Figure 2.15:} A frame is described by three vectors
-- an origin and two edges.

\begin{example}
                         __
                     __--  \
                 __--       \
      __     __--            \   __
     |\  __--                 \__-|
       \-                  __--
frame   \              __--
edge2    \         __--    frame
vector    \    __--        edge1
           \_--            vector
            -   <--+
          frame    |
          origin   +-- (0, 0) point
          vector       on display screen
\end{example}
\end{comment}
\includegraphics[width=51mm]{fig/chap2/Fig2.15a.pdf}
\begin{quote}
\heading{Figure 2.15:} 枠は、原点と二つの辺という三つのベクトルによって記述される。
\end{quote}
\end{figure}

画像は、単位正方形内の座標\( (0 \le x, y \le 1) \)を使って記述することにします。
それぞれの枠には\newterm{frame coordinate map}(\jnewterm{枠座標マップ})
というものを関連づけ、画像が枠に合うようにずらしたり拡大縮小したりするのに
使います。このマップは、ベクトル\( {\bf v} = (x, y) \)を次のようなベクトルの和に
マップすることによって単位正方形を枠内に変換します。
\begin{comment}

\begin{example}
Origin(Frame) + x * Edge_1(Frame) + y * Edge_2(Frame)
\end{example}

\end{comment}
\begin{displaymath}
 {\rm Origin(Frame)} + x \cdot {\rm Edge_1(Frame)} + y \cdot {\rm Edge_2(Frame)}. 
\end{displaymath}
例えば、(0, 0)は枠の原点に、(1, 1)は原点と対角線上にある頂点に、
(0.5, 0.5)は枠の中心にマップされます。枠座標マップは次の手続きによって
作ることができます。
\footnote{\code{frame\-/coord\-/map}は、後で\link{Exercise 2.46}で記述する
ベクトル演算を使っています。これらは何らかのベクトルの表現を使って
実装されているとします。データ抽象化のおかげで、このベクトル表現がどのようなもので
あるかは、ふるまいさえ正しければ問題になりません。}

\begin{scheme}
(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect (scale-vect (xcor-vect v)
                           (edge1-frame frame))
               (scale-vect (ycor-vect v)
                           (edge2-frame frame))))))
\end{scheme}

\noindent
\code{frame\-/coord\-/map}をある枠に適用すると、ベクトルが与えられるとベクトルを
返す手続きを返します。引数ベクトルが単位正方形内にあれば、返り値のベクトルは
枠内のものになります。例えば、次の式は

\begin{scheme}
((frame-coord-map a-frame) (make-vect 0 0))
\end{scheme}

\noindent
以下と同じベクトルを返します。

\begin{scheme}
(origin-frame a-frame)
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.46}Exercise 2.46:} 
原点からある一点に張られる二次元ベクトルは、\( x \)座標と\( y \)座標からなる
ペアとして表現できる。コンストラクタ\code{make\-/vect}と、それに対応する
セレクタ\code{xcor\-/vect}, \code{ycor\-/vect}を与え、ベクトルに対する
データ抽象化を実装せよ。それらのセレクタとコンストラクタによって、ベクトルの
足し算、引き算、スカラによるかけ算という演算を行う手続き
\code{add\-/vect}, \code{sub\-/vect}, \code{scale\-/vect}を実装せよ。
\begin{comment}

\begin{example}
(x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)
(x_1, y_1) - (x_2, y_2) = (x_1 - x_2, y_1 - y_2)
             s * (x, y) = (sx, sy)
\end{example}

\end{comment}
\begin{displaymath}
%  
% \eqalign{
% 	(x_1, y_1) + (x_2, y_2) 	&= (x_1 + x_2, y_1 + y_2), \cr
% 	(x_1, y_1) - (x_2, y_2) 	&= (x_1 - x_2, y_1 - y_2), \cr
% 	s \cdot (x, y) 			&= (sx, sy). \cr }
% 
\begin{array}{r@{{}={}}l}
	(x_1, y_1) + (x_2, y_2) 	& (x_1 + x_2, y_1 + y_2), \\
	(x_1, y_1) - (x_2, y_2) 	& (x_1 - x_2, y_1 - y_2), \\
	s \cdot (x, y) 			& (sx, sy). 
\end{array}
\end{displaymath}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.47}Exercise 2.47:} 
次に、枠のコンストラクタとして使えるものを二つ挙げる。

\begin{scheme}
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
\end{scheme}

それぞれのコンストラクタに対し、適切なセレクタを加えて枠の実装を
完成させよ。
\end{quote}

\subsubsection*{ペインタ}

ペインタは、枠を引数として取り、ある特定の画像をずらしたり拡大縮小したりして
枠にフィットするように描画する手続きとして表現できます。つまり、\code{p}がペインタで
\code{f}がフレームであれば、\code{f}を引数として\code{p}を呼び出すことで、
\code{f}の中に\code{p}の画像を生成します。

基本ペインタがどのように実装されるかという具体的なところは、グラフィックシステムの
特性と描画する画像のタイプに依存します。例えば、二つの指定された点の間に
スクリーン上の線を引く\code{draw\-/line}という手続きを持っているとします。
すると、\link{Figure 2.10}の\code{wave}ペインタのような線画のペインタは、
次のような線分のリストから作ることができます。
\footnote{
\code{segments\-/>painter}は、後で\link{Exercise 2.48}で記述する線分の表現を
使っています。また、\link{Exercise 2.23}で記述した\code{for\-/each}手続きも
利用しています。}

\begin{scheme}
(define (segments->painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame) 
         (start-segment segment))
        ((frame-coord-map frame)
         (end-segment segment))))
     segment-list)))
\end{scheme}

\noindent
線分は、単位正方形に対する座標を使って与えられます。リスト中のそれぞれの線分に対し、
ペインタは線分の両端点を枠座標マップを使って変換し、変換した点の間に線を引きます。

ペインタを手続きとして表現することは、図形言語の中に強力な抽象化の壁を作ります。
さまざまなグラフィック機能に基づくいろいろな基本ペインタを作り、また組み合わせる
ことができます。枠を引数として取り、その枠に合わせて何かを描くものであれば、
どんな手続きでもペインタとして使うことができます。

\footnote{
例えば、\link{Figure 2.11}の\code{rogers}ペインタはグレースケール画像によって
構築されています。枠内の各点に対し、\code{rogers}ペインタは枠座標マップによって
そこにマップされる画像内の点を決定し、それに従って点の濃淡をつけます。
\link{Section 2.1.3}では、有理数の実装はある適切な条件を満たすものであれば
何でもいいということを述べましたが、ここでさまざまな種類のペインタを使える
ようにしているのは、そこで述べた抽象データという考え方を利用したものです。
ここでは、指定された枠の中に何かを描画するものであれば、ペインタはどのような
実装でもいいということを利用しています。\link{Section 2.1.3}では
ペアを手続きとして実装する方法を示しましたが、ペインタはデータを手続きによって
表現する二つ目の例となっています。}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.48}Exercise 2.48:} 
平面上の方向つきの線分は、ベクトルのペア---原点から線分の始点へと張られるベクトルと、
原点から線分の終点へと張られるベクトル---として表現できる。\link{Exercise 2.46}で
書いたベクトル表現を使って、\code{make\-/segment}というコンストラクタと
\code{start\-/segment}と\code{end\-/segment}というセレクタによって線分の
表現を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.49}Exercise 2.49:} 
\code{segments\-/>painter}を使って、以下の基本ペインタを定義せよ。

\begin{enumerate}[a]

\item
指定された枠の輪郭を描くペインタ。

\item
枠の対角線同士をつないで``X''を描くペインタ。

\item
枠の辺の中点をつないで菱形を描くペインタ。

\item
\code{wave}ペインタ。

\end{enumerate}
\end{quote}

\subsubsection*{ペインタの変形と組み合わせ}

ペインタに対する演算(\code{flip\-/vert}や\code{beside}のようなもの)は、引数として
取った枠から導出した枠に対して元のペインタを呼び出すようなペインタを作るという
仕組みで動いています。ですので、例えば\code{flip\-/vert}が画像をひっくり返す際に、
ペインタがどのように動作しているかを知る必要はありません---枠をひっくり返す方法さえ
わかっていれば大丈夫です。ひっくり返したペインタは元のペインタをそのまま使いますが、
それをひっくり返した枠に対して使うというだけです。

ペインタ操作は、\code{transform\-/painter}という手続きに基づいています。
この手続きは引数として、ペインタと、枠をどのように変形するかという情報を取り、
新しいペインタを作ります。変形したペインタは、ある枠に対して呼ばれたとき、
その枠を変形して、変形した枠に対して元のペインタを呼び出します。
\code{transform\-/painter}の引数は(ベクトルとして表現した)複数の点で、
新しい枠の頂点を指定するものです。これらが枠に対してマップされるとき、
一つ目の点は新しい枠の原点を指定し、残り二つの点は枠の辺ベクトルの終点を
指定します。つまり、単位正方形内の引数は、元の枠内に含まれる枠を指定することに
なります。

\begin{scheme}
(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter (make-frame 
                  new-origin
                  (sub-vect (m corner1) new-origin)
                  (sub-vect (m corner2) new-origin)))))))
\end{scheme}

\noindent
ペインタの画像を上下逆にするには次のようにします。

\begin{scheme}
(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)   ~\textrm{; new \code{origin}}~
                     (make-vect 1.0 1.0)   ~\textrm{; new end of \code{edge1}}~
                     (make-vect 0.0 0.0))) ~\textrm{; new end of \code{edge2}}~
\end{scheme}

\noindent
\code{transform\-/painter}を用いることで簡単に新しい変換を定義することができます。
右上4分の1のフレームは次のようにして与えられます。

\begin{scheme}
(define (shrink-to-upper-right painter)
  (transform-painter
   painter (make-vect 0.5 0.5)
   (make-vect 1.0 0.5) (make-vect 0.5 1.0)))
\end{scheme}

\noindent
画像を反時計回りに90度回転させるという変形もあります。
\footnote{\code{rotate90}は回転した枠にフィットするように画像を伸縮させるという
ことも行うため、純粋な回転になるのは枠が正方形のときだけです。}

\begin{scheme}
(define (rotate90 painter)
  (transform-painter painter 
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
\end{scheme}

\noindent
また、画像を枠の中心方向につぶすという変形もあります。
\footnote{\link{Figure 2.10}と\link{Figure 2.11}に出てきた菱形の画像は、
\code{squash\-/inwards}を\code{wave}と\code{rogers}に適用して作ったものです。}

\begin{scheme}
(define (squash-inwards painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 0.65 0.35)
                     (make-vect 0.35 0.65)))
\end{scheme}

\noindent
枠の変換は、二つ以上のペインタを組み合わせる手段を定義するためにキーとなるもの
でもあります。例えば、\code{beside}手続きは二つのペインタを引数に取り、
それらを引数の枠の左半分と右半分を描画するように変形し、新しい複合ペインタを
作ります。ある枠を引数として複合ペインタを呼び出すと、一つ目の変形ペインタを
呼んで枠の左半分を描画し、二つ目の変形ペインタを呼んで枠の右半分を描画します。

\begin{scheme}
(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter 
            painter1
            (make-vect 0.0 0.0)
            split-point
            (make-vect 0.0 1.0)))
          (paint-right
           (transform-painter
            painter2
            split-point
            (make-vect 1.0 0.0)
            (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
\end{scheme}

\noindent
ペインタのデータ抽象化と、特にペインタを手続きとして実装したことによって、
\code{beside}が実装しやすくなっているということがわかるでしょうか。
部品となるペインタについて\code{beside}が知っておくべきことは、それぞれの
ペインタが指定した枠に何かを描画するということだけで、そのほかには何も
知る必要がありません。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.50}Exercise 2.50:} 
ペインタを左右逆にする変換\code{flip\-/horiz}、ペインタを反時計回りに
180度、270度回転させる変換を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.51}Exercise 2.51:} 
ペインタに対する\code{below}演算を定義せよ。\code{below}は二つのペインタを引数に取る。
返り値となるペインタは、枠が与えられたとき、一つ目のペインタで枠の下部を描画し、
二つ目のペインタで上部を描画する。二つのやり方で\code{below}を定義せよ。
一つ目は、上に示した\code{beside}手続きと似たような手続きを書くというもので、
二つ目は、\code{beside}と適切な回転演算(\link{Exercise 2.50}のもの)によって
定義するというものである。
\end{quote}

\subsubsection*{頑健な設計のための言語レベル}

図形言語は、手続きとデータによる抽象化についてこれまで紹介してきた重要な考え方の
練習となっています。基本的なデータ抽象化であるペインタは手続きによる表現を使って
実装され、異なる基礎的な描画機能を言語が統一したやり方で扱うことができるように
しています。結合手段は閉包性を満たしているため、複雑な設計も簡単に組み立てることが
できます。最後に、手続きを抽象化するためのツールはすべて、ペインタの結合手段を
抽象化するのに利用できます。

また、言語とプログラム設計についての、もうひとつの決定的な考え方を垣間見ることが
できました。それは\newterm{stratified design}(\jnewterm{階層化設計})というアプローチで、
複雑なシステムは一連の言語によって記述される一連のレベルとして構造化されるべきだという
概念です。それぞれのレベルは、そのレベルで基本とされる部品を組み合わせて構築され、
それぞれのレベルで構築された部品は次のレベルで基本部品として使われます。階層化設計の
それぞれのレベルで使われる言語は、その詳細さのレベルに合った基本要素、結合手段、
抽象化の手段を備えています。

階層化設計は、複雑なシステムのエンジニアリングのあらゆるところに出てきます。
例えば計算機工学では、抵抗やトランジスタを組み合わせて(またアナログ回路の言語を
使って記述して)ANDゲートやORゲートのような部品を作り、それらはデジタル回路設計の
言語では基本要素となります。\footnote{\link{Section 3.3.4}でそのような言語のひとつを
記述します。} これらの部品を組み合わせてプロセッサ、バス構造、メモリシステムを構築し、
今度はコンピュータアーキテクチャに適した言語を使ってそれらを組み合わせて
コンピュータを作ります。コンピュータは、ネットワーク相互接続を記述するのに適した
言語を使って組み合わされて分散システムを構成します。こういった繰り返しです。

階層化のごく小さな例として、ここでの図形言語は、点や線を指定する言語を使って
作られた基本要素(基本ペインタ)によって\code{segments\-/>painter}の線分のリストや
\code{rogers}のようなペインタの濃淡の詳細を提供します。図形言語についての
説明の大半は、これらの基本要素を組み合わせることや、\code{beside}や\code{below}の
ような幾何学的な結合器について焦点を当てていました。さらに、\code{beside}や
\code{below}を言語の基本要素と見なすことで、さらに高いレベルでの作業も行いました。
その言語の\code{square\-/of\-/four}のような演算は、幾何学的な結合器を組み合わせる
際のよくあるパターンを捉えています。

階層化設計は、\newterm{robust}(\jnewterm{頑健})なプログラムを作りやすくします。
頑健というのは、仕様の小さな変更が、プログラム上でも相応に小さな変更ですむという
ことです。例えば、\link{Figure 2.9}に示した、\code{wave}をもとにした画像を変更
したいとします。このとき、最も下のレベルに手を加え、\code{wave}の細かい見た目を
変えることもできます。また、中間レベルで、\code{corner\-/split}が
\code{wave}を複製するやり方を変えることもできます。最も上のレベルで、
\code{square\-/limit}が四隅の画像を配置するやり方を変えることもできます。
一般的に、階層化設計のそれぞれのレベルは、システムの特性を表現するうえでの
異なる語彙を提供し、システムを変更するための異なる能力を提供します。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.52}Exercise 2.52:} 
上で述べた各レベルに手を加え、\link{Figure 2.9}に示した\code{wave}による
square-limitを変更せよ。具体的には、次のようなものである。

\begin{enumerate}[a]

\item
\link{Exercise 2.49}の\code{wave}基本ペインタに線分をいくつか加えよ
(例えば、笑顔を追加するなど)。

\item
\code{corner\-/split}によって構築されるパターンを変更せよ
(例えば、\code{up\-/split}や\code{right\-/split}の画像を二つではなく一つだけ使う
ようにする)

\item
\code{square\-/of\-/four}を使うほうの\code{square\-/limit}を修正し、
四隅を違うパターンで組み立てるようにせよ(例えば、正方形の四隅で大きなロジャーズ氏が
外を向くようにするなど)

\end{enumerate}
\end{quote}

\section{記号データ}
\label{Section 2.3}

ここまで使ってきた複合データオブジェクトはすべて、究極的には数値から構成されて
いました。この節では、任意の記号をデータとして扱う能力を導入し、私たちの言語の
表現能力を拡張します。

\subsection{クォート}
\label{Section 2.3.1}

記号を作って複合データを作れるとしたら、次のようなリストが使えることになります。

\begin{scheme}
(a b c d)
(23 45 17)
((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))
\end{scheme}

\noindent
記号を含むリストは、私たちの言語の次のような式と同じように見えるかもしれません。

\begin{scheme}
(* (+ 23 45) 
   (+ x 9))
(define (fact n) 
  (if (= n 1) 1 (* n (fact (- n 1)))))
\end{scheme}

\noindent
記号を操作するためには、私たちの言語に新しい要素を入れる必要があります。
それは、データオブジェクトを\newterm{quote}(\jnewterm{クォート})する能力です。
\code{(a b)}というリストを構築するという場合について考えてみましょう。
これは、\code{(list a b)}と書いてもうまくいきません。この式は、\code{a}や\code{b}と
いった記号そのものではなく、その\jnewterm{値}を要素としたリストを作ってしまう
からです。この問題は、自然言語についてはよく知られています。自然言語では、単語や文が
意味的な実体となることもあり、文字の列(統語的な実体)となることもあります。
自然言語では、単語や文をそのまま文字の列として扱うということを示すのに、
引用符を使うのが一般的です。例えば、``John''の最初の文字というと、それは当然``J''
です。誰かに``あなたの名前を声に出して言ってください''と頼んだら、その人の名前を
言ってくれるでしょう。しかし、`` `あなたの名前'を声に出して言ってください''と
頼んだら、``あなたの名前''という単語列を言ってもらえるはずです。ほかの人の
発言を伝えるために、引用符をネストさせないといけなくなっていることに気をつけて
ください。
\footnote{言語でクォートを使えるようにすると、等しいものは等しいもので
置き換えられるという概念を破壊するため、言語を単純に推論する能力を台無しに
してしまいます。例えば、三は一足す二ですが、「三」という単語は「一足す二」という
句ではありません。クォートを使うと、ほかの式を操作する式を作れるようになるので、
そういう意味でクォートは強力です(これについては、\link{Chapter 4}でインタプリタを
書く際に見ることになります)。しかし、ある言語の中で、その言語で書かれた文について
表現する文というものを許すと、「等しいもの同士は交換できる」ということが
何を意味するのかについて、一貫性のある原則を維持することがとても難しくなります。
例えば、もし宵の明星は明けの明星であると知っていれば、「宵の明星は金星である」
という文から、「明けの明星は金星である」と推論できます。しかし、「ジョンは
宵の明星は金星であると知っている」ということからは、「ジョンは明けの明星は
金星であると知っている」を導くことはできません。}

リストや記号について、式として評価の対象にするのでなく、データオブジェクトとして
扱いたいというときにも、これと同じような慣例に従うことができます。しかし、
ここでのクォートの形式は、自然言語の場合と違って、クォートするオブジェクトの前に
引用符(伝統的にシングルクォートの記号 \code{'}を使います)をひとつだけ置く
というものです。Schemeの文法では、オブジェクトを区切るのに空白や括弧を使っているため、
クォートはひとつだけで問題ありません。このようなわけで、シングルクォートは
次のオブジェクトをクォートするという意味になっています。
\footnote{表示する文字列を囲むのにはダブルクォートを使ってきましたが、シングル
クォートはそれとは違うものです。シングルクォートはリストや記号を表すのに使われる
のに対して、ダブルクォートは文字列にしか使われません。この本では、文字列を使うのは
項目を表示する場合だけです。}

これで、記号とその値を区別することができるようになりました。

\begin{scheme}
(define a 1)
(define b 2)
(list a b)
~\textit{(1 2)}~
(list 'a 'b)
~\textit{(a b)}~
(list 'a b)
~\textit{(a 2)}~
\end{scheme}

\noindent
リストを表示するときに使う慣習的な表現を使って複合オブジェクトを入力することも、
クォートによってできるようになります。
\footnote{厳密に言うと、この引用符の使い方は、言語内のすべての複合式は括弧で
囲まれていてリストのように見えるという一般的なルールを破っています。ここで、
\code{quote}という特殊形式を導入することによって、この一貫性を取り戻すことができます。
\code{quote}の役割はクォートと同じです。つまり、\code{'a}の代わりに\code{(quote a)}と
入力したり、\code{'(a b c)}の代わりに\code{(quote (a b c))}と入力したりすることが
できます。これはインタプリタの動作方式そのままです。引用符は、次に来る完全な式を
\code{quote}を使って包んで、\( \hbox{\ttfamily(quote}\;\langle\kern0.06em
\hbox{\ttfamily\slshape expression}\kern0.08em\rangle\hbox{\ttfamily)} \)を
作るということを、一文字に省略したものにすぎません。これは重要なポイントです。
こうすることによって、インタプリタから見える式はすべてデータオブジェクトとして
操作できるという原則を維持できるからです。例えば、\code{(car '(a b c))}という
式は\code{(car (quote (a b c)))}と同じものなので、
\code{(list 'car (list 'quote '(a b c)))}を評価することによって構築できます。}

\begin{scheme}
(car '(a b c))
~\textit{a}~
(cdr '(a b c))
~\textit{(b c)}~
\end{scheme}

\noindent
この原則通りに、\code{'()}を評価すると空リストが得られます。これによって、
変数\code{nil}は必要なくなります。

記号の操作に使われるもうひとつの基本要素は\code{eq?}です。これは二つの記号を
引数として取り、それらが同じであるかどうかをテストするものです。
\footnote{
二つの記号が同じ順番の同じ文字で構成されているとき、それらは``同じ''であると
考えることができます。このような定義は、まだここでは取り組むことが難しい、
プログラミング言語における``同一性''の意味とは何かという深い問題を
避けて通っています。\link{Chapter 3} (\link{Section 3.1.3})では、この問題に
戻ってくることになります。}
\code{eq?}を使うと、\code{memq}という便利な手続きを実装できるようになります。
これは記号とリストという二つの引数を取り、記号がリストに含まれていなければ
(つまり、リストのどの項目とも\code{eq?}でなければ)、\code{memq}は偽を返します。
そうでなければ、そのリストの中で記号が最初に見つかったところから始まる
サブリストを返します。

\begin{scheme}
(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
\end{scheme}

\noindent
例えば、次の式の値は偽になります。

\begin{scheme}
(memq 'apple '(pear banana prune))
\end{scheme}

\noindent
一方、次の式の値は\code{(apple pear)}になります。

\begin{scheme}
(memq 'apple '(x (apple sauce) y apple pear))
\end{scheme}

\noindent

\begin{quote}
\heading{\phantomsection\label{Exercise 2.53}Exercise 2.53:} 
以下の式をそれぞれ評価したとき、それらに対してインタプリタは何を表示するか。

\begin{scheme}
(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.54}Exercise 2.54:} 
二つのリストは、同じ要素を同じ順番で持つときに\code{equal?}であると言える。
例えば、

\begin{scheme}
(equal? '(this is a list) '(this is a list))
\end{scheme}

\noindent
は真である。しかし、

\begin{scheme}
(equal? '(this is a list) '(this (is a) list))
\end{scheme}

\noindent
は偽である。より正確に言うと、記号が等しいかどうかという基本的な\code{eq?}を使って、
再帰的に\code{equal?}を定義することができる。\code{a}と\code{b}は、どちらも記号で
あってそれらが\code{eq?}であるか、どちらもリストであって、\code{(car a)}と\code{(car b)}が
\code{equal?}であり、かつ\code{(cdr a)}と\code{(cdr b)}が\code{equal?}である場合、
\code{equal?}である。この考え方を使って、\code{equal?}を手続きとして実装せよ。
\footnote{実際は、プログラマは記号だけでなく数値を含むリストに対しても使います。
数値は記号とは見なされません。数として等しい二つの数値(\code{=}でテストできます)が
\code{eq?}でもあるかという問題は、高度に実装依存です。\code{equal?}の定義としては、
(Schemeで基本要素となっているもののように)\code{a}と\code{b}が両方とも数値である場合、
\code{a}が\code{b}が数として等しければそれらは\code{equal?}であるということも
規定しておくほうがよいでしょう。}
 
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.55}Exercise 2.55:} 
Eva Lu Atorはインタプリタに次の式を入力した。

\begin{scheme}
(car ''abracadabra)
\end{scheme}

予想外なことに、インタプリタは\code{quote}という表示を返してきた。このことを説明せよ。
\end{quote}


\subsection{例: 記号微分}
\label{Section 2.3.2}

記号操作の例として、またデータ抽象化の別の例として、代数式の記号微分を行う
手続きの設計について考えてみましょう。手続きは、引数として代数式と変数を取り、
その変数に関するその式の導関数を返すようにします。例えば、手続きに対する引数が
\( ax^2 + bx + c \)と\( x \)であれば、手続きは\( 2ax + b \)を返すというものです。
記号微分は、Lispにとっては特別な歴史的意義があります。記号微分は、記号を操作する
コンピュータ言語を開発するうえでの動機となる実例のひとつでした。さらに、記号微分の
研究は、現在応用数学者や物理学者に使われるようになってきている強力な記号数式処理
システムの開発につながる一連の研究のスタート地点となるものです。

記号微分プログラムを開発するにあたっては、\link{Section 2.1.1}の有理数システムを開発した
ときと同じデータ抽象化戦略に従います。つまり、まず``和''、``積''、``変数''といった
抽象オブジェクトの上で動く微分アルゴリズムを定義することにして、それらの抽象オブジェクトが
どのように表現されるべきかということは考えないことにします。表現の問題については
後ほど取り組みます。

\subsubsection*{抽象データによる微分プログラム}

問題を簡単にするために、二引数の足し算・かけ算という演算だけから構成される式だけを
扱う、とても単純な記号微分プログラムについて考えることにします。任意のそのような式の
微分は、以下の簡約ルールを適用することによって行うことができます。
\begin{comment}

\begin{example}
dc
-- = 0  for c a constant, or a variable different from x
dx

dx
-- = 1
dx

d(u + v)   du   dv
-------- = -- + --
   dx      dx   dx

d(uv)     / dv \     / du \
----- = u | -- | + v | -- |
 dx       \ dx /     \ dx /
\end{example}

\end{comment}
\begin{displaymath}
{{\it dc} \over {\it dx}} 		= 0, 
	\quad c\ \mbox{が定数または} x\ \mbox{と異なる変数のとき}, 
\end{displaymath}
\begin{displaymath}
{{\it dx} \over {\it dx}} 		= 1, 
\end{displaymath}
\begin{displaymath}
{{\it d\,(u + v\,)} \over {\it dx}} 	= {{\it du} \over {\it dx}} + {{\it dv} \over {\it dx}}, 
\end{displaymath}
\begin{displaymath}
{{\it d\,(uv\,)} \over {\it dx}} 	= u {{\it dv} \over {\it dx}} + v {{\it du} \over {\it dx}}. 
\end{displaymath}

\noindent
後ろの二つのルールは本質的に再帰的であるということがわかるでしょうか。
というのは、和の導関数を求めるには、まずそれぞれの項の導関数を求め、それらを足す
ことになるからです。それぞれの項は、さらに分解が必要な式であるかもしれません。
項をどんどん小さなものに分解していくと、最終的には定数か変数のものになり、
その導関数は0または1になります。

これらのルールを手続きという形にするために、有理数の実装を設計したときと同じように、
ちょっとした希望的思考をすることにします。もし代数式の表現手段があるとするなら、
ある式が和なのか、積なのか、定数なのか、変数なのか判別できるはずです。また、
式から構成要素を抽出することもできるでしょう。和については、例えば加数(第一項)と
被加数(第二項)を抽出できるようになっていてほしいところです。それに、構成要素から
式を構築することもできるはずです。ここでは、次のようなセレクタ、コンストラクタ、
述語を実装する手続きがもうできているとします。

\begin{scheme}
(variable? e)            ~\textrm{\code{e}は変数か?}~
(same-variable? v1 v2)   ~\textrm{\code{v1}と\code{v2}は同じ変数か?}~
(sum? e)                 ~\textrm{\code{e}は和か?}~
(addend e)               ~\textrm{和\code{e}の加数}~
(augend e)               ~\textrm{和\code{e}の被加数}~
(make-sum a1 a2)         ~\textrm{\code{a1}と\code{a2}の和を構築する}~
(product? e)             ~\textrm{\code{e}は積か?}~
(multiplier e)           ~\textrm{積\code{e}の乗数}~
(multiplicand e)         ~\textrm{積\code{e}の被乗数}~
(make-product m1 m2)     ~\textrm{\code{m1}と\code{m2}の積を構築する}~
\end{scheme}

\noindent
これらの手続きと、数値かどうかを判断する基本述語の\code{number?}を使って、
微分のルールを次の手続きのように表現することができます。

\begin{scheme}
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error "unknown expression type: DERIV" exp))))
\end{scheme}

\noindent
この\code{deriv}手続きには、完全な微分アルゴリズムが組み込まれています。
抽象データによって表現されているため、ちゃんとしたセレクタとコンストラクタの
セットを設計する限り、代数式をどう表現したとしても動くはずです。この問題については
次で見ていきます。

\subsubsection*{代数式を表現する}

リスト構造を使って代数式を表現するやり方はいろいろ考えられます。例えば、
通常の代数記法を反映した記号のリストを使って、\( ax + b \)を\code{(a * x + b)}
というリストとして表現するということも可能です。ですが、とりわけ素直なやり方は、
Lisp が複合式に使うのと同じ、括弧でくくった前置記法を使うというものです。
つまり、\( ax + b \)は\code{(+ (* a x) b)}と表現することになります。そうすると、
微分問題に対するデータ表現は次のようになります。

\begin{itemize}

\item
変数は記号である。基本述語\code{symbol?}で判別する。

\begin{scheme}
(define (variable? x) (symbol? x))
\end{scheme}

\item
二つの変数は、それらを表現する記号が\code{eq?}であれば等しい。

\begin{scheme}
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
\end{scheme}

\item
和と積は、リストとして構築する。

\begin{scheme}
(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-product m1 m2) (list '* m1 m2))
\end{scheme}

\item
和は、最初の要素が記号\code{+}であるリストである。

\begin{scheme}
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
\end{scheme}

\item
加数は、和のリストの二つ目の項である。

\begin{scheme}
(define (addend s) (cadr s))
\end{scheme}

\item
被加数は、和のリストの三つめの項である。

\begin{scheme}
(define (augend s) (caddr s))
\end{scheme}

\item
積は、最初の要素が記号\code{*}であるリストである。

\begin{scheme}
(define (product? x) (and (pair? x) (eq? (car x) '*)))
\end{scheme}

\item
乗数は、積のリストの二つ目の項である。

\begin{scheme}
(define (multiplier p) (cadr p))
\end{scheme}

\item
被乗数は、積のリストの三つめの項である。

\begin{scheme}
(define (multiplicand p) (caddr p))
\end{scheme}

\end{itemize}

\noindent
こうすると、\code{deriv}に具体的に書いたようなアルゴリズムによってこれらの要素を
組み合わせるだけで、ちゃんと動く記号微分プログラムができます。そのふるまいについて、
いくつかの例を見てみましょう。

\begin{scheme}
(deriv '(+ x 3) 'x)
~\textit{(+ 1 0)}~
(deriv '(* x y) 'x)
~\textit{(+ (* x 0) (* 1 y))}~
(deriv '(* (* x y) (+ x 3)) 'x)
~\textit{(+ (* (* x y) (+ 1 0))}~
   ~\textit{(* (+ (* x 0) (* 1 y))}~
      ~\textit{(+  x 3)))}~
\end{scheme}

\noindent
プログラムは正しい答えを返します。しかし、答えは簡約されていません。次の結果は、確かに
正しいものです。
\begin{comment}

\begin{example}
d(xy)
----- = x * 0 + 1 * y
 dx
\end{example}

\end{comment}
\begin{displaymath}
 {{\it d\,(xy)} \over {\it dx}} = x \cdot 0 + 1 \cdot y, 
\end{displaymath}
しかし、プログラムには\( x \cdot 0 = 0 \), \( 1 \cdot y = y \), \( 0 + y = y \)だという
ことをわかっていてほしいものです。二つ目の例の答えは、単純に\code{y}であるべきです。
三つ目の例でわかるように、式が複雑であるとこれは深刻な問題になってきます。

ここで問題になっていることは、有理数の実装の際に問題になったことととても似ています。
答えが最も単純な形に簡約されていないという問題です。有理数の簡約は、実装の中で
コンストラクタとセレクタだけを変更するだけでできました。ここでも、同じような戦略が
使えます。\code{deriv}にはまったく手を加えないことにします。その代わり、
\code{make\-/sum}に変更を加え、もし両方の加数が数値であれば、それらを足し合わせて
和を返すようにします。また、加数のひとつが0であれば、もうひとつの加数のみを返すように
します。

\begin{scheme}
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        (else (list '+ a1 a2))))
\end{scheme}

\noindent
ここでは、ある式が与えられた数値と等しいかどうかをチェックする\code{=number?}という
手続きを使っています。

\begin{scheme}
(define (=number? exp num) (and (number? exp) (= exp num)))
\end{scheme}

\noindent
同じように、\code{make\-/product}に変更を加えて、0には何をかけても0で、1に何かをかけると
その何か自身になるというルールを組み込みます。

\begin{scheme}
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
\end{scheme}

\noindent
今回のものが、先ほどの三つの例に対してどう動作するかを次に示します。

\begin{scheme}
(deriv '(+ x 3) 'x)
~\textit{1}~
(deriv '(* x y) 'x)
~\textit{y}~
(deriv '(* (* x y) (+ x 3)) 'x)
~\textit{(+ (* x y) (* y (+ x 3)))}~
\end{scheme}

\noindent
これでだいぶよくなりましたが、三つ目の例を見ると、式を誰もが``最も単純''だといえる
ような形にするプログラムができるまでには、まだだいぶ距離がありそうです。代数的簡約化の
問題は、何よりも、ある目的のためには最も単純である形式がほかの目的のためには
そうではないということがありうるため、複雑なものになっています。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.56}Exercise 2.56:} 
より多くの種類の式を扱えるようにこの基本的な微分プログラムを拡張するには
どうすればよいかを示せ。例えば、次の微分ルールを実装せよ。
\begin{comment}

\begin{example}
d(u^n)            du
------ = nu^(n-1) --  
  dx              dx
\end{example}

\end{comment}
\begin{displaymath}
 {{\it d\,(u^n)} \over {\it dx}} = nu^{n-1} {{\it du} \over {\it dx}} 
\end{displaymath}
実装にあたっては、\code{deriv}プログラムに新しい節を追加し、また
\code{exponentiation?}, \code{base}, \code{exponent}, \code{make\-/exponentiation}を
適切に定義せよ(冪乗の表現には\code{**}という記号を使ってもよい)。任意の数の0乗は
1であり、任意の数の1乗はそれ自身であるというルールを組み込め。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.57}Exercise 2.57:} 
微分プログラムを拡張し、(2以上の)任意の数の項の和と積を扱えるようにせよ。
すると上の最後の例は以下のように表現できる。

\begin{scheme}
(deriv '(* x y (+ x 3)) 'x)
\end{scheme}

\code{deriv}手続きにはまったく手を加えず、和と積の表現のみを変更することによって解け。
例えば、和の\code{addend}(加数)は最初の項で、\code{augend}(被加数)は残りの項の和と
いうようにする。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.58}Exercise 2.58:} 
微分プログラムを修正して、\code{+}と\code{*}が前置演算子ではなく中置演算子となるような、
通常の数学の記法に対して動作させたいとする。微分プログラムは抽象データによって定義されて
いるので、微分プログラムの動作基盤となる代数式の表現を定義する述語、セレクタ、コンストラクタを
変更するだけで、異なる表現を扱うように修正できる。

\begin{enumerate}[a.]

\item
\code{(x + (3 * (x + (y + 2))))}のような中置記法で表された代数式を微分するには
どのようにするかを示せ。問題を簡単にするため、\code{+}と\code{*}は常に二つの
引数を取り、式は完全に括弧でくくられていると仮定せよ。

\item
\code{(x + 3 * (x + y + 2))}のような標準的な代数記法を認めると、問題はずっと
難しくなる。この記法では、必要のない括弧は省略し、乗算は加算より先に行われると
仮定している。ここでの微分プログラムがそのような記法に対してもうまく動くように、
適切な述語、セレクタ、コンストラクタを設計することができるだろうか。

\end{enumerate}
\end{quote}

\subsection{例: 集合を表現する}
\label{Section 2.3.3}

ここまでの例では、有理数と代数式という、二種類の複合データオブジェクトの表現を
構築しました。この例のうちのひとつでは、式の単純化(簡約化)をコンストラクタで
行うかセレクタで行うかという選択肢がありましたが、そのほかの点では、これらの
構造のリストによる表現の選択肢は素直なものでした。しかし、集合の表現ということに
なると、表現をどう決めるかということはあまり明らかではありません。実際に、
可能な表現は数多くあり、それぞれいくつかの点でお互いに大きく異なっています。

ざっくりした言い方をすると、集合とはただの異なるオブジェクトの集まりです。より
正確な定義をするには、データ抽象化の手法を使うことができます。つまり、
集合に使われる演算を規定することによって``集合''を定義するということです。
それらの演算は、\code{union\-/set}, \code{intersection\-/set}, \code{element\-/of\-/set?},
\code{adjoin\-/set}です。
\code{element\-/of\-/set?}は、与えられた要素が集合の構成要素であるかどうかを判定する
述語です。\code{adjoin\-/set}は、オブジェクトと集合を引数に取り、元の集合の要素に加えて
追加された要素を含む集合を返します。\code{union\-/set}は、二つの集合の和集合、
つまりどちらかの引数に含まれる要素をすべて含む集合を計算します。\code{intersection\-/set}は、
二つの集合の共通部分、つまり引数のどちらにも含まれる要素のみを含む集合を計算します。
データ抽象という視点から見ると、上の解釈と整合性があるものでさえあれば、これらの演算を
実装するのにどのような表現でも自由に設計できます。
\footnote{
さらに形式的に書くなら、``上の解釈と整合性がある''というところを、演算が次のような
一連の規則を満たすというように規定することができます。

\noindent
任意の集合\code{S}と任意のオブジェクト\code{x}に対し、
\code{(element\-/of\-/set? x (adjoin\-/set x S))}は真である(ざっくり言うと、
``集合にオブジェクトを追加すると、そのオブジェクトを含む集合ができる'')。

\noindent
任意の集合\code{S}, \code{T}と任意のオブジェクト\code{x}に対し、
\code{(element\-/of\-/set? x (union\-/set S T))}は
\code{(or (element\-/of\-/set? x S) (element\-/of\-/set? x T))}に等しい。
(ざっくり言うと、``\code{(union S T)}の要素は、\code{S}に含まれる要素か、
\code{T}に含まれる要素である'')。

\noindent
任意のオブジェクト\code{x}に対し、\code{(element\-/of\-/set? x '())}は偽である
(ざっくり言うと、``空集合の要素となるオブジェクトは存在しない'')。
}

\subsubsection*{順序なしリストとしての集合}

リストを表現するやり方のひとつは、要素が二回以上現れることがないリストという
ものです。空集合は空リストとして表現します。この表現では、\code{element\-/of\-/set?}は
\link{Section 2.3.1}の\code{memq}手続きと似たものになります。ここでは\code{eq?}ではなく
\code{equal?}を使っているため、集合の要素は記号である必要はありません。

\begin{scheme}
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
\end{scheme}

\noindent
これを使って、\code{adjoin\-/set}を書くことができます。追加するオブジェクトがすでに
集合の中にあるなら、単にその集合を返します。そうでなければ、\code{cons}を使って
そのオブジェクトを集合を表すリストに追加します。

\begin{scheme}
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
\end{scheme}

\noindent
\code{intersection\-/set}には、再帰的な戦略が使えます。もし、\code{set2}と、
\code{set1}の\code{cdr}との共通部分を作ることができるなら、\code{set1}の
\code{car}をそれに含めるかどうかを決めるだけで十分です。しかし、これは
\code{(car set1)}が\code{set2}にも含まれているかどうかによって決まります。
結果として、手続きは次のようになります。

\begin{scheme}
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
\end{scheme}

\noindent
表現を設計する際に考慮するべき問題のひとつは効率です。この集合演算に必要となる
ステップ数を考えてみましょう。どの演算も\code{element\-/of\-/set?}を使っているので、
この演算の速度は集合の実装全体の効率に大きな影響を与えます。ここで、あるオブジェクトが
集合の要素かどうかチェックするために、\code{element\-/of\-/set?}は集合全体を
スキャンする必要があるかもしれません(最悪の場合、オブジェクトは集合の中になかったという
結果になります)。そのため、集合が\( n \)個の要素を持っているとすると、
\code{element\-/of\-/set?}には最大\( n \)ステップかかるかもしれません。つまり、
必要なステップ数は\( \Theta(n) \)で増加するということです。\code{adjoin\-/set}は
この演算を使うので、やはり\( \Theta(n) \)で増加します。\code{intersection\-/set}は、
\code{set1}の要素それぞれに対して\code{element\-/of\-/set?}のチェックをするため、
必要なステップ数は関係する集合の大きさの積に比例して増加、つまり大きさ\( n \)の二つの集合
に対して\( \Theta(n^2) \)で増加するということになります。\code{union\-/set}についても
同じことが言えます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.59}Exercise 2.59:} 
順序なしリストとして表現した集合に対する\code{union\-/set}演算を実装せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.60}Exercise 2.60:}
上の例では、集合は重複のないリストとして表現するよう規定した。ここで、重複を許す
場合について考えてみよう。その場合、例えば\( \{1, 2, 3\} \)という集合は
\code{(2 3 2 1 3 2 2)}というリストとして表現することもできる。この表現に対して
演算を行う手続き\code{element\-/of\-/set?}, \code{adjoin\-/set}, \code{union\-/set},
\code{intersection\-/set}を設計せよ。それぞれの効率は、重複なし表現に対する手続きで
それに対応するものと比べてどうだろうか。重複なしの表現よりもこの表現のほうが
向いているような応用はあるだろうか。
\end{quote}

\subsubsection*{順序つきリストとしての集合}

この集合演算の速くする方法のひとつとして、集合の要素が昇順に並ぶように
表現を変えるというものがあります。これをするためには、二つのオブジェクトを
比較してどちらが大きいか判断するための何らかの方法が必要です。例えば、
記号を辞書順に比較したり、オブジェクトに一意の数値を割り振ることに決めて
対応する数値によって要素を比較したりといったことが考えられます。ここでは
話を簡単にするため、集合の要素が数値である場合についてのみ考えることにします。
この場合、要素は\code{>}と\code{<}によって比較できます。数値の集合を表現するのには、
要素を昇順に並べたものを使います。上に挙げた最初の表現では、\( \{1, 3, 6, 10\} \)
という集合を表すのに要素をどのように並べてもかまいませんでしたが、
新しい表現では\code{(1 3 6 10)}というリストしか許可しません。

順序に従って並べることのひとつの利点は\code{element\-/of\-/set?}で出てきます。
項目があるかどうかを調べるのに、もう集合全体をスキャンする必要はありません。
探している項目よりも大きい要素に出会ったら、その項目が集合内にないということが
わかります。

\begin{scheme}
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) false)
        (else (element-of-set? x (cdr set)))))
\end{scheme}

\noindent
これはどれだけのステップ数の節約になるでしょうか。最悪の場合、探している項目は
集合内の一番大きなものかもしれず、その場合ステップ数は順序なし表現の場合と
同じです。しかし、いろいろな大きさの項目を検索するときのことを考えると、
場合によってはリストの始点のあたりで検索を終了することができたり、
場合によってはやっぱりリストのほとんどを調べないといけなかったり、となることが
期待できます。平均的には、集合の約半分の項目を検査しなければいけないということに
なるでしょう。このため、必要な平均ステップ数はだいたい\( n / 2 \)になります。
これは依然として\( \Theta(n) \)という増加オーダーですが、それでもやはり、平均的には、
前の実装に比べてステップ数を半分に節約できます。

\code{intersection\-/set}では、さらに目覚ましい高速化が達成できます。順序なし表現では、
この演算には\( \Theta(n^2) \)というステップ数が必要でした。それは、\code{set1}の
要素それぞれに対して\code{set2}の完全なスキャンを行っていたからでした。しかし、
順序つきの表現では、より賢い方法が使えます。まず、二つの集合の最初の要素
\code{x1}と\code{x2}を比較します。もし\code{x1}と\code{x2}が等しければ、それは
共通部分の要素になり、共通部分の残りは二つの集合の\code{cdr}の共通部分という
ことになります。では、\code{x1}が\code{x2}より小さい場合はどうなるか考えてみましょう。
\code{x2}は\code{set2}の最小要素なので、\code{x1}は\code{set2}のどこにも現れないと
結論づけることができます。つまり、共通部分にも含まれないということになります。
このため共通部分は、\code{set2}と、\code{set1}の\code{cdr}との共通部分に等しくなります。
同じように、もし\code{x2}が\code{x1}よりも小さければ、求める共通部分は、\code{set1}と、
\code{set2}の\code{cdr}との共通部分となります。手続きは次のようになります。

\begin{scheme}
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1 (intersection-set (cdr set1)
                                          (cdr set2))))
              ((< x1 x2)
               (intersection-set (cdr set1) set2))
              ((< x2 x1)
               (intersection-set set1 (cdr set2)))))))
\end{scheme}

\noindent
このプロセスで必要となるステップ数を見積もるには、各ステップで、共通部分問題を
より小さな集合の共通部分集合の計算に縮小していることに注意してください。
縮小は、\code{set1}と\code{set2}のどちらかまたは両方から最初の要素を削除することに
よって行われます。このため、必要なステップ数は、最大でも\code{set1}と\code{set2}の
大きさの合計で、順序なし表現のように大きさの積になることはありません。これは、
\( \Theta(n^2) \)というオーダーに対して\( \Theta(n) \)というオーダーになるという
ことで、そこそこの大きさの集合に対してもかなりの高速化になります。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.61}Exercise 2.61:} 
順序つき表現を使った\code{adjoin\-/set}を実装せよ。\code{element\-/of\-/set?}から
類推して、順序つきであることの利点を生かして、順序なしの表現に比べて平均的に半分の
ステップを必要とする手続きを作るやり方を示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.62}Exercise 2.62:} 
順序つきリストとして表現された集合に対して、\code{union\-/set}を\( \Theta(n) \)で
実装せよ。
\end{quote}

\subsubsection*{二分木としての集合}
集合の要素を木という形式で配置することで、順序つきリスト表現をさらに改善することが
できます。木の各ノードは集合の要素をひとつ持ち、それはノードの``エントリ''と呼ばれます。
また、ほかの二つのノード(ノードは空であることもあります)へのリンクも持っています。
``左''のリンクは、そのノードより小さな要素を指していて、``右''のリンクは
そのノードより大きな要素を指しています。\link{Figure 2.16}に、
集合\( \{1, 3, 5, 7, 9, 11\} \)を表現するいくつかの木を示します。ある同じ集合を
木という形で表現するのには、数多くの方法がありえます。ここで、有効な木の表現の
条件として求めるものは、あるノードの左部分木のすべての要素がそのノードの要素よりも
小さく、右部分木のすべての要素がそれよりも大きいということだけです。

\begin{figure}[tb]
\phantomsection\label{Figure 2.16}
\centering
\begin{comment}
\heading{Figure 2.16:} Various binary trees that represent the set \( \{1, 3, 5, 7, 9, 11\} \).

\begin{example}
   7          3             5
   /\         /\            /\
  3  9       1  7          3  9
 /\   \         /\        /   /\
1  5  11       5  9      1   7  11
                   \
                   11
\end{example}
\end{comment}
\includegraphics[width=70mm]{fig/chap2/Fig2.16b.pdf}
\begin{quote}
\heading{Figure 2.16:} 集合\( \{1, 3, 5, 7, 9, 11\} \)を表現するさまざまな二分木
\end{quote}
\end{figure}
木による表現の利点は次の通りです。ある数値\( x \)がある集合に含まれているかどうかを
チェックしたいとします。まず、\( x \)とトップノードのエントリを比較します。
もし\( x \)がそれより小さければ、左部分木だけを探索すればいいということがわかります。
もし\( x \)がそれより大きければ、右部分木だけを探索すればいいということです。
ここで、もし木が``バランスが取れた''状態であれば、各部分木の大きさは元の木の約半分です。
そのため、一回のステップで、大きさ\( n \)の木を探索するという問題を、大きさ\( n / 2 \)の
木を探索するという問題に縮小したことになります。木の大きさは各ステップで半分になるので、
大きさ\( n \)の木の探索に必要なステップ数は\( \Theta(\log n) \)で増加すると予測できます。
\footnote{各ステップで問題の大きさが半分になるということは、対数増加の特徴的な性質です。
このことについては、\link{Section 1.2.4}の高速冪乗アルゴリズムや、\link{Section 1.3.3}の
区間二分探索法見てきました。}
大きな集合に対しては、これは以前の表現に比べてかなりの高速化になるでしょう。

木はリストを使って表現できます。各ノードは、ノードのエントリ、左部分木、右部分木という
三つの項目のリストになります。左または右の部分木が空リストである場合は、そこにつながる
部分木がないということを示します。この表現は、次のような手続きで表すことができます。
\footnote{
ここでは、集合は木によって表現し、木はリストによって表現しています。つまり、データ抽象化
の上にデータ抽象化が構築されているということです。手続き\code{entry}, \code{left\-/branch},
\code{right\-/branch}, \code{make\-/tree}は、リストによる表現といった特定のやり方から
``二分木''という抽象化を分離する方法と見なすことができます。}

\begin{scheme}
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
\end{scheme}

\noindent
これで、上で述べたような戦略を使って\code{element\-/of\-/set?}を書くことができるように
なります。

\begin{scheme}
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        ((> x (entry set))
         (element-of-set? x (right-branch set)))))
\end{scheme}

\noindent
集合に項目を追加するというのも同じように実装でき、必要ステップ数はやはり
\( \Theta(\log n) \)になります。項目\code{x}を追加するには、\code{x}をノードの
エントリと比較し、右と左のどちらの枝に追加するべきかを決めます。そして、\code{x}を
適切な枝に追加したら、この新しく作った枝を元のエントリやほかの枝とくっつけ合わせます。
もし\code{x}がエントリに等しければ、ノードをそのまま返します。もし空の木に\code{x}を
追加するよう求められたら、エントリが\code{x}で、右と左の枝が空である木を生成します。


項目\code{x}を付加するためには、\code{x}をノードのエントリと比較し\code{x}が右か
左のどちらの枝に追加されるべきを判断し、\code{x}を適切な枝に追加し、この新しく構築された枝を元の
エントリともう一方の枝と共に接続します。もし\code{x}を空の木に付加するよう求められたら
エントリに\code{x}を持ち、右と左の枝は空である木を生成します。この手続きを以下に示します。

\begin{scheme}
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree (entry set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((> x (entry set))
         (make-tree (entry set) (left-branch set)
                    (adjoin-set x (right-branch set))))))
\end{scheme}

\noindent
木の探索が対数的ステップで実行できるという上の主張は、木が``バランスが取れている''
\yakuchu{「バランスの取れた木」に対しては``平衡木''、``バランス木''などの訳語が
ありますが、ここでは\newterm{balanced}(\jnewterm{バランスの取れた})との兼ね合いから
「バランスの取れた木」としています。}
という前提に依存しています。つまり、すべての木の左右の部分木はだいたい同じ数の要素を
持っていて、各部分木は親の約半分の要素を持っているということです。しかし、ここで構築
する木がバランスが取れていると当てにできるでしょうか。バランスの取れた木から始めたと
しても、\code{adjoin\-/set}で要素を追加すると、バランスの取れていない結果になって
しまうかもしれません。新たに追加する要素の位置は、その要素と集合にすでに存在する項目の
大小を比べた結果によるので、要素を``ランダムに''追加すれば、平均的には木はバランスの
取れたものになりやすくなります。しかし、このことは保証されていません。例えば、もし
空集合から始めて、1から7の数値を順番に追加していくと、\link{Figure 2.17}に示すような
とてもバランスの悪い木ができあがってしまいます。この木では、すべての左部分木は空なので、
単純な順序つきリストに対する優位点がありません。この問題を解決する方法のひとつとして、
任意の木を同じ要素を持つバランスの取れた木に変換する演算を定義するというものがあります。
こうすると、何回か\code{adjoin\-/set}演算を行うたびにこの変換を実行して、集合をバランスの
取れた状態にしておくことができます。この問題を解く方法はほかにもありますが、だいたいは
検索や挿入がどちらも\( \Theta(\log n) \)ステップで行えるような新しいデータ構造を設計する
ということをしています。
\footnote{このようなデータ構造の例としては、\newterm{B-trees}(\jnewterm{B木})や
\newterm{red-black trees}(\jnewterm{赤黒木})などがあります。この問題については
多くの文献があります。 \link{Cormen et al. 1990}参照。}

\begin{figure}[tb]
\phantomsection\label{Figure 2.17}
\centering
\begin{comment}
\heading{Figure 2.17:} Unbalanced tree produced by adjoining 1 through 7 in sequence.

\begin{example}
1
 \
  2
   \
    4
     \
      5
       \
        6
         \
          7
\end{example}
\end{comment}
\includegraphics[width=40mm]{fig/chap2/Fig2.17a.pdf}
\begin{quote}
\heading{Figure 2.17:} 1から7まで順番に追加するとできるバランスの取れていない木
\end{quote}
\end{figure}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.63}Exercise 2.63:} 
次の二つの手続きは、どちらも二分木をリストに変換する。
以下の2つの手続きはそれぞれ二分木をリストに変換する。

\begin{scheme}
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 
                      (right-branch tree))))))
(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list 
                              (right-branch tree)
                              result-list)))))
  (copy-to-list tree '()))
\end{scheme}

\begin{enumerate}[a]

\item
二つの手続きは、すべての木に対して同じ結果を生成するだろうか。そうでないとしたら、
結果はどのように異なるだろうか。二つの手続きは、\link{Figure 2.16}の木に対して
どのようなリストを生成するだろうか。

\item
二つの手続きは、\( n \)要素のバランスの取れた木を変換する際に、同じステップ数の
増加オーダーを持っているだろうか。そうでないなら、どちらが遅いだろうか。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.64}Exercise 2.64:} 
次の手続き\code{list\-/>tree}は、順序つきリストをバランスの取れた木に変換する。
補助手続き\code{partial\-/tree}は、整数\( n \)と、少なくとも\( n \)個の要素を
持つリストを引数に取り、リストの最初の\( n \)個の要素を含むバランスの取れた木を
生成する。\code{partial\-/tree}の返り値はペア(\code{cons}で構築される)で、
\code{car}には構築された木を持ち、\code{cdr}には木に含まれなかった要素のリストを持つ。

\begin{scheme}
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result 
               (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result 
                   (partial-tree 
                    (cdr non-left-elts)
                    right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts 
                     (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
\end{scheme}

\begin{enumerate}[a]

\item
\code{partial\-/tree}がどのように動くのか、できるだけ明確に文章で答えよ。
リスト\code{(1 3 5 7 9 11)}に対して\code{list\-/>tree}が生成する木を描け。

\item
\code{list\-/>tree}が\( n \)要素のリストを変換するのに必要なステップ数の
増加オーダはどのようになるだろうか。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.65}Exercise 2.65:} 
\link{Exercise 2.63}と\link{Exercise 2.64}の結果を使って、集合を
(バランスの取れた)二分木として\( \Theta(n) \)で実装せよ。
\footnote{
\link{Exercise 2.63}から\link{Exercise 2.65}まではPaul Hilfingerによるものである。}
\end{quote}

\subsubsection*{集合と情報検索}

ここまで、集合をリストで表現するのにどのような方法があるかを検討し、データ
オブジェクトに対してどのような表現を選ぶかということが、そのデータを使う
プログラムのパフォーマンスに大きな影響を及ぼすということを見てきました。
集合に対して詳しく検討するもうひとつの理由は、ここで考察するテクニックは
情報検索に関わる応用の中でよく出てくるものだということです。

個別のレコードを大量に含むデータベースについて考えてみましょう。例えば、企業の
人事ファイルや、会計システムの取引などです。データ管理システムは普通、そのレコードに
アクセスしたり更新したりするのに多くの時間を消費するので、レコードにアクセスする
効率的な手法が必要となります。これは、各レコードの中で、識別\newterm{key}
(\jnewterm{キー})として使える部分を特定することによって行うことができます。
キーは、レコードを一意に識別するものであれば何でもかまいません。人事ファイルで
あれば、従業員番号などがよいでしょう。会計システムであれば、取引番号に
なるかもしれません。キーが何であっても、レコードをデータ構造として定義する際には、
あるレコードに対して関連づけられたキーを取得する\code{key}セレクタ手続きを
持つ必要があります。

ここで、データベースをレコードの集合として表現することにします。あるキーに対する
レコードの場所を調べるには、\code{lookup}という手続きを使います。この手続きは、
キーとデータベースを引数に取り、そのキーを持つレコードを返すか、そのようなレコードが
なければ偽を返します。\code{lookup}は、\code{element\-/of\-/set?}とほぼ同じように
実装されます。例えば、レコードの集合が順序なしリストとして表現されていれば、
次のようにすることができます。

\begin{scheme}
(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) false)
        ((equal? given-key (key (car set-of-records)))
         (car set-of-records))
        (else (lookup given-key (cdr set-of-records)))))
\end{scheme}

\noindent
もちろん、巨大な集合を表現するのには、順序なしリストよりもいい方法があります。
レコードを``ランダムアクセス''する必要がある情報検索システムでは、普通は
木構造による手法によって表現されます。例えば、前に検討した二分木のようなものです。
そのようなシステムを設計するにあたっては、データ抽象化の方法論はとても役に立ちます。
設計する人は、順序なしリストのような単純で素直な表現を使って、最初の実装を作る
ことができます。これは最終的なシステムのためには不適切なものでしょうが、
システムの残りの部分をテストするための``quick and dirty''(手早く汚い)データベースを
提供してくれるという意味では役に立ちます。データ表現を修正してより洗練されたものに
することは後になってからでもできます。もしデータベースが抽象セレクタとコンストラクタ
によってアクセスされるようになっていれば、そうやって表現を変更しても、システムの
残りの部分には修正の必要がないはずです。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.66}Exercise 2.66:}

レコードの集合が、キーの数値の大小によって順序づけられた二分木という構造に
なっている場合について、\code{lookup}手続きを実装せよ。
\end{quote}

\subsection{例: ハフマン符号化木}

この節では、集合と木を操作するためのリスト構造とデータ抽象化の使い方を練習します。
ここでは、データを1と0の列(ビット列)として表現する手法を適用対象とします。
例えば、コンピュータ内でテキストを表現するのに使われるASCII標準符号は、各文字を
7ビットの列として表現します。7ビットを使うことで、\( 2^7 \)、つまり128通りの
異なる文字を区別することができます。一般的に、\( n \)個の異なる記号を区別しようと
思うと、記号ごとに\( \log_2\!n \)ビットを使う必要があります。もしメッセージすべてが
A, B, C, D, E, F, G, Hという8個の記号からなるとすると、一文字あたり3ビットの
符号を選ぶことができます。例えば、次のようになります。

\begin{example}
A 000    C 010    E 100    G 110
B 001    D 011    F 101    H 111
\end{example}

\noindent
この符号を使って次のメッセージ

\begin{example}
BACADAEAFABBAAAGAH
\end{example}

\noindent
を符号化すると、54ビットの列になります。

\begin{example}
001000010000011000100000101000001001000000000110000111
\end{example}

\noindent
ASCII符号や、上に挙げたAからHまでの符号は、メッセージ内のそれぞれの記号を同じビット数で
表すので、\newterm{fixed-length}(\jnewterm{固定長})符号といいます。しかし、時には
異なる記号が異なるビット数で表されることもある\newterm{variable-length}(\jnewterm{可変長})
符号を使ったほうがいい場合もあります。例えばモールス符号では、アルファベットの各文字に
対して使う短点と長点の数が異なります。特に、最もよく出てくる文字のEは、短点ひとつで
表されます。一般的に、もしメッセージの中でとてもよく出てくる記号とほとんど出てこない記号が
あるのなら、よく出てくる記号に短い符号を割り当てるとデータをより効率的に(つまり、メッセージ
に対して少ないビット数で)符号化することができます。次に挙げる、AからHまでに対する
別のコードについて考えてみましょう。

\begin{example}
A 0      C 1010    E 1100    G 1110
B 100    D 1011    F 1101    H 1111
\end{example}

\noindent
この符号を使って符号化すると、上と同じメッセージが次のようになります。

\begin{example}
100010100101101100011010100100000111001111
\end{example}

\noindent
この列は42ビットなので、上に示した固定長符号に比べて空間を20\%以上節約できている
ことになります。

可変長符号を使ううえで難しいことのひとつに、0と1の列を読んでいく際に、いつ記号の終わりに
達したかをどうやって知るかということがあります。モールス符号では、各文字に対応する
短点と長点の列の後に、特別な\newterm{separator code}(\jnewterm{分離符号})(この場合は休止)を
置くことで、この問題を解決しています。ほかの解決法として、どの記号についても、その符号
全体がほかの記号に対する符号の前の部分(\newterm{prefix}(\jnewterm{接頭辞}))になることが
ないように符号を設計するというものがあります。そのような符号は\newterm{prefix code}
(\jnewterm{接頭符号})と呼ばれます。上の例では、Aを0、Bを100として符号化しているので、
ほかのどの記号も、0や100で始まる符号を持つことはできません。

一般的に、符号化するメッセージの相対頻度を利用した可変長接頭符号を使えば、
かなりの節約をすることができます。これを行う戦略のひとつにハフマン符号化法という
ものがあります。これは発見者のDavid Huffmanにちなんでつけられた名前です。
ハフマン符号は二分木として表現でき、葉は符号化対象の記号となります。木の中で、
葉でないノードは、そのノード以下の葉に対応する記号をすべて含んだ集合を持っています。
それに加えて、葉の記号それぞれには重み(相対頻度)が割り当てられていて、葉でない
ノードはその下にある葉の重みをすべて合計した重みをそれぞれ持っています。重みは
符号化・復号化の際には使いません。以下では、木を構築する際に重みをどう利用するのか
見ていきます。

\link{Figure 2.18}に、上に書いたAからHまでの符号に対するハフマン木を示しています。
葉の重みは、Aが相対頻度8、Bが相対頻度3、ほかの文字は相対頻度1で現れるような
メッセージに対してこの木が設計されているということを示しています。

\begin{figure}[tb]
\phantomsection\label{Figure 2.18}
\centering
\begin{comment}
\heading{Figure 2.18:} A Huffman encoding tree.

\begin{example}
           {A B C D E F G H} 17
                    *
                   / \
                  /   \
                A 8    * {B C D E F G H} 9
            __________/ \_____________
           /                          \
{B C D} 5 *                            * {E F G H} 4
         / \                       ___/ \___
        /   \                     /         \
      B 3    * {C D} 2   {E F} 2 *           * {G H} 2
            / \                 / \         / \
           /   \               /   \       /   \
         C 1   D 1           E 1   F 1   G 1   H 1
\end{example}
\end{comment}
\includegraphics[width=81mm]{fig/chap2/Fig2.18a.pdf}
\par\bigskip
\noindent
\heading{Figure 2.18:} ハフマン符号化木
\end{figure}

ハフマン木があれば、どの記号に対する符号も、根から始めてその記号を持つ葉に
たどり着くまで下りていくことで知ることができます。左の枝を下りるたびに
符号に0を追加し、右の枝を下りるたびに1を追加します(どちらの枝を下りるかについては、
どちらの枝にその記号の葉があるか、またはその記号を集合に含むかを見て決めます)。
例えば、\link{Figure 2.18}の根から始めてDの葉に着くまでには、右枝、左枝、右枝、
右枝とたどっていきます。そのため、Dに対する符号は1011となります。

ハフマン木を使ってビット列を復号するには、根から始めて、左と右のどちらの枝を
下りるのかをビット列の0と1の列を使って決めます。葉に着くたびに、メッセージ中の
記号を新たにひとつ生成し、そこでまた根に戻って次の記号を探します。例えば、上記の木と
10001010というビット列があるとします。根から始めて、右の枝を下り(ビット列の最初の
ビットは1なので)、それから左の枝を下り(二番目のビットは0なので)、次に左の枝を
下ります(三番目のビットも0なので)。こうするとBの葉にたどり着くので、復号した
メッセージの最初の記号はBです。ここでまた根から始めて、ビット列中の次のビットは0
なので、左に動きます。こうすると、Aの葉に着きます。それからまた根から始めると、
残りのビット列は1010なので、右、左、右、左と動いてCに着きます。つまり、メッセージ
全体はBACということになります。

\subsubsection*{ハフマン木の生成}

記号の``アルファベット''と相対頻度がわかっているとき、``最善の''符号を作るには
どうしたらいいでしょうか(言い換えると、メッセージを最小のビット数で符号化するのは
どのような木でしょうか)。ハフマンはこれを行うアルゴリズムを与え、結果となる符号が
実際に、符号構築時に使った頻度と記号の相対頻度が一致するようなメッセージを符号化
するのに最適な可変長符号であるということを示しました。ここではハフマン符号の最適性の
証明はせずに、ハフマン木の構築の仕方のみを示します。\footnote{ハフマン符号の数学的
性質についての議論は\link{Hamming 1980}を参照。}

ハフマン木を生成するアルゴリズムはとても単純です。考え方としては、出現頻度が最低の
記号が根から一番遠いところに出てくるように木を配置するというものです。まず、符号構築
対象の初期データによって決まる、記号と頻度を持つ葉ノードの集合から始めます。ここで、
重みが小さいほうから二つの葉を選び、二つをくっつけて新しいノードを作り、新しいノードの
左と右の枝がその二つのノードになるようにします。新しいノードの重みは二つの重みの合計
とします。元の集合からその二つの葉を取り除き、代わりに新しいノードを入れます。それから
このプロセスを続けていきます。各段階で、重みが小さいほうから二つのノードを集合から
取り除き、それらを左と右の枝として持つノードを代わりに入れることよって、その二つの
ノードをくっつけていきます。ノードがひとつだけになったら、それが木全体の根となり、
プロセスは停止します。以下に、\link{Figure 2.18}のハフマン木が生成される過程を
示します。

\begin{example}
Initial  
leaves   {(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}
Merge    {(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}
Merge    {(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}
Merge    {(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}
Merge    {(A 8) (B 3) ({C D} 2) ({E F G H} 4)}
Merge    {(A 8) ({B C D} 5) ({E F G H} 4)}
Merge    {(A 8) ({B C D E F G H} 9)}
Final    {({A B C D E F G H} 17)}
merge
\end{example}

\noindent
このアルゴリズムは常に同じ木になるとは限りません。各ステップで、最小の重みとなる
ノードのペアが一意であるとは限らないからです。また、二つのノードをくっつける
順番をどうするか(つまり、どちらを右枝としてどちらを左枝とするか)も任意です。

\subsubsection*{ハフマン木の表現}

以下の練習では、ハフマン木を使ってメッセージの暗号化・復号化を行ったり、
上で概要を示したアルゴリズムに従ってハフマン木を作ったりするシステムを
扱います。まず、木をどのように表現するかを検討しましょう。

木の葉は、\code{leaf}という記号、その葉の記号、重みからなるリストによって表現します。

\begin{scheme}
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
\end{scheme}

\noindent
一般の木は、左枝、右枝、記号の集合、重みからなります。記号の集合は、単純に
記号のリストにして、より複雑な集合の表現は使わないことにします。二つのノードを
くっつけて木を作るとき、その木の重みは二つのノードの重みの合計となり、
記号の集合は、二つのノードが持つ記号の集合の和集合となります。記号の集合は
リストとして表されているため、和集合は\link{Section 2.2.1}で定義した\code{append}
手続きによって作ることができます。

\begin{scheme}
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left)
                (symbols right))
        (+ (weight left)
           (weight right))))
\end{scheme}

\noindent
木をこうやって作ると、セレクタは次のようになります。

\begin{scheme}
(define (left-branch  tree) (car  tree))
(define (right-branch tree) (cadr tree))

(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
\end{scheme}

\noindent

手続き\code{symbols}と\code{weight}は、渡されたものが葉である場合と一般の木である場合とで、
少し違うことをしなければいけません。これらは、\newterm{generic procedures}
(\jnewterm{ジェネリック手続き})(二種類以上のデータを扱う手続き)の簡単な例になっています。
これについては、\link{Section 2.4}と\link{Section 2.5}で詳しく説明します。

\subsubsection*{復号化手続き}

以下の手続きは、復号化アルゴリズムを実装したものです。0と1のリストに加え、ハフマン木を
引数に取ります。

\begin{scheme}
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch 
                (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit: CHOOSE-BRANCH" bit))))
\end{scheme}

\noindent
手続き\code{decode\-/1}は、残りのビットのリストと、木の中での現在位置という、二つの引数を
取ります。リストの次のビットが0か1かによって、左か右の枝を``下りて''いきます
(これは手続き \code{choose\-/branch}で行っています)。葉にたどり着くと、木の根から始めて
メッセージの残りを復号した結果に葉の記号を\code{cons}することで、メッセージの次の
記号として返します。\code{choose\-/branch}の最終節のエラーチェックに注意してください。
ここでは、入力データの中の0または1以外のものを手続きが見つけた場合にエラーを出します。

\subsubsection*{重みつき要素の集合}

この木の表現では、葉でないノードはそれぞれ記号の集合を持つようになっていて、
その集合は単純なリストとして表現してきました。しかし、上で検討した木の生成
アルゴリズムでは、葉と木の集合も扱って、小さいほうから二つの項目を順にくっつけて
いくという必要がありました。集合の最小項目を何度も求めることになるので、この種の
集合は順序つきの表現を使うほうが便利です。

葉と木の集合は、重みの昇順に配置した要素のリストとして表現することにします。
以下の\code{adjoin\-/set}手続きは集合を構築するためのものですが、これは
\link{Exercise 2.61}で説明したものと似ています。しかし、項目の比較は重みによって
行い、また追加する要素がすでに集合にあるということはありません。

\begin{scheme}
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set)))
         (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
\end{scheme}

\noindent
次の手続きは、\code{((A 4) (B 2) (C 1) (D 1))}のような記号と頻度のペアの
リストを取り、初期状態での葉の順序つき集合を構築し、ハフマンアルゴリズムに
従ってすぐ連結できるようにします。

\begin{scheme}
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)    ~\textrm{; symbol}~
                               (cadr pair))  ~\textrm{; frequency}~
                    (make-leaf-set (cdr pairs))))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.67}Exercise 2.67:} 
符号化木とサンプルメッセージを次のように定義する。

\begin{scheme}
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
\end{scheme}

\code{decode}手続きを使ってメッセージを復号し、結果を示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.68}Exercise 2.68:} 
\code{encode}手続きは、引数としてメッセージと木を取り、メッセージを符号化した
ビットのリストを返す。

\begin{scheme}
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
\end{scheme}

\code{encode\-/symbol}は、与えられた木に従って与えられた記号を符号化したビット列を
返す。この手続きを書け。記号が木に含まれていなければエラーを出すように
\code{encode\-/symbol}を設計せよ。\link{Exercise 2.67}で得た結果をサンプルの木を
使って符号化し、それが元のサンプルメッセージと同じになるかどうか確認して、書いた
手続きをテストせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.69}Exercise 2.69:} 
以下の手続きは、引数として記号・頻度ペアのリスト(同じ記号が二つ以上のペアに
出てくることはない)を取り、ハフマンアルゴリズムに従ってハフマン符号化木を
生成する。

\begin{scheme}
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
\end{scheme}

\code{make\-/leaf\-/set}は上で与えた手続きで、ペアのリストを葉の順序つき集合に変換する。
\code{successive\-/merge}は、集合の中で重みが最小の要素を\code{make\-/code\-/tree}を
使って順番にくっつけていき、最後に要素がひとつだけ残るようにするというものである。
その要素が求めるハフマン木となる。この手続きを書け(この手続きはちょっとトリッキーだが、
そこまで複雑ではない。もし手続きの設計が複雑になったとしたら、ほぼ確実に何かを間違えて
いる。順序つきの集合表現を使っているということが大きな助けになる)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.70}Exercise 2.70:}
以下に示す8記号の相対頻度つきアルファベットは、1950年代のロックの歌詞を効率よく
符号化できるよう設計されたものである(``アルファベット''の``記号''が単独の文字で
あるとは限らないことに注意)。

\begin{example}
A    2   GET 2   SHA 3   WAH 1
BOOM 1   JOB 2   NA 16   YIP 9
\end{example}


\code{generate\-/huffman\-/tree}(\link{Exercise 2.69})を使って対応するハフマン木を
生成し、\code{encode} (\link{Exercise 2.68})を使って次のメッセージを符号化せよ。

\begin{example}
Get a job
Sha na na na na na na na na
Get a job
Sha na na na na na na na na
Wah yip yip yip yip yip yip yip yip yip
Sha boom
\end{example}

符号化には何ビット必要だろうか。もし固定長符号をこの8記号アルファベットに使ったとしたら、
最低でどれだけのビット数が必要になるだろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.71}Exercise 2.71:} 
\( n \)記号のアルファベットに対するハフマン木があり、記号の相対頻度は
\( 1, 2, 4, \dots, 2^{n-1} \)であるとする。\( n=5 \)、\( n=10 \)の場合の
木をスケッチせよ。そのような木では、(一般の\( n \)について)最も頻度の高い
記号を符号化するのに何ビット必要になるだろうか。最も頻度の低い記号はどう
だろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.72}Exercise 2.72:} 
\link{Exercise 2.68}で設計した符号化手続きについて考える。ひとつの記号を符号化する
のに必要なステップ数の増加オーダーはどのようになるだろうか。各ノードに着くたびに
記号リストを検索するのに必要なステップ数を含めることを忘れないように。この問題の
一般の場合について答えることは難しい。ここでは、\( n \)記号の相対頻度が
\link{Exercise 2.71}のようになっている特別な場合について考えよう。アルファベット中で
頻度が最大の記号と最小の記号を符号化するのにかかるステップ数の増加オーダーを
(\( n \)の関数として)答えよ。
\end{quote}

\section{抽象データの多重表現}
\label{Section 2.4}

ここまで、データ抽象化というものを紹介してきました。これはシステムを構築する
ための方法論で、プログラムの操作対象となるデーオブジェクトに対してどのような実装を
選ぶかということと独立に、プログラムのほとんどの部分を記述できるようにするというものでした。
例えば\link{Section 2.1.1}では、有理数を使うプログラムを設計するというタスクを、
複合データを構築するためにコンピュータ言語が持っている基本メカニズムによって有理数を
実装するというタスクから切り離すやり方について見てきました。
ポイントとなる考え方は、抽象化の壁---この場合は、有理数のセレクタとコンストラクタ
(\code{make\-/rat}, \code{numer}, \code{denom})---を建てて、有理数をどう使うかという
ところと、有理数のリスト構造による表現という内部の構造とを分離するということでした。
結果として、プログラムは\link{Figure 2.1}に示したような構造になりました。

これらのデータ抽象化の壁は、複雑性をコントロールする強力な道具です。データオブジェクトの
内部表現を分離することで、大きなプログラムの設計というタスクを、別々に行うことのできる
小さなタスクの集まりに分割することができます。しかし、この手のデータ抽象化はまだ
十分に強力とは言えません。というのは、データ構造の``内部表現''というものがいつも
意味があるとは限らないからです。

一つ目には、データオブジェクトの便利な表現方法が二つ以上あって、複数の表現を
扱えるようなシステムを設計したいという場合があります。単純な例について考えると、
複素数は二種類のほぼ等価な方法、直交形式(実部と虚部)と極形式(絶対値と偏角)によって
表すことができます。直交形式のほうが適切な場合もあれば、極形式のほうが適切な
場合もあります。実際に、複素数が両方の形式で表され、複素数を操作する手続きは
どちらか一方の表現を扱うといったシステムも、十分に考えられます。

さらに重要なことは、プログラミングシステムは仕様変更を繰り返しながら長期間に
わたって多くの人々によって設計されるということがよくあるということです。
そのような環境では、データ表現として何を選ぶかについてみんなが前もって合意する
ということはまずありません。つまり、データの表現をそれを使うところから分離する
データ抽象化の壁に加えて、複数のデータ表現をそれぞれ分離し、ひとつのプラットフォーム
上でそれらを共存させる抽象化の壁が必要だということです。また、大きなプログラムという
ものは、別々に設計されたすでに存在するモジュールを組み合わせて作られることが多いので、
プログラマがモジュールを\newterm{additively}(\jnewterm{加法的}に)、つまり、これらの
モジュールを設計し直したり実装し直したりすることなく、より大きなシステムに
組み込んでいくための規約が必要になります。

この節では、プログラムの部品によって違う方法で表現されるデータを扱うやり方について
学びます。そのためには、\newterm{generic procedures}(\jnewterm{ジェネリック手続き})---
二種類以上の方法で表現されるデータを扱える手続き---を構築する必要があります。
ジェネリック手続きを構築するためにここで使う主なテクニックは、\newterm{type tags}
(\jnewterm{タイプタグ})を持つデータオブジェクト、つまりどのように処理されるべきかという
情報を明示的に持っているデータオブジェクトを使うということです。また、
\newterm{data-directed}(\jnewterm{データ主導})プログラミングについても検討します。
これは、ジェネリック演算によって加法的にシステムを組み立てていくための強力で便利な
実装戦略です。

最初に、単純な複素数の例を扱います。タイプタグとデータ主導スタイルを使うことで、
``複素数''データオブジェクトという抽象概念を維持したまま、複素数の表現として
直交形式と極形式を別々に設計できるということを見ていきます。これは、
複素数がどのように表現されているかということと独立に複素数の各部分にアクセスする
ジェネリックセレクタによって複素数の算術演算(\code{add\-/complex}, \code{sub\-/complex},
\code{mul\-/complex}, \code{div\-/complex})を定義することで達成できます。
これによってできる複素数システムでは、\link{Figure 2.19}に示すように、
二種類の異なる抽象化の壁を持つことになります。``水平な''抽象化の壁は、
\link{Figure 2.1}に出てきたものと同じ役割を果たします。それらは、``高レベル''演算を
``低レベル''演算から分離するものです。それに加えて、複数の表現を別々に設計して
組み込めるようにするための``垂直な''壁があります。

\begin{figure}[tb]
\phantomsection\label{Figure 2.19}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.19:} Data-abstraction barriers in the complex-number system.

\begin{example}
           Programs that use complex numbers
  +-------------------------------------------------+
--| add-complex sub-complex mul-complex div-complex |--
  +-------------------------------------------------+
              Complex arithmetic package
---------------------------+---------------------------
          Rectangular      |         Polar
        representation     |     representation
---------------------------+---------------------------
    List structure and primitive machine arithmetic
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=108mm]{fig/chap2/Fig2.19a.pdf}
\par\bigskip
\noindent
\heading{Figure 2.19:} 複素数システムのデータ抽象化の壁
\end{figure}

\link{Section 2.5}では、タイプタグとデータ主導スタイルを使ってジェネリック算術演算
パッケージを開発するやり方を示します。このシステムは、すべての種類の``数値''を操作
するのに使える手続き(\code{add}, \code{mul} など)を提供し、新たな種類の数値が必要に
なったら簡単に拡張できるようになっています。\link{Section 2.5.3}では、記号代数を実行
するシステムの中でジェネリック数値演算を使う方法を示します。

\subsection{複素数の表現}
\label{Section 2.4.1}
\label{Sec. 2.4.1}

ここでは、ジェネリック演算を使うプログラムの単純で非現実的な例として、複素数に対する
算術演算を行うシステムを開発していきます。まず、複素数を順序つきペアとして表すときに
考えられる二つの表現方法、直交形式(実部と虚部)と極形式(絶対値と偏角)について検討します。
\footnote{実際の計算システムでは、ほとんどの場合、直行形式が選ばれます。
これは、直交形式と極形式の変換時に発生する丸め誤差のためです。このため、この
複素数の例は現実的ではありません。しかし、ジェネリック演算を使ったシステムの
設計を説明する例としては明快ですし、この章の後のほうで開発する、より実質的な
システムへの導入としても役に立ちます。}
\link{Section 2.4.2}では、タイプタグとジェネリック演算を使うことによって両方の表現を
共存させるやり方を示します。

有理数と同じように、複素数は順序つきペアとして自然に表現できます。複素数の集合は、
``実''軸と``虚''軸という二つの直交する軸を持つ二次元空間と考えることができます
(\link{Figure 2.20}参照)。この見方をすると、\( z = x + iy \) (\( i^2 = -1 \))という
複素数は、の実座標が\( x \)で虚座標が\( y \)の平面上の点として考えることができます。
複素数の和は、この表現では、座標の和になります。
\begin{comment}

\begin{example}
Real-part(z_1 + z_2) = Real-part(z_1) + Real-part(z_2)

Imaginary-part(z_1 + z_2) = Imaginary-part(z_1) + Imaginary-part(z_2)
\end{example}

\end{comment}
\begin{displaymath}
%  \eqalign{
% \hbox{Real-part} (z_1 + z_2)\; 		&= 
% 	\hbox{ Real-part} (z_1)\; + \hbox{ Real-part} (z_2), \cr
% \hbox{Imaginary-part} (z_1 + z_2)\; 	&= 
% 	\hbox{ Imaginary-part} (z_1)\; + \hbox{ Imaginary-part} (z_2). \cr 
% } 
\begin{array}{r@{{}={}}l}
  \hbox{Real-part} (z_1 + z_2)\; 	& 
	\hbox{ Real-part} (z_1)\; + \hbox{ Real-part} (z_2), \\
  \hbox{Imaginary-part} (z_1 + z_2)\; 	& 
	\hbox{ Imaginary-part} (z_1)\; + \hbox{ Imaginary-part} (z_2). 
\end{array}
\end{displaymath}

\begin{figure}[tb]
\phantomsection\label{Figure 2.20}
\centering
\begin{comment}
\heading{Figure 2.20:} Complex numbers as points in the plane.

\begin{example}
 Imaginary
    ^
    |
  y |.........................* z = x + ?y = r e^(?A)
    |                    __-- .
    |                __--     .
    |          r __--         .
    |        __--             .
    |    __-- \               .
    |__--    A |              .
----+----------+-------------------> Real
                              x
\end{example}
\end{comment}
\includegraphics[width=79mm]{fig/chap2/Fig2.20.pdf}
\par\bigskip
\noindent
\heading{Figure 2.20:} 平面上の点としての複素数
\end{figure}

複素数をかけ算するときには、複素数を極形式で、つまり大きさと角度(
\link{Figure 2.20}内の\( r \)と\( A \))を使って考えるほうが自然です。
二つの複素数の積は、ひとつの複素数をもう一方の長さをかけて伸縮させ、
もう一方の角度だけ回転させて得られるベクトルになります。

\begin{comment}

\begin{example}
Magnitude(z_1 * z_2) = Magnitude(z_1) * Magnitude(z_2)

Angle(z_1 * z_2) = Angle(z_1) + Angle(z_2)
\end{example}

\end{comment}
\begin{displaymath}
%  \eqalign{
% 	\hbox{Magnitude} (z_1 \cdot z_2)\; 	&= 
% 		\hbox{ Magnitude} (z_1)\; \cdot \hbox{ Magnitude} (z_2), \cr
% 	\hbox{Angle} (z_1 \cdot z_2)\; 		&= 
% 		\hbox{ Angle} (z_1)\; + \hbox{ Angle} (z_2). \cr
% } 
\begin{array}{r@{{}={}}l}
	\hbox{Magnitude} (z_1 \cdot z_2)\; 	& 
		\hbox{ Magnitude} (z_1)\; \cdot \hbox{ Magnitude} (z_2), \\
	\hbox{Angle} (z_1 \cdot z_2)\; 		& 
		\hbox{ Angle} (z_1)\; + \hbox{ Angle} (z_2). 
\end{array}
\end{displaymath}
\begin{displaymath}
\begin{array}{r@{{}={}}l}
	\hbox{大きさ} (z_1 \cdot z_2)\; 	&
		\hbox{ 大きさ} (z_1)\; \cdot \hbox{ 大きさ} (z_2), \\
	\hbox{角度} (z_1 \cdot z_2)\; 		&
		\hbox{ 角度} (z_1)\; + \hbox{ 角度} (z_2).
\end{array}
\end{displaymath}
つまり、複素数には二つの異なる表現があり、それぞれ異なる演算に適しているということです。
しかし、複素数を使うプログラムを書いている人の視点からは、データ抽象化の原則により、
コンピュータがどちらの表現を使っていても、複素数の演算すべてが使えるようになって
いなければいけません。例えば、直交形式によって指定された複素数の絶対値が求められると
便利なことがよくあります。同じように、極形式によって指定された複素数の実部を求められると
便利なことがよくあります。

そのようなシステムを設計するにあたっては、\link{Section 2.1.1}で有理数パッケージを
設計する際に使ったのと同じデータ抽象化戦略が使えます。複素数演算は、\code{real\-/part},
\code{imag\-/part}, \code{magnitude}, \code{angle}という四つのセレクタによって実装されて
いるとします。また、複素数の構築には二つの手続きがあるとします。
\code{make\-/from\-/real\-/imag}は、指定された実部と虚部を持つ複素数を返し、
\code{make\-/from\-/mag\-/ang}は、指定された絶対値と偏角を持つ複素数を返します。
これらの手続きは、任意の複素数に対して

\begin{scheme}
(make-from-real-imag (real-part z) (imag-part z))
\end{scheme}

\noindent
と

\begin{scheme}
(make-from-mag-ang (magnitude z) (angle z))
\end{scheme}

\noindent
の両方とも\code{z}に等しい複素数を返すという性質を持っています。


これらのコンストラクタとセレクタを使うことで、\link{Section 2.1.1}で有理数について
行ったように、コンストラクタとセレクタによって規定される``抽象データ''を使って
複素数の算術演算を実装することができます。上の式に示したように、足し算と引き算は
実部と虚部を使って、またかけ算と割り算は絶対値と偏角を使って行えます。

\begin{scheme}
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
\end{scheme}

\begin{scheme}
(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))
\end{scheme}

\begin{scheme}
(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))
\end{scheme}

\begin{scheme}
(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
\end{scheme}

\noindent
複素数パッケージを完成させるには、複素数の表現を選び、コンストラクタとセレクタを
基本数値と基本リストを使って実装しなければいけません。すぐわかるように、この方法は
二通りあります。``直交形式''のペア(実部、虚部)として表現するか、``極形式''のペア
(絶対値、偏角)として表現するかです。どちらを選ぶべきでしょうか。

この二つの選択の具体的な例として、Ben BitdiddleとAlyssa P. Hackerという、独立に
複素数システムの表現を設計している二人のプログラマがいると想像してください。Ben は
複素数を直交形式で表現することにします。この場合、複素数の実部と虚部を選択することや、
複素数を与えられた実部と虚部から構築することは、素直に実現できます。絶対値と偏角を
求めたり、複素数を与えられた絶対値と偏角から構築するのは、次のような三角法の関係を
使います。
\begin{comment}

\begin{example}
                      __________
x = r cos A     r = ./ x^2 + y^2

y = r sin A     A = arctan(y,x)
\end{example}

\end{comment}
\begin{displaymath}
%  \eqalign{
% 	x = r \cos A, \qquad 	& r = \sqrt{x^2 + y^2}, \cr
% 	y = r \sin A, \qquad 	& A = \arctan(y, x), \cr
% } 
\begin{array}{r@{{}={}}lr@{{}={}}l}
	x & r \cos A, \qquad 	& r & \sqrt{x^2 + y^2}, \\
	y & r \sin A, \qquad 	& A & \arctan(y, x), 
\end{array}
\end{displaymath}
これは、実部と虚部\( (x, y) \)と絶対値と偏角\( (r, A) \)の関係を表しています。
\footnote{
ここで出てきた逆正接関数はSchemeの\code{atan}手続きで計算できるもので、引数
\( y, x \)を取り、正接が\( y / x \)となる角度を返すよう定義されています。
引数の符号によって角度の象限が決まります。}
このため、Benの表現は以下のようなセレクタとコンストラクタによって書くことができます。

\begin{scheme}
(define (real-part z) (car z))
(define (imag-part z) (cdr z))
(define (magnitude z)
  (sqrt (+ (square (real-part z))
           (square (imag-part z)))))
(define (angle z)
  (atan (imag-part z) (real-part z)))
(define (make-from-real-imag x y) (cons x y))
(define (make-from-mag-ang r a)
  (cons (* r (cos a)) (* r (sin a))))
\end{scheme}

\noindent
一方、Alyssaは複素数を極形式で表現することにしました。彼女の方法では、絶対値と偏角の
セレクトは素直にできます。しかし、実部と虚部を求めるには、三角法の関係を使う必要が
あります。Alyssaの表現は次のようになります。

\begin{scheme}
(define (real-part z) (* (magnitude z) (cos (angle z))))
(define (imag-part z) (* (magnitude z) (sin (angle z))))
(define (magnitude z) (car z))
(define (angle z) (cdr z))
(define (make-from-real-imag x y)
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))
(define (make-from-mag-ang r a) (cons r a))
\end{scheme}

\noindent
データ抽象化の規律に従っているため、\code{add\-/complex}, \code{sub\-/complex},
\code{mul\-/complex}, \code{div\-/complex}の同じ実装が、Benの表現とAlyssaの表現の
どちらに対してもうまく動くということが保証されます。

\subsection{タグ付きデータ}
\label{Section 2.4.2}

データ抽象化は、``最小責任の原則''の応用として見ることもできます。
\link{Section 2.4.1}で複素数システムを実装したとき、Benの直行形式による表現と
Alyssaの極形式による表現のどちらを使うこともできました。セレクタとコンストラクタが
抽象化の壁を作っているため、データオブジェクトの具体的な表現に何を選ぶかということを
最後の瞬間まで遅らせることができ、そのためシステム設計の柔軟性を最大限にできます。

最小責任の原則は、さらに極限まで進めることができます。もし望むなら、セレクタと
コンストラクタを設計した``後''になっても表現を曖昧にしたままで、Benの表現と
Alyssaの表現の``両方''を使うようにすることもできます。しかし、両方の実装が
単独のシステムに含まれている場合、極形式のデータと直交形式のデータを区別するための
何らかの方法が必要になります。そうしないと、例えば(3, 4)というペアの\jnewterm{絶対値}
を求めるよう言われた場合に、答えを(数値を直行形式と解釈して)5とするべきか
(数値を極形式と解釈して)3とするべきかわかりません。これを区別できるようにする
素直なやり方は、\newterm{type tag}(\jnewterm{タイプタグ})---\code{rectangular}または
\code{polar}という記号---を、それぞれの複素数の一部として含めるというものです。
こうすると、複素数を操作することが必要になったときに、どちらのセレクタを適用するべきかを
このタグを使って決めることができます。

タグつきデータを操作するために、\code{type\-/tag}と\code{contents}という手続きを
持っていると想定します。\code{type\-/tag}はデータオブジェクトからタグを抽出するもので、
\code{contents}は実際の中身(複素数の場合、極形式または直行形式の座標)を抽出するものです。
また、\code{attach\-/tag}という手続きも持っていると仮定します。これは、タグと中身を取り、
タグつきデータオブジェクトを返すというものです。これを実装する素直なやり方は、普通の
リスト構造を使うというものです。

\begin{scheme}
(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: TYPE-TAG" datum)))
(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum: CONTENTS" datum)))
\end{scheme}

\noindent
これらの手続きを使って、直交形式と極形式をそれぞれ識別する述語\code{rectangular?},
\code{polar?}を定義することができます。

\begin{scheme}
(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))
(define (polar? z) (eq? (type-tag z) 'polar))
\end{scheme}

\noindent
タイプタグを使うことにしたので、BenとAlyssaはコードを修正して、異なる表現が
同じシステムの中で共存できるようにしました。Benが複素数を構築するたびに、それに
直交形式というタグをつけます。Alyssaが複素数を構築するたびに、それに極形式という
タグをつけます。それに加えて、BenとAlyssaはそれぞれの手続きの名前が衝突しないように
しなければいけません。これを行う方法としては、Benが自分の表現の手続きに接尾辞
\code{rectangular}を追加し、Alyssaは自分の表現手続きに\code{polar}を追加するという
ものがあります。以下は、\link{Section 2.4.1}のBenの直行形式表現を修正したものです。

\begin{scheme}
(define (real-part-rectangular z) (car z))
(define (imag-part-rectangular z) (cdr z))
(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))
(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))
(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))
(define (make-from-mag-ang-rectangular r a)
  (attach-tag 'rectangular
              (cons (* r (cos a)) (* r (sin a)))))
\end{scheme}

\noindent
Alyssaの極形式表現の修正版のは次のようになりました。

\begin{scheme}
(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))
(define (imag-part-polar z)
  (* (magnitude-polar z) (sin (angle-polar z))))
(define (magnitude-polar z) (car z))
(define (angle-polar z) (cdr z))

(define (make-from-real-imag-polar x y)
  (attach-tag 'polar
              (cons (sqrt (+ (square x) (square y)))
                    (atan y x))))
(define (make-from-mag-ang-polar r a)
  (attach-tag 'polar (cons r a)))
\end{scheme}

\noindent
どちらのジェネリックセレクタも、引数のタグをチェックして、そのタイプのデータを扱う
適切な手続きを呼ぶ手続きとして実装されています。例えば、複素数の実部を得る場合、
\code{real\-/part}はタグを調べ、Benの\code{real\-/part\-/rectangular}とAlyssaの
\code{real\-/part\-/polar}のどちらを使うのかを決定します。どちらの場合でも、
\code{contents}を使って生のタグなしデータを取り出し、それを必要に応じて直交形式または
極形式の手続きに渡します。

\begin{scheme}
(define (real-part z)
  (cond ((rectangular? z)
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error "Unknown type: REAL-PART" z))))

(define (imag-part z)
  (cond ((rectangular? z)
         (imag-part-rectangular (contents z)))
        ((polar? z)
         (imag-part-polar (contents z)))
        (else (error "Unknown type: IMAG-PART" z))))

(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else (error "Unknown type: MAGNITUDE" z))))
(define (angle z)
  (cond ((rectangular? z)
         (angle-rectangular (contents z)))
        ((polar? z)
         (angle-polar (contents z)))
        (else (error "Unknown type: ANGLE" z))))
\end{scheme}

\noindent
複素数の算術演算を実装するのには、\link{Section 2.4.1}の手続き\code{add\-/complex}, 
\code{sub\-/complex}, \code{mul\-/complex}, \code{div\-/complex}と同じものが使えます。
それらが呼び出すセレクタはジェネリックなので、どちらの表現を使っても動くからです。
例えば、手続き\code{add\-/complex}は相変わらずそのままで、以下のようになります。

\begin{scheme}
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
\end{scheme}

\noindent
最後に、複素数を構築するのにBenの表現とAlyssaの表現のどちらを使うかを決める必要が
あります。実部と虚部が渡されたときには直行形式を使い、大きさと角度を渡されたときには
極形式を使うというのが妥当でしょう。

\begin{scheme}
(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))
(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
\end{scheme}

\noindent
このようにして作った複素数システムは、\link{Figure 2.21}に示すような構造を持ちます。
システムは、比較的独立した三つの部分に分解されています。複素数算術演算、Alyssaの
極形式による実装、Benの直交形式による実装です。極形式と直交形式の実装は、Benと
Alyssaが別々に書いていたとしても問題ありません。第三者のプログラマが抽象コンストラクタ、
セレクタによって複素数算術演算手続きを実装する際に、内部表現として両方とも使うことが
できます。

\begin{figure}[tb]
\phantomsection\label{Figure 2.21}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.21:} Structure of the generic complex-arithmetic system.

\begin{example}
    +-------------------------------------------------+
----| add-complex sub-complex mul-complex div-complex |----
    +-------------------------------------------------+
                Complex arithmetic package
                 +-----------------------+
                 | real-part   imag-part |
-----------------|                       |------------------
                 | magnitude   angle     |
                 +-----------+-----------+
           Rectangular       |          Polar
          representation     |     representation
-----------------------------+------------------------------
       List structure and primitive machine arithmetic
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=108mm]{fig/chap2/Fig2.21a.pdf}
\par\bigskip
\noindent
\heading{Figure 2.21:} ジェネリックな複素数算術演算システムの構造
\end{figure}

それぞれのデータオブジェクトには型のタグがついているので、セレクタはジェネリックに
データを操作します。つまり、それぞれのセレクタは適用されるデータの個々の型によって
異なるふるまいをするように定義されているということです。別々の表現をインターフェイスで
接続する際の一般的なメカニズムに注目してください。ある表現の実装(例えば、Alyssaの
極形式パッケージ)の中で極形式型の複素数を操作するときには、タグを取り除き、中身を
Alyssaのコードに渡します。逆に、Alyssaが一般使用のための数値を構築する際には、
それに型のタグをつけて、上のレベルの手続きが適切に認識できるようにします。データ
オブジェクトをレベル間でやりとりする際にタグをつけたり外したりするというこの規律は、
重要な組織化戦略になりえます。\link{Section 2.5}では、このことについて見ていきます。

\subsection{データ主導プログラミングと加法性}
\label{Section 2.4.3}

データの型をチェックして適切な手続きを呼ぶという一般的な戦略は、

データの型をチェックし適切な手続きを呼ぶ一般的な戦略は\newterm{dispatching on type}
(\jnewterm{型によるディスパッチ})と呼ばれるものです。これは、システム設計でモジュール性を
達成するための強力な戦略です。一方で、\link{Section 2.4.2}のようにディスパッチを実装する
ことには二つの大きな弱点があります。弱点のひとつは、ジェネリックインターフェイス手続き
(\code{real\-/part}, \code{imag\-/part}, \code{magnitude}, \code{angle})がすべての異なる
表現について知っていなければいけないということです。例えば、複素数の新しい表現をこの複素数
システムに組み込みたいとします。そのためには、この新しい表現を型で識別できるようにして、
それから各ジェネリックインターフェイス手続きにその新しい型をチェックする節を追加し、
そしてその表現に対する適切なセレクタを適用することが必要になるでしょう。

このテクニックのもうひとつの弱点は、個々の表現は別々に設計できるものの、システム全体で
二つの手続きが同じ名前を持つということがないように保証しなければならないということです。
このために、BenとAlyssaは\link{Section 2.4.1}の元の手続きの名前を変える必要があったのでした。

この二つの弱点の元となっているのは、ジェネリックインターフェイスを実装するテクニックが
\newterm{additive}(\jnewterm{加法的})でないということです。ジェネリックセレクタ手続きを
実装する人は、新しい表現が組み込まれるたびにそれらの手続きを変更しなければならず、
また個々の表現のインターフェイスを作る人は、名前の衝突を避けるためにコードを変更しなければ
なりません。どちらの場合でも、コードに加えるべき変更は単純なものですが、それでもやはり
行わなければならず、このことが不便さとエラーの原因になります。これは複素数システムに
関しては現時点ではあまり大きな問題ではありませんが、仮に複素数の表現が二つではなく
数百個あったとしたらどうでしょうか。また、抽象データインターフェイスにはメンテナンスする
べきジェネリックセレクタが数多くあるとしたらどうでしょうか。また、すべてのインターフェイス
手続きやすべての表現について知っているプログラマが誰もいないとしたらどうでしょうか。
この問題は現実的なもので、大規模データベース管理システムのようなプログラムではこの問題に
取り組む必要があります。

ここで、システム設計をさらにモジュール化するための手段が必要になります。
\newterm{data-directed programming}(\jnewterm{データ主導プログラミング})として知られる
プログラミングテクニックはその手段を提供してくれます。データ主導プログラミングが
どうやって動くのかを理解するために、まず次のことに注目します。いろいろな型の集合に対して
共通のものとなるジェネリック演算を扱う際にはいつも、実質的には、ひとつの軸が可能な演算で、
もうひとつの軸が可能な型であるような二次元のテーブルを扱っていることになります。
テーブルの項目は、それぞれの引数の型に対するそれぞれの演算を実装する手続きです。
前の節で開発した複素数システムでは、演算の名前、データタイプ、実際の手続きの間の対応関係は、
ジェネリックインターフェイス手続きのいろいろな条件節の中に広がっていました。しかし、それと
同じ情報を\link{Figure 2.22}に示すようにテーブルの中に構造化することもできたところです。

データ主導プログラミングは、そのようなテーブルを直接扱うようにプログラムを設計する
テクニックです。前のほうで、複素数算術演算のコードと、それぞれ型によって明示的な
ディスパッチを行う手続きの集合となっている二つの表現パッケージとの間の橋渡しをする
メカニズムを実装しました。ここでは、そのインターフェイス部分を、演算の名前と引数の型の
組み合わせをテーブルから検索して適用するべき正しい手続きを見つけ、それを引数の中身に
適用するということを行う、単一の手続きとして実装します。こうすると、新しい表現パッケージを
システムに追加する際に、既存の手続きには何の変更も加えなくても大丈夫です。テーブルに新しい
項目を追加するだけで十分です。

\begin{figure}[tb]
\phantomsection\label{Figure 2.22}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.22:} Table of operations for the complex-number system.

\begin{example}
           |               Types
Operations | Polar           | Rectangular
===========+=================+======================
real-part  | real-part-polar | real-part-rectangular
imag-part  | imag-part-polar | imag-part-rectangular
magnitude  | magnitude-polar | magnitude-rectangular
angle      | angle-polar     | angle-rectangular
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=102mm]{fig/chap2/Fig2.22.pdf}
\par\bigskip
\noindent
\heading{Figure 2.22:} 複素数システム演算のテーブル
\end{figure}

この計画を実装するために、演算-型テーブルを操作する\code{put}と\code{get}という二つの
手続きがあるということにします。

\begin{itemize}

\item
\( \hbox{\tt(put}\;\langle \)\var{op}\( \kern0.1em\rangle\;\langle \)\var{type}\( \kern0.08em\rangle\;\langle \)\var{item}\( \kern0.08em\rangle\hbox{\tt)} \)は、テーブルの\( \langle \)\var{op}\( \kern0.1em\rangle \)と\( \langle \)\var{type}\( \kern0.08em\rangle \)が指すところに\( \langle \)\var{item}\( \kern0.08em\rangle \)を入れる。

\item
\( \hbox{\tt(get}\;\langle \)\var{op}\( \kern0.1em\rangle\;\langle \)\var{type}\( \kern0.08em\rangle\hbox{\tt)} \)は、テーブルから
\( \langle \)\var{op}\( \kern0.08em\rangle \), \( \langle \)\var{type}\( \kern0.08em\rangle \)の項目を検索し、そこで見つかった項目を返す。 見つからなければ、\code{get}はfalseを返す。

\end{itemize}

\noindent
今のところは、\code{put}と\code{get}は言語に含まれているということにします。
\link{Chapter 3} (\link{Section 3.3.3})では、これらを含め、テーブル操作演算の実装方法
について学びます。

それでは、複素数システムでデータ主導プログラミングをどう使うかについて見ていきましょう。
直行形式表現を開発したBenは、元のものと同じようにコードを実装します。それから手続きの集合、
つまり\newterm{package}(\jnewterm{パッケージ})を定義し、システムに直交形式の数値の
扱い方を知らせるテーブルに項目を追加することで、これらの手続きをシステムのほかの部分と
接続します。これは、次の手続きを呼ぶことで行えます。

\begin{scheme}
(define (install-rectangular-package)
  ~\textrm{;; 内部手続き}~
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))

  ~\textrm{;; システムのほかの部分とのインターフェイス}~
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
\end{scheme}

\noindent
ここでの内部手続きが、\link{Section 2.4.1}でBenが単独で書いたものと同じ
手続きであることに注目してください。これらをシステムのほかの部分と接続するのに、
変更を加える必要はありません。それに、これらの手続きの定義は組み込み手続きの内部に
あるので、直交形式パッケージの外のほかの手続きと名前が衝突する心配もありません。
これらの手続きをシステムのほかの部分と接続するために、Benは自分の\code{real\-/part}
手続きを、演算名\code{real\-/part}と型\code{(rectangular)}のところに入れます。
ほかのセレクタも同じようにします。
\footnote{
ここでは、\code{rectangular}という記号ではなく\code{(rectangular)}というリストを使い、
必ずしも同じ型であるとは限らない複数の引数を持つ手続きを持てるようにしています。}
このインターフェイスは、システムのほかの部分から使うためのコンストラクタも定義しています。
\footnote{
コンストラクタを入れる場所の型はリストにしなくても大丈夫です。コンストラクタは必ず
ある特定の型のオブジェクトを作るのに使われるからです。}コンストラクタはBenが内部で
定義していたものと同じですが、タグをつけるというところが違います。

Alyassaの極形式パッケージも似たようなものになります。

\begin{scheme}
(define (install-polar-package)
  ~\textrm{;; 内部手続き}~
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ~\textrm{;; システムのほかの部分とのインターフェイス}~
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
\end{scheme}

\noindent
BenとAlyssaは、相手のものと同じ名前(例えば、\code{real\-/part}など)によって
定義された元々の手続きをまだ使っていますが、これらの定義は今では別々の手続きの
内部定義(\link{Section 1.1.8}参照)になっているので、名前の衝突は起こりません。

複素数算術演算セレクタは、\code{apply\-/generic}というジェネリック``演算''手続きを
使ってテーブルにアクセスします。これは、ジェネリック演算を引数に適用するものです。
\code{apply\-/generic}は、テーブルから演算の名前と引数の型に対応する箇所を検索し、
手続きがあればそれを適用します。
\footnote{
\code{apply\-/generic}は、\link{Exercise 2.20}で説明したドット末尾記法を使います。
それぞれのジェネリック演算が取る引数の数は違うかもしれないからです。
\code{apply\-/generic}では、\code{op}は\code{apply\-/generic}の第一引数を値として
持ち、\code{args}は残りの引数のリストを値として持ちます。

また、\code{apply\-/generic}は\code{apply}という基本手続きを使っています。この手続きは
手続きとリストという二つの引数を取り、リストの要素を引数として手続きを適用します。
例えば、

\begin{smallscheme}
(apply + (list 1 2 3 4))
\end{smallscheme}

\noindent
は10を返します。}

\begin{scheme}
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error
            "No method for these types: APPLY-GENERIC"
            (list op type-tags))))))
\end{scheme}

\noindent
\code{apply\-/generic}を使うと、複素数演算のジェネリックセレクタは以下のように定義
できます。

\begin{scheme}
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))
\end{scheme}

\noindent
新しい表現がシステムに追加されてもこれらはまったく変わらないということに注意して
ください。

また、このパッケージの外部のプログラムが、実部と虚部や絶対値と偏角から複素数を作る際に
使うコンストラクタを抽出することもできます。\link{Section 2.4.2}と同じように、実部と
虚部がある場合は直交形式の複素数を構築し、絶対値と偏角がある場合は極形式の複素数を
構築します。

\begin{scheme}
(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'polar) r a))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.73}Exercise 2.73:} 
\link{Section 2.3.2}では、記号微分を行うプログラムについて説明した。

\begin{scheme}
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) 
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum (make-product
                    (multiplier exp)
                    (deriv (multiplicand exp) var))
                   (make-product 
                    (deriv (multiplier exp) var)
                    (multiplicand exp))))
        ~\( \dark \langle \)~~\var{\dark more rules can be added here}~~\( \dark \rangle \)~
        (else (error "unknown expression type: 
                      DERIV" exp))))
\end{scheme}

このプログラムは、微分する式の型によってディスパッチを実行していると捉えることもできる。
この場合、データの``タイプタグ''は代数演算記号(\code{+}など)で、行う演算は\code{deriv}
ということになる。基本的な微分を行う手続きを次のように書き直すと、プログラムを
データ主導スタイルに変形できる。

\begin{scheme}
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) 
         (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp)) 
               (operands exp) var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
\end{scheme}

\begin{enumerate}[a]

\item
上で何をしているか説明せよ。手続き\code{number?}と\code{variable?}は、なぜデータ主導
ディスパッチとして取り込むことができないのだろうか。

\item
和と積に対する微分手続きと、上記のプログラムで使っているテーブルにそれらを組み込む
補助コードを書け。

\item
任意の微分ルール(例えば、\link{Exercise 2.56}の指数の微分など)を選び、それを
このデータ主導システムに組み込め。

\item
この単純な代数操作では、式の型は式をまとめる代数演算子となっている。しかし、
仮に手続きのインデックスを逆にして、\code{deriv}でディスパッチを行う箇所を
次のようにするとする。
\begin{scheme}
((get (operator exp) 'deriv) (operands exp) var)
\end{scheme}

\noindent
これに対応して、微分システムにはどのような変更を加える必要があるだろうか。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.74}Exercise 2.74:} 
Insatiable Enterprises, Inc.(貪欲エンタープライズ社)は、世界中に散らばった多数の
独立事業所からなる分散型複合企業である。この会社のコンピュータ設備は、どのユーザから
見てもネットワーク全体がひとつのコンピュータのように見えるような巧妙なネットワーク
インターフェイス方式によって相互接続されたところだ。貪欲社の社長は、初めてネットワークの
機能を使って事業所ファイルから管理情報を取り出そうとして愕然とした。事務所ファイルは
すべてSchemeのデータ構造として実装されているのに、使われている個々のデータ構造は
事業所ごとに違うのだ。事業所長会議が急遽開かれ、事業所の独立性をこれまで通りに保ったままで、
本部の要求を満たせるようにファイルを統合する戦略を探ることになった。

そのような戦略をデータ主導プログラミングによって実装する方法を示せ。例として、
各事業所の人事記録は単独のファイルからなり、従業員の名前をキーとしたレコードの集合を
持っているとする。集合の構造は事業所ごとに異なる。さらに、各従業員のレコードは
それ自身が(事業所ごとに異なる構造を持つ)集合で、\code{address}と\code{salary}のような
識別子をキーとした情報を含んでいるとする。具体的には、

\begin{enumerate}[a]

\item
指定した人事ファイルから指定した従業員のレコードを取得する\code{get\-/record}手続きを
本部向けに実装せよ。この手続きは、任意の事業所のファイルに適用できる必要がある。
個々の事業所のファイルはどのように構造化しなければならないか説明せよ。具体的には、
どのような型情報を提供する必要があるだろうか。

\item
任意の事業所の人事ファイル内の与えられた職員のレコードから給与情報を返す\code{get\-/salary}
手続きを本部向けに実装せよ。この演算が動くようにするには、レコードはどのように構造化
しなければならないだろうか。

\item
本部向けに、\code{find\-/employee\-/record}手続きを実装せよ。この手続きは、全事業所の
ファイルから与えられた従業員を検索し、該当レコードを返す。引数として、従業員名と
全事業所のファイルのリストを取るとせよ。

\item
貪欲社が新しい会社を吸収した場合、新しい人事情報を中央システムに組み入れるためには
どのような変更が必要になるだろうか。

\end{enumerate}
\end{quote}

\subsubsection*{メッセージパッシング}

データ主導プログラミングでポイントとなる考え方は、プログラム中のジェネリック演算を
\link{Figure 2.22}のような演算-型テーブルを明示的に扱うというところです。
\link{Section 2.4.2}で使ったプログラミングスタイルでは、それぞれの演算に自分の
ディスパッチの面倒を見させることによって、必要となる型ディスパッチを構築していました。
実質的には、それぞれのジェネリック演算手続きがテーブルの行を表すというやり方で、
演算-型テーブルを行に分解していたことになります。

もうひとつの実装戦略は、テーブルを列に分解し、データ型によってディスパッチを行う
``賢い演算''を使うのではなく、演算の名前によってディスパッチを行う
``賢いデータオブジェクト''を使うというものです。これを実現するには、データオブジェクト
(例えば直交形式の複素数)を手続きとして表現し、その手続きは実行するべき演算名を引数として
取り、指定された演算を実行するというようにします。このような規律に従うと、
\code{make\-/from\-/real\-/imag}は以下のように書くことができます。

\begin{scheme}
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude)
           (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else (error "Unknown op: 
                        MAKE-FROM-REAL-IMAG" op))))
  dispatch)
\end{scheme}

\noindent
\code{apply\-/generic}手続きはジェネリック演算を引数に適用するものでしたが、
このデータに対応する\code{apply\-/generic}手続きは、単に演算の名前をデータオブジェクトに
渡して、オブジェクトに仕事をさせるだけになります。
\footnote{
この仕組みの制約のひとつは、一引数のジェネリック手続きしか使えないということです。
}

\begin{scheme}
(define (apply-generic op arg) (arg op))
\end{scheme}

\noindent
\code{make\-/from\-/real\-/imag}の返す値が手続き---内部手続き\code{dispatch}---である
ことに注意してください。これは、\code{apply\-/generic}が演算の実行を要求したときに
呼び出される手続きです。



このプログラミングスタイルは\newterm{message passing}(\jnewterm{メッセージパッシング})と
呼ばれています。この名前は、データオブジェクトは要求された演算の名前を``メッセージ''として
受け取る実体であるというイメージから来ています。メッセージパッシングの例については、
\link{Section 2.1.3}ですでに見ています。そこでは、\code{cons}, \code{car}, \code{cdr}が
データオブジェクトを使わずに手続きだけを使って定義できるということを見てきました。
ここでは、メッセージパッシングがただの数学的トリックではなく、ジェネリック演算によって
システムを組み立てるうえでの便利な技術だということを示しました。この章の残りでは、
ジェネリックな算術演算について検討するために、メッセージパッシングではなくデータ主導
プログラミングを使い続けることにします。\link{Chapter 3}ではメッセージパッシングに戻り、
それがシミュレーションプログラムを構築するうえでの強力なツールになるということを見て
いきます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.75}Exercise 2.75:} 
コンストラクタ\code{make\-/from\-/mag\-/ang}をメッセージパッシングスタイルで実装せよ。
この手続きは、上で与えた\code{make\-/from\-/real\-/imag}と似たようなものになるだろう。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.76}Exercise 2.76:} 
ジェネリック演算を使った大きなシステムが発展するにつれ、新しいデータオブジェクトの型や
新しい演算が必要になることがある。三つの戦略(明示的ディスパッチによるジェネリック演算、
データ主導スタイル、メッセージパッシングスタイル)それぞれについて、新しい型や新しい
演算を追加するために必要な変更を記述せよ。新しい型がよく追加されるシステムでは、どの
どの組み立て方が最も適しているだろうか。新しい演算を追加するシステムでは、どれが最も
適しているだろうか。
\end{quote}

\section{ジェネリック演算によるシステム}
\label{Section 2.5}

前の節では、データオブジェクトの表現が二通り以上あるシステムの設計方法について
見てきました。ポイントとなる考え方は、ジェネリックインターフェイスという手段によって、
データ演算を指定するコードをいくつかの表現に結びつけるというものでした。ここでは、
同じ考え方を使って、いろいろな表現に対してジェネリックな演算を定義するだけでなく、
いろいろな種類の引数に対してジェネリックな演算を定義するやり方について見ていきます。
ここまで、いくつもの算術演算パッケージに触れてきました。言語組み込みの基本算術演算
(\code{+}, \code{-}, \code{*}, \code{/})、\link{Section 2.1.1}の有理数演算
(\code{add\-/rat}, \code{sub\-/rat}, \code{mul\-/rat}, \code{div\-/rat})、
それに\link{Section 2.4.3}で実装した複素数演算があります。今度はデータ主導テクニックを
使い、これまでに構築してきたすべての算術演算パッケージを合併した算術演算パッケージを
構築します。

\begin{figure}[tb]
\phantomsection\label{Figure 2.23}
\centering
\begin{comment}
\label{Figure 2.23}
\heading{Figure 2.23:} Generic arithmetic system.

\begin{example}
                        Programs that use numbers
                           +-----------------+
---------------------------| add sub mul div |-------------------
                           +-----------------+
                        Generic arithmetic package
 +-----------------+   +-------------------------+
 | add-rat sub-rat |   | add-complex sub-complex |   +---------+
-|                 |-+-|                         |-+-| + - * / |-
 | mul-rat div-rat | | | mul-complex div-complex | | +---------+
 +-----------------+ | +-------------------------+ |
      Rational       |     Complex artithmetic     |   Ordinary
     arithmetic      +--------------+--------------+  arithmetic
                     | Rectangular  |     Polar    |
---------------------+--------------+--------------+-------------
             List structure and primitive machine arithmetic
\end{example}
\end{comment}
\includegraphics[width=111mm]{fig/chap2/Fig2.23a.pdf}
\par\bigskip
\noindent
\heading{Figure 2.23:} ジェネリック算術演算システム
\end{figure}

\link{Figure 2.23}は、これから構築するシステムの構造を示しています。抽象化の壁に
注目して下さい。``数値''を使う人の視点からは、どんな種類の数が与えられても演算を
行う\code{add}というたったひとつの手続きだけが見えています。\code{add}はジェネリック
インターフェイスの一部で、別々になっている通常の算術演算、有理数の算術演算、複素数の
算術演算のパッケージに、数値を使うプログラムから統一的なアクセスができるようにします。
個々の算術演算パッケージ(例えば複素数パッケージ)は、それ自身、異なる表現
(例えば直交形式と極形式)のために設計された複数のパッケージを連結するジェネリック手続き
(例えば\code{add\-/complex})によってアクセスするようになっていることもあります。
また、システムの構造は加法的なので、それぞれの算術演算パッケージは別々に設計して
組み合わせてジェネリック算術演算システムを作れるようになっています。

\subsection{ジェネリック算術演算}
\label{Section 2.5.1}


ジェネリック算術演算を設計するというタスクは、ジェネリック複素数演算を設計するのと
似たようなものになります。例えば、通常の数値に対しては基本手続きの足し算\code{+}の
ようにふるまい、有理数に対しては\code{add\-/rat}のようにふるまい、複素数に対しては
\code{add\-/complex}のようにふるまうジェネリックな足し算手続き\code{add}がほしい
ところです。\code{add}その他のジェネリック算術演算は、\link{Section 2.4.3}で複素数の
ジェネリックなセレクタの実装に使ったのと同じ戦略によって実装できます。それぞれの
種類の数値にタイプタグをくっつけ、ジェネリック手続きが引数のデータ型によって適切な
パッケージにディスパッチを行うようにします。

ジェネリック算術演算手続きは、次のように定義します。

\begin{scheme}
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
\end{scheme}

\noindent
まず、\newterm{ordinary}(\jnewterm{通常の})数値、つまり言語の基本数値を扱うパッケージを
組み込みます。通常の数値には\code{scheme\-/number}という記号のタグをつけることにします。
このパッケージの算術演算は基本算術演算手続きです(つまり、タグなし数値を扱うのに新たに
手続きを定義する必要はありません)。これらの演算はそれぞれ二つの引数を取るので、テーブルには
\code{(scheme\-/number scheme\-/number)}というリストをキーとして組み込みます。

\begin{scheme}
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
\end{scheme}

\noindent
scheme-numberパッケージのユーザは、次の手続きによって(タグつきの)通常の数値を作成します。

\begin{scheme}
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
\end{scheme}

\noindent
ジェネリック算術演算システムのフレームワークがもうできているので、新しい種類の数値を
加えることは簡単にできます。以下は、有理数算術演算を行うパッケージです。加法性のおかげで、
\link{Section 2.1.1}の有理数のコードを修正なしでパッケージの内部手続きとして使えるという
ところに注目してください。

\begin{scheme}
(define (install-rational-package)
  ~\textrm{;; 内部手続き}~
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  ~\textrm{;; システムのほかの部分とのインターフェイス}~
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
\end{scheme}

\noindent
複素数を扱う同様のパッケージを、\code{complex}というタグを使って組み込みます。
このパッケージを作る際に、直交形式と極形式のパッケージで定義した演算
\code{make\-/from\-/real\-/imag}と\code{make\-/from\-/mag\-/ang}をテーブルから
取り出しています。加法性のおかげで、\link{Section 2.4.1}の手続き
\code{add\-/complex}, \code{sub\-/complex}, \code{mul\-/complex}, \code{div\-/complex}
が内部手続きとして使えます。

\begin{scheme}
(define (install-complex-package)
  ~\textrm{;; 直交形式パッケージと極形式パッケージからインポートした手続き}~
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ~\textrm{;; 内部手続き}~
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ~\textrm{;; システムのほかの部分とのインターフェイス}~
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
\end{scheme}

\noindent
複素数パッケージの外部のプログラムは、複素数を構築するのに実部と虚部を使うこともできますし、
絶対値と偏角を使うこともできます。元の手続きは、本来は直交形式パッケージと
極形式パッケージの中で定義されたものですが、そこから複素数パッケージにエクスポートされ、
さらにそこから外の世界へとエクスポートされているというところに注目してください。

\begin{scheme}
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
\end{scheme}

\noindent
ここでは、二つのレベルのタグシステムができています。\( 3 + 4i \)のような典型的な複素数は、
\link{Figure 2.24}に示すように表現されることになります。外側のタグ(\code{complex})は、
数値を複素数パッケージに送るために使われます。複素数パッケージに入ると、次のタグ
数値を直行形式パッケージに送るのに(\code{rectangular})タグが使われます。
巨大で複雑なシステムでは、多くのレベルが、それぞれ次のレベルとジェネリック演算という
手段によって接続されるという形で存在するということがありえます。データオブジェクトが
``下向きに''渡されるにつれ、適切なパッケージに送るために使われた外側のタグは
(\code{contents}の適用によって)はがされ、(もしあれば)次のレベルのタグが
見えるようになり、さらなるディスパッチに使われます。

\begin{figure}[tb]
\phantomsection\label{Figure 2.24}
\centering
\begin{comment}
\heading{Figure 2.24:} Representation of \( 3 + 4i \) in rectangular form.

\begin{example}
     +---+---+     +---+---+     +---+---+
---->| * | *-+---->| * | *-+---->| * | * |
     +-|-+---+     +-|-+---+     +-|-+-|-+
       |             |             |   |
       V             V             V   V
 +---------+   +-------------+  +---+ +---+
 | complex |   | rectangular |  | 3 | | 4 |
 +---------+   +-------------+  +---+ +---+
\end{example}
\end{comment}
\includegraphics[width=64mm]{fig/chap2/Fig2.24c.pdf}
\par\bigskip
\noindent
\heading{Figure 2.24:} 直行形式による\( 3 + 4i \)の表現
\end{figure}

上記のパッケージでは、\code{add\-/rat}, \code{add\-/complex}その他の算術演算手続きは、
最初に書いたときそのままの状態で使いました。しかし、これらの定義が異なるインストール
手続きの内部に入ると、互いに識別できる名前である必要はなくなります。両方のパッケージで、
単に\code{add}, \code{sub}, \code{mul}, \code{div}という名前をつけていたとしても大丈夫です。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.77}Exercise 2.77:} 
Louis Reasonerは、式\code{(magnitude z)}を評価しようとした。ここで、\code{z}は
\link{Figure 2.24}に示したオブジェクトである。驚いたことに、5という答えが返ってくるのでは
なく、\code{apply\-/generic}からのエラーメッセージが返ってきて、型\code{(complex)}には
\code{magnitude}という演算を行う手続きがないという。彼がこのやりとりをAlyssa P. Hackerに
見せると、Alyssaは``複素数セレクタが\code{polar}と\code{rectangular}の数値にだけしか
定義されていなくて、\code{complex}の数値に対して定義されていないのが問題なのよ。
動くようにするには\code{complex}パッケージに以下の式を追加すれば大丈夫。''と言う。

\begin{scheme}
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
\end{scheme}

なぜこれが動くのか、詳しく説明せよ。例として、\code{z}が\link{Figure 2.24}に示した
オブジェクトであるとき、式\code{(magnitude z)}を評価した際に呼ばれるすべての手続きを
トレースせよ。具体的には、\code{apply\-/generic}は何回起動されるだろうか。
それぞれの場合について、ディスパッチ先の手続きは何になるだろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.78}Exercise 2.78:} 
\code{scheme\-/number}パッケージの内部手続きは、本質的に基本手続き\code{+}, \code{-}
その他に対する呼び出しでしかない。ここでのタイプタグシステムでは、各データオブジェクトに
型がくっついていないといけないようになっていたので、直接この言語の基本手続きを使う
ことはできなかった。しかし、実際のところ、Lisp の実装はすべて型システムを持っていて、
内部で使用している。\code{symbol?}や\code{number?}のような基本述語は、データオブジェクトが
特定の型を持つか判別している。\link{Section 2.4.2}の\code{type\-/tag}, \code{contents},
\code{attach\-/tag}の定義を変更し、ここでのジェネリックシステムがSchemeの内部型システムを
利用できるようにせよ。つまり、システムの挙動はそのままで、普通の数値を\code{car}が
\code{scheme\-/number}という記号であるペアとして表すのではなく、単にSchemeの数値として
表現されるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.79}Exercise 2.79:}
二つの数値の等価性をテストするジェネリックな等価性述語\code{equ?}を定義し、
ジェネリック算術演算パッケージに組み込め。この演算は、通常の数値、有理数、複素数に対して
動作しなければならない。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.80}Exercise 2.80:} 
引数が0であるかテストするジェネリックな述語\code{=zero?}を定義し、ジェネリック算術
演算パッケージに組み込め。この演算は、通常の数値、有理数、複素数に対して動作しなければ
ならない。
\end{quote}

\subsection{異なる型のデータを組み合わせる}
\label{Section 2.5.2}

ここまで、統合算術演算システムの定義の仕方について見てきました。このシステムは、
通常の数値、複素数、有理数を含み、またこのほかどんな数値のタイプでも作って組み込む
ことができるものでした。しかし、無視してきた重要な問題がひとつあります。ここまでで
定義してきた演算は、異なるデータ型を完全に独立したものとして扱うようになっています。
つまり、例えば二つの通常の数字を足すのと二つの複素数を足すのに別々のパッケージが
あるということです。考えの対象外にしていたのは、型の境界を超えた演算、例えば複素数と
通常の数値との足し算のようなものについて考えることに意味があるという事実です。
私たちは、プログラムの部品同士の間に壁を作り、独立して開発したり理解したりできるように
することに多大な労力をつぎ込んできました。ここでは、注意深くコントロールされた
やり方でクロスタイプ(異なる型同士)の演算を導入し、モジュール境界を大きく壊すことなく
それらの演算をサポートできるようにします。

クロスタイプ演算を扱う方法のひとつは、可能な型の組み合わせの中で、演算が有効であるもの
それぞれに対して別々の手続きを設計するというものです。例えば、複素数パッケージを拡張し、
複素数と実数の足し算を提供するようにして、\code{(complex scheme\-/number)}というタグを
使ってテーブルに組み込むということができます。
\footnote{このほかに、\code{(scheme\-/number complex)}という二つの型を扱うために、
ほとんど同じ手続きをもうひとつ用意する必要があります。}

\begin{scheme}
  ~\textrm{;; 複素数パッケージに含める}~
(define (add-complex-to-schemenum z x)
  (make-from-real-imag (+ (real-part z) x) (imag-part z)))
(put 'add '(complex scheme-number)
     (lambda (z x) (tag (add-complex-to-schemenum z x))))
\end{scheme}

\noindent
このテクニックはうまくいくのですが、面倒です。このようなシステムでは、新しい型を導入する
コストが、その型を扱う手続きのパッケージの構築だけでは終わらず、クロスタイプ演算を
実装する手続きを構築して組み込む分まで必要になります。これはあっという間に、その型自身の
演算を定義するのに必要な分よりずっと多い量になってしまいます。この手法はまた、別々の
パッケージを加法的に組み合わせる能力を台無しにしてしまいます。少なくとも、個々のパッケージを
実装する人がほかのパッケージについてあまり考慮しないでいいようにするという能力は台無しに
なってしまいます。例えば、上の例では、複素数と通常の数値の混合演算を扱うのが複素数
パッケージの責任だということは妥当に見えます。しかし、有理数と複素数を組み合わせるのは、
複素数パッケージでやってもいいし、有理数パッケージでやってもいいし、これら二つの
パッケージから演算を抽出する何らかの第三ののパッケージでやってもいいかもしれません。
複数のパッケージにわたる責任の分割について一貫したポリシーを策定するということは、
多くのパッケージと多くのクロスタイプ演算を伴うシステムを設計する際には、どうしようも
ないほど大変なタスクになってしまうでしょう。

\subsubsection*{強制型変換}

まったく関係のない型同士のまったく関連のない演算という一般的な状況では、
たとえ面倒でも、明示的なクロスタイプ演算を実装することぐらいしかできません。
幸い普通は、型システムに隠れているかもしれない積み上げ式の構造を利用して、
もっとうまくやることができます。別々のデータ型が完全に独立しているというわけでは
なく、ある型のオブジェクトをほかの型と見なす方法があるということはよくあります。
このプロセスは、\newterm{coercion}(\jnewterm{強制型変換})と呼ばれます。例えば、
通常の数値と複素数を算術演算によって組み合わせることを求められたら、通常の数値を
虚部がゼロの複素数と見なすことができます。こうすると、この問題を二つの複素数を
組み合わせる問題に変換でき、複素数パッケージによって普通のやり方で扱うことが
できるようになります。

一般に、ある型のオブジェクトを等価なほかの型のオブジェクトに変換する強制型変換手続きを
設計することによって、この考え方を実装できます。以下のものは典型的な強制型変換手続きで、
与えられた通常の数値を、実部がその数値で虚部がゼロの複素数に変換します。

\begin{scheme}
(define (scheme-number->complex n)
  (make-complex-from-real-imag (contents n) 0))
\end{scheme}

\noindent
これらの強制型変換手続きは、特別な強制型変換テーブルに組み込むことにします。
二つの型の名前をキーとして使います。

\begin{scheme}
(put-coercion 'scheme-number
              'complex 
              scheme-number->complex)
\end{scheme}

\noindent
(このテーブルを操作するための手続き\code{put\-/coercion}と\code{get\-/coercion}が
存在すると仮定しています)一般に、このテーブルにはいくつか空きができます。
すべての型の任意のデータオブジェクトをほかのすべての型に強制型変換するということは、
一般的には可能でないからです。例えば、任意の複素数を実数に強制型変換する方法というものは
ありません。そのため、一般的な\code{complex\-/>scheme\-/number}手続きがテーブルに
含まれるということはありません。

強制型変換テーブルが準備できたら、\link{Section 2.4.3}の\code{apply\-/generic}手続きに
変更を加えることによって、強制型変換を統一的に扱うことができるようになります。演算を
適用することを求められたら、最初はこれまでと同じように引数の型に対して演算が定義されて
いるかどうかチェックします。定義されていれば、演算-型テーブルで見つかった手続きに
ディスパッチします。定義されていなければ、強制型変換を試みます。簡単にするために、
ここでは引数が二つの場合だけを考えます。\footnote{一般化については\link{Exercise 2.82}を
参照。}強制型変換テーブルを見て、一つ目の型のオブジェクトが二つ目の型に強制型変換可能か
どうか確認します。可能であれば、一つ目の引数を強制型変換し、もう一度演算を試みます。
もし一つ目の型のオブジェクトが二つ目の型に一般的に強制型変換できないのであれば、逆に
二つ目の引数を一つ目の引数の型に強制型変換できないか試してみます。最後に、どちらの型に
ついてももう一方の型に強制型変換する既知の方法がなければ、諦めます。手続きは以下のように
なります。

\begin{smallscheme}
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2 
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1 
                         (apply-generic op a1 (t2->t1 a2)))
                        (else (error "No method for these types"
                                     (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))
\end{smallscheme}

\noindent
上でざっくり見たように、この強制型変換という構想は、明示的にクロスタイプ演算を定義する
という手法に比べて多くのメリットがあります。型同士を関連づけるために強制型変換手続きを
書く(\( n \)個の型を持つシステムに対しては、最大で\( n^2 \)個の手続き)ということはやはり
必要ですが、書く必要があるのはそれぞれの型のペアに対して手続きひとつだけで、それぞれの
型の集合とそれぞれのジェネリック演算に対して別々の手続きを書く必要はありません。
\footnote{うまくやると、普通は\( n^2 \)よりも少ない数の強制型変換手続きで済ませることが
できます。例えば、もし型1から型2への変換方法と型2から型3への変換方法がわかっていれば、
この知識を使って型1から型3に変換することができます。このやり方を使うと、システムに
新しい型を追加する際に明示的に提供する必要のある強制型変換手続きの数を劇的に減らすことが
できます。もしシステムを必要なだけ高度なものにする準備があるのなら、システムが型同士の
関係の``グラフ''を検索して、明示的に提供された強制型変換手続きから推論できる強制型変換
手続きを自動的に生成させることもできます。}ここでは、型同士の適切な変換は型そのものによって
決まり、適用する演算には依存しないという事実を利用しています。

一方、この強制型変換構想の持つ汎用性では十分でない応用もあるかもしれません。組み合わせる
オブジェクトのどちらももう一方の型に変換できないという場合でも、両方のオブジェクトを
第三の型に変換することで演算の実行が可能かもしれません。そのような複雑な場合を扱いながら
プログラムのモジュール性を維持するためには、普通は型同士の関係のさらに深い構造を利用する
システムを構築することが必要になります。これについては次節で検討します。

\subsubsection*{型の階層}

上で紹介した強制型変換構想は、型のペアの間に自然な関係があるということを頼りにしていました。
しかし、異なる型の間の関係には、より``グローバルな''構造があるということがよくあります。
例えば、整数、有理数、実数、複素数を扱うジェネリック算術演算システムを構築していると
しましょう。そのようなシステムでは、整数を特別な種類の有理数と見なし、有理数を特別な種類の
実数と見なし、実数を特別な種類の複素数と見なすというのはとても自然です。ここで実際に扱って
いるのはいわゆる\newterm{hierarchy of types}(\jnewterm{型の階層})というもので、その中では、
例えば整数は有理数の\newterm{subtype}(\jnewterm{サブタイプ})(つまり、有理数に適用できる任意の
演算は自動的に整数に適用できる)ということになります。逆に、有理数は整数の\newterm{supertype}
(\jnewterm{スーパータイプ})と呼びます。ここで扱っている特定の階層はとても単純なもので、
それぞれの型は高々ひとつのスーパータイプと高々ひとつのサブタイプを持ちます。このような
構造は\newterm{tower}(\jnewterm{タワー})と呼ばれます。\link{Figure 2.25}にこの構造を示します。

\begin{figure}[tb]
\phantomsection\label{Figure 2.25}
\centering
\begin{comment}
\heading{Figure 2.25:} A tower of types.

\begin{example}
 complex
   ^
   |
  real
   ^
   |
rational
   ^
   |
integer
\end{example}
\end{comment}
\includegraphics[width=11mm]{fig/chap2/Fig2.25.pdf}
\par\bigskip
\noindent
\heading{Figure 2.25:} 型のタワー
\end{figure}

もし扱っているのがタワー構造であれば、階層に新しい型を追加するという問題はとても
簡単にできます。新しい型をすぐ上のスーパータイプに組み入れる方法と、新しい型が
すぐ下の型のどのようなスーパータイプであるかを記述するだけで十分だからです。
例えば、複素数と整数の足し算をしたい場合、明示的に\code{integer\-/>complex}
という特別な強制型変換手続きを定義する必要はありません。その代わりに、整数の
有理数への変換方法、有理数の実数への変換方法、実数の複素数への変換方法を定義します。
次に、システムがこれらのステップを通して整数を複素数に変換できるようにして、
それから二つの複素数を足し合わせます。

\code{apply\-/generic}手続きは、次のように設計し直すことができます。それぞれの型に
対して、その型のオブジェクトをタワーの一階上に``上げる''\code{raise}という手続きを用意
します。こうすると、システムが異なる型のオブジェクトの演算を行うよう求められたとき、
すべてのオブジェクトが塔の同じ階に揃うようになるまで低い型を連続して上げていくという
ことができるようになります(\link{Exercise 2.83}と\link{Exercise 2.84}は、そのような
戦略の実装の詳細に関係するものです)。

タワーの別の利点として、すべての型がスーパータイプに定義されたすべての演算を
``継承する''という概念を簡単に実装できるということがあります。例えば、整数に
対して実部を求める特別な手続きを提供していないとしても、整数は複素数のサブタイプ
なので、整数に対しても\code{real\-/part}が定義されていることが期待されます。
タワーであれば、\code{apply\-/generic}を修正して、統一的な方法でこれを実現できます。
もし必要な演算が与えられたオブジェクトの型に対して直接定義されていなければ、
オブジェクトをそのスーパータイプに上げて再試行します。こうやって、望む演算が実行可能に
なる階にたどり着くか、てっぺんに当たるか(その場合はあきらめることになります)するまで、
引数を変換しながらタワーを登っていきます。

より一般的な階層に対してのタワーのもう一つの利点は、データオブジェクトを最も単純な
表現に``下げる''ことが簡単にできるということがあります。例えば、\( 2 + 3i \)と
\( 4 - 3i \)を足す場合、複素数\( 6 + 0i \)という形で答えを得るよりも、整数の6という
答えを得るほうがいいでしょう。\link{Exercise 2.85}では、そのようなレベル下げ演算に
ついて検討します(注意すべきところは、レベル下げが可能な\( 6 + 0i \)のような
オブジェクトと、レベル下げが不可能な\( 6 + 2i \)のようなオブジェクトを見分ける
一般的な方法が必要だというところです)。

\subsubsection*{階層の不適切さ}

システムのデータ型が自然にタワーとして配置できる場合、ここまで見てきたように、
異なる型同士のジェネリック演算の問題はとても単純になります。残念ながら、
普通はそうはいきません。\link{Figure 2.26} はいろいろな型のより複雑な関係を
図示したものです。この例では、さまざまな型の幾何学図形同士の関係を示しています。
この図から、一般的にはひとつの型が二つ以上のサブタイプを持つということが見て取れます。
例えば、三角形と四角形はどちらも多角形のサブタイプです。それに加えて、ひとつの型が
二つ以上のスーパータイプを持つこともあります。例えば、直角二等辺三角形は二等辺三角形と
見なすこともできますし、直角三角形と見なすこともできます。この複数スーパータイプ問題は
特に厄介です。ある型を階層の中で``上げる''ための唯一の方法というものがないということに
なるからです。あるオブジェクトにある演算を適用する際に、``正しい''スーパータイプを
見つけるために、\code{apply\-/generic}のような手続きが型ネットワーク全体の中を
かなり検索しないといけないことになるかもしれません。一般的に、ひとつの型には複数の
サブタイプがあるので、値を型階層の中で``下げる''強制型変換にも同じような問題があります。
巨大システムを設計する際に、モジュール性を保ちながら相互に関連する多くの型を取り扱う
ということは非常に難しく、現在多くの研究がなされている領域です。
\footnote{この文は第一版にもあったものですが、12年前と同じように、現状に対しても
当てはまります。いろいろな型を持つ実体同士の関係(哲学者が``オントロジー''と呼ぶもの)
を表現する実用的で汎用的なフレームワークを開発するということは、どうしようもないほど
難しいように思えます。10年前に存在した混乱といま存在する混乱の主な違いは、今では
いろいろな不適切なオントロジーの理論が、同じように不適切なプログラミング言語の山に
組み入れられているということです。例えば、オブジェクト指向言語の複雑性---それと、
現代的なオブジェクト指向言語同士の微妙で混乱を招く相違点---の多くは、相互に関連する
型に対するジェネリック演算の扱いが中心となっています。\link{Chapter 3}では計算
オブジェクトについて検討しますが、これらの問題を完全に回避しています。オブジェクト
指向言語に慣れた読者は、\link{Chapter 3}で局所状態についてかなり紙面を費やして
いるのに、``クラス''や``継承''には一言も触れていないことに気づくと思います。
実際のところ、知識表現や自動推論の研究成果を利用することなしに、これらの問題を
コンピュータ言語設計という観点のみから解決することはできないのではないかと私たちは
疑っています。}

\begin{figure}[tb]
\phantomsection\label{Figure 2.26}
\centering
\begin{comment}
\heading{Figure 2.26:} Relations among types of geometric figures.

\begin{example}
                     polygon
                    /       \
                   /         \
            triangle         quadrilateral
            /     \              /     \
           /       \            /       \
     isosceles   right      trapezoid   kite
     triangle    triangle       |         |
      |     \      |            |         |
      |      \     |            |         |
equilateral   isosceles   parallelogram   |
triangle      right          |       \    |
              triangle       |        \   |
                          rectangle  rhombus
                                \    /
                                 \  /
                                square
\end{example}
\end{comment}
\includegraphics[width=96mm]{fig/chap2/Fig2.26e.pdf}
\par\bigskip
\noindent
\heading{Figure 2.26:} 幾何学図形の型の間の関係
\end{figure}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.81}Exercise 2.81:} 
Louis Reasonerは、引数の型がすでに同じであっても、\code{apply\-/generic}は引数を
お互いの型に強制型変換しようとしてもいいのではないかと気がついた。そのため、
それぞれの型の引数をそれ自身の型に\newterm{coerce}(\jnewterm{強制型変換})する
手続きを強制型変換テーブルに入れる必要があると彼は考えた。例えば、上に示した
\code{scheme\-/number\-/>complex}という強制型変換に加え、彼は次のことを行う。

\begin{scheme}
(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)
(put-coercion 'scheme-number 
              'scheme-number
              scheme-number->scheme-number)
(put-coercion 'complex 'complex complex->complex)
\end{scheme}

\begin{enumerate}[a]

\item
Louisの強制型変換手続きを組み込むと、もし\code{scheme\-/number}型の二つの引数や
\code{complex}型の二つの引数とある演算に対して\code{apply\-/generic}が呼ばれ、
その演算がテーブル内でそれらの型に対して見つからない場合は、何が起こるだろうか。
例えば、ジェネリックな指数関数演算を定義したとする。

\begin{scheme}
(define (exp x y) (apply-generic 'exp x y))
\end{scheme}

\noindent
そして、Scheme-numberパッケージに対して指数関数手続きを追加し、ほかのパッケージには
追加しないとする。

\begin{scheme}
~\textrm{;; 以下はScheme-numberパッケージに追加する}~
(put 'exp '(scheme-number scheme-number)
     (lambda (x y) (tag (expt x y)))) 
     ~\textrm{; 基本手続き\code{expt}を使う}~
\end{scheme}

\noindent
\code{exp}を二つの複素数の引数で呼び出した場合、何が起こるだろうか。

\item
同じ型の引数に対する強制型変換について手を加えないといけないとする
Louisの考え方は正しいだろうか。それとも、\code{apply\-/generic}はそのままの状態で
正しく動作するだろうか。

\item
\code{apply\-/generic}を修正し、二つの引数が同じ型であれば強制型変換を試行しないように
せよ。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.82}Exercise 2.82:} 
\code{apply\-/generic}を一般化し、複数の引数一般について強制型変換を扱うようにする
やり方を示せ。戦略のひとつとしては、すべての引数を一つ目の引数の型に強制型変換する
ことを試み、次に二つ目の引数の型に強制型変換することを試み、ということを続けるという
ものだ。この戦略について(また、上で述べた二引数バージョンについても)、それが
十分に一般的でないような状況の例を挙げよ(ヒント：テーブルには適切な混合型演算があり、
それが試行されないという場合について考える)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.83}Exercise 2.83:} 
\link{Figure 2.25}に示した型のタワー(整数、有理数、実数、複素数)を扱う
ジェネリック算術演算システムを設計しているとする。それぞれの型(複素数を除く)に対し、
その型のオブジェクトをタワーの中で一階上げる手続きを設計せよ。それぞれの型
(複素数を除く)に対して動作するジェネリックな\code{raise}演算を組み込む方法を
示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.84}Exercise 2.84:} 
\link{Exercise 2.83}の\code{raise}演算を使って\code{apply\-/generic}手続きを修正して、
この節で検討した通り、連続して``上げる''という方法によって引数が同じ型を持つよう
強制型変換を行うようにせよ。二つの型のどちらがタワーの中で高い位置にあるかを
テストする方法を考える必要がある。システムのほかの部分と``互換性がある''ようなやり方で
これを行い、タワーに新しい階を追加する際に問題を引き起こさないようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.85}Exercise 2.85:} 
この節では、あるデータオブジェクトを型のタワーの中で可能な限り下げていくことによって
``単純化''するという方法について触れた。\link{Exercise 2.83}で述べたタワーについて、
これを実行する手続き\code{drop}を設計せよ。ポイントは、オブジェクトを下げることが
できるかどうかを何らかの汎用的なやり方で決めるということにある。例えば、複素数
\( 1.5 + 0i \)は\code{real}まで下げることができ、複素数\( 1 + 0i \)は
\code{integer}まで下げることができるが、複素数\( 2 + 3i \)はまったく下げることが
できない。以下に、あるオブジェクトを下げることができるかどうかを決める計画のひとつを
示す。まず、オブジェクトをタワーの中で一階下に``押す''ジェネリック演算\code{project}
(射影)を定義する。例えば、複素数の射影では虚部を捨てることになる。こうすると、
ある数値を\code{project}して、その結果を元の型に\code{raise}したときに、最初のものと
等しい何かになっていれば、その数値は下げることができるということになる。
可能な限りオブジェクトを落とす手続き\code{drop}を書くことで、この考え方を実装する
やり方を詳しく示せ。いろいろな射影演算を設計し
\footnote{実数は、引数に最も近い整数を返す基本手続き\code{round}を使って整数に射影
できる。}、\code{project}をジェネリック演算としてシステムに組み込むことが必要になる。
また、\link{Exercise 2.79}で述べたジェネリック等価性述語を利用することも必要となる。
最後に、\code{drop}を使って\link{Exercise 2.84}の\code{apply\-/generic}を書き直し、
解答を``単純化''するようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.86}Exercise 2.86:}
複素数の実部、虚部、絶対値、偏角に、通常の数値や有理数や、これからシステムに
追加するその他の数値を使えるようにしたいとする。そのような複素数を使えるように
するために、システムにどのような変更を加える必要があるか説明し、それを実装せよ。
通常の数値と有理数に対してジェネリックに使える\code{sine}や\code{cosine}のような
演算を定義する必要があるだろう。
\end{quote}

\subsection{例: 記号代数}
\label{Section 2.5.3}

記号代数式の操作は複雑な処理です。それについて検討することで、大規模システムの設計の
際に起こる多くの困難な問題について知ることができます。代数式は一般に、木構造の演算子を
オペランドに適用する階層構造と見なすことができます。代数式を構築するには、
定数や変数のような基本オブジェクトから始め、これらを加算や乗算のような代数演算子に
よって組み合わせます。ほかの言語の場合と同じように、複合オブジェクトを簡単に
参照できるように抽象化を行います。記号代数での典型的な抽象化としては、線形結合、
多項式、有理関数、三角関数などの考え方があります。これらは複合``型''と見なすことが
でき、そうすることで式の処理を指示することがやりやすくなります。例えば、次の式は、
\begin{comment}

\begin{example}
x^2 sin (y^2 + 1) + x cos 2y + cos(y^3 - 2y^2)
\end{example}

\end{comment}
\begin{displaymath}
 x^2 \sin (y^2 + 1) + x \cos 2y + \cos(y^3 - 2y^2) 
\end{displaymath}
整数を係数とする\( y \)の多項式の三角関数を係数とする\( x \)の多項式として記述する
ことができます。

ここでは完全な代数処理システムを開発しようとしているわけではありません。そのような
システムは、深い代数の知識と洗練されたアルゴリズムを具現化した、非常に複雑な
プログラムになります。ここでは、代数操作の単純でありながら重要な部分である
多項式の算術演算について見ていきます。また、そのようなシステムを設計する際にどのような
決定をしなければいけないかということと、その取り組みに抽象データとジェネリック演算と
いう考え方を適用する方法について説明します。

\subsubsection*{多項式の算術演算}

多項式の数値演算を行うシステムを設計するにあたっての最初の仕事は、多項式とは何なのかを
決めることです。多項式は通常、いくつかの変数(多項式の\newterm{indeterminates}
(\jnewterm{不定元}))に関して定義されます。簡単にするために、ひとつしか不定元を持たない
多項式(\newterm{univariate polynomials}
(\jnewterm{一元多項式}))に限定することにします。
\footnote{
一方で、多項式の係数自身が別の変数に関する多項式であることは許すことにします。
こうすると、完全な多元システムと本質的に同じ表現力を持つことになりますが、
この先で述べるように、強制型変換の問題が出てきます。}
多項式は項の和として定義し、その項は係数か、不定元の冪乗か、係数と不定元の冪乗の積
であるとします。係数は、多項式の不定元と独立な代数式と定義します。例えば、
\begin{comment}

\begin{example}
5x^2 + 3x + 7
\end{example}

\end{comment}
\begin{displaymath}
 5x^2 + 3x + 7 
\end{displaymath}
は単純な\( x \)の多項式で、
\begin{comment}

\begin{example}
(y^2 + 1)x^3 + (2y)x + 1
\end{example}

\end{comment}
\begin{displaymath}
 (y^2 + 1)x^3 + (2y)x + 1 
\end{displaymath}
は係数が\( y \)の多項式である\( x \)の多項式です。

ここまでで、もういくつかの厄介な問題を避けて通ってきています。上の一番目の
多項式は、多項式\( 5y^2 + 3y + 7 \)と同じものでしょうか、それとも異なるもの
でしょうか。妥当な答えは、``多項式を純粋に数学の関数であると考えれば、同じものです。
しかし、多項式を構文形式であると考えれば、異なるものです。''となるでしょう。
また、二番目の多項式は、\( x \)の多項式を係数とする\( y \)の多項式と代数学的に
等価です。私たちのシステムはこのことを認識するべきでしょうか。しかも、多項式を表現する
方法はほかにもあります---例えば、因数の積、(一元多項式の場合)根の集合、特定の
点の集合における多項式の値のリストなどによって表すこともできます。
\footnote{
一元多項式について、与えられた点の集合における多項式の値を使うということが
特によい表現となることもあります。こうすると、多項式の算術演算は非常に単純に
なります。例えば、この方式で表現された二つの多項式の和を求めることは、対応する
点における多項式の値を足し合わせるだけでできます。より見慣れた表現に変形するには、
\( n + 1 \)個の点における多項式の値から\( n \)次の多項式の係数を復元する
ラグランジュの補間公式が使えます。}
この代数操作システムでは、``多項式''というのは特定の構文形式であって、
その奥にある数学的意味ではないと決めることで、これらの問題を解決することができます。

次に、多項式の算術演算をどのようなものにするか考える必要があります。この単純な
システムでは、加算と乗算だけ考えることにします。さらに、組み合わせる二つの多項式は
同じ不定元を持っていなければならないということにします。

このシステムの設計にあたっては、おなじみのデータ抽象化の規律に従います。
多項式は\newterm{poly}というデータ構造を使って表現し、\newterm{poly}はひとつの変数と
項の集まりからなります。polyからそれらの部品を抽出するセレクタ\code{variable}, 
\code{term\-/list}と、与えられた変数と項のリストからpolyを組み立てるコンストラクタ
\code{make\-/poly}があると想定します。変数はただの記号なので、変数の比較には
\link{Section 2.3.2}の\code{same\-/variable?}手続きが使えます。以下の手続きは、
polyの加算と乗算を定義するものです。

\begin{scheme}
(define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (add-terms (term-list p1)
                            (term-list p2)))
      (error "Polys not in same var: ADD-POLY"
             (list p1 p2))))

(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (mul-terms (term-list p1)
                            (term-list p2)))
      (error "Polys not in same var: MUL-POLY"
             (list p1 p2))))
\end{scheme}

\noindent
多項式を私たちのジェネリック算術演算システムに組み入れるためには、タイプタグをつける必要が
あります。タグとしては\code{polynomial}を使うことにして、タグつき多項式に対する
適切な演算を演算テーブルに組み込みます。\link{Section 2.5.1}同様、コードはすべて
多項式パッケージの組み込み手続きの中に埋め込むことにします。

\begin{scheme}
(define (install-polynomial-package)
  ~\textrm{;; 内部手続き}~
  ~\textrm{;; polyの表現}~
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  ~\( \dark \langle \)~~\emph{Section 2.3.2の\code{same\-/variable?}と\code{variable?}手続き}~~\( \dark \rangle \)~

  ~\textrm{;; 項と項リストの表現}~
  ~\( \dark \langle \)~~\emph{下記の\code{adjoin\-/term} \( \dots \) \code{coeff}手続き}~~\( \dark \rangle \)~

  (define (add-poly p1 p2) ~\( \dots \)~)
  ~\( \dark \langle \)~~\emph{\code{add\-/poly}が使う手続き}~~\( \dark \rangle \)~
  (define (mul-poly p1 p2) ~\( \dots \)~)
  ~\( \dark \langle \)~~\emph{\code{mul\-/poly}が使う手続き}~~\( \dark \rangle \)~

  ~\textrm{;; システムのほかの部分とのインターフェイス}~
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms)
         (tag (make-poly var terms))))
  'done)
\end{scheme}

\noindent
多項式の加算は項ごとに実行します。同じ次数の項(つまり、同じ指数を持つ不定元)
同士を組み合わせる必要があります。これは、足す項と足される項の係数の合計を
係数とする、同じ次数を持つ新しい項を作ることで行えます。片方にだけ項があって、
もう一方のほうに同じ次数の項がない場合は、構築中の和の多項式にその項をそのまま
追加します。

項リストを操作するために、空の項リストを返す\code{the\-/empty\-/termlist}という
コンストラクタと、項リストに新しい項を追加する\code{adjoin\-/term}というコンストラクタが
あると想定します。さらに、与えられた項リストが空かどうか調べる\code{empty\-/termlist?}という
述語と、項リストから最大次数の項を取り出すセレクタ\code{first\-/term}、最大次数の項以外の
全ての項を返すセレクタ\code{rest\-/terms}もあると想定します。項を操作するために、
与えられた次数と係数から項を構築するコンストラクタ\code{make\-/term}と、項の次数と係数を
それぞれ返すセレクタ\code{order}と\code{coeff}があると想定します。これらの演算によって、
項と項リストがデータ抽象として捉えられるようになり、具体的な表現は別に考えることができます。

以下は、二つの多項式の和となる項リストを構築する手続きです。\footnote{
この演算は、\link{Exercise 2.62}で開発した\code{union\-/set}演算にとても似ています。
実際、不定元の指数の順に並べた集合として多項式の項を考えると、和の項リストを生成する
プログラムは\code{union\-/set}とほとんど同じものになります。}

\begin{scheme}
(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1)) 
               (t2 (first-term L2)))
           (cond ((> (order t1) (order t2))
                  (adjoin-term
                   t1 (add-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term
                   t2 (add-terms L1 (rest-terms L2))))
                 (else
                  (adjoin-term
                   (make-term (order t1)
                              (add (coeff t1) (coeff t2)))
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))
\end{scheme}

\noindent
ここでの最も重要なポイントは、項の係数同士を足し合わせるのにジェネリック加算手続き
\code{add}を使っているというところです。以下で見ていくように、このことは強力な結果を
もたらします。

二つの項リストを乗算するには、\code{mul\-/term\-/by\-/all\-/terms}を繰り返し使って、
最初のリストの各項をもう一方のリストのすべての項と乗算します。
\code{mul\-/term\-/by\-/all\-/terms}は、与えられた項と与えられた項リストのすべての項と
乗算するものです。返される項リストの列(一つ目のリストの項それぞれに対してひとつずつ)を
和として蓄積します。二つの項の乗算では、各乗数の次数の和を次数とし、各乗数の係数の
積を係数とする項を作ります。

\begin{scheme}
(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2)
                 (mul-terms (rest-terms L1) L2))))
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let ((t2 (first-term L)))
        (adjoin-term
         (make-term (+ (order t1) (order t2))
                    (mul (coeff t1) (coeff t2)))
         (mul-term-by-all-terms t1 (rest-terms L))))))
\end{scheme}

\noindent
多項式の加算と乗算は本当にこれがすべてです。項の演算にはジェネリック手続き
\code{add}と\code{mul}を使っているため、ジェネリック数値演算パッケージにとって既知の
どんな型の係数でも、自動的に多項式パッケージが扱えるようになっているというところに
注意してください。\link{Section 2.5.2}で考察したような強制型変換メカニズムを組み込めば、
以下のような係数の型が異なる多項式に対する演算も自動的に扱えるようになります。
\begin{comment}

\begin{example}
                         /        2                 \
[3x^2 + (2 + 3i)x + 7] * | x^4 + --- x^2 + (5 + 3i) |
                         \        3                 /
\end{example}

\end{comment}
\begin{displaymath}
 [3x^2 + (2 + 3i)x + 7] \cdot \! \left[ x^4 + {2\over3} x^2 + (5 + 3i) \right]\!.
\end{displaymath}

\code{add\-/poly}, \code{mul\-/poly}という多項式の加算と乗算の手続きを
\code{polynomial}型の\code{add}と\code{mul}としてジェネリック算術演算システムに組み込んだ
ので、私たちのシステムは自動的に次のような多項式演算を扱えるようになっています。
\begin{comment}

\begin{example}
[(y + 1)x^2 + (y^2 + 1)x + (y - 1)] * [(y - 2)x + (y^3 + 7)]
\end{example}

\end{comment}
\begin{displaymath}
 \Big[(y + 1)x^2 + (y^2 + 1)x + (y - 1)\Big] \cdot \Big[(y - 2)x + (y^3 + 7)\Big]. 
\end{displaymath}
その理由は、システムが係数を組み合わせようとするとき、\code{add}と\code{mul}を通して
ディスパッチを行うためです。係数はそれ自身(\( y \)の)多項式なので、これらは
\code{add\-/poly}と\code{mul\-/poly}を使って組み合わされることになります。
結果として、これは``データ主導再帰''のようなものになります。例えば、\code{mul\-/poly}
を呼び出すと、係数同士をかけ算するために\code{mul\-/poly}を再帰的に呼び出す結果になる
ということです。もし係数の係数がそれ自身多項式なら(この方法は三変数の多項式を表現するのに
使えます)、データ主導の仕組みによってシステムがもう一レベルの再帰を行うことが保証されます。
データ構造によって規定されるレベルの数だけ、この再帰は続きます。
\footnote{
この仕組みが完全にスムーズに動くようにするには、ジェネリック算術演算システムに``数値''を
多項式に強制型変換する能力を追加しなければなりません。そのためには、数値を0次の多項式と
見なし、係数がその数値であるとします。これは、次のような演算を行う場合に必要になります。
\begin{comment}

\begin{example}
[x^2 + (y + 1)x + 5] + [x^2 + 2x + 1]
\end{example}

\end{comment}
\begin{displaymath}
 [x^2 + (y + 1)x + 5] + [x^2 + 2x + 1], 
\end{displaymath}
\noindent
この例では、係数\( y + 1 \)と係数2を足すことが求められます。}

\subsubsection*{項リストの表現}

最後に、項リストのよい表現を実装するという仕事に取りかからなければなりません。
項リストというのは、実質的には、項の次数をキーとする係数の集合です。つまり、
\link{Section 2.3.3}で検討したようなどんな集合の表現手法でも、このタスクに
適用することができます。一方、手続き\code{add\-/terms}と\code{mul\-/terms}は、
常に高い次数から低い次数という方向で、項リストに順次アクセスします。このため、
何らかの順序つきリスト表現を使うことにします。

項リストを表現するリストはどのように構造化するべきでしょうか。考慮するポイントのひとつは、
操作対象となる多項式の``濃度''です。多項式は、ほとんどの次数の項が0でない係数を持つ場合、
\newterm{dense}(\jnewterm{密})と呼ばれます。もし0の項が多ければ、\newterm{sparse}
(\jnewterm{疎})と呼ばれます。例えば、
\begin{comment}

\begin{example}
A : x^5 + 2x^4 + 3x^2 - 2x - 5
\end{example}

\end{comment}
\begin{displaymath}
 A: \quad x^5 + 2x^4 + 3x^2 - 2x - 5 
\end{displaymath}
\noindent
は密多項式です。
\begin{comment}

\begin{example}
B : x^100 + 2x^2 + 1
\end{example}

\end{comment}
\begin{displaymath}
 B: \quad x^{100} + 2x^2 + 1 
\end{displaymath}
\noindent
は疎です。

密な多項式の項リストは、係数のリストとして表現するのが最も効率的です。例えば上の
\( A \)は、\code{(1 2 0 3 -2 -5)}という形でうまく表現できます。この表現では、
その項の係数から始まるサブリストの長さから1を引いたものになります。
\footnote{
これらの多項式の例では、\link{Exercise 2.78}で提案したような型メカニズムを使って
ジェネリック算術演算システムを実装していると想定しています。つまり、通常の数値の係数は、
\code{car}が記号\code{scheme\-/number}であるペアとしてではなく、数値そのものによって
表現されているということです。}
しかしこれは、\( B \)のような疎な多項式の表現としてはひどいものになります。ほんの少しの
孤立した非ゼロ項によって区切られた、巨大なゼロのリストになってしまうでしょう。疎な多項式の
もうちょっとまともな表現としては、非ゼロ項のリストというものがあります。それぞれの項は、
項の次数とその次数に対する係数を含むリストになります。その計画を使う場合、多項式\( B \)は
\code{((100 1) (2 2) (0 1))}という形で効率的に表現されることになります。ほとんどの多項式
操作は疎な多項式に対して実行されるので、こちらの手法を使うことにします。項リストは
高次から低次の順に並べられた項のリストとして表現されると想定します。このことを決めれば、
セレクタとコンストラクタは素直に実装できます。\footnote{
項リストは順序つきだと想定していますが、\code{adjoin\-/term}の実装は、新しい項を
既存の項リストに単純に\code{cons}するようになっています。\code{adjoin\-/term}を使う手続き
(\code{add\-/terms}など)がこの手続きを呼ぶ際に、リスト内のものよりも高次の項を引数として
呼び出しを行うということを保証するなら、このままでも問題はありません。そのような保証を
したくなければ、順序つきリストとしての集合の表現(\link{Exercise 2.61})に対する
\code{adjoin\-/set}に近い形で\code{adjoin\-/term}を実装することもできます。}

\begin{scheme}
(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (cons term term-list)))

(define (the-empty-termlist) '())
(define (first-term term-list) (car term-list))
(define (rest-terms term-list) (cdr term-list))
(define (empty-termlist? term-list) (null? term-list))

(define (make-term order coeff) (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))
\end{scheme}

\noindent
\code{=zero?}は\link{Exercise 2.80}で定義したものです(下の\link{Exercise 2.87}も参照)。

多項式パッケージのユーザは、(タグつきの)多項式を次の手続きによって作成します。

\begin{scheme}
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.87}Exercise 2.87:} 
多項式に対する\code{=zero?}をジェネリック数値演算パッケージに組み込め。こうすることで、
係数がそれ自身多項式となっている多項式に対して\code{adjoin\-/term}が動作するようになる。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.88}Exercise 2.88:} 
多項式システムを拡張し、多項式の減算ができるようにせよ(ヒント：ジェネリックな符号反転演算を
定義するといいかもしれない)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.89}Exercise 2.89:} 
密な多項式に適していると上で述べた項リスト表現を実装する手続きを定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.90}Exercise 2.90:} 
疎な多項式と密な多項式の両方に対して効率的な多項式システムを作りたいとする。
そのためのひとつの方法は、システム内でどちらの項リスト表現も使えるようにするということで
ある。この状況は\link{Section 2.4}の複素数の例と似ている。そのときは直行形式と極形式の
どちらの表現も使えるようにした。
これを行うためには、異なる型の項リストを判別し、項リストに対する演算をジェネリックに
しなければならない。この一般化を実装するために、多項式システムを再設計せよ。
これは局所的な変更ではなく、かなりの作業が必要になる。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.91}Exercise 2.91:} 
1変数多項式は、別の1変数多項式によって割ることができる。商と剰余は多項式となる。例えば、
次のようになる
\begin{comment}

\begin{example}
x^5 - 1
------- = x^3 + x, remainder x - 1
x^2 - 1
\end{example}

\end{comment}
\begin{displaymath}
 {x^5 - 1 \over x^2 - 1} = x^3 + x, \hbox{  remainder  } x - 1. 
\end{displaymath}
除算は筆算方式で実行できる。まず、被除数の最高次の項を除数の最高次の項で割る。その答えが
商の第一項となる。次に、答えに除数をかけ、被除数からそれを引く。このようにして、
再帰的に引き算の結果を除数で割り算するということを繰り返して残りの答えを求める。
除数の次数が被除数の次数を上回ったら終わりとして、被除数を剰余とする。また、もし被除数が
ゼロになった場合には、商と剰余の両方をゼロとして返す。

\code{div\-/poly}手続きは、\code{add\-/poly}や\code{mul\-/poly}をベースに設計できる。
この手続きは、二つの多項式が同じ変数を持つかどうかチェックする。同じ変数を持つなら、
\code{div\-/poly}は変数を取り去って問題を\code{div\-/terms}に渡す。\code{div\-/terms}は
項リストに対する除算を実行する。最後に、\code{div\-/poly}は\code{div\-/terms}の結果に
変数をくっつけ直す。\code{div\-/terms}は、除算の商と剰余の両方を求めるようにするのが便利だ。
\code{div\-/terms}は項リスト二つを引数として取り、商となる項リストと剰余となる項リスト
からなるリストを返す。

次の空欄を埋め、\code{div\-/terms}の定義を完成させよ。これを使って、二つの多項式を
引数として取り、商と剰余のpolyのリストを返す\code{div\-/poly}を実装せよ。

\begin{smallscheme}
(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) (coeff t2)))
                  (new-o (- (order t1) (order t2))))
              (let ((rest-of-result
                     ~\( \langle \)~~\var{再帰的に残りを計算する}~~\( \rangle \)~
                     ))
                ~\( \langle \)~~\var{完全な結果を作る}~~\( \rangle \)~
                ))))))
\end{smallscheme}
\end{quote}

\subsubsection*{記号代数の型の階層}

私たちの多項式システムは、ある型(ここでは多項式)のオブジェクトが、実際には多くの
異なる型のオブジェクトを部品として持つ複雑なオブジェクトだということがありうることを
示しています。このことは、ジェネリック演算を定義するうえで特に難しい問題にはなりません。
必要な複合型の部品の操作を行うための適切なジェネリック演算を組み込むだけで大丈夫です。
実際、多項式は``再帰的データ抽象化''の一種となっているということを見てきました。
これは、多項式の部品がそれ自身多項式でありうるということです。ジェネリック演算と
データ主導プログラミングスタイルのおかげで、それほど苦労せずにこの複雑な問題を扱うことが
できています。

一方、多項式代数は、データ型を自然にタワー型に配置することができないシステムです。
例えば、このシステムでは係数が\( y \)の多項式である\( x \)の多項式というものが
作れます。また、係数が\( x \)の多項式である\( y \)の多項式を作ることもできます。
これらの型は、自然に考えると、片方がもう一方の``上''であるとはどうやっても言えません。
しかし、それぞれの集合の要素を足し合わせることが必要になるということはよくあります。
ひとつの可能性としては、片方の多項式を展開したり再配置したりして、もう一方の多項式の
型に変換し、両方の多項式が同じ主変数を持つようにするというものです。変数に順番をつけて、
どんな多項式でも、高優先度の変数が主変数となり低優先度の変数が係数に埋め込まれるような
``標準形''に常に変換することにすれば、タワー的な構造を押しつけることはできます。
この戦略はそれなりにうまくいくのですが、変換の過程で多項式を不必要に展開して、
読みにくくなったり、場合によっては非効率になってしまったりします。このタワー戦略と
いうのは、確実にこの領域に対して自然なものとは言えません。ユーザが古い型をいろいろな
やり方(三角関数、冪級数、積分など)によって組み合わせて動的に新しい型を発明できるような
どのような領域に対しても、同じことが言えます。

強制型変換の制御は大規模な代数処理システムを設計するうえで深刻な問題になります。
これは驚くには当たりません。そのようなシステムでは、複雑性の多くはいろいろな型同士の
関係に関わるところにあります。実際のところ、強制型変換についてはまだ完全に理解できて
いるとは言えないところがあります。それどころか、データ型という概念についても、
完全にわかっているとは言えません。それでも、私たちの知識は、大規模なシステムの設計を
支える強力な構造化とモジュール化の原則を与えてくれます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.92}Exercise 2.92:}
変数に順番をつけることによって、異なる変数の多項式同士の加算と乗算が動作するよう
多項式パッケージを拡張せよ。(これは簡単ではない!)
\end{quote}

\subsubsection*{拡張問題: 有理関数}

ジェネリック算術演算システムを拡張し、\newterm{rational functions}(\jnewterm{有理関数})を
含むようにすることもできます。これは、次のように分子と分母が多項式の``分数''です。
\begin{comment}

\begin{example}
 x + 1
-------
x^3 - 1
\end{example}

\end{comment}
\begin{displaymath}
 {x + 1 \over x^3 - 1}\,. 
\end{displaymath}
システムは、有理関数の加算、減算、乗算、除算ができなければなりません。また、
以下のような計算も実行できる必要があります。
\begin{comment}

\begin{example}
 x + 1       x      x^3 + 2x^2 + 3x + 1
------- + ------- = -------------------
x^3 - 1   x^2 - 1    x^4 + x^3 - x - 1
\end{example}

\end{comment}
\begin{displaymath}
 {x + 1 \over x^3 - 1} + {x \over x^2 - 1} = 
	{x^3 + 2x^2 + 3x + 1 \over x^4 + x^3 - x - 1}\,. 
\end{displaymath}
\noindent
(ここでは、加算結果は共通因数を取り除いて簡約されています。通常の``たすき掛け''であれば、
分子が4次多項式で分母が5次多項式分の分数になっていたところです。)

有理数算術演算パッケージを修正し、ジェネリック演算を使えるようにすれば、
分数を既約にするという問題を除いて、望むことができるようになります。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.93}Exercise 2.93:} 
有理数算術演算パッケージを修正し、ジェネリック演算を使うようにせよ。
しかし、\code{make\-/rat}は分数を既約にしようと試みないように変更せよ。
\code{make\-/rational}を二つの多項式に対して呼び出し有理関数を作ることで、
システムをテストせよ。

\begin{scheme}
(define p1 (make-polynomial 'x '((2 1)(0 1))))
(define p2 (make-polynomial 'x '((3 1)(0 1))))
(define rf (make-rational p2 p1))
\end{scheme}

次に、\code{add}を使って\code{rf}にそれ自身を足せ。この加算手続きが分数を既約にしないことが
確認できるだろう。
\end{quote}

\noindent
多項式の分数を既約にするのは、整数のところで使ったのと同じ考え方ですることができます。
\code{make\-/rat}を修正して、分子と分母の両方を、それらの最大公約数で割るようにするという
ことです。``最大公約数''という概念は、多項式についても考えることができます。実際に、
二つの多項式の\acronym{GCD}(\jnewterm{最大公約数})は、整数に対するユークリッドの
アルゴリズムと本質的に同じものを使って求めることができます。
\footnote{
ユークリッドのアルゴリズムが多項式に対して動作する働くということは、代数では、多項式が
\newterm{Euclidean ring}(\jnewterm{ユークリッド環})と呼ばれる代数領域の一種を形成すると
いうように形式化されます。ユークリッド環とは、加算、減算、交換可能な乗算を認め、
環の各元\( x \)に対して、ある性質を持った``測度''\( m(x) \)という正の整数を
割り当てる方法を持つ領域です。その性質とは、任意の非ゼロな\( x \)と\( y \)に対し
\( m(xy) \ge m(x) \)となり、任意の\( x \)と\( y \)に対し、\( y = qx + r \)で
\( r = 0 \)または\( m(r) < m(x) \)となる\( q \)が存在するというものです。

抽象化の視点からこれがユークリッドのアルゴリズムがうまく行くのに必要な条件です。
整数の定義域に対して、整数の大きさ\( m \)はその整数の絶対値です。多項式の定義域においては
多項式の大きさはその次数です。}整数版は次のようなものでした。

\begin{scheme}
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
\end{scheme}

\noindent
これを使って、自明な修正を加えて項リストに対して動く\acronym{GCD}演算を定義できます。

\begin{scheme}
(define (gcd-terms a b)
  (if (empty-termlist? b)
      a
      (gcd-terms b (remainder-terms a b))))
\end{scheme}

\noindent
ここでの\code{remainder\-/terms}は、\link{Exercise 2.91}で実装した項リスト除算演算
\code{div\-/terms}が返すリストから、剰余の部分を取り出すものです。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.94}Exercise 2.94:} 
\code{div\-/terms}を使って手続き\code{remainder\-/terms}を実装し、それを使って
\code{gcd\-/terms}を上記のように定義せよ。次に、二つの多項式に対して
多項式\acronym{GCD}を求める手続き\code{gcd\-/poly}を書け(この手続きは、
二つの多項式が同じ変数のものでなければエラーを出すようにする)。
システムに\code{greatest\-/common\-/divisor}というジェネリック演算を組み込み、
多項式は\code{gcd\-/poly}によって簡約し、通常の数値は通常の\code{gcd}によって簡約する
ようにせよ。テストとして以下を実行せよ。

\begin{scheme}
(define p1 (make-polynomial 
            'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p2 (make-polynomial 'x '((3 1) (1 -1))))
(greatest-common-divisor p1 p2)
\end{scheme}

\noindent

その結果を手計算によって確認せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.95}Exercise 2.95:} 
以下の多項式\( P_1 \), \( P_2 \), \( P_3 \)を定義せよ。
\begin{comment}

\begin{example}
P_1 : x^2 - 2x + 1

P_2 : 11x^2 + 7

P_3 : 13x + 5
\end{example}

\end{comment}
\begin{displaymath}
%  \eqalign{
% 	P_1 	&: \quad x^2 - 2x + 1, \cr
% 	P_2 	&: \quad 11x^2 + 7, \cr
% 	P_3 	&: \quad 13x + 5. \cr
% } 
\begin{array}{l@{{}:}l}
	P_1 	& \quad x^2 - 2x + 1, \\
	P_2 	& \quad 11x^2 + 7, \\
	P_3 	& \quad 13x + 5. 
\end{array}
\end{displaymath}
次に、\( P_1 \)と\( P_2 \)の積\( Q_1 \)、\( P_1 \)と\( P_3 \)の積\( Q_2 \)を定義し、
\code{greatest\-/common\-/divisor}(\link{Exercise 2.94})を使って\( Q_1 \)と\( Q_2 \)
の\acronym{GCD}を求めよ。答えが\( P_1 \)と同じにならないことに注意せよ。この例では
計算に非整数演算の演算が絡んでくるので、\acronym{GCD}アルゴリズムが困難になっている。
\footnote{
\acronym{MIT} Schemeのような実装では、この計算は確かに\( Q_1 \)と\( Q_2 \)の約数となる
多項式を生成しますが、係数は有理数になります。ほかの多くのSchemeシステムでは、
整数の除算結果は有限精度の小数となることがあるので、正しい約数が得られないことがあります。}
何が起こっているか理解するために、\acronym{GCD}の計算時に\code{gcd\-/terms}をトレース
せよ。または、この除算を手計算で実行せよ。
\end{quote}

\noindent
\link{Exercise 2.95}で出てきた問題は、以下のように\acronym{GCD}アルゴリズムを修正すると
解決できます(これは、実際には整数係数の多項式の場合にしか動作しません)。\acronym{GCD}
計算で多項式の除算を行う前にはいつも、除算過程で分数が現れないことを保証するように選んだ
整数定数を被除数にかけるようにします。こうすると、答えは実際の\acronym{GCD}と整数定数
倍だけ違うものになりますが、このことは有理関数を既約にする場合には問題になりません。
\acronym{GCD}は分子と分母の両方を割るのに使うので、整数定数倍は相殺されます。

より正確には、\( P \)と\( Q \)が多項式であるとき、\( O_1 \)を\( P \)の次数
(つまり、\( P \)の最大項の次数)とし、\( O_2 \)を\( Q \)の次数とします。
\( c \)を\( Q \)の先頭の係数とします。すると、\( P \)に\newterm{integerizing factor}
(\jnewterm{整数化因子})\( c^{1 + O_1 - O_2} \)をかけると、答えの多項式を
\code{div\-/terms}アルゴリズムを使って分数を出さずに\( Q \)で割ることができるという
ことが示せます。被除数にこの定数をかけてから割るという操作は、\( P \)の\( Q \)による
\newterm{pseudodivision}(\jnewterm{擬除算})と呼ばれることもあります。除算の剰余は
\newterm{pseudoremainder}(\jnewterm{擬剰余})と呼ばれます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.96}Exercise 2.96:}
\begin{enumerate}[a]

\item
手続き\code{pseudoremainder\-/terms}を実装せよ。これは\code{remainder\-/terms}と
同じようなものになるが、\code{div\-/terms}を呼ぶ前に、上で述べた整数化因数を被除数に
かけるというところが違う。\code{gcd\-/terms}を修正して\code{pseudoremainder\-/terms}を
使うようにし、\code{greatest\-/common\-/divisor}が\link{Exercise 2.95}の例に対して
整数係数の答えを返すようになっていることを確認せよ。

\item
これで\acronym{GCD}は整数係数になる。しかし、係数は\( P_1 \)の係数よりも大きくなる。
\code{gcd\-/terms}を修正し、答えの係数すべての(整数の)最大公約数で係数を割ることによって
答えの係数から共通因数を取り除くようにせよ。
\end{enumerate}
\end{quote}

\noindent
まとめると、有理関数を既約にする方法は以下のようになります。

\begin{itemize}

\item
\link{Exercise 2.96}版の\code{gcd\-/terms}を使って、分子と分母の\acronym{GCD}を
求める。

\item
\acronym{GCD}を求めたら、分子と分母を\acronym{GCD}で割る前に、それらに同じ整数化因子を
かけて、\acronym{GCD}による割り算で非整数の係数が出ないようにする。整数化因子としては、
\acronym{GCD}の最初の係数を\( 1 + O_1 - O_2 \)乗したものが使える。ここで、\( O_2 \)は
\acronym{GCD}の次数、\( O_1 \)を分子と分母の大きいほうの次数とする。こうすると、
分子と分母を\acronym{GCD}で割っても分数が出てこないということが保証できる。

\item
この演算の結果は、整数係数を持つ分子と分母になる。いろいろ整数化因子をかけているため、
係数は普通とても大きなものになっている。そのため、最終ステップとして、分子と分母の
係数すべてに対する(整数の)最大公約数を求め、それで割ることによって、冗長な因数を
取り除く。

\end{itemize}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.97}Exercise 2.97:}
\begin{enumerate}[a]

\item
このアルゴリズムを\code{reduce\-/terms}という手続きとして実装せよ。手続きは
\code{n}と\code{d}という二つの項リストを引数として取り、上で説明したアルゴリズムによって
\code{n}と\code{d}を既約にした\code{nn}と\code{dd}のリストを返す。また、\code{add\-/poly}
と同様の手続き\code{reduce\-/poly}を実装せよ。これは二つのpolyが同じ変数を持つかどうか
チェックし、もし同じであれば変数を取り去って問題を\code{reduce\-/terms}に渡し、
\code{reduce\-/terms}に返された二つの項リストにその変数をつけ直す。

\item
\code{reduce\-/terms}と似たような手続きとして、元々の\code{make\-/rat}が整数に対して
行っていたことと同じことを実行するものを次のように定義せよ。

\begin{scheme}
(define (reduce-integers n d)
  (let ((g (gcd n d))) (list (/ n g) (/ d g))))
\end{scheme}

\noindent
そして、\code{reduce}というジェネリック演算を定義せよ。これは、\code{apply\-/generic}を
呼んで、\code{reduce\-/poly}(\code{polynomial}型引数に対して)または
\code{reduce\-/integers}(\code{scheme\-/number}型引数に対して)にディスパッチする。
こうすると、\code{make\-/rat}が分子と分母を組み合わせて有理数を作る前に\code{reduce}を
呼ぶようにすることで、有理数算術演算パッケージが有理数を既約にするようにできる。
これで、このシステムは整数と多項式のどちらの有理式も扱えるようになった。プログラムを
テストするために、この拡張練習問題の最初に出てきた例を試してみよ。

\begin{scheme}
(define  p1 (make-polynomial 'x '((1 1) (0  1))))
(define  p2 (make-polynomial 'x '((3 1) (0 -1))))
(define  p3 (make-polynomial 'x '((1 1))))
(define  p4 (make-polynomial 'x '((2 1) (0 -1))))
(define rf1 (make-rational p1 p2))
(define rf2 (make-rational p3 p4))
(add rf1 rf2)
\end{scheme}

正しく既約になっている正しい答えが返ってくるかどうかを確認せよ。
\end{enumerate}
\end{quote}

\noindent
\acronym{GCD}の計算は、有理関数の演算を行うどんなシステムでも、中心的な存在になります。
上で使ったアルゴリズムは、数学的には素直なのですが、非常に遅いものです。遅さの原因は、
部分的には除算回数の多さにあり、部分的には擬除算によって生成される中間係数が巨大に
なるというところにあります。多項式の\acronym{GCD}を求めるよりよいアルゴリズムをどう設計
するかということは、代数処理システム開発において活発な領域のひとつです。
\footnote{多項式\acronym{GCD}計算の非常に効率的でエレガントな手法が
Richard \link{Zippel (1979)}によって発見されました。この手法は、\link{Chapter 1}で
検討した高速な素数性テストと同じく、確率的アルゴリズムです。Zippelの本
(\link{Zippel 1993})では、この手法のほかにも、多項式の\acronym{GCD}を求めるほかの
いくつかの方法について解説しています。}

%=======================================================================================================
%=======================================================================================================
%=======================================================================================================

\chapter{モジュール性、オブジェクト、状態}
\label{Chapter 3}

\begin{quote}
\begin{greek}
Mεταβάλλον ὰναπαύεται
\end{greek}

(変化していながら、静止している)

---Heraclitus
\end{quote}

\begin{quote}
Plus \c{c}a change, plus c'est la m\^{e}me chose.

(変化すればするほど、同じものとなる)

---Alphonse Karr
\end{quote}

\vspace{1.0em}

\noindent
ここまでの章では、プログラムを作る基本的な要素を紹介してきました。基本手続きや
基本データを組み合わせて合成物を作る方法について概観し、大きなシステムの複雑性に
対処するには抽象化が重要だということを学びました。しかし、これらの道具はプログラムを
設計するのに十分ではありません。プログラムを効率的に統合していくためには、
プログラムの全体的な設計計画を立てるうえで助けになってくれる組織化原則が必要です。
とりわけ、大きなシステムを\newterm{modular}(\jnewterm{モジュール式})に構成する、
つまり、システムをまとまりのある部品に``自然に''分割し、別々に開発、保守をすることを
可能にするための戦略が必要となります。

物理システムをモデル化するプログラムの構成に特に適した強力な設計戦略のひとつとして、
モデル化対象のシステムの構造をもとにプログラムの構造を決めるというものがあります。
システムのそれぞれのオブジェクトに対して、対応する計算オブジェクトを構築するという
ものです。この戦略をとることの狙いは、新しいオブジェクトやアクションを導入するために
モデルを拡張する際に、プログラムの戦略はそのままで、それらのオブジェクトやアクションの
記号的な対応物を追加するだけですむようにすることです。システムの組織化がうまくいって
いれば、新しい機能を追加したり古い機能をデバッグしたりするのに、システムの局所的
部品に手を加えるだけでいいようになっているはずです。

すると、大きなプログラムを組織化する方法は、モデル化の対象となるシステムを私たちが
どう知覚するかというところにかなり左右されることになります。この章では、システムの
構造に対する二つのかなり異なった``世界観''から浮かび上がってくる、二つの顕著な
組織化戦略について調べていきます。一つ目の組織化戦略は\newterm{objects}
(\jnewterm{オブジェクト})に集中するもので、はっきり分かれたオブジェクトの集合として
大きなシステムを捉え、それらのオブジェクトのふるまいは時間とともに変化するとします。
もうひとつの組織化戦略は、システムを流れる情報の\newterm{streams}
(\jnewterm{ストリーム})に集中するというものです。これは、電子技術者が信号処理システムを
見るのと同じやり方です。

オブジェクトによるアプローチもストリーム処理によるアプローチも、どちらもプログラムに
おける大きな言語的な問題を引き起こします。オブジェクトの場合、どうやって計算オブジェクトを
変化させながら同一性を維持させるかという問題に取り組む必要があります。この問題のために、
古い置換モデル(\link{Section 1.1.5})はあきらめて、より機械的なものの理論的には扱いにくい、
計算の\newterm{environment model}(\jnewterm{環境モデル})を採用することになります。
オブジェクト、変化、同一性を扱うことの難しさは、計算モデルの中で時間を扱うことの必要性から
生まれる根本的な問題です。プログラムを並列実行できるようにしようとすると、
これらの問題はますます大きくなります。ストリームというアプローチは、モデルの中で
シミュレートしている時間と、評価の際にコンピュータの中で起こるイベントの
順番とを切り離す場合に最も役に立ちます。このことは、\newterm{delayed evaluation}
(\jnewterm{遅延評価})として知られているテクニックによって達成できます。



\section{代入と局所状態}
\label{Section 3.1}

私たちは普通、独立した物(オブジェクト)があちこちにあるような場所としてこの世界を
捉えています。それらのオブジェクトは、時間とともに変わる状態を持っています。
オブジェクトのふるまいがその過去に影響されるとき、そのオブジェクトは``状態を持つ''
といいます。例えば銀行口座は、``100ドル引き出せますか?''という質問の答えが預金と
引き出しの取引履歴によって変わるという意味で、状態を持つといえます。オブジェクトの
状態は、ひとつ以上の\newterm{state variables}(\jnewterm{状態変数})によって特徴づける
ことができます。状態変数は、オブジェクトの現在のふるまいを決めるのに十分な履歴情報を
保持します。単純な銀行システムでは、口座の取引履歴全体を記憶するのではなく、現在の残高に
よって特徴づけることができるでしょう。

多くのオブジェクトからなるシステムでは、オブジェクト同士が完全に独立しているという
ことはほとんどありません。それぞれのオブジェクトは相互作用によってほかのオブジェクトの
状態に影響を与え、その相互作用がオブジェクトの状態変数同士を結びつけます。実際に、
システムがばらばらのオブジェクトによって構成されているという見方は、システムの
状態変数がいくつかの密結合のサブシステムにグループ化することができて、
サブシステム同士の結合は疎であるという場合に最も役に立つものです。

このシステムの見方は、システムの計算モデルを組織化する強力なフレームワークとなりえます。
そのようなモデルをモジュール式にするには、システムの実際のオブジェクトをモデル化する
計算オブジェクトに分解する必要があります。それぞれの計算オブジェクトは、実際の
オブジェクトの状態を表す\newterm{local state variables}(\jnewterm{局所状態変数})を
持たなければなりません。モデル化対象のシステムに存在するオブジェクトの状態は時間と
ともに変化するので、それらに対応する計算オブジェクトの状態変数も同じく変化しなければ
なりません。もしシステム内での時間の流れをコンピュータ内での経過時間としてモデル化する
ことにするなら、プログラムの実行に伴ってふるまいの変わる計算オブジェクトを構築する
方法が必要です。具体的には、もし状態変数をプログラミング言語の通常の記号名によって
モデル化したいならば、プログラミング言語は\newterm{assignment operator}
(\jnewterm{代入演算子})を提供し、名前に関連づけられた値を変化させることができなければ
なりません。


\subsection{局所状態変数}
\label{Section 3.1.1}

時間とともに変化する状態を持った計算オブジェクトを持つということがどういうことなのかを
示すために、銀行口座からお金を引き出すという状況をモデル化することにします。そのために
、引き出す\code{amount}(金額)を引数に取る\code{withdraw}(引き出し)という手続きを
使います。引き出しを行うのに十分なお金が口座にあれば、\code{withdraw}は引き出し後に残る
残高を返します。そうでなければ、\code{withdraw}は\emph{Insufficient funds}(残高不足)
というメッセージを返します。例えば、口座に100ドルある状態から始めた場合、
\code{withdraw}を使うことで、次のような一連の応答を受け取ります。

\begin{scheme}
(withdraw 25)
~\textit{75}~
(withdraw 25)
~\textit{50}~
(withdraw 60)
~\textit{"Insufficient funds"}~
(withdraw 15)
~\textit{35}~
\end{scheme}

\noindent
式\code{(withdraw 25)}は二回評価されていますが、それぞれ違う値を返しているというところに
注意してください。これは、手続きのふるまいとして、これまでになかった種類のものです。
これまでは、手続きはすべて数学関数を計算する仕様として捉えることが可能でした。
手続きの呼び出しを行うと、与えられた引数を関数に適用したときの値の計算が行われ、
同じ手続きを同じ引数で二回呼び出すと、いつでも同じ値が返ってくることになっていました。
\footnote{実際には、これはあまり正しくありません。例外のひとつとして、
\link{Section 1.2.6}の乱数生成器があります。また別の例外としては、\link{Section 2.4.3}で
導入した演算-型テーブルに関連するものがあります。この場合、同じ引数で\code{get}を
二回呼び出した場合の値は、その間の\code{put}の呼び出しによって変わります。
一方、代入を導入するまで、そのような手続きを自分で作る方法はないということです。}

\code{withdraw}を実装するために、口座の残高を示す変数\code{balance}を使い、
\code{balance}にアクセスする手続きとして\code{withdraw}を定義します。
\code{withdraw}手続きは、\code{balance}が少なくとも要求された\code{amount}以上の
大きさがあるかをチェックします。もしあるなら、\code{withdraw}は\code{balance}を
\code{amount}分だけ減らし、新しい\code{balance}の値を返します。なければ、
\code{withdraw}は\emph{Insufficient funds}(残高不足)というメッセージを返します。
以下は、\code{balance}と\code{withdraw}の定義です。

\begin{scheme}
(define balance 100)
(define (withdraw amount)
  (if (>= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      "Insufficient funds"))
\end{scheme}

\noindent
\code{balance}の減算は次の式によって行います。

\begin{scheme}
(set! balance (- balance amount))
\end{scheme}

\noindent
ここでは\code{set!}という特殊形式を使っています。構文は次のようになります。

\begin{scheme}
(set! ~\( \dark \langle \)~~\var{\dark name}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark new-value}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
ここで、\( \langle \)\var{name}\( \kern0.08em\rangle \)は記号で、
\( \langle \)\var{new-value}\( \kern0.08em\rangle \)は任意の式です。
\code{set!}は\( \langle \)\var{name}\( \kern0.08em\rangle \)の値を
\( \langle \)\var{new-value}\( \kern0.08em\rangle \)を評価して得られる結果に変更します。
ここでの例では、\code{balance}を変更して、\code{balance}の以前の値から\code{amount}を
引いた結果を新しい値にします。\footnote{
\code{set!}式の値は実装依存です。\code{set!}は作用のためだけに使うもので、
値のために使うものではありません。

\code{set!}という名前は、Schemeで使われる命名規則に従っています。変数の値を変更する
演算(または、\link{Section 3.3}で学ぶデータ構造を変える演算)は、感嘆符で終わる名前を
つけることになっています。これは、述語を指すのに疑問符で終わる名前を使うのと似ています。}

\code{withdraw}では、\code{if}のテストが真の場合に二つの式が評価されるようにするために、
\code{begin}という特殊形式も使っています。二つの式では、まず\code{balance}を減らし、
それから\code{balance}の値を返しています。一般的に、以下の式を評価すると、

\begin{scheme}
(begin ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark exp_k \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
\( \langle \)\( exp_1 \)\( \kern0.08em\rangle \)から
\( \langle \)\( exp_k \)\( \kern0.08em\rangle \)までの式が順番に評価され、最後の式
\( \langle \)\( exp_k \)\( \kern0.08em\rangle \)の値が\code{begin}形式全体の値として
返されます。
\footnote{
Schemeでは手続きの本体として式の連続が使えるので、すでに\code{begin}を暗黙的に
プログラムの中で使っていることになります。また、\code{cond}式の各節の
\( \langle \)\var{consequent}\( \kern0.08em\rangle \)部分も、単一の式ではなく、式の連続に
することができます。}


\code{withdraw}は意図した通りに動くのですが、変数\code{balance}が問題になります。
上で記述したように、\code{balance}はグローバル環境で定義された名前なので、どんな手続き
からでもアクセスして値を調べたり変更したりすることができてしまいます。何とかして
\code{balance}を\code{withdraw}の内部に置いて、\code{withdraw}が\code{balance}に直接
アクセスできる唯一の手続きになるようにして、ほかの手続きは全部、\code{balance}には
(\code{withdraw}の呼び出しを通して)間接的にしかアクセスできないようにできればずっとよくなる
でしょう。そうできれば、\code{withdraw}が口座の状態を覚えておくために使っている
局所状態変数が\code{balance}であるという概念をより正確にモデル化できることになります。

\code{balance}を\code{withdraw}の内部に置くようにするには、定義を以下のように書き直します。

\begin{scheme}
(define new-withdraw
  (let ((balance 100))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
\end{scheme}

\noindent
ここでは、初期値100に束縛されたローカル変数\code{balance}を持つ環境を\code{let}によって
作っています。この局所環境の中で、\code{amount}を引数に取り以前の\code{withdraw}手続きと
同じようなふるまいをする手続きを\code{lambda}を使って作っています。\code{let}式を評価した
結果として返されるこの手続きは\code{new\-/withdraw}で、\code{withdraw}と正確に同じふるまいを
しますが、変数\code{balance}はほかのどの手続きからもアクセスできません。
\footnote{
プログラミング言語の業界用語では、変数\code{balance}は手続き\code{new\-/withdraw}の中に
\newterm{encapsulated}(\jnewterm{カプセル化})されていると言います。カプセル化は、
\newterm{hiding principle}(\jnewterm{隠蔽原理})として知られる、一般的なシステム設計の原則を
反映したものです。隠蔽原理とは、システムの各部品をほかの部品から守ることによって、システムを
よりモジュール的で頑健なものにできるという考え方です。これはつまり、``知る必要''のある
システムの部品にだけ、情報へのアクセス権を与えるということです。}

\code{set!}をローカル変数と組み合わせるというのは、今後局所状態を持つ計算オブジェクトを構築するのに
使うことになる一般的なプログラミングテクニックです。残念ながら、このテクニックを使うと深刻な問題が
出てきます。最初に手続きを導入したとき、手続きの適用とはどういうことかを解釈するために
評価の置換モデル(\link{Section 1.1.5})というものも導入しました。そのとき、手続きの適用とは、
仮引数を値で置き換えたうえで手続きの本体を評価することとして解釈するべきだと述べました。
問題は、言語に代入を導入したとたん、置換というのは手続き適用の適切なモデルではなくなるということ
です(どうしてそうなるのかは\link{Section 3.1.3}で見ていきます)。結果として、厳密に言うと、
\code{new\-/withdraw}がなぜ上で述べたようにふるまうのかということについて現時点で理解する方法が
ないということになります。\code{new\-/withdraw}のような手続きをちゃんと理解するには、手続き適用
についての新しいモデルを開発する必要があります。\link{Section 3.2}ではそのようなモデルを紹介し、
さらに\code{set!}とローカル変数についての説明も加えます。しかし、とりあえずは
\code{new\-/withdraw}によって打ち立てられたテーマについて、いくつかの別のパターンを詳しく
見ていきましょう。

次の手続き\code{make\-/withdraw}は``引き出し処理器''を作成します。\code{make\-/withdraw}の
仮引数\code{balance}は、口座の初期残高を指定します。
\footnote{
上の\code{new\-/withdraw}とは違い、\code{balance}をローカル変数にするために\code{let}を使う
必要はありません。仮引数は元々ローカルだからです。このことは、\link{Section 3.2}で評価の
環境モデルについて検討すると、よりはっきりします(\link{Exercise 3.10}も参照)。
}

\begin{scheme}
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
\end{scheme}

\noindent
\code{make\-/withdraw}を使うと、以下のように\code{W1}と\code{W2}という二つのオブジェクトを
作ることができます。

\begin{scheme}
(define W1 (make-withdraw 100))
(define W2 (make-withdraw 100))

(W1 50)
~\textit{50}~
(W2 70)
~\textit{30}~
(W2 40)
~\textit{"Insufficient funds"}~
(W1 40)
~\textit{10}~
\end{scheme}

\noindent
\code{W1}と\code{W2}は完全に独立したオブジェクトで、それぞれ自分の局所状態変数
\code{balance}を持っているということがわかるでしょうか。片方から引き出しても、
もう一方には影響しません。

引き出しだけでなく預け入れも扱うオブジェクトを作ることもできます。これによって、
単純な銀行口座を表現することができるようになります。以下は、指定した初期残高を持つ
``銀行口座オブジェクト''を返す手続きです。

\begin{scheme}
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request: MAKE-ACCOUNT"
                       m))))
  dispatch)
\end{scheme}

\noindent
\code{make\-/account}を呼び出すたびに、局所状態変数\code{balance}を持つ環境が構築されます。
この環境の中で、\code{make\-/account}は\code{balance}にアクセスする手続き\code{deposit},
\code{withdraw}と、また``メッセージ''を入力として取り二つの局所手続きのうちひとつを
返す\code{dispatch}という追加の手続きを定義します。銀行口座オブジェクトを表現する値としては、
\code{dispatch}手続きそのものが返されます。これはまさに、\link{Section 2.4.3}で学んだ
\newterm{message-passing}(\jnewterm{メッセージパッシング})のプログラミングスタイルですが、
ここではローカル変数を変更する能力と合わせて使っています。


\code{make\-/account}は次のように使えます。

\begin{scheme}
(define acc (make-account 100))
((acc 'withdraw) 50)
~\textit{50}~
((acc 'withdraw) 60)
~\textit{"Insufficient funds"}~
((acc 'deposit) 40)
~\textit{90}~
((acc 'withdraw) 60)
~\textit{30}~
\end{scheme}

\noindent
\code{acc}を呼び出すたびに、局所的に定義された\code{deposit}または\code{withdraw}手続きの
どちらかが返され、それが指定された\code{amount}に適用されます。\code{make\-/withdraw}の場合と
同じように、\code{make\-/account}をもう一度呼び出すと、

\begin{scheme}
(define acc2 (make-account 100))
\end{scheme}

\noindent
完全に別の口座オブジェクトを作り、自分のローカルな\code{balance}を保持します。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.1}Exercise 3.1:} 
\newterm{accumulator}は、ひとつの数値引数で繰り返し呼ばれる手続きで、引数を合計に蓄積していく。
呼び出されるたびに現在までに蓄積された合計を返す。それぞれ独立した合計を持つアキュムレータを
返す手続き\code{make\-/accumulator}を書け。\code{make\-/accumulator}への入力は、合計の初期値を
指定する。例えば、以下のようになる。

\begin{scheme}
(define A (make-accumulator 5))
(A 10)
~\textit{15}~
(A 10)
~\textit{25}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.2}Exercise 3.2:}
ソフトウェアをテストするアプリケーションでは、計算の過程で、ある手続きが何回呼ばれたかを
数えられると便利だ。一引数の手続き\code{f}を入力として取る手続き\code{make\-/monitored}を書け。
\code{make\-/monitored}が返すのは第三の手続き(仮に\code{mf}とする)で、この手続きは内部カウンタを
保持することによって呼び出された回数を覚えておく。\code{mf}に対する入力が
\code{how\-/many\-/calls?}という特別な記号である場合、\code{mf}はカウンタの値を返す。
入力が\code{reset\-/count}という特別な記号である場合、\code{mf}はカウンタをゼロにリセットする。
それ以外の入力に対しては、\code{mf}はその入力によって\code{f}を呼び出した結果を返し、
カウンタを1増やす。例えば、監視をつけたバージョンの\code{sqrt}手続きを作ることもできる。

\begin{scheme}
(define s (make-monitored sqrt))
(s 100)
~\textit{10}~
(s 'how-many-calls?)
~\textit{1}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.3}Exercise 3.3:} 
\code{make\-/account}手続きを修正し、パスワードで守られた口座を作成するようにせよ。
具体的には、次のように\code{make\-/account}が追加の引数としてひとつの記号を取るようにする。

\begin{scheme}
(define acc (make-account 100 'secret-password))
\end{scheme}

結果としてできる口座オブジェクトは、アカウント作成時のパスワードを伴っている場合にだけ
リクエストを処理し、その他の場合にはエラーメッセージを出す。

\begin{scheme}
((acc 'secret-password 'withdraw) 40)
~\textit{60}~
((acc 'some-other-password 'deposit) 50)
~\textit{"Incorrect password"}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.4}Exercise 3.4:} 
\link{Exercise 3.3}の\code{make\-/account}手続きを変更して別のローカル状態変数を追加し、
間違ったパスワードで口座に7回連続アクセスされると\code{call\-/the\-/cops}(警察を呼ぶ)という
手続きを呼ぶようにせよ。
\end{quote}

\subsection{代入を導入する利点}
\label{Section 3.1.2}

今後見ていくことになりますが、プログラミング言語に代入を導入したことによって、
我々は難しい概念的問題の藪の中に迷い込むことになります。それでもなお、ローカルな状態を持つ
オブジェクトの集合としてのシステムの見方は、モジュール化された設計を維持していくうえで
強力なテクニックになります。単純な例として、\code{rand}手続きの設計について考えてみましょう。
\code{rand}手続きは、呼ばれるたびにランダムに選ばれた整数を返します。

``ランダムに選ぶ''というのがどういうことなのかはまったくはっきりしていません。
私たちが望んでいるのは、おそらく、\code{rand}を連続して呼び出すと一様分布という統計的性質を
持つ数列を作るということです。ここでは、適切な数列を生成する方法については議論しません。
その代わりに、ある数値\( x_1 \)から始めると、望ましい統計的性質を持った数列
\( x_1 \), \( x_2 \), \( x_3 \)を以下のように生成するという性質を持つ手続き
\code{rand\-/update}がもうあるとします。
\footnote{
\code{rand\-/update}を実装する一般的な方法としては、\( a \), \( b \), \( m \)を適切に選ばれた
整数として、\( x \)を\( ax + b \) modulo \( m \)に更新するというものがあります。
\link{Knuth 1981}の3章は、乱数列を生成し、それらの統計的性質を確立するテクニックについて
広汎に考察しています。\code{rand\-/update}手続きは数学関数を計算しているということに
注意してください。同じ入力を2回与えられると、この手続きは同じ出力を返します。そのため、
それぞれの数値が前の数値と関係していないというのが``ランダム''だとすると、\code{rand\-/update}に
よって生成される数列は、まったく``ランダム''とはいえません。``真のランダム性''と、はっきりと
規定された計算によって生成されるものの適切な統計的性質を持つ、いわゆる\newterm{pseudo-random}
(\jnewterm{擬似乱数})との関係は、数学と哲学の難しい課題が絡む複雑な問題です。
Kolmogorov, Solomonoff, Chaitinはこれらの問題の解明に大きく寄与しました。これに関する議論は
\link{Chaitin 1975}にあります。
}

\begin{scheme}
~\( \dark x_2 \)~ = (rand-update ~\( \dark x_1 \)~)
~\( \dark x_3 \)~ = (rand-update ~\( \dark x_2 \)~)
\end{scheme}

\noindent

\code{rand}は、局所状態変数\code{x}を持ち、それをある固定値\code{random\-/init}で初期化する
手続きとして実装できます。\code{rand}を呼び出すたびに、現在の\code{x}の値に対する
\code{rand\-/update}を計算し、それを乱数として返します。また、この値を\code{x}の新しい値として
保存します。

\begin{scheme}
(define rand (let ((x random-init))
               (lambda () 
                 (set! x (rand-update x))
                 x)))
\end{scheme}

\noindent
もちろん、単純に\code{rand\-/update}を直接呼べば、代入を使わないで同じ乱数列を
生成することもできます。しかし、そうするとプログラムの中で乱数を使うどの箇所でも、
現在の\code{x}の値を明示的に覚えておいて、\code{rand\-/update}の引数として渡さないと
いけないということになります。これがどれだけ面倒なことになるかを実感するために、
\newterm{Monte Carlo simulation}(\jnewterm{モンテカルロシミュレーション})と呼ばれる
テクニックを実装するために乱数を使う場合について考えてみましょう。

モンテカルロ法は、大きい集合からランダムにサンプルの試行を選び、それらの試行結果を集計する
ことによって推測した確率をもとに推定を行うというものです。例えば、ランダムに選んだ二つの
整数が共通因子を持たない、つまり最大公約数が1であるという確率が\( 6/\pi^2 \)であるという事実を
使って、\( \pi \)を近似することができます。
\footnote{この定理はE. Ces\`aroによるものです。議論と証明については、\link{Knuth 1981}の
4.5.2節参照。}
\( \pi \)の近似値を求めるためには数多くの試行を行います。それぞれの試行では二つの整数を
ランダムに選び、それらの\acronym{GCD}が1であるかをテストします。テストをパスした回数の割合に
よって\( 6/\pi^2 \)の近似値が得られるので、この値から\( \pi \)の近似値が得られます。

プログラムの中心となるのは手続き\code{monte\-/carlo}です。この手続きは試行回数と試行を引数に
取ります。試行は、実行されるたびに真または偽を返す、引数なしの手続きとして表現されます。
\code{monte\-/carlo}は、指定された回数だけ試行を実行し、試行が真となった割合を表す数値を
返します。

\begin{scheme}
(define (estimate-pi trials)
  (sqrt (/ 6 (monte-carlo trials cesaro-test))))
(define (cesaro-test)
   (= (gcd (rand) (rand)) 1))

(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1) 
                 (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) 
                 trials-passed))))
  (iter trials 0))
\end{scheme}

\noindent
今度は、\code{rand}の代わりに\code{rand\-/update}を使って同じ計算をしてみましょう。
局所状態をモデル化するために代入を使わないとすると、このやり方をするしかありません。

\begin{scheme}
(define (estimate-pi trials)
  (sqrt (/ 6 (random-gcd-test trials random-init))))
(define (random-gcd-test trials initial-x)
  (define (iter trials-remaining trials-passed x)
    (let ((x1 (rand-update x)))
      (let ((x2 (rand-update x1)))
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((= (gcd x1 x2) 1)
               (iter (- trials-remaining 1)
                     (+ trials-passed 1)
                     x2))
              (else
               (iter (- trials-remaining 1)
                     trials-passed
                     x2))))))
  (iter trials 0 initial-x))
\end{scheme}

\noindent
プログラムはまだ単純ではありますが、残念ながらモジュール性が破られてしまっているところが
いくつかあります。プログラムの最初のバージョンでは、\code{rand}を使って、
任意の\code{experiment}手続きを引数として取る汎用の\code{monte\-/carlo}手続きとして
モンテカルロ法を直接表現することができました。プログラムの二つ目のバージョンでは、
乱数生成器の局所状態がないので、\code{random\-/gcd\-/test}は乱数\code{x1}と\code{x2}を明示的に
操作し、\code{rand\-/update}に対する新たな入力として\code{x2}を繰り返しのループの間ずっと
再利用する必要があります。このように乱数を明示的に扱うと、テスト結果を蓄積していくという構造と、
この特定の試行では乱数を二つ使うという事実とが結びついてしまいます。しかし、ほかのモンテカルロ法の
試行では、使う乱数の数が一つだったり三つだったりするかもしれません。トップレベルの手続き
\code{estimate\-/pi}まで、乱数の初期値を提供することについて面倒を見なければなりません。
乱数生成器の内部がプログラムのほかの部分に漏れてしまっているため、モンテカルロ法という考え方を
分離して、ほかのタスクにも適用できるようにするということが難しくなっています。プログラムの
最初のバージョンでは、代入が乱数生成器の状態を\code{rand}手続きの中にカプセル化しているので、
乱数生成の細かいところはプログラムのほかの部分から独立していることができます。

モンテカルロ法の例から、次の一般的な現象がわかります。複雑なプロセスのある部品という立場から
見ると、ほかの部品は時間とともに変化しているように見えます。それらの部品は、時とともに変化する
隠れた局所状態を持っています。このような分解方法を反映した構造を持つコンピュータプログラムを
書こうと思うと、ふるまいが時間とともに変わる計算オブジェクト(銀行口座や乱数生成器など)を
作ることになります。状態は局所状態変数によってモデル化し、状態の変化はそれらの変数への
代入としてモデル化します。

こうなると、次のように結論づけてしまいたくなるところです。代入と、状態をローカル変数に隠す
というテクニックを導入したことで、追加の引数を渡すことによって全ての状態を明示的に操作する
よりも、よりモジュール性の高いスタイルでシステムを構造化できるようになった、と。
残念ながら、これから見ていくように、話はそんなに簡単ではありません。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.5}Exercise 3.5:} 
\newterm{Monte Carlo integration}(\jnewterm{モンテカルロ積分})は、モンテカルロシミュレーションに
よって定積分を推定する手法である。領域内の点\( (x, y) \)に対しては真となり、領域外の点に対しては
偽となるような述語\( P(x, y) \)によって記述される領域の面積を計算する場合について考える。
例えば、中心(5, 7)で半径が3である円に含まれる領域は、\( (x - 5)^2 + (y - 7)^2 \le 3^2 \)となるか
どうかをテストする述語によって記述される。そのような述語によって記述された領域の面積を
推定するには、まずその領域を包含する長方形を選ぶ。例えば、向かい合う頂点が(2, 4)と(8, 10)にある
長方形は、上で述べた円を含む。求める積分は、長方形の中でその領域の中に入る部分の面積である。
その積分は、ランダムに長方形の中の点\( (x, y) \)を選んでいき、それぞれの点について\( P(x, y) \)を
テストし、その点が元の領域の中にあるかどうかを決定することによって推定できる。もしこの試行を
多くの点について行えば、領域の中に入る点の割合から、その領域の中にある長方形の割合を推定する
ことができる。よって、その割合に長方形全体の面積をかけると、積分の推定値が得られることになる。

モンテカルロ積分を、手続き\code{estimate\-/integral}として実装せよ。引数として、述語\code{P}、
長方形の上下界\code{x1}, \code{x2}, \code{y1}, \code{y2}、推定値を生成するための試行回数を取る。
この手続きは、上で\( \pi \)を推定するために使ったものと同じ\code{monte\-/carlo}手続きを
使わなければならない。この\code{estimate\-/integral}を使って、単位円の面積を測ることによって
\( \pi \)の推定値を求めよ。

この手続きを書くのには、与えられた範囲からランダムに選んだ数値を返す手続きがあれば便利だ。
以下の\code{random\-/in\-/range}手続きは、\link{Section 1.2.6}で使った、入力よりも小さい
非負数を返す\code{random}手続きによってそれを実装している。
\footnote{\acronym{MIT} Schemeはそのような手続きを提供しています。\code{random}に
(\link{Section 1.2.6}のように)整数が渡されれば整数を返しますが、(この課題のように)
小数を渡されると小数を返します。}

\begin{scheme}
(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (random range))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.6}Exercise 3.6:}
乱数生成器をリセットして、与えられた値から始まる数列を作れるようにできると便利だ。
記号\code{generate}または\code{reset}のどちらかを引数として取り、次のようなふるまいをする新しい
\code{rand}手続きを設計せよ。\code{(rand 'generate)}は新しい乱数を生成する。
\code{((rand 'reset)}\( \;\langle \)\var{new-value}\( \kern0.11em\rangle \)\code{)}は内部の
状態変数を指定された\( \langle \)\var{new-value}\( \kern0.08em\rangle \)にリセットする。
つまり、状態をリセットすることによって、再現可能な数列が生成できる。これは乱数を使うプログラムを
テストしたりデバッグしたりするのにとても役に立つ。

\end{quote}

\subsection{代入を導入することのコスト}
\label{Section 3.1.3}

ここまでで見てきたように、\code{set!}演算があると局所状態を持つオブジェクトをモデル化することが
できるようになります。しかし、この利点は代償を伴うものです。このことによって、私たちの
プログラミング言語は\link{Section 1.1.5}で紹介した手続き適用の置換モデルによって解釈することが
もうできなくなっています。それだけでなく、プログラミング言語のオブジェクトと代入を扱う適切な
枠組みとして使えるような、``いい感じの''数学的性質を持った単純なモデルというものは存在しません。

代入を使わない限り、同じ引数による同じ手続きの呼び出しは二回評価しても同じ結果になるので、
手続きは数学関数の計算と見なすことができます。この本の一章と二章を通してしてきたような、
まったく代入を使わないプログラミングというのは、そのために\newterm{functional programming}
(\jnewterm{関数型プログラミング})と呼ばれています。

代入によってどれだけ話が難しくなるかということを、\link{Section 3.1.1}の\code{make\-/withdraw}
手続きを単純化したバージョンを使って考えてみましょう。このバージョンでは、残額が十分かどうかの
チェックをしないようにしています。

\begin{scheme}
(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
(define W (make-simplified-withdraw 25))
(W 20)
~\textit{5}~
(W 10)
~\textit{-5}~
\end{scheme}

\noindent
この手続きと、\code{set!}を使わない次の\code{make\-/decrementer}手続きとを比べてみてください。

\begin{scheme}
(define (make-decrementer balance)
  (lambda (amount)
    (- balance amount)))
\end{scheme}

\noindent
\code{make\-/decrementer}は、指定された残高\code{balance}から入力値を引く手続きを返します。
しかし、続けて呼び出しても、\code{make\-/simplified\-/withdraw}のような蓄積効果はありません。

\begin{scheme}
(define D (make-decrementer 25))
(D 20)
~\textit{5}~
(D 10)
~\textit{15}~
\end{scheme}

\noindent
\code{make\-/decrementer}の動作の説明には置換モデルが使えます。例えば、以下の式の評価を
解析してみましょう。

\begin{scheme}
((make-decrementer 25) 20)
\end{scheme}

\noindent
まず、\code{make\-/decrementer}本体の\code{balance}を25によって置き換えて、組み合わせの演算子を
単純にします。式は以下のようになります。

\begin{scheme}
((lambda (amount) (- 25 amount)) 20)
\end{scheme}

\noindent
\code{lambda}式本体にある\code{amount}を20によって置き換えて、演算子を適用します。

\begin{scheme}
(- 25 20)
\end{scheme}

\noindent
最終的な答は5になります。


しかし、\code{make\-/simplified\-/withdraw}に対して同じような置換による解析をしようとすると
どうなるでしょうか。

\begin{scheme}
((make-simplified-withdraw 25) 20)
\end{scheme}

\noindent
まず、\code{make\-/simplified\-/withdraw}の本体にある\code{balance}を25に置き換えて演算子を
単純にします。すると、式は次のようになります。\footnote{
\code{set!}式に出てくる\code{balance}は置き換えません。\code{set!}内の
\( \langle \)\var{name}\( \kern0.08em\rangle \)は評価されていないからです。
これを置き換えるとすると、\code{(set! 25 (- 25 amount))}というおかしな結果になってしまいます。}

\begin{scheme}
((lambda (amount) (set! balance (- 25 amount)) 25) 20)
\end{scheme}

\noindent
今度は、\code{lambda}式本体の\code{amount}を20に置き換えて演算子を適用します。

\begin{scheme}
(set! balance (- 25 20)) 25
\end{scheme}

\noindent
置換モデルにあくまでこだわるのであれば、この手続き適用の意味は、まず\code{balance}を5に設定して、
それから式の値として25を返すというものだ、と言わなければならないことになります。これは間違った
答えです。正しい答えを得るには、何とかして一つ目の\code{balance}(\code{set!}の効果の前)と
二つ目の\code{balance}(\code{set!}の効果の後)とを区別する必要があります。しかし、これは置換モデル
ではできません。

ここで問題になるのは、置換というものが究極的に、私たちの言語の記号というものが本質的に値に対する
名前であるという概念に基づいているということです。しかし、\code{set!}を導入し、変数の値は
変えられるものだという考え方を導入したとたん、変数はもはや単純に名前であるとはいえなくなります。
変数は、値が格納される場所を何らかの方法で参照するもので、その場所に格納された値は変えることが
できるということになります。\link{Section 3.2}では、私たちの計算モデルの中で、環境がこの
``場所''という役割を勤めるということを見ていきます。

\subsubsection*{同一性と変化}

ここで浮上してきた問題は、ある特定の計算モデルが破綻するというだけではなく、より奥の深いものです。
私たちの計算モデルに変更を導入したとたん、これまで単純だった多くの概念に問題が出てきます。
例えば、二つのものが``同じ''であるという概念について考えてみます。

同じ引数で\code{make\-/decrementer}を二回呼び、二つの手続きを作成するとします。

\begin{scheme}
(define D1 (make-decrementer 25))
(define D2 (make-decrementer 25))
\end{scheme}

\noindent
\code{D1}と\code{D2}は同じでしょうか。無難な答えは「同じ」です。\code{D1}と\code{D2}は
同じ計算上のふるまい---どちらも入力から25を引くという手続きだということ---を持っているからです。
実際、どんな計算であっても、結果を変えることなく\code{D2}の代わりに\code{D1}を使うことができます。

これと、\code{make\-/simplified\-/withdraw}を二回呼ぶ場合とを対比してみましょう。

\begin{scheme}
(define W1 (make-simplified-withdraw 25))
(define W2 (make-simplified-withdraw 25))
\end{scheme}

\noindent
\code{W1}と\code{W2}は同じでしょうか。これは確実に違います。\code{W1}と\code{W2}の呼び出しは、
次のやりとりでわかるように、異なる効果を持っています。

\begin{scheme}
(W1 20)
~\textit{5}~
(W1 20)
~\textit{-15}~
(W2 20)
~\textit{5}~
\end{scheme}

\noindent
\code{W1}と\code{W2}は、\code{(make\-/simplified\-/withdraw 25)}という同じ式を評価して
作られたという意味では``同じ''ものですが、どんな式であっても、式の評価結果を変えずに
\code{W2}の代わりに\code{W1}が使えるということはありません。

式の値を変化させることなく、式の中で``等しいものは等しいものによって置き換えることができる''
という概念をサポートしている言語は、\newterm{referentially transparent}(\jnewterm{参照透明})
であると言われます。私たちの計算機言語に\code{set!}を含めたときに、参照透明性は破られました。
そのため、どういう場合に等価な式を置き換えることによって式を単純にできるかということを
決めるのは厄介な問題になります。結果として、代入を使うプログラムについて推論を行うことは
劇的に難しくなります。

参照透明性をあきらめると、計算オブジェクトが``同じ''であるというのはどういう意味かという
概念は、形式的に捉えることが難しくなります。実際のところ、私たちのプログラムのモデル化対象で
ある現実世界において``同じ''というのがどういう意味かということ自身、はっきりしているとは
とても言えません。一般的に、見たところ同一に見えるオブジェクトが実際に``同じもの''であるか
どうかは、片方のオブジェクトを変更してみて、もう一方のオブジェクトも同じように変更されるか
どうかを観測することによって決めるしかありません。しかし、あるオブジェクトが``変化''したか
どうかを調べるには、``同じ''オブジェクトを二回観測して、そのオブジェクトの属性が
最初の観測と二回目の観測で違うかどうかを調べる以外に方法がありません。このため、``変化''を
測定することは、``同じ''ということについての\emph{a priori}(先験的)な概念なしにはできません。
そして、同じかどうかを測定することは、変化の効果を観測することなしにはできません。

プログラミングの中でこの問題が起こってくる例として、PeterとPaulが100ドル入っている口座を持っている
という状況について考えます。これを次のようにモデル化するのと、

\begin{scheme}
(define peter-acc (make-account 100))
(define paul-acc (make-account 100))
\end{scheme}

\noindent
次のようにモデル化するのとでは、大きな違いがあります。

\begin{scheme}
(define peter-acc (make-account 100))
(define paul-acc peter-acc)
\end{scheme}

\noindent
一つ目の状況では、二つの銀行口座は違うものです。Peterによる取引はPaulの口座には影響せず、
その逆も同じです。しかし、二つ目の状況では、\code{paul\-/acc}は\code{peter\-/acc}と
\emph{同じもの}になるよう定義しています。実質的に、この場合はPeterとPaulが共同口座を持っている
ことになり、Peterが\code{peter\-/acc}から引き出しをすると、Paulは\code{paul\-/acc}の残額が
減っていることを観測することになります。これら二つの、似ているものの異なっている状況は、
計算モデルを構築するうえで混乱を招きます。共同口座があると、具体的には、ひとつのオブジェクト
(銀行口座)で二つの異なる名前(\code{peter\-/acc}と\code{paul\-/acc})を持つものがあるということが
特に混乱を招くものになります。仮に、プログラムの中で\code{paul\-/acc}が変更される可能性がある
場所をすべて検索しようとしているとすると、\code{peter\-/acc}を変更するものも忘れずに探さなければ
なりません。
\footnote{
ひとつの計算オブジェクトが二つ以上の名前によってアクセスされるという現象は、\newterm{aliasing}
(\jnewterm{エイリアス})と呼ばれます。共同口座の状況は、エイリアスのとても単純な例を
示しています。\link{Section 3.3}では、``別の''複合データ構造が部品を共有するといった、
より複雑な例について学びます。もし、二つの``異なる''オブジェクトが実際はひとつのオブジェクトに
異なるエイリアスがついたものであることによって、あるオブジェクトを変更すると``副作用''として
``異なる''オブジェクトを変更してしまうことがあるということを忘れていると、プログラムにバグが
起こったりします。このような、いわゆる\newterm{side\-/effect bugs}(\jnewterm{副作用バグ})と
いうものは、特定が難しく解析も難しいため、プログラミング言語は副作用やエイリアスを許可しない
よう設計するべきだと提案する人もいます。(\link{Lampson et al. 1981}; \link{Morris et al. 1980})}

``同じ''、``変化''について上で述べたことに関して、もしPeterとPaulが銀行の残高を調べることしか
できず、残高を変えられるような操作ができないとすると、二つの口座が異なるかどうかという問題は
意味がなくなるということに注意してください。一般的に、もしデータオブジェクトを決して変更しない
のであれば、複合データオブジェクトはその部品を合わせたものだと見なすことができます。例えば、
有理数は分母と分子によって決定されます。しかしこの見方は、変化がある場合には有効でなくなります。
その場合、複合データは、複合データを構成する部品を合わせたものとは少し違う``アイデンティティ''を
持つことになります。銀行口座は、引き出しを行って残高を変更しても、依然として``同じ''銀行口座です。
その反対に、同じ状態情報を持つ二つの異なる銀行口座を作ることもできます。この複雑性の原因となって
いるのは、私たちのプログラミング言語ではなく、私たちが銀行口座をオブジェクトとして捉えていると
いうことです。例えば、有理数については、分子を変更しても``同じ''有理数であり続けることができるような
アイデンティティを持つ変更可能なオブジェクトと見なしたりすることは普通ありません。

\subsubsection*{命令型プログラミングの落とし穴}

関数型プログラミングとは対照的に、代入を多用するプログラミングは\newterm{imperative programming}
(\jnewterm{命令型プログラミング})といいます。計算モデルのいろいろな問題を引き起こすだけでなく、
命令型スタイルで書いたプログラムは、関数型プログラムでは起こり得ないバグが起こりやすくなります。
例えば、\link{Section 1.2.1}の反復階乗プログラムのことを思い出してみましょう。

\begin{scheme}
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product) (+ counter 1))))
  (iter 1 1))
\end{scheme}

\noindent
内部の反復ループで、引数を渡す代わりに、変数\code{product}と\code{counter}の値を更新するのに
明示的な代入を使うことで、より命令型のスタイルにすることができます。

\begin{scheme}
(define (factorial n)
  (let ((product 1)
        (counter 1))
    (define (iter)
      (if (> counter n)
          product
          (begin (set! product (* counter product))
                 (set! counter (+ counter 1))
                 (iter))))
    (iter)))
\end{scheme}

\noindent
これは、プログラムの生成する結果を変えるわけではありません。しかし、ここで微妙な罠が
入り込んでいます。代入の順序はどうやって決めたらいいのでしょうか。今回の場合、プログラムは
たまたまこのままで正しいものになっています。しかし、代入を逆の順番で書いてしまうと、

\begin{scheme}
(set! counter (+ counter 1))
(set! product (* counter product))
\end{scheme}

\noindent
別の、間違った答えになるところです。一般的に、代入のあるプログラミングをする際には、代入の
相対的な順番を注意深く考えて、それぞれの文が、中身の変わった各変数の正しいバージョンを
使うように気をつけないといけません。この問題は、関数型プログラミングでは最初から起こりません。
\footnote{
このことを考えると、初歩的なプログラミングを教える際に、非常に命令型に偏ったスタイルが
よく使われるというのは皮肉なことです。これは、1960年代と1970年代を通して一般的だった、
手続きを呼ぶプログラムは代入を行うプログラムに比べて本質的に非効率的だ(\link{Steele 1977}は
それが誤りだと証明しています)という信念の名残かもしれません。あるいは、初心者にとっては
ステップごとの代入のほうが手続きの呼び出しよりもイメージしやすいという考え方によるもの
かもしれません。理由はどうあれ、このことによって初級プログラマに
``この変数の設定は、あの変数より前にしたほうがいいのか、後にしたほうがいいのか''という心配を
させることになり、プログラミングを複雑にして、重要な考え方を見えにくくさせてしまうということが
よくあります。}

命令型プログラミングの複雑性は、複数のプロセスが並行に実行されるアプリケーションを考えると、
ますますひどいことになります。この点については\link{Section 3.4}で見ていくことにします。
ここでは、まずは代入を含む式について計算モデルを与えるという問題に取り組み、またシミュレーションの
設計をするのに局所状態を持つオブジェクトを使うことについて検討します。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.7}Exercise 3.7:} 
\link{Exercise 3.3}で述べた、パスワード機能を追加した\code{make\-/account}で作った
銀行口座オブジェクトについて考える。私たちの銀行システムでは、共同口座を作る能力が
必要だとする。これを実現する手続き\code{make\-/joint}を定義せよ。\code{make\-/joint}は三つの
引数を取る。一つ目はパスワード保護された口座である。二つ目の引数は口座を定義したときの
パスワードと一致している必要があり、そうでなければ\code{make\-/joint}演算を進めることはできない。
三番目の引数は新しいパスワードである。\code{make\-/joint}は、元の口座に新しいパスワードでも
アクセスできるようにする。例えば、\code{peter\-/acc}が\code{open\-/sesame}というパスワードを
持つ銀行口座だとすると、

\begin{scheme}
(define paul-acc
  (make-joint peter-acc 'open-sesame 'rosebud))
\end{scheme}

\noindent
このようにすることで、\code{paul\-/acc}という名前と\code{rosebud}というパスワードによって
\code{peter\-/acc}に対する取引ができるようにする。この新しい機能に対応するには、
\link{Exercise 3.3}の解答を修正するのがよいかもしれない。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.8}Exercise 3.8:} 
\link{Section 1.1.3}で評価モデルを定義したときに、式を評価する最初のステップはその部分式を
評価することだと述べました。しかし、部分式を評価する順番(例えば、左から右、または右から左)に
ついては規定していませんでした。代入を導入すると、手続きの引数を評価する順番によって結果が
変わるということが起こり得ます。単純な手続き\code{f}を定義して、次の式

\begin{scheme}
(+ (f 0) (f 1))
\end{scheme}

を評価する際に、\code{+}の引数の評価順が左から右であれば0を返し、右から左であれば1を返す
ようにせよ。
\end{quote}

\section{評価の環境モデル}
\label{Section 3.2}

\link{Chapter 1}で複合手続きを導入した際には、手続きを引数に適用するということの意味を
定義するため、評価の置換モデル(\link{Section 1.1.5})を使いました。

\begin{itemize}

\item
複合手続きを引数に適用するには、手続きの本体に出てくる仮引数を対応する引数で置き換えて、それを評価する。
\end{itemize}

\noindent
プログラミング言語で代入を認めることにすると、このような定義はもはや適切ではなくなります。
特に、\link{Section 3.1.3}では、代入があると変数はもはや単なる値に対する名前であるとは言えなく
なるということを示しました。変数は、値が格納できる``場所''を何らかの方法で指していなければ
ならないことになります。新しい評価モデルでは、これらの場所は\newterm{environments}(\jnewterm{環境})
と呼ばれる構造で保存されます。

環境というのは\newterm{frames}(\jnewterm{フレーム})が並んだものです。それぞれのフレームは、
変数の名前と、それに対応する値を結び付ける\newterm{bindings}(\jnewterm{束縛})のテーブル
(空のこともある)です(ひとつのフレームは、任意の変数に対して高々ひとつの束縛を持っています)。
それぞれのフレームは、そのほかに\newterm{enclosing environment}(\jnewterm{外側の環境})への
ポインタも持っています。例外として、ここで説明のために\newterm{global}(\jnewterm{グローバル})と
呼ぶものは外側の環境へのポインタを持ちません。ある環境についての\newterm{value of a variable}
(\jnewterm{変数の値})とは、環境の中でその変数に対する束縛を含む最初のフレームの中で、
その変数の束縛によって与えられる値ということになります。もしフレームの列の中にその変数に対する
束縛を規定しているものがなければ、その変数はその環境の中で\newterm{unbound}(\jnewterm{未束縛})
であるといいます。

\link{Figure 3.1}は、三つのフレームからなる簡単な環境の構造を示したものです。フレームには
それぞれ、I, II, IIIというラベルがついています。この図の中で、A, B, C, Dは環境へのポインタです。
CとDは同じ環境を指しています。変数\code{z}と\code{x}がフレームIIに束縛されていて、
\code{y}と\code{x}がフレームIに束縛されています。環境Dの中では、\code{x}の値は3です。
環境Bについても、\code{x}の値は3です。これは次のように決定されています。まず、列の最初の
フレーム(フレーム III)を調べます。\code{x}に対する束縛は見つからないので、外側の環境Dに進み、
フレーム Iで束縛が見つかります。一方、環境Aでは\code{x}の値は7です。列の最初のフレーム
(フレーム II)が\code{x}と7の束縛を含んでいるからです。環境Aについて、フレーム IIの\code{x}と7の
束縛が、フレーム Iの\code{x}と3の束縛を\newterm{shadow}(\jnewterm{隠蔽})しているといいます。

\begin{figure}[tb]
\phantomsection\label{Figure 3.1}
\centering
\begin{comment}
\heading{Figure 3.1:} A simple environment structure.

\begin{example}
           +--------+
           |      I |
           | x: 3   |
           | y: 5   |
           +--------+
              ^  ^
              |  |
            C |  | D
+---------+   |  |   +----------+
|      II |   |  |   |      III |
| z: 6    +---+  +---+ m: 1     |
| x: 7    |          | y: 2     |
+---------+          +----------+
\end{example}
\end{comment}
\includegraphics[width=48mm]{fig/chap3/Fig3.1.pdf}
\par\bigskip
\noindent
\heading{Figure 3.1:} 単純な環境構造
\end{figure}

環境は評価プロセスにとって不可欠なものです。式を評価するコンテキストを決めるのは環境だからです。
プログラミング言語の式は、それ自身意味を持たないとも言えます。式は、式が評価される環境があって
初めて意味を持つことになります。\code{(+ 1 1)}のような単純な式を解釈するのにも、\code{+}が加算の
記号だというコンテキストの中で演算をしていると理解していることが必要になります。そのため、私たちの
評価モデルの中では、式の評価について語るときには、必ず環境についても語ることにします。
また、インタプリタとのやりとりについて説明するために、グローバル環境というものがあると想定します。
グローバル環境は(外側の環境のない)単一のフレームからなり、そのフレームは記号の値として基本手続きとの
関連づけを含んでいるとします。例えば、\code{+}が加算の記号であるということは、記号\code{+}は
グローバル環境の中で基本要素の加算手続きに束縛されているというように捉えます。

\subsection{評価規則}
\label{Section 3.2.1}

インタプリタが組み合わせを評価するやり方に関する全体的な仕様は、最初に\link{Section 1.1.3}で
導入したものと同じものになります。

\begin{itemize}

\item
組み合わせを評価するには、

\end{itemize}

\begin{enumerate}

\item
組み合わせの部分式を評価する。\footnote{
代入があると、ステップ1に難しいところが出てきます。\link{Exercise 3.8}で示したように、
代入があると、組み合わせの部分式がどういう順番で評価されるかによって違う値を返すような
式が書けるようになるからです。そのため、正確には、ステップ1の評価順序(例えば、左から右や
右から左)を規定しておく必要があります。しかし、この順序は常に実装の細部として捉えられるべき
ものであって、特定の順序に依存したプログラムは決して書いてはいけません。例えば、よくできた
コンパイラであれば、部分式の評価順序を変えることによってプログラムを最適化したりすることも
ありえるからです。}

\item
演算子となっている部分式の値を、オペランドとなっている部分式の値に適用する。

\end{enumerate}

\noindent
評価の環境モデルは、複合手続きを引数に適用することの意味を規定することによって、
置換モデルに取って代わります。

評価の環境モデルでは、手続きは常に、何らかのコードと、ある環境へのポインタというペアに
なります。手続きを作る方法はひとつだけです。その方法とは、\( \lambda \)式を評価することです。
\( \lambda \)式を評価することによって手続きが作られますが、\( \lambda \)式のテキストが
手続きのコードとなり、\( \lambda \)式が評価されたときの環境が手続きの環境になります。
例えば、次の手続きの定義が、

\begin{scheme}
(define (square x)
  (* x x))
\end{scheme}

\noindent
グローバル環境の中で評価される場合について考えてみましょう。この手続き定義の文法は、その下にある
暗黙の\( \lambda \)式に対するシンタックスシュガーにすぎません。次のものを使っても同じことです。

\begin{scheme}
(define square
  (lambda (x) (* x x)))
\end{scheme}

\noindent
これは、グローバル環境の中で\code{(lambda (x) (* x x))}を評価し、グローバル環境の中で\code{square}
とその結果を束縛するものです。

\link{Figure 3.2}は、この\code{define}式を評価した結果を示したものです。手続きオブジェクトは
ペアであり、そのコード部分は、手続きが\code{x}という仮引数をひとつ持つということと、手続きの
本体が\code{(* x x)}であるということを規定しています。手続きの環境部分はグローバル環境への
ポインタになります。\( \lambda \)式を評価して手続きを作ったのがグローバル環境の中だったからです。
手続きオブジェクトと記号\code{square}を結びつける束縛は、グローバルなフレームに追加されています。
一般的に、\code{define}はフレームに束縛を追加することによって定義を作成します。

\begin{figure}[tb]
\phantomsection\label{Figure 3.2}
\centering
\begin{comment}
\heading{Figure 3.2:} Environment structure produced by
evaluating \code{(define (square x) (* x x))} in the global environment.

\begin{example}
           +----------------------+
           | other variables      |
global --->|                      |
env        | square: --+          |
           +-----------|----------+
                       |       ^
(define (square x)     |       |
  (* x x))             V       |
                   .---.---.   |
                   | O | O-+---+
                   `-|-^---'
                     |
                     V
                   parameters: x
                   body: (* x x)
\end{example}
\end{comment}
\includegraphics[width=49mm]{fig/chap3/Fig3.2b.pdf}
\begin{quote}
\heading{Figure 3.2:} グローバル環境の中で\code{(define (square x) (* x x))}を評価することによって作られる環境
\end{quote}
\end{figure}

手続きの作られ方がわかったので、手続きがどのように適用されるかということも説明できるように
なります。環境モデルは、以下のことを規定します。手続きを引数に適用するには、仮引数を引数の値に
束縛するフレームを含む新しい環境を作ります。このフレームの外側の環境は、手続きによって規定される
環境です。そして、この新しい環境の中で、手続きの本体を評価します。

この規則が実際にどのように適用されるか見てみましょう。\link{Figure 3.3}は、グローバル環境で
\code{(square 5)}という式を評価することによって作られる環境構造を示したものです。ここで、
\code{square}は\link{Figure 3.2}で生成された手続きです。手続きを適用すると新しい環境が作られます。
図の中ではE1というラベルをつけています。この環境の最初のフレームでは、手続きの仮引数である
\code{x}が、引数の5に束縛されています。このフレームから上に伸びている矢印のポインタは、
このフレームの外側の環境がグローバル環境であるということを示しています。ここでグローバル環境が
選ばれているのは、\code{square}手続きオブジェクトの環境部分が指しているのがグローバル環境だからです。
E1の中で、手続きの本体である\code{(* x x)}を評価します。E1の中での\code{x}の値は5であるため、
結果は\code{(* 5 5)}、つまり25になります。

\begin{figure}[tb]
\phantomsection\label{Figure 3.3}
\centering
\begin{comment}
\heading{Figure 3.3:} Environment created by evaluating
\code{(square 5)} in the global environment.

\begin{example}
          +------------------------------------+
          | other variables                    |
global -->|                                    |
env       | square: --+                        |
          +-----------|---------------------+--+
                      |       ^             ^
(square 5)            |       |             |
                      V       |             |
                  .---.---.   |         +---+--+
                  | O | O-+---+   E1 -->| x: 5 |
                  `-|-^---'             +------+
                    |
                    V
                  parameters: x
                  body: (* x x)
\end{example}
\end{comment}
\includegraphics[width=78mm]{fig/chap3/Fig3.3b.pdf}
\begin{quote}
\heading{Figure 3.3:} グローバル環境で\code{(square 5)}を評価することによって作られる環境
\end{quote}
\end{figure}

手続き適用の環境モデルを要約すると、次の二つの規則になります。

\begin{itemize}

\item
引数セットへの手続きオブジェクトの適用は、フレームを構築し、手続きの仮引数を呼び出しの引数に
束縛し、それから新しく構築された環境という文脈の中で手続きの本体を評価することによって行う。
新しいフレームは、適用する手続きオブジェクトの環境部分を外側の環境として持つ。

\item
手続きは、与えられた環境について\( \lambda \)式を評価することによって作る。結果としてできる
手続きオブジェクトは、\( \lambda \)式のテキストと、手続きが作成された環境へのポインタから
なるペアである。

\end{itemize}

\noindent
このほかに、\code{define}を使って記号を定義すると、現在の環境フレームの中に束縛を作り、
その記号に指定の値を割り当てるということも規定します。
\footnote{
もしその変数に対する束縛が現在のフレームにすでにあれば、その束縛は変更されます。
こうすると記号が再定義できるので便利です。しかし、それができるということは、\code{define}を
使って値の変更ができるということになります。つまり、明示的に\code{set!}を使っていないのに、
代入に関する問題が出てくることになります。このため、すでに存在する記号を再定義しようとすると
エラーや警告を出すようにしてほしいという人もいます。}
最後に、\code{set!}のふるまいを規定します。そもそも、環境モデルを導入しなければならなくなったのは
この演算のせいでした。ある環境で、
\code{(set!}\( \;\langle \)\var{variable}\( \kern0.08em\rangle \)\( \;\langle \)\var{value}\( \kern0.08em\rangle \)\code{)}
という式を評価すると、その環境の中でのその変数に対する束縛を探し、その束縛を変更して新しい値を
指すようにします。つまり、その変数に対する束縛を含む、その環境の中での最初のフレームを探し、
そのフレームを修正するということです。もしその変数がその環境の中で束縛されていなければ、
\code{set!}はエラーを発生させます。

これらの評価ルールは、置換モデルよりはだいぶ複雑ですが、まだそれなりに単純です。それに、この
評価モデルは抽象的ではあるものの、インタプリタが式を評価するやり方を正しく描写しています。
\link{Chapter 4}では、ちゃんと動くインタプリタを実装するのに、このモデルが青写真となってくれる
ということを見ていきます。次の節では、いくつかの具体例としてのプログラムを解析していくことで、
このモデルの詳細について解説していきます。

\subsection{単純な手続きの適用}
\label{Section 3.2.2}

\link{Section 1.1.5}で置換モデルを導入した際に、以下のような手続き定義があるとき、
\code{(f 5)}という組み合わせを評価した結果がどのようにして136になるかということを
示しました。

\begin{scheme}
(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
\end{scheme}

\noindent
同じ例を環境モデルを使って分析することもできます。\link{Figure 3.4}は、グローバル環境で
\code{f}, \code{square}, \code{sum\-/of\-/squares}の定義を評価することによって作られる
三つの手続きオブジェクトを示したものです。それぞれの手続きオブジェクトは、何かしらのコードと
グローバル環境へのポインタから構成されています。

\begin{figure}[tb]
\phantomsection\label{Figure 3.4}
\centering
\begin{comment}
\heading{Figure 3.4:} Procedure objects in the global frame.

\begin{example}
          +--------------------------------------------+
          | sum-of-squares:                            |
global -->| square:                                    |
env       | f: --+                                     |
          +------|--------------+--------------+-------+
                 |     ^        |     ^        |     ^
                 |     |        |     |        |     |
                 V     |        V     |        V     |
             .---.---. |    .---.---. |    .---.---. |
             | O | O-+-+    | O | O-+-+    | O | O-+-+
             `-|-^---'      `-|-^---'      `-|-^---'
               |              |              |
               V              V              V
   parameters: a          parameters: x  parameters: x, y
   body: (sum-of-squares  body: (* x x)  body: (+ (square x)
           (+ a 1)                                (square y))
           (* a 2))
\end{example}
\end{comment}
\includegraphics[width=106mm]{fig/chap3/Fig3.4a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.4:} グローバルフレーム内の手続きオブジェクト
\end{figure}

\link{Figure 3.5}には、式\code{(f 5)}を評価することによって作られる環境構造を示してあります。
\code{f}を呼び出すことによってE1という新しい環境が作られ、その中のフレームで\code{f}の仮引数である
\code{a}が引数の5に束縛されます。E1の中で、\code{f}の本体を評価します。

\begin{scheme}
(sum-of-squares (+ a 1) (* a 2))
\end{scheme}

\noindent
この組み合わせを評価するには、まず部分式から評価します。最初の部分式\code{sum\-/of\-/squares}は、
値として手続きオブジェクトを持っています(この値の見つけ方に注意してください。まずE1の最初の
フレームを見ますが、そこには\code{sum\-/of\-/squares}に対する束縛がありません。次に、外側の
環境、つまりグローバル環境に進み、\link{Figure 3.4}に示した束縛が見つかります)。
残り二つの部分式の評価は、基本演算\code{+}と\code{*}を適用して\code{(+ a 1)}と\code{(* a 2)}という
二つの組み合わせを評価することによって行えます。結果はそれぞれ6, 10になります。

今度は、手続きオブジェクト\code{sum\-/of\-/squares}を引数6, 10に適用します。その結果、新しい
環境E2が作られ、その中で仮引数\code{x}, \code{y}がそれらの引数に束縛されます。E2の中で、
\code{(+ (square x) (square y))}という組み合わせを評価します。すると、次は\code{(square x)}を
評価することになります。\code{square}はグローバルフレームで見つかり、\code{x}は6です。
もう一度新しい環境E3を用意して、\code{x}を6に束縛し、E3の中で\code{square}の本体\code{(* x x)}を
評価します。また、\code{sum\-/of\-/squares}の適用の中では、\code{(square y)}という部分式も
評価する必要があります。ここで、\code{y}は10です。この二回目の\code{square}の呼び出しでは、
また別の環境E4が作られ、その中で\code{square}の形式パラメタ\code{x}が10に束縛されます。
そして、E4の中で\code{(* x x)}を評価しなければなりません。

\begin{figure}[tb]
\phantomsection\label{Figure 3.5}
\centering
\begin{comment}
\heading{Figure 3.5:} Environments created by evaluating
\code{(f 5)} using the procedures in \link{Figure 3.4}.

\begin{example}
          +-----------------------------------------------------+
global -->|                                                     |
env       +-----------------------------------------------------+
            ^              ^                ^               ^
(f 5)       |              |                |               |
        +------+       +-------+        +------+        +-------+
  E1 -->| a: 5 |  E2 ->| x: 6  |  E3 -->| x: 6 |  E4 -->| x: 10 |
        |      |       | y: 10 |        |      |        |       |
        +------+       +-------+        +------+        +-------+
   (sum-of-squares   (+ (square x)       (* x x)         (* x x)
     (+ a 1)            (square u))
     (+ a 2))
\end{example}
\end{comment}
\includegraphics[width=100mm]{fig/chap3/Fig3.5a.pdf}
\begin{quote}
\heading{Figure 3.5:} \link{Figure 3.4}内の手続きを用いて\code{(f 5)}を評価することで作られた環境
\end{quote}
\end{figure}

注意すべき重要な点は、\code{square}を呼び出すたびに、\code{x}の束縛を含む新しい環境が作られる
ということです。ここから、それぞれのフレームが、どれも\code{x}という名前を持つ異なるローカル変数を
それぞれ別々にしておくのに役に立っているということがわかります。\code{square}によって作られた
それぞれのフレームがグローバル環境を指していることに注意してください。これは、
\code{square}の手続きオブジェクトが指している環境がグローバル環境だからです。

部分式が評価された後には、その結果が返されます。\code{square}の二回の呼び出しによって
生成された値は、\code{sum\-/of\-/squares}によって加算され、その結果が\code{f}によって返されます。
ここで私たちが着目しているのは環境構造なので、これらの返される値がどのように複数の呼び出しの間で
渡されていくかというところには深入りしません。しかし、これも評価プロセスの重要な側面のひとつです。
この点については、\link{Chapter 5}で詳しく見ていきます。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.9}Exercise 3.9:} 
\link{Section 1.2.1}では、階乗を計算する二つの手続きを解析するのに置換モデルを使った。
再帰版は以下の通りで、

\begin{scheme}
(define (factorial n)
  (if (= n 1) 1 (* n (factorial (- n 1)))))
\end{scheme}

\noindent
反復版は以下の通りである。

\begin{scheme}
(define (factorial n) (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
\end{scheme}

それぞれの\code{factorial}手続きを使って\code{(factorial 6)}を評価することによって作られる
環境構造を示せ。
\footnote{
\link{Section 1.2.1}で述べた、インタプリタは\code{fact\-/iter}のような手続きを末尾再帰を使う
ことによって一定の空間量で実行できるという主張は、環境モデルでは曖昧にしておきます。
末尾再帰については、\link{Section 5.4}でインタプリタの制御構造を扱う際に考察します。}
\end{quote}

\subsection{局所状態の保管場所としてのフレーム}
\label{Section 3.2.3}

局所状態を持つオブジェクトを表現するのに手続きと代入を使うやり方について考えるのには
環境モデルが役に立ちます。ひとつの例として、次の手続きを呼び出すことによって作られる
\link{Section 3.1.1}の``引き出し処理器''について考えてみましょう。

\begin{scheme}
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
\end{scheme}

\noindent
次の式を評価し、

\begin{scheme}
(define W1 (make-withdraw 100))
\end{scheme}

\noindent
続けて次の式を評価する場合について説明します。

\begin{scheme}
(W1 50)
~\textit{50}~
\end{scheme}

\noindent
\link{Figure 3.6}は、グローバル環境で\code{make\-/withdraw}手続きを定義した結果を示しています。
この定義は、グローバル環境へのポインタを持つ手続きオブジェクトを作成します。ここまでは
これまで見た例と同じですが、手続きの本体がそれ自身\( \lambda \)式であるというところが違います。

\begin{figure}[tb]
\phantomsection\label{Figure 3.6}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 3.6:} Result of defining \code{make\-/withdraw} in the global environment.

\begin{example}
          +---------------------------+
global -->| make-withdraw: --+        |
env       +------------------|--------+
                             |      ^
                             V      |
                         .---.---.  |
                         | O | O-+--+
                         `-|-^---'
                           |
                           V
         parameters: balance
         body: (lambda (amount)
                 (if (>= balance amount)
                     (begin (set! balance
                                  (- balance amount))
                            balance)
                     "Insufficient funds"))
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=91mm]{fig/chap3/Fig3.6b.pdf}
\begin{quote}
\heading{Figure 3.6:} グローバル環境で\code{make\-/withdraw}を定義した結果
\end{quote}
\end{figure}

計算の面白いところは、手続き\code{make\-/withdraw}を引数に適用するときに起こります。

\begin{scheme}
(define W1 (make-withdraw 100))
\end{scheme}

\noindent
まず、いつも通り環境E1を立ち上げ、その中で仮引数\code{balance}を引数の100に束縛します。
この環境の中で、\code{make\-/withdraw}の本体、つまり\( \lambda \)式を評価します。
すると、新しい手続きオブジェクトが構築され、そのコード部分は\code{lambda}で規定されるものとなり、
環境部分は、\code{lambda}が評価された環境であるE1になります。結果としてできる手続きオブジェクトは、
\code{make\-/withdraw}の呼び出しに対して返される値になります。これがグローバル環境で\code{W1}に
束縛されます。これは、\code{define}自身がグローバル環境で評価されているからです。
\link{Figure 3.7}に最終的な環境構造を示します。

これで、\code{W1}が引数に適用されるとどうなるか解析できるようになります。

\begin{scheme}
(W1 50)
~\textit{50}~
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.7}
\centering
\begin{comment}
\heading{Figure 3.7:} Result of evaluating \code{(define W1 (make\-/withdraw 100))}.

\begin{example}
          +-----------------------------------------------+
          | make-withdraw: -----------------------+       |
global -->|                                       |       |
          | W1: --+                               |       |
          +-------|-------------------------------|-------+
                  |                ^              |     ^
                  |                |              V     |
                  |        +-------+------+   .---.---. |
                  |  E1 -->| balance: 100 |   | O | O-+-+
                  |        +--------------+   `-|-^---'
                  V                ^            |
              .---.---.            |            V
            +-+-O | O-+------------+    parameters: balance
            | `---^---'                 body: ...
            V
    parameters: amount
    body: (if (>= balance amount)
              (begin (set! balance (- balance amount))
                     balance)
              "Insufficient funds")
\end{example}
\end{comment}
\includegraphics[width=100mm]{fig/chap3/Fig3.7a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.7:} \code{(define W1 (make\-/withdraw 100))}を評価した結果
\end{figure}

まずフレームを構築し、その中で\code{W1}の仮引数\code{amount}を引数50に束縛します。
注意すべき重要な点は、このフレームが持っている外側の環境が、グローバル環境ではなく
環境E1だというところです。これは、\code{W1}手続きオブジェクトによって規定されている
環境がE1だからです。この新しい環境の中で、手続きの本体を評価します。

\begin{scheme}
(if (>= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    "Insufficient funds")
\end{scheme}

\noindent
結果の環境構造を\link{Figure 3.8}に示します。評価されている式は、\code{amount}と\code{balance}の
両方を参照しています。\code{amount}は環境の最初のフレームで見つかり、\code{balance}は外側の環境の
ポインタをたどることによってE1で見つかります。

\begin{figure}[tb]
\phantomsection\label{Figure 3.8}
\centering
\begin{comment}
\heading{Figure 3.8:} Environments created by applying the procedure object \code{W1}.

\begin{example}
          +---------------------------------------------------+
          | make-withdraw: ...                                |
global -->|                                                   |
env       | W1: --+                                           |
          +-------|-------------------------------------------+
                  |               ^
                  |               |
                  |       +-------+------+ Here is the balance
                  | E1 -->| balance: 100 | that will be changed
                  |       +--------------+ by the set!.
                  V               ^   ^
              .---.---.           |   +----+
              | O | O-+-----------+        |
              `-|-^---'             +------+-----+
                |                   | amount: 50 |
                V                   +------------+
      parameters: amount   (if (>= balance amount)
      body: ...                (begin (set! balance
                                            (- balance amount))
                                      balance)
                               "Insufficient funds")
\end{example}
\end{comment}
\includegraphics[width=99mm]{fig/chap3/Fig3.8c.pdf}
\begin{quote}
\heading{Figure 3.8:} 手続きオブジェクト\code{W1}を適用することによって作成される環境
\end{quote}
\end{figure}

\code{set!}が実行されると、E1中の\code{balance}の束縛が変更されます。\code{W1}の呼び出しが
終わるときには\code{balance}は50になっていて、\code{balance}を含むフレームはそれまで通り
手続きオブジェクト\code{W1}によって指されています。\code{balance}を変更するコードを実行した、
\code{amount}を束縛しているフレームは、もういらなくなりました。このフレームを構築することに
なった手続きの呼び出しは終了していますし、環境のほかの部分からこのフレームを指しているところも
ないからです。次に\code{W1}が呼ばれるときには、新しいフレームが構築されて\code{amount}を束縛し、
その外側の環境はE1になります。手続きオブジェクト\code{W1}の局所状態を持っておく``場所''
としての役割をE1が果たしているということがわかります。\link{Figure 3.9}に、\code{W1}を呼び出した
後の様子を示します。

もう一度\code{make\-/withdraw}を呼び出して、二つ目の``withdraw''オブジェクトを作るとどうなるか
見てみましょう。

\begin{scheme}
(define W2 (make-withdraw 100))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.9}
\centering
\begin{comment}
\heading{Figure 3.9:} Environments after the call to \code{W1}.

\begin{example}
           +------------------------------------+
           | make-withdraw: ...                 |
global --->|                                    |
env        | W1: --+                            |
           +-------|----------------------------+
                   |                   ^
                   |                   |
                   |            +------+------+
                   |     E1 --->| balance: 50 |
                   |            +-------------+
                   V                   ^
               .---.---.               |
               | O | O-+---------------+
               `-|-^---'
                 |
                 V
          parameters: amount
          body: ...
\end{example}
\end{comment}
\includegraphics[width=96mm]{fig/chap3/Fig3.9a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.9:} \code{W1}呼び出し後の環境
\end{figure}

\begin{figure}[tb]
\phantomsection\label{Figure 3.10}
\centering
\begin{comment}
\heading{Figure 3.10:} Using \code{(define W2 (make\-/withdraw 100))} to create a second object.

\begin{example}
         +-------------------------------------------------+
         | make-withdraw: ...                              |
global ->| W2: ---------------------------+                |
env      | W1: --+                        |                |
         +-------|------------------------|----------------+
                 |              ^         |              ^
                 |              |         |              |
                 |       +------+------+  |       +------+-------+
                 |  E1 ->| balance: 50 |  |  E2 ->| balance: 100 |
                 |       +-------------+  |       +--------------+
                 V              ^         V              ^
             .---.---.          |     .---.---.          |
             | O | O-+----------+     | O | O-+----------+
             `-|-^---'                `-|-^---'
               | +----------------------+
               V V
        parameters: amount
        body: ...
\end{example}
\end{comment}
\includegraphics[width=108mm]{fig/chap3/Fig3.10a.pdf}
\begin{quote}
\heading{Figure 3.10:} \code{(define W2 (make\-/withdraw 100))}を使って二つ目のオブジェクトを作成
\end{quote}
\end{figure}

こうすると、\link{Figure 3.10}のような環境構造が生成されます。この図は、\code{W2}が
手続きオブジェクトであるということ、つまり何らかのコードとひとつの環境のペアであるということを
示しています。\code{W2}の環境E2は、\code{make\-/withdraw}を呼び出すことによって作られます。
この環境は、\code{balance}に対する局所的な束縛を持つフレームを含んでいます。一方、\code{W1}と
\code{W2}のコードは同じです。どちらも、\code{make\-/withdraw}本体の\( \lambda \)式によって
規定されるコードです。
\footnote{
\code{W1}と\code{W2}はコンピュータ内の同じ物理コードを共有しているのか、それともそれぞれ
コードのコピーを持っているのかということは、実装上の詳細に属することです。\link{Chapter 4}で
実装するインタプリタでは、コードは実際には共有されることになります。}
これで、なぜ\code{W1}と\code{W2}が独立したオブジェクトとしてふるまうのかがわかりました。
\code{W1}の呼び出しはE1に格納された状態変数\code{balance}を参照し、\code{W2}の呼び出しは
E2に格納された\code{balance}を参照しています。このため、一方のオブジェクトの局所状態に
変更を加えても、もう一方のオブジェクトには影響がありません。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.10}Exercise 3.10:} 
\code{make\-/withdraw}手続きでは、ローカル変数\code{balance}は\code{make\-/withdraw}の仮引数と
して作られる。局所状態変数は、\code{let}を使って、以下のように明示的に作ることもできる。

\begin{scheme}
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
\end{scheme}

\code{let}は手続き呼び出しに対する単純なシンタックスシュガーだという\link{Section 1.3.2}の内容を
思い出そう。

\begin{scheme}
(let ((~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~)) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上記の式は、次の式の別の書き方として解釈される。

\begin{scheme}
((lambda (~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~) ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~)
\end{scheme}

環境モデルを使って、この\code{make\-/withdraw}の別のバージョンを解析し、上のような図を描いて
次のやりとりを説明せよ。

\begin{scheme}
(define W1 (make-withdraw 100))
(W1 50)
(define W2 (make-withdraw 100))
\end{scheme}

\code{make\-/withdraw}のどちらのバージョンも同じふるまいを持つオブジェクトを作るということを示せ。
環境構造は二つのバージョンの間でどのように異なるだろうか。
\end{quote}

\subsection{内部定義}
\label{Section 3.2.4}

\link{Section 1.1.8}では、手続きが内部定義を持つことができるという考えを導入し、それによって、
次の平方根を計算する手続きに出てくるようなブロック構造が作れるようになりました。

\begin{scheme}
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
\end{scheme}

\noindent
今回は、これらの内部定義がどうして望み通りにふるまうのかを見るのに環境モデルを使うことができます。
\link{Figure 3.11}は、式\code{(sqrt 2)}を評価する途中の、\code{guess}を1として内部手続き
\code{good\-/enough?}に対する初回の呼び出しを行った時点の様子を示しています。

環境構造をよく見てください。\code{sqrt}はグローバル環境の中にある記号で、手続きオブジェクトに
束縛されています。その手続きオブジェクトに関連づけられている環境はグローバル環境です。
\code{sqrt}が呼ばれると、グローバル環境の下に新しい環境E1が作られます。その中では、
仮引数\code{x}が2に束縛されています。それから、\code{sqrt}の本体がE1の中で評価されます。
\code{sqrt}の本体の最初の式は以下の通りなので、

\begin{scheme}
(define (good-enough? guess)
  (< (abs (- (square guess) x)) 0.001))
\end{scheme}

\noindent
この式を評価するときに、手続き\code{good\-/enough?}が環境E1の中に定義されます。より正確に
言うと、記号\code{good\-/enough?}がE1の最初のフレームに追加され、環境E1に関連づけられた
手続きオブジェクトに束縛されるということになります。同じように、\code{improve}と
\code{sqrt\-/iter}がE1の中で手続きとして定義されます。簡単にするために、\link{Figure 3.11}では
\code{good\-/enough?}に対する手続きオブジェクトだけを示しています。

\begin{figure}[tb]
\phantomsection\label{Figure 3.11}
\centering
\begin{comment}
\heading{Figure 3.11:} \code{Sqrt} procedure with internal definitions.

\begin{example}
          +--------------------------------------------------+
global -->| sqrt: --+                                        |
env       |         |                                        |
          +---------|----------------------------------------+
                    V       ^                   ^
                .---.---.   |                   |
     +----------+-O | O-+---+        +----------+------------+
     |          `---^---'            | x: 2                  |
     V                         E1 -->| good-enough?: -+      |
parameters: x                        | improve: ...   |      |
body: (define good-enough? ...)      | sqrt-iter: ... |      |
      (define improve ...)           +----------------|------+
      (define sqrt-iter ...)          ^  ^            |     ^
      (sqrt-iter 1.0)                 |  |            V     |
                            +---------++ |        .---.---. |
                      E2 -->| guess: 1 | |        | O | O-+-+
                            +----------+ |        `-|-^---'
                      call to sqrt-iter  |          |
                                         |          V
                               +---------++    parameters: guess
                         E3 -->| guess: 1 |    body: (< (abs ...)
                               +----------+             ...)
                         call to good-enough?
\end{example}
\end{comment}
\includegraphics[width=107mm]{fig/chap3/Fig3.11a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.11:} 内部定義を持つ\code{sqrt}手続き
\end{figure}


局所手続きが定義された後に、式\code{(sqrt\-/iter 1.0)}が評価されます。この式の評価が
行われる環境は、やはりE1です。そのため、E1の中で\code{sqrt\-/iter}に束縛されている手続き
オブジェクトが、1を引数として呼び出されます。この呼び出しで環境E2が作られ、その中では
\code{sqrt\-/iter}の仮引数\code{guess}が1に束縛されています。\code{sqrt\-/iter}は、
(E2の)\code{guess}の値を引数として\code{good\-/enough?}を呼び出します。こうすると
別の環境E3が構築され、\code{guess}(\code{good\-/enough?}の引数)は1に束縛されます。
\code{sqrt\-/iter}と\code{good\-/enough?}はどちらも\code{guess}という名前の仮引数を
持っていますが、これらは別々のフレームにある別々のローカル変数です。また、E2とE3は両方とも
外側の環境としてE1を持っています。手続き\code{sqrt\-/iter}と\code{good\-/enough?}はどちらも
環境部分としてE1を持っているためです。その結果、\code{good\-/enough?}の本体の中の記号\code{x}は、
E1に出てくる\code{x}の束縛を参照することになります。これは、元の\code{sqrt}手続きの呼び出しに
使われた\code{x}の値ということになります。

このように、環境モデルを使うと、プログラムをモジュール化する便利なテクニックとして局所手続きの
定義を使ううえでの二つのキーとなる性質について説明することができます。

\begin{itemize}

\item
局所手続きの名前は、それらを囲む手続きの外側の名前と衝突しない。局所手続きの名前は、
グローバル環境に束縛されるのではなく、手続きが実行されるときに作られるフレームに
束縛されるからである。

\item
局所手続きは、単純に仮引数の名前を自由変数として使うだけで、それらを囲む手続きの引数に
アクセスできる。これは、局所手続きの本体が、外側の手続きの評価環境に属する環境で評価される
からである。

\end{itemize}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.11}Exercise 3.11:} 
\link{Section 3.2.3}では、局所状態を持つ手続きのふるまいがどのように環境モデルによって
説明されるかを見た。ここでは、内部定義がどのように動くのかを見た。典型的なメッセージパッシング
手続きは、これら両方の側面を持っている。\link{Section 3.1.1}の銀行口座手続きについて考えてみよう。

\begin{scheme}
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else 
           (error "Unknown request: 
                   MAKE-ACCOUNT"
                  m))))
  dispatch)
\end{scheme}

次のやりとりによって生成される環境構造を示せ。

\begin{scheme}
(define acc (make-account 50))
((acc 'deposit) 40)
~\textit{90}~
((acc 'withdraw) 60)
~\textit{30}~
\end{scheme}

\code{acc}の局所状態はどこに保存されているだろうか。次のように、別の口座を定義したとする。

\begin{scheme}
(define acc2 (make-account 100))
\end{scheme}

二つの口座の局所状態は、どのようにして別々に保存されることになるだろうか。\code{acc}と
\code{acc2}では、環境構造のどの部分が共有されているだろうか。
\end{quote}

\section{可変データによるモデル化}
\label{Section 3.3}

\link{Chapter 2}では、複合データを複数の部品からなる計算オブジェクトを作る手段として
使う方法について取り上げました。これは、複数の側面を持つ現実世界のオブジェクトをモデル化
するためのものでした。また、\link{Chapter 2}ではデータ抽象化の規律を導入しました。
その規律に従うと、データ構造は、データオブジェクトを作るコンストラクタと、複合データ
オブジェクトの部品にアクセスするセレクタによって規定することになっていました。
しかし今では、データというものには\link{Chapter 2}では触れなかったような別の側面があると
いうことがわかっています。状態が変化するオブジェクトからなるシステムをモデル化しようとすると、
複合データを構築したり選択を行ったりするだけでなく、それらを修正する必要も出てきます。
状態の変化する複合オブジェクトをモデル化するために、ここでセレクタとコンストラクタに加えて、
データオブジェクトを変更する\newterm{mutators}(\jnewterm{ミューテータ})と呼ばれる演算を
含めたデータ抽象化を設計することにします。例えば、銀行システムをモデル化しようとすると、
口座残高を変更する必要があります。このため、銀行口座を表すデータ構造は、例えば次のように
指定された口座の残高を指定された新しい値に変更する演算ができるようにすることが考えられます。

\begin{scheme}
(setbalance! ~\( \dark \langle \)~~\var{\dark account}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark newvalue}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
ミューテータが定義されているデータオブジェクトは、\newterm{mutable data objects}
(\jnewterm{可変データオブジェクト})と呼ばれます。

\link{Chapter 2}では、複合データを合成するための汎用的な``糊''としてペアを導入しました。
この節では、ペアのための基本的なミューテータを定義することから始め、可変データオブジェクトを
構築するためのブロックとしてペアを使うことができるようにします。これらのミューテータはペアの
表現力を大幅に拡張し、それによって\link{Section 2.2}で取り組んだ列や木構造以外のデータ構造も
作れるようになります。また、シミュレーションの例もいくつか取り上げます。それらの例では、複雑な
システムを局所状態を持つオブジェクトの集合としてモデルすることになります。

\subsection{可変リスト構造}
\label{Section 3.3.1}

ペアに対する基本演算---\code{cons}, \code{car}, \code{cdr}---は、リスト構造を構築し、
またリスト構造から部品を選択するために使うことができます。しかし、これらはリスト構造を変更する
ことはできません。これまで学んできた、\code{append}や\code{list}のようなリスト演算についても
同じことが言えます。これらは、\code{cons}, \code{car}, \code{cdr}によって定義できるものだからです。
リスト構造を変更するには、新しい命令が必要となります。

ペアに対する基本ミューテータは\code{set\-/car!}と\code{set\-/cdr!}です。\code{set\-/car!}は二つの
引数を取り、一つ目の引数はペアでなければなりません。\code{set\-/car!}はこのペアを変更し、
\code{car}ポインタを\code{set\-/car!}の第二引数へのポインタに置き換えます。
\footnote{
\code{set\-/car!}と\code{set\-/cdr!}の返す値は実装依存です。\code{set!}同様、これらの命令は
効果のために使うものです。}

\begin{figure}[tp]
\phantomsection\label{Figure 3.12}
\centering
\begin{comment}
\heading{Figure 3.12:} Lists \code{x}: \code{((a b) c d)} and \code{y}: \code{(e f)}.

\begin{example}
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | c |         | d |
       |           +---+         +---+
       |           +---+---+     +---+---+
       +---------->| * | *-+---->| * | / |
                   +-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | a |         | b |
                   +---+         +---+
                   +---+---+     +---+---+
              y -->| * | *-+---->| * | / |
                   +-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=72mm]{fig/chap3/Fig3.12b.pdf}
\par\bigskip
\noindent
\heading{Figure 3.12:} リスト \code{x}: \code{((a b) c d)}と\code{y}: \code{(e f)}
\end{figure}

例として、\link{Figure 3.12}に示すように、\code{x}がリスト\code{((a b) c d)}に束縛され、
\code{y}がリスト\code{(e f)}に束縛されているという場合について考えます。
式\code{ (set\-/car!  x y)}を評価すると、\code{x}が束縛されているペアが変更され、
その\code{car}を\code{y}の値で置き換えます。演算の結果を\link{Figure 3.13}に示します。
構造\code{x}は変更され、今では\code{((e f) c d)}と表示されるような構造になっています。
置き換えられたポインタが指していたリスト\code{(a b)}を表す二つのペアは、今では元の構造から
切り離されています。
\footnote{
ここから、リストに対して変更演算を行うと、アクセス可能な構造の部品になっていない``garbage''
(ゴミ)ができるかもしれないということがわかります。\link{Section 5.3.2}では、Lispのメモリ管理
システムは\newterm{garbage collector}(\jnewterm{ガベージコレクタ})というものを含んでいて、
それによって必要のないペアが使っていたメモリ空間をリサイクルということを学びます。}

\link{Figure 3.13}と\link{Figure 3.14}を見比べてみてください。後者は、\code{x}と\code{y}が
\link{Figure 3.12}の元のリストに束縛されている状態で\code{(define z (cons y (cdr x)))}を
実行した結果を示したものです。変数\code{z}は\code{cons}演算によって作られた新しいペアに
束縛されるようになっていますが、\code{x}が束縛されているリストは変化していません。

\begin{figure}[bp]
\phantomsection\label{Figure 3.13}
\centering
\begin{comment}
\heading{Figure 3.13:} Effect of \code{(set\-/car! x y)} on the lists in \link{Figure 3.12}.

\begin{example}
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | c |         | d |
       |           +---+         +---+
       |           +---+---+     +---+---+
       |           | * | *-+---->| * | / |
       |           +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | a |         | b |
       |           +---+         +---+
       +---------->+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=72mm]{fig/chap3/Fig3.13b.pdf}
\par\bigskip
\noindent
\heading{Figure 3.13:} \link{Figure 3.12}のリストに対する\code{(set\-/car! x y)}の効果
\end{figure}


\begin{figure}[tp]
\phantomsection\label{Figure 3.14}
\centering
\begin{comment}
\heading{Figure 3.14:} Effect of \code{(define z (cons y (cdr x)))} on the lists in \link{Figure 3.12}.

\begin{example}
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+ +-->+-|-+---+     +-|-+---+
       |       |     V             V
       |       |   +---+         +---+
       |       |   | c |         | d |
       |       |   +---+         +---+
       |       |   +---+---+     +---+---+
       +-------+-->| * | *-+---->| * | / |
               |   +-|-+---+     +-|-+---+
     +---+---+ |     V             V
z -->| * | *-+-+   +---+         +---+
     +-|-+---+     | a |         | b |
       |           +---+         +---+
       +---------->+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=72mm]{fig/chap3/Fig3.14b.pdf}
\begin{quote}
\heading{Figure 3.14:} \link{Figure 3.12}のリストに対する\code{(define z (cons y (cdr x)))}の効果
\end{quote}
\end{figure}

\clearpage

\noindent
\code{set\-/cdr!}演算は\code{set\-/car!}と似ています。唯一の違いは、置き換えるのが
ペアの\code{car}ポインタではなく\code{cdr}ポインタだということです。\link{Figure 3.12}のリストに
対して\code{(set\-/cdr! x y)}を実行したときの効果を\link{Figure 3.15}に示します。ここでは、
\code{x}の\code{cdr}ポインタが\code{(e f)}に対するポインタに置き換えられています。また、
\code{x}の\code{cdr}だったリスト\code{(c d)}は、今では構造から取り外されています。

\enlargethispage{\baselineskip}

\begin{figure}[bp]
\phantomsection\label{Figure 3.15}
\centering
\begin{comment}
\heading{Figure 3.15:} Effect of \code{(set\-/cdr! x y)} on the lists in \link{Figure 3.12}.

\begin{example}
     +---+---+     +---+---+     +---+---+
x -->| * | * |     | * | *-+---->| * | / |
     +-|-+-|-+     +-|-+---+     +-|-+---+
       |   |         V             V
       |   |       +---+         +---+
       |   |       | c |         | d |
       |   |       +---+         +---+
       |   |       +---+---+     +---+---+
       +---+------>| * | *-+---->| * | / |
           |       +-|-+---+     +-|-+---+
           |         V             V
           |       +---+         +---+
           |       | a |         | b |
           |       +---+         +---+
           +------>+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=72mm]{fig/chap3/Fig3.15b.pdf}
\par\bigskip
\noindent
\heading{Figure 3.15:} \link{Figure 3.12}のリストに対する\code{(set\-/cdr! x y)}の効果
\end{figure}

\code{cons}は新しいペアを作ることによって新しいリスト構造を組み立てるものですが、
\code{set\-/car!}と\code{set\-/cdr!}は既存のペアを修正するものです。実際のところ、これら二つの
ミューテータと、既存のリスト構造の一部でない新しいペアを返す\code{get\-/new\-/pair}という
手続きがあれば、それらによって\code{cons}を実装することもできます。まず新しいペアを取得し、
指定されたオブジェクトを\code{car}と\code{cdr}ポインタに設定し、その新しいペアを
\code{cons}の結果として返します。
\footnote{
\code{get\-/new\-/pair}は、Lispの実装に必要となるメモリ管理の一部として実装する必要がある
演算のひとつです。これについては \link{Section 5.3.1}で検討します。}

\begin{scheme}
(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
\end{scheme}

\clearpage

\begin{quote}
\heading{\phantomsection\label{Exercise 3.12}Exercise 3.12:} 

\link{Section 2.2.1}では、次のリスト追加手続きを紹介した。

\begin{scheme}
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
\end{scheme}

\code{append}は、\code{x}の要素を連続で\code{y}に\code{cons}していくことによって新しい
リストを作る。手続き\code{append!}は\code{append}と似ているが、コンストラクタではなく
ミューテータである。これは\code{x}の最後のペアを修正し、\code{cdr}が\code{y}になるように
して二つのリストをつなぎ合わせることによって追加を行う(空の\code{x}を引数として
\code{append!}を呼ぶとエラーになる)。

\begin{scheme}
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
\end{scheme}


ここで、\code{last\-/pair}は引数の最後のペアを返す手続きである。

\begin{scheme}
(define (last-pair x)
  (if (null? (cdr x)) x (last-pair (cdr x))))
\end{scheme}

次のやりとりについて考えよ。

\begin{scheme}
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
~\textit{(a b c d)}~
(cdr x)
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
(define w (append! x y))
w
~\textit{(a b c d)}~
(cdr x)
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
\end{scheme}

空欄の\( \langle \)\var{response}\( \rangle \)はどのようになるだろうか。
箱とポインタの図を描き、答えについて説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.13}Exercise 3.13:}
次の\code{make\-/cycle}手続きについて考えよ。これは、\link{Exercise 3.12}で定義した
\code{last\-/pair}手続きを使っている。

\begin{scheme}
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
\end{scheme}

次の式によって作られる構造\code{z}を表す箱とポインタの図を描け。

\begin{scheme}
(define z (make-cycle (list 'a 'b 'c)))
\end{scheme}

\code{(last\-/pair z)}を計算しようとすると、どうなるだろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.14}Exercise 3.14:} 
次の手続きはわかりにくいが、とても役に立つ。

\begin{scheme}
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
\end{scheme}

\code{loop}は``一時的''な変数\code{temp}を使って、\code{x}の\code{cdr}の古い値を保持する。
これは、次の行の\code{set\-/cdr!}が\code{cdr}を破壊するためである。一般的に\code{mystery}が
何をするのか説明せよ。\code{v}は\code{(define v (list 'a 'b 'c 'd))}によって定義されたものだと
する。\code{v}が束縛されるリストを表す箱とポインタの図を描け。次に、\code{(define w (mystery v))}を
評価したとする。この式を評価した後の\code{v}と\code{w}の構造を表す箱とポインタの図を描け。
\code{v}と\code{w}の値として何が表示されるだろうか。
\end{quote}

\subsubsection*{共有とアイデンティティ}

\link{Section 3.1.3}では、代入を導入することによって出てくる``同一性''と``変更''という
理論的な問題について触れました。これらの問題は、個々のペアが別々のデータオブジェクトの間で
\newterm{shared}(\jnewterm{共有})されると実際に起こるようになります。例えば、以下のように
作られる構造について考えてみましょう。

\begin{scheme}
(define x (list 'a 'b))
(define z1 (cons x x))
\end{scheme}

\noindent
\link{Figure 3.16}に示したように、\code{z1}は、\code{car}と\code{cdr}が両方とも\code{x}という
同じペアを指しています。このように、\code{z1}の\code{car}と\code{cdr}によって\code{x}が共有
できるようになっているのは、\code{cons}が単純な方法で実装されているからです。一般的に、
\code{cons}を使ってリストを構築すると、多くの個々のペアが多くの別々の構造によって共有される、
ペアの絡まり合った構造ができます。

\link{Figure 3.16}に対して、\link{Figure 3.17}は次の式によって作られる構造を示しています。

\begin{scheme}
(define z2 (cons (list 'a 'b) (list 'a 'b)))
\end{scheme}

\noindent
この構造の中では、二つの\code{(a b)}リストに含まれるペアは、実際の記号は共有されていても、
区別可能です。
\footnote{
\code{cons}を呼び出すたびに新しいペアが返されるため、二つのペアは区別可能です。記号は共有されて
います。Schemeでは、どんな名前に対しても唯一の記号が存在します。Schemeは記号を変更する手段を
提供していないため、この共有を検出することはできません。また、そのように記号が共有されていることに
よって、単純にポインタが同じかどうかをチェックするだけの\code{eq?}によって記号の比較ができるように
なっているということにも注意してください。}

\begin{figure}[tb]
\phantomsection\label{Figure 3.16}
\centering
\begin{comment}
\heading{Figure 3.16:} The list \code{z1} formed by \code{(cons x x)}.

\begin{example}
      +---+---+
z1 -->| * | * |
      +-|-+-|-+
        V   V
      +---+---+     +---+---+
 x -->| * | *-+---->| * | / |
      +-|-+---+     +-|-+---+
        V             V
      +---+         +---+
      | a |         | b |
      +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=46mm]{fig/chap3/Fig3.16b.pdf}
\par\bigskip
\noindent
\heading{Figure 3.16:} \code{(cons x x)}によって作られるリスト\code{z1}
\end{figure}

\begin{figure}[tb]
\phantomsection\label{Figure 3.17}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 3.17:} The list \code{z2} formed by \code{(cons (list 'a 'b) (list 'a 'b))}.

\begin{example}
      +---+---+     +---+---+     +---+---+
z2 -->| * | *-+---->| * | *-+---->| * | / |
      +-|-+---+     +-|-+---+     +-|-+---+
        |             V             V
        |           +---+         +---+
        |           | a |         | b |
        |           +---+         +---+
        |             ^             ^
        |             |             |
        |           +-|-+---+     +-|-+---+
        +---------->| * | *-+---->| * | / |
                    +---+---+     +---+---+
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=71mm]{fig/chap3/Fig3.17b.pdf}
\begin{quote}
\heading{Figure 3.17:} \code{(cons (list 'a 'b) (list 'a 'b))}によって作られるリスト\code{z2}
\end{quote}
\end{figure}

リストとして考えると、\code{z1}と\code{z2}は両方とも``同じ''リスト、つまり\code{((a b) a b)}を
表現しています。一般的に、リストに対して\code{cons}, \code{car}, \code{cdr}だけを使って
操作するのであれば、共有は完全に検出不可能です。しかし、リスト構造に対して変更を許可するとなると、
共有は意味を持つようになります。共有によって違いが出てくる例として、次の手続きについて
考えてみましょう。これは、適用対象の構造の\code{car}を修正するものです。

\begin{scheme}
(define (set-to-wow! x) (set-car! (car x) 'wow) x)
\end{scheme}

\noindent
\code{z1}と\code{z2}は``同じ''構造のはずなのに、これらに\code{set\-/to\-/wow!}を適用すると、
異なる結果が返ってきます。\code{z1}の場合は、\code{car}と\code{cdr}は同じペアなので、
\code{car}を変更すると\code{cdr}も変更することになります。\code{z2}の場合は、\code{car}と
\code{cdr}は別のものなので、\code{set\-/to\-/wow!}は\code{car}しか変更しません。

\begin{scheme}
z1
~\textit{((a b) a b)}~
(set-to-wow! z1)
~\textit{((wow b) wow b)}~
z2
~\textit{((a b) a b)}~
(set-to-wow! z2)
~\textit{((wow b) a b)}~
\end{scheme}

\noindent
リスト構造の中にある共有を検出する方法として、述語\code{eq?}を使うというものがあります。
この述語は、二つの記号が同じかどうかテストする方法として\link{Section 2.3.1}で紹介したものです。
より一般的に、\code{(eq?  x y)}は\code{x}と\code{y}が同じオブジェクトかどうか(つまり、
\code{x}と\code{y}がポインタとして等しいかどうか)をテストします。そのため、\link{Figure 3.16}と
\link{Figure 3.17}のように定義された\code{z1}と\code{z2}では、\code{(eq?  (car z1) (cdr z1))}
は真になり、\code{(eq? (car z2) (cdr z2))}は偽になります。

以降の節で見ていくように、共有を活用すると、ペアで表現可能なデータ構造の範囲を大きく広げる
ことができます。一方、共有は危険なものになる可能性もあります。ある構造に加えた変更が、
その変更部分をたまたま共有している別の構造にも影響することになるからです。
変更演算の\code{set\-/car!}と\code{set\-/cdr!}を使う際には注意する必要があります。扱っている
データオブジェクトについてよく理解していないと、変更が予期しない結果を招くことがあるかも
しれないからです。
\footnote{
可変データオブジェクトの共有を扱うことの難しさには、\link{Section 3.1.3}で提起した
``同一性''と``変更''の問題が根底にあります。そこでは、私たちの言語で変更を許すようにするためには
複合データは構成部品の集まりとは別の``アイデンティティ''を持たなければならないということに
触れました。Lispでは、この``アイデンティティ''は、\code{eq?}によってテストされるような性質だと
考えます。つまり、ポインタが同じかどうかということになります。多くのLisp実装では、ポインタの
実装は本質的にはメモリアドレスなので、データオブジェクト``そのもの''は特定のメモリ上の場所の
セットに格納された情報であると取り決めることによって、オブジェクトのアイデンティティを定義すると
いう``問題を解決''しています。これは単純なLispのプログラムには十分ですが、計算モデルの
``同一性''という問題を解く一般的な方法とはとても言えないものです。}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.15}Exercise 3.15:} 
箱とポインタの図を描いて、上記の構造\code{z1}と\code{z2}に対する\code{set\-/to\-/wow!}の効果を
説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.16}Exercise 3.16:} 
Ben Bitdiddleは任意のリスト構造内のペアの数を数える手続きを書くことにした。``簡単だよな''と
彼は考えた。``どんな構造でも、\code{car}のぶんの数と\code{cdr}のぶんの数を足して、それに
そのペア自身を数えるために1を足せば、ペアの数が求められる。'' そして、Benは次の手続きを書いた。

\begin{scheme}
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
\end{scheme}

この手続きが正しくないということを示せ。具体的には、ちょうど三つのペアからなるリスト構造で、
Benの手続きが3, 4, 7を返すもの、また手続きが終了しないものを考え、それらを表す箱とポインタの
図を描け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.17}Exercise 3.17:} 
\link{Exercise 3.16}の\code{count\-/pairs}手続きの正しいバージョンを考え、任意の構造について
異なるペアの数を返すようにせよ。(ヒント：カウント済みのペアを記録しておく補助データ構造を
維持しながら構造をたどれ)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.18}Exercise 3.18:}
リストを検査し、循環を持つかどうか、つまり連続して\code{cdr}を取ることによってリストの終端を
探そうとするプログラムが無限ループになるかどうかを判定する手続きを書け。\link{Exercise 3.13}で
そのようなリストを構築した。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.19}Exercise 3.19:} 定数量の空間しか使わない
アルゴリズムによって\link{Exercise 3.18}をやり直せ(これにはとても巧妙なアイデアが必要となる)。
\end{quote}

\subsubsection*{変更は代入にすぎない}

複合データを導入したとき、\link{Section 2.1.3}ではペアが純粋に手続きだけによって表現できると
いうことを見ました。

\begin{scheme}
(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined operation: CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
\end{scheme}

\noindent
可変データについても同じことが言えます。可変データオブジェクトは、代入と局所状態を使って
手続きとして実装できます。例えば、\link{Section 3.1.1}で\code{make\-/account}を使って
銀行口座を実装したのと似たようなやり方で、上記のペアの実装を拡張して\code{set\-/car!}と
\code{set\-/cdr!}を扱えるようにすることができます。

\begin{scheme}
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else 
           (error "Undefined operation: CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
(define (set-car! z new-value) 
  ((z 'set-car!) new-value) z)
(define (set-/cdr! z new-value)
  ((z 'set-cdr!) new-value) z)
\end{scheme}

\noindent
可変データのふるまいを説明するためには、理論的には、代入だけあれば十分です。私たちの言語で
\code{set!}を認めたとたんに、代入の問題だけでなく、可変データ一般に関する問題がすべて
引き起こされることになります。
\footnote{
一方、実装面から見ると、代入を実装するためには環境を変更することが必要となりますが、この環境と
いうのはそれ自身が可変データ構造です。このように、代入と変更は等価だということです。
どちらも、もう一方によって実装することができます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.20}Exercise 3.20:} 
上記の手続きによるペアの実装を使って、次の式の列を評価する。
\begin{scheme}
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)
(car x)
~\textit{17}~
\end{scheme}

\noindent
評価の様子を、環境の図を描いて説明せよ(\link{Exercise 3.11}と比較せよ)。
\end{quote}

\subsection{キューの表現}
\label{Section 3.3.2}

ミューテータ\code{set\-/car!}、\code{set\-/cdr!}を使うと、\code{cons}, \code{car}, \code{cdr}
だけでは構築できないようなデータがペアを使って構築できるようになります。この節では、ペアを使って
キューと呼ばれるデータ構造を表現する方法を学びます。\link{Section 3.3.3}では、テーブルと呼ばれる
データ構造を表現するやり方について学ぶことになります。

\newterm{queue}(\jnewterm{キュー})とは、項目を一方の端(キューの\newterm{rear}(\jnewterm{終端}))
に挿入し、もう一方の端(\newterm{front}(\jnewterm{先端}))から削除する列です。
\link{Figure 3.18}は、最初は空だったキューにアイテム\code{a}と\code{b}が挿入される様子を
示しています。次に\code{a}が削除され、\code{c}と\code{d}が挿入され、\code{b}が削除されています。
項目は常に挿入した順番に削除されるため、キューは\newterm{FIFO}(first in, first out)
(\jnewterm{先入れ先出し})バッファと呼ばれることもあります。

\begin{figure}[tb]
\phantomsection\label{Figure 3.18}
\centering
\begin{comment}
\heading{Figure 3.18:} Queue operations.

\begin{example}
Operation                Resulting Queue
(define q (make-queue))
(insert-queue! q 'a)     a
(insert-queue! q 'b)     a b
(delete-queue! q)        b
(insert-queue! q 'c)     b c
(insert-queue! q 'd)     b c d
(delete-queue! q)        c d
\end{example}
\end{comment}
\includegraphics[width=70mm]{fig/chap3/Fig3.18a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.18:} キュー演算
\end{figure}

データ抽象化を使うと、キューは以下の演算の集合によって定義されるものと考えることができます。

\begin{itemize}

\item
コンストラクタ：\code{(make\-/queue)}は、空のキュー(項目を持たないキュー)を返す。

\item
二つのセレクタ：

\begin{scheme}
(empty-queue? ~\( \dark \langle \)~~\var{\dark queue}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
キューが空かどうかテストする。

\begin{scheme}
(front-queue ~\( \dark \langle \)~~\var{\dark queue}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
キューの先頭にあるオブジェクトを返す。キューが空ならエラーを出す。キューは変更しない。

\item
二つのミューテータ：

\begin{scheme}
(insert-queue! ~\( \dark \langle \)~~\var{\dark queue}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark item}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
キューの最後尾にアイテムを挿入し、変更されたキューを値として返す。

\begin{scheme}
(delete-queue! ~\( \dark \langle \)~~\var{\dark queue}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
キューの先頭のアイテムを削除し、変更されたキューを値として返す。削除前にキューが空であれば
エラーを出す。

\end{itemize}

\noindent
キューはアイテムの列なので、当然通常のリストとして表現できるところです。キューの先頭は
リストの\code{car}となり、キューへの項目の挿入はリストの終端に新しい要素を追加することとなり、
キューからのアイテムの削除は単にリストの\code{cdr}を取るということになるでしょう。しかし、
この表現は非効率的です。というのは、項目を挿入するためにはリストを終端まで走査しなければ
いけないからです。リストを走査するための手段は\code{cdr}演算を連続して使うことだけなので、
この走査は\( n \)項目のリストに対して\( \Theta(n) \)ステップが必要になります。リスト表現に
単純な変更を加えるだけで、必要なステップが\( \Theta \)(1)、つまり必要なステップ数がキューの長さと
独立なキュー演算の実装ができるようになり、この欠点を克服することができます。

リスト表現の難しいところは、リストの終端を見つけるためにリストを走査しないといけないという
ことです。なぜ走査しないといけないかというと、リストをペアの鎖として表現する標準的なやり方
では、先頭へのポインタはすぐに得られるのに対し、リストの終端へのポインタは簡単にアクセスできない
ようになっているからです。その欠点を避けるためには、キューをリストとして表現したうえで、
リストの最終ペアを指す追加のポインタを加えるように修正します。こうすると、項目を挿入する際に
終端ポインタを見ることによってリストの走査を避けられます。

このやり方では、キューは\code{front\-/ptr}, \code{rear\-/ptr}というポインタのペアとして表現
できます。ポインタはそれぞれ通常のリストの先頭と最後のペアを指しています。キューを識別可能な
オブジェクトにするために、\code{cons}を使って二つのポインタを結合します。つまり、キュー自身は
二つのポインタの\code{cons}になります。\link{Figure 3.19}はこの表現を図示したものです。

\begin{figure}[tb]
\phantomsection\label{Figure 3.19}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 3.19:} Implementation of a queue as a list with front and rear pointers.

\begin{example}
       +---+---+
  q -->| * | *-+-------------------+
       +-|-+---+                   |
         |                         |
         | front-ptr               | rear-ptr
         V                         V
     +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V
     +---+        +---+        +---+
     | a |        | b |        | c |
     +---+        +---+        +---+
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=69mm]{fig/chap3/Fig3.19b.pdf}
\begin{quote}
\heading{Figure 3.19:} 先端と終端のポインタを持つリストとしてのキューの実装
\end{quote}
\end{figure}

キュー演算を定義するには以下の手続きを使います。これらは、キューの先端・終端ポインタを
選択・変更できるようにするものです。

\begin{scheme}
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))
\end{scheme}

\noindent
これで、実際のキュー演算を実装できるようになります。先端のポインタが空リストであればキューは
空であるとします。

\begin{scheme}
(define (empty-queue? queue) (null? (front-ptr queue)))
\end{scheme}

\noindent
\code{make\-/queue}コンストラクタは、初期状態の空キューとして、\code{car}と\code{cdr}の両方が
空リストであるペアを返します。

\begin{scheme}
(define (make-queue) (cons '() '()))
\end{scheme}

\noindent
キューの先頭の項目を選択するには、先端ポインタが指すペアの\code{car}を返します。

\begin{scheme}
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))
\end{scheme}

\noindent
キューにアイテムを挿入するには、結果として\link{Figure 3.20}のようになるような手順を
実行します。まず、\code{car}が挿入する項目で\code{cdr}が空リストという新しいペアを作ります。
もしキューが元々空だったら、先端と終端のポインタが両方ともこの新しいペアを指すようにします。
そうでなければ、キューの最終ペアが新しいペアを指すように変更し、また終端ポインタも
新しいペアを指すようにします。

\begin{scheme}
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.20}
\centering
\begin{comment}
\heading{Figure 3.20:} Result of using \code{(insert\-/queue! q 'd)} on the queue of \link{Figure 3.19}.

\begin{example}
       +---+---+
  q -->| * | *-+--------------------------------+
       +-|-+---+                                |
         |                                      |
         | front-ptr                            | rear-ptr
         V                                      V
     +---+---+    +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V            V
     +---+        +---+        +---+        +---+
     | a |        | b |        | c |        | d |
     +---+        +---+        +---+        +---+
\end{example}
\end{comment}
\includegraphics[width=88mm]{fig/chap3/Fig3.20b.pdf}
\begin{quote}
\heading{Figure 3.20:} \link{Figure 3.19}のキューに\code{(insert\-/queue! q 'd)}を使った結果 
\end{quote}
\end{figure}

キューの先頭の項目を削除するのは、先頭ポインタがキューの二番目の項目を指すようにするだけで
大丈夫です(\link{Figure 3.21}参照)。
\footnote{
最初の項目がキューの最終項目でもある場合、削除後に先端ポインタは空リストになり、これが
キューが空だという印になります。終端ポインタは依然として削除済みの項目を指し続けることに
なりますが、わざわざ更新する必要はありません。\code{empty\-/queue?}は先端ポインタしか見ない
からです。}

\begin{scheme}
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else (set-front-ptr! queue (cdr (front-ptr queue)))
              queue)))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.21}
\centering
\begin{comment}
\heading{Figure 3.21:} Result of using \code{(delete\-/queue!  q)} on the queue of \link{Figure 3.20}.

\begin{example}
       +---+---+
  q -->| * | *-+--------------------------------+
       +-|-+---+                                |
         +------------+                         |
            front-ptr |                         | rear-ptr
                      V                         V
     +---+---+    +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V            V
     +---+        +---+        +---+        +---+
     | a |        | b |        | c |        | d |
     +---+        +---+        +---+        +---+
\end{example}
\end{comment}
\includegraphics[width=88mm]{fig/chap3/Fig3.21b.pdf}
\begin{quote}
\heading{Figure 3.21:} \link{Figure 3.20}のキューに\code{(delete\-/queue!  q)}を使った結果
\end{quote}
\end{figure}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.21}Exercise 3.21:} 
Ben Bitdiddleは、上記のキューの実装をテストすることにした。彼はLispインタプリタにキューの
手続きを入力し、それから試しに使ってみた。

\begin{scheme}
(define q1 (make-queue))
\end{scheme}

\begin{scheme}
(insert-queue! q1 'a)
~\textit{((a) a)}~
\end{scheme}

\begin{scheme}
(insert-queue! q1 'b)
~\textit{((a b) b)}~
\end{scheme}

\begin{scheme}
(delete-queue! q1)
~\textit{((b) b)}~
\end{scheme}

\begin{scheme}
(delete-queue! q1)
~\textit{(() b)}~
\end{scheme}

``全然ダメじゃないか''と彼は文句を言う。``インタプリタの応答を見てみろよ。最後の項目がキューに
二回挿入されているじゃないか。それに、項目を両方とも削除しても、二つ目の\code{b}は残ったままだ。
つまり、キューは空になっていないってことだ。空になっていないといけないのに''
Eva Lu Atorは、Benが挙動を誤解していると言う。``項目がキューに二回入っているわけじゃなくて''
彼女は説明する。``Lisp標準の表示プログラムが、キューの表現をどう解釈していいかわからないって
だけ。キューをちゃんと表示させたいなら、キューを表示する手続きを自分で書かないと''
Eva Luの話について解説せよ。具体的には、なぜBenの例がそのような表示結果を出力するのか説明せよ。
キューを入力として取り、キュー内の項目列を表示する手続き\code{print\-/queue}を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.22}Exercise 3.22:} 
キューは、ポインタのペアとして表現する以外に、局所状態を持つ手続きとして構築することもできる。
局所状態は通常のリストの先端と終端へのポインタからなる。したがって、手続き\code{make\-/queue}は
以下のような形になる。

\begin{scheme}
(define (make-queue)
  (let ((front-ptr ~\( \dots \)~ )
        (rear-ptr ~\( \dots \)~ ))
    ~\( \dark \langle \)~~\var{\dark definitions of internal procedures}~~\( \dark \rangle \)~
    (define (dispatch m) ~\( \dots \)~)
    dispatch))
\end{scheme}

\code{make\-/queue}の定義を完成させ、この表現によるキューの演算を実装せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.23}Exercise 3.23:} 
\newterm{deque}(\jnewterm{両端キュー})(``double\-/ended queue'')は、先端と終端のどちらに対しても
項目の挿入と削除が行える列である。dequeに対する演算は、コンストラクタ\code{make\-/deque}、
述語\code{empty\-/deque?}、セレクタ\code{front\-/deque}、\code{rear\-/deque}、
ミューテータ\code{front\-/insert\-/deque!},\code{rear\-/insert\-/deque!},
\code{front\-/delete\-/deque!}, \code{rear\-/delete\-/deque!}である。
ペアによってdequeを表現するやり方を示せ。また、演算を実装せよ。
\footnote{
インタプリタに循環を含む構造を表示させないように注意せよ(\link{Exercise 3.13}参照)。}
全ての演算は\( \Theta \)(1)ステップで完了しなければならない。
\end{quote}

\subsection{テーブルの表現}
\label{Section 3.3.3}

\link{Chapter 2}で集合を表現するいろいろなやり方について学んだ際に、\link{Section 2.3.3}では、
識別用キーによって索引づけされたレコードのテーブルを保持するというタスクについて触れました。
\link{Section 2.4.3}のデータ主導プログラミングを実装するにあたっては、二つのキーによって
情報を格納したり取り出したりする二次元のテーブルが大活躍しました。ここでは、可変リスト構造として
テーブルを構築するやり方について見ていきます。

\begin{figure}[tb]
\phantomsection\label{Figure 3.22}
\centering
\begin{comment}
\heading{Figure 3.22:} A table represented as a headed list.

\begin{example}
 +---+---+    +---+---+    +---+---+    +---+---+
 | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
 +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
   |            |            |            |
   V            V            V            V
+---------+   +---+---+   +---+---+   +---+---+
| *table* |   | * | * |   | * | * |   | * | * |
+---------+   +-|-+-|-+   +-|-+-|-+   +-|-+-|-+
                |   |       |   |       |   |
                V   V       V   V       V   V
             +---+ +---+ +---+ +---+ +---+ +---+
             | a | | 1 | | b | | 2 | | c | | 3 |
             +---+ +---+ +---+ +---+ +---+ +---+
\end{example}
\end{comment}
\includegraphics[width=81mm]{fig/chap3/Fig3.22c.pdf}
\par\bigskip
\noindent
\heading{Figure 3.22:} 頭つきリストとして表現されたテーブル
\end{figure}

まず、一次元の表について考えます。一次元の表では、それぞれの値は単独のキーの下に格納されます。
このテーブルをレコードの列として実装し、それぞれのレコードは、キーとそれに関連づけられた
値とのペアとして実装します。レコードはペアによって連結して列状にします。連結用ペアの
\code{car}は連続したレコードを指しています。これらの連結用ペアは、テーブルの\newterm{backbone}
(\jnewterm{背骨})といいます。テーブルに新しいレコードを追加するときに変更できる場所が必要なので、
テーブルは\newterm{headed list}(\jnewterm{頭つきリスト})として構築します。頭つきリストは、
先頭に特別な背骨のペアを持っています。これはダミーの``レコード''---今回の場合、適当に選んだ記号
\code{*table*}---を持っています。\link{Figure 3.22}は、次のテーブルに対する箱とポインタの図を
示したものです。

\begin{scheme}
a:  1
b:  2
c:  3
\end{scheme}

\noindent
テーブルから情報を取り出すには\code{lookup}という手続きを使います。この手続きは引数として
キーを取り、関連づけられた値(キーの下に格納された値がなければ偽)を返します。\code{lookup}は、
引数としてキーとレコード列を取る\code{assoc}演算によって定義します。\code{assoc}はダミーレコードを
見ないことに注意してください。\code{assoc}は、与えられたキーを\code{car}として持つレコードを
返します。
\footnote{\code{assoc}は\code{equal?}を使うため、記号・数値・リスト構造のキーを認識できます。}
それから\code{lookup}は、\code{assoc}に返されたレコードが偽でないことをチェックし、そのレコードの
値(\code{cdr})を返します。

\begin{scheme}
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))
(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
\end{scheme}

\noindent
特定のキーの下に値を挿入するには、まず\code{assoc}を使って、すでにそのキーを持つレコードが
テーブルにないか確認します。なければ、キーと値を\code{cons}して新しいレコードを作り、
それをテーブルのレコード列の先頭、つまりダミーレコードの後ろに挿入します。すでにそのキーの
レコードがあるなら、そのレコードの\code{cdr}を指定された新しい値にセットします。テーブルの
ヘッダは、新しいレコードを挿入するために修正する固定の場所という役割を果たしています。
\footnote{このため、最初の背骨ペアは、テーブル``そのもの''を表現するオブジェクトという
ことになります。つまり、テーブルを指すポインタというのは、このペアを指すポインタだということ
です。この同じ背骨ペアは、常にテーブルのスタート地点になっています。もしこういうやり方をして
いなければ、\code{insert!}が新しいレコードを追加する際に、テーブルの新しいスタート地点の値を
返さなければならなくなるところです。}

\begin{scheme}
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value)
                        (cdr table)))))
  'ok)
\end{scheme}

\noindent
新しいテーブルを構築するのは、記号\code{*table*}を持つリストを作るだけで終わりです。

\begin{scheme}
(define (make-table)
  (list '*table*))
\end{scheme}

\subsubsection*{二次元テーブル}

\noindent
二次元テーブルでは、それぞれの値は二つのキーによって索引づけがされています。そのような
テーブルは、一次元テーブルのそれぞれのキーがサブテーブルを特定ようにすることで作れます。
\link{Figure 3.23}は、次のテーブルに対する箱とポインタの図を示したものです。

\begin{example}
math:    +:  43        letters:    a:  97
         -:  45                    b:  98
         *:  42
\end{example}

\noindent
このテーブルは、二つのサブテーブルを持っています。(サブテーブルには特別なヘッダ記号は
必要ありません。サブテーブルを特定するキーがその目的を果たすためです)。

項目を探すときには、一つ目のキーを使って正しいサブテーブルを特定します。次に、二つ目の
キーを使ってサブテーブル中のレコードを特定します。

\begin{scheme}
(define (lookup key-1 key-2 table)
  (let ((subtable 
         (assoc key-1 (cdr table))))
    (if subtable
        (let ((record 
               (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.23}
\centering
\begin{comment}
\heading{Figure 3.23:} A two-dimensional table.

\begin{example}
table
  |
  V
+---+---+   +---+---+   +---+---+
| * | *-+-->| * | *-+-->| * | / |
+-|-+---+   +-|-+---+   +-|-+---+
  V           |           V
+-------+     |         +---+---+   +---+---+   +---+---+
|*table*|     |         | * | *-+-->| * | *-+-->| * | / |
+-------+     |         +-|-+---+   +-|-+---+   +-|-+---+
              |           V           V           V
              |       +-------+     +---+---+   +---+---+
              |       |letters|     | * | * |   | * | * |
              |       +-------+     +-|-+-|-+   +-|-+-|-+
              |                       V   V       V   V
              |                    +---+ +---+ +---+ +---+
              |                    | a | | 97| | b | | 98|
              |                    +---+ +---+ +---+ +---+
              V
            +---+---+   +---+---+   +---+---+   +---+---+
            | * | *-+-->| * | *-+-->| * | *-+-->| * | / |
            +-|-+---+   +-|-+---+   +-|-+---+   +-|-+---+
              V           V           V           V
          +------+      +---+---+   +---+---+   +---+---+
          | math |      | * | * |   | * | * |   | * | * |
          +------+      +-|-+-|-+   +-|-+-|-+   +-|-+-|-+
                          V   V       V   V       V   V
                       +---+ +---+ +---+ +---+ +---+ +---+
                       | + | | 43| | - | | 45| | * | | 42|
                       +---+ +---+ +---+ +---+ +---+ +---+
\end{example}
\end{comment}
\includegraphics[width=103mm]{fig/chap3/Fig3.23a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.23:} 二次元テーブル
\end{figure}

キーのペアの下に新しい項目を挿入するには、\code{assoc}を使って一つ目のキーの下にサブテーブルが
格納されているかどうか確認します。もしなければ、ひとつのレコード(\code{key\-/2}, \code{value})を
持つ新しいサブテーブルを構築し、それをテーブルの一つ目のキーの下に挿入します。もし一つ目のキーに
対するサブテーブルがすでに存在するなら、上で述べた一次元テーブルの挿入法を使って、そのサブテーブルに
新しいレコードを挿入します。

\begin{scheme}
(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
\end{scheme}

\subsubsection*{局所テーブルの作成}

上で定義した\code{lookup}と\code{insert!}演算は、引数としてテーブルを取ります。このことに
よって、二つ以上のテーブルにアクセスするプログラムが使えるようになります。複数のテーブルを
扱う別の方法としては、それぞれのテーブルに対して別々の\code{lookup}と\code{insert!}手続きを
持つというものがあります。これは、内部テーブルを局所状態として保持するオブジェクトとして
テーブルを手続き的に表現することによって達成できます。適切なメッセージが送られると、
この``テーブルオブジェクト''は内部テーブルに対する演算を行う手続きを提供します。以下に、
この方法で表現した二次元テーブル生成プログラムを示します。

\begin{scheme}
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable 
             (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record 
                   (assoc key-2 (cdr subtable))))
              (if record (cdr record) false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable 
             (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record 
                   (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1 (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation: TABLE" m))))
    dispatch))
\end{scheme}

\noindent
\code{make\-/table}を使うと、\link{Section 2.4.3}でデータ主導プログラミングに使った
\code{get}と\code{put}を次のように実装できます。

\begin{scheme}
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
\end{scheme}

\noindent
\code{get}は二つのキーを引数に取り、\code{put}は二つのキーと値を引数に取ります。どちらの操作も、
\code{make\-/table}呼び出し時に作られるオブジェクトにカプセル化された同じ局所テーブルに
アクセスします。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.24}Exercise 3.24:}
上のテーブル実装では、キーの等価性は\code{equal?}(\code{assoc}に呼ばれる)によってテストされて
いる。これは常に適切なテストというわけではない。例えば、数字をキーとするテーブルを扱っている場合、
検索する数字に対して完全に一致する必要がなく、いくらかの誤差の範囲内のものであればいいということも
考えられる。キーの``等価性''をテストするのに使う手続き\code{same\-/key?}を引数として取る
テーブルコンストラクタ\code{make\-/table}を定義せよ。\code{make\-/table}は、局所テーブルに
対する適切な\code{lookup}, \code{insert!}手続きにアクセスするために使用できる\code{dispatch}
手続きを返すようにすること。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.25}Exercise 3.25:} 
一次元と二次元のテーブルを一般化し、任意の数のキーの下に値を格納するテーブルを実装する
やり方を示せ。値によってキーの数は異なることもある。\code{lookup}, \code{insert!}手続きは、
テーブルにアクセスするためのキーのリストを入力として取る。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.26}Exercise 3.26:} 
上のように実装したテーブルを検索するには、レコードのリストを走査する必要がある。
これは、基本的に\link{Section 2.3.3}の順序なしリスト表現である。大きなテーブルに対しては、
別のやり方でテーブルを構造化するほうが効率がよくなるかもしれない。(キー, 値)のレコードを
二分木を使ってまとめるようなテーブルの実装について説明せよ。キーは、何らかの方法(数の大小順や
アルファベット順など)によって順序づけができるものとする(\link{Chapter 2}の\link{Exercise 2.66}と
比較せよ)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.27}Exercise 3.27:} 
\newterm{memoization}(\jnewterm{メモ化})(\newterm{tabulation}(\jnewterm{テーブル化})とも)とは、
以前計算したことのある値を手続きが局所テーブルに記録できるようにするテクニックである。この
テクニックを使うことでプログラムのパフォーマンスが大きく変わることもある。メモ化された手続きは、
以前の呼び出しの値をテーブルに保持する。キーにはその値を生成した引数を使う。メモ化された手続きが
値を計算するよう求められると、まずテーブルをチェックしてその値が入っていないか見て、もし
入っていればその値をそのまま返す。入っていなければ、普通のやり方で新しい値を計算し、それを
テーブルに格納する。メモ化の例として、\link{Section 1.2.2}のフィボナッチ数を計算する指数的
プロセスを思い出そう。

\begin{scheme}
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))
\end{scheme}

同じ手続きをメモ化したバージョンは次のようになる。

\begin{scheme}
(define memo-fib
  (memoize
   (lambda (n)
     (cond ((= n 0) 0)
           ((= n 1) 1)
           (else (+ (memo-fib (- n 1))
                    (memo-fib (- n 2))))))))
\end{scheme}

\noindent
ここで、memoizeは以下のように定義される手続きである。

\begin{scheme}
(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result 
             (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
\end{scheme}

環境の図を描き、\code{(memo\-/fib 3)}の計算を分析せよ。なぜ\code{memo\-/fib}が\( n \)番目の
フィボナッチ数を\( n \)に比例するステップ数で計算できるのか説明せよ。単に\code{memo\-/fib}を
\code{(memoize fib)}と定義していたとしても、この構想はうまくいくだろうか。
\end{quote}

\subsection{デジタル回路シミュレータ}
\label{Section 3.3.4}

複雑なデジタルシステム(例えばコンピュータなど)の設計は重要な工学活動です。デジタルシステムは、
単純な要素を相互接続することで構築されます。個々の要素のふるまいは単純ですが、それらが構成する
ネットワークのふるまいはとても複雑になることもあります。回路設計案のコンピュータシミュレーションは、
デジタルシステムエンジニアに使われる重要なツールです。この節では、デジタル論理シミュレーションを
実行するシステムを設計します。このシステムは、\newterm{event-driven simulation}
(\jnewterm{イベント駆動シミュレーション})と呼ばれる種類のプログラムの例となります。この種類の
プログラムでは、アクション(``イベント'')は後になってさらなるイベントを引き起こし、それらの
イベントがまたさらなるイベントを引き起こし\( \dots \)という繰り返しになっています。


本書での回路の計算モデルは、回路を構成する基本部品に対応するオブジェクトによって構成される
ことになります。まず、\newterm{digital signals}(\jnewterm{デジタル信号})を伝える
\newterm{wires}(\jnewterm{線})があります。デジタル信号は、ある特定の瞬間には、二つの可能な
値である0と1のどちらかしか取りません。ほかには、いろいろなタイプのデジタル
\newterm{function boxes}(\jnewterm{関数箱})もあり、入力信号を伝える回路と、ほかの出力回路とを
接続しています。これらの箱は、入力信号から計算される信号を出力します。出力信号は、関数箱の
タイプによって時間的な遅れが生じます。例えば、\newterm{inverter}(\jnewterm{インバータ})は入力を
反転する基本関数箱です。インバータに対する入力信号が0に変化すると、インバータ遅延時間1単位後に
インバータは出力信号を1に変えます。インバータに対する入力信号が1に変化すると、インバータ遅延時間
1単位後にインバータは出力信号を0に変えます。インバータは\link{Figure 3.24}のような記号として
表します。同じ\link{Figure 3.24}に示している\newterm{and\-/gate}(\jnewterm{ANDゲート})は、
二つの入力とひとつの出力を持つ基本関数箱です。この関数箱は、入力の\newterm{logical and}
(\jnewterm{論理積})となる値に出力信号を駆動します。つまり、入力信号が両方とも1になると、
ANDゲート遅延時間1単位後に、ANDゲートは出力信号を1にするということです。そうでなければ、出力は
0です。\newterm{or\-/gate}(\jnewterm{ORゲート})は、似たような2入力の基本関数箱で、入力の
\newterm{logical or}(\jnewterm{論理和})となる値に出力を駆動します。つまり、少なくともひとつの
入力信号が1であれば出力は1になり、そうでなければ出力は0になるということです。

\begin{figure}[tb]
\phantomsection\label{Figure 3.24}
\centering
\begin{comment}
\heading{Figure 3.24:} Primitive functions in the digital logic simulator.

\begin{example}
               __          ___
  |\        --|  \       --\  \
--| >o--      |   )--       )  >--
  |/        --|__/       --/__/

Inverter    And-gate     Or-gate
\end{example}
\end{comment}
\includegraphics[width=74mm]{fig/chap3/Fig3.24b.pdf}
\begin{quote}
\heading{Figure 3.24:} デジタル論理回路シミュレータにおける基本関数
\end{quote}
\end{figure}

基本関数を接続すると、より複雑な関数を構築することができます。そのためには、関数箱の出力を
別の関数箱の入力に結線します。例えば、\link{Figure 3.25}に示す\newterm{half\-/adder}
(\jnewterm{半加算器})は、ひとつのORゲート、二つのANDゲート、ひとつのインバータからなります。
入力信号としてはAとBの二つを取り、出力信号はSとCの二つです。Sは、AとBのどちらかひとつだけが
1のときに1になり、CはAとBの両方が1のときに1になります。図を見ると、遅延があるために、
出力が異なる時刻に生成されるかもしれないということがわかります。デジタル回路設計の設計の
難しさは、多くはこの事実によって起こるものです。

\begin{figure}[tb]
\phantomsection\label{Figure 3.25}
\centering
\begin{comment}
\heading{Figure 3.25:} A half-adder circuit.

\begin{example}
    +--------------------------------------+
    |         ____                         |
A --------*---\   \ D               ___    |
    |     |    >   >---------------|   \   |
    |  +--|---/___/                |    )----- S
    |  |  |              |\  E  +--|___/   |
    |  |  |           +--| >o---+          |
    |  |  |    ___    |  |/                |
    |  |  +---|   \   |                    |
    |  |      |    )--*----------------------- C
B -----*------|___/                        |
    |                                      |
    +--------------------------------------+
\end{example}
\end{comment}
\includegraphics[width=72mm]{fig/chap3/Fig3.25c.pdf}
\par\bigskip
\noindent
\heading{Figure 3.25:} 半加算器回路
\end{figure}

ここからは、私たちの学習対象となる、デジタル論理回路をモデル化するプログラムを作っていきます。
このプログラムでは、信号を``保持''する線をモデル化する計算オブジェクトを構築します。
関数箱は、信号同士の正しい関係を成り立たせる手続きによってモデル化します。

シミュレーションの基本要素のひとつは、回路を構築する手続き\code{make\-/wire}です。例えば、
次のようにして6つの線を構築することができます。

\begin{scheme}
(define a (make-wire))
(define b (make-wire))
(define c (make-wire))
(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
\end{scheme}

\noindent
ある関数箱を線につなげるには、そのタイプの関数箱を構築する手続きを呼びます。コンストラクタ
手続きの引数は、その箱につなげる線です。例えば、ANDゲート、ORゲート、インバータを構築できる
ようになっているとすると、\link{Figure 3.25}に示す半加算器を結線できます。

\begin{scheme}
(or-gate a b d)
~\textit{ok}~
(and-gate a b c)
~\textit{ok}~
(inverter c e)
~\textit{ok}~
(and-gate d e s)
~\textit{ok}~
\end{scheme}

\noindent
さらに都合のいいことに、この演算には明示的に名前をつけることができます。そのためには、
半加算器につなげる四本の外部の線が与えられたときにこの回路を構築する\code{half\-/adder}
という手続きを定義します。

\begin{scheme}
(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
\end{scheme}

\noindent
この定義の利点は、より複雑な回路を作成するための構築用ブロックとして\code{half\-/adder}自身を
使うことができるということです。例えば、\link{Figure 3.26}は、二つの半加算器とひとつのORゲートに
よって構成される\newterm{full\-/adder}(\jnewterm{全加算器})を示したものです。
\footnote{全加算器は、二つの二進数の加算に使われる基本的な回路要素です。ここで、AとBは加算する
二つの数の対応する位置のビットで、\( \rm C_{in} \)はひとつ右の位置での加算から来る
キャリー(繰り上がり)ビットです。この回路は、対応する位置の合計ビットであるSUMと、左に伝播させる
キャリービットである\( \rm C_{out} \)を生成します。}
全加算器は、次のように構築できます。

\begin{scheme}
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire)) (c1 (make-wire)) (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.26}
\centering
\begin{comment}
\heading{Figure 3.26:} A full-adder circuit.

\begin{example}
    +----------------------------------+
    |              +-------+           |
A -----------------+ half- +-------------- SUM
    |  +-------+   | adder |   ____    |
B -----+ half- +---+       +---\   \   |
    |  | adder |   +-------+    >or >----- Cout
C -----+       +---------------/___/   |
    |  +-------+                       |
    +----------------------------------+
\end{example}
\end{comment}
\includegraphics[width=74mm]{fig/chap3/Fig3.26a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.26:} 全加算器回路
\end{figure}

\code{full\-/adder}を手続きとして定義したので、今度はそれを構築用ブロックとして使って、
さらに複雑な回路を作ることができるようになります(例は\link{Exercise 3.30}を参照)。

簡単にいうと、このシミュレータは回路を構築するための道具を提供してくれるものだといえます。
\link{Section 1.1}でLispの学習に対するアプローチとして使ったような一般的な視点から見ると、
基本関数箱は言語の基本要素を構成し、箱を結線することは組み合わせの手段であり、手続きとして
線のパターンを規定することは抽象化の手段としての役割を果たしているといえるでしょう。

\subsubsection*{基本関数箱}

基本関数箱は、ひとつの線上の信号の変化がほかの線上の信号に影響を与える``力''を実装した
ものです。関数箱を構築するには、線に対する次のような演算を使います。

\begin{itemize}

\item \code{(get\-/signal}\( \;\;\langle\kern0.06em\hbox{\ttfamily\slshape wire}\kern0.08em\rangle \)\code{)}

\noindent
これは、線上の信号の現時点での値を返します。

\item \code{(set\-/signal!}\( \;\;\langle\kern0.08em\hbox{\ttfamily\slshape wire}\kern0.08em\rangle\;\;\langle\kern0.08em\hbox{\ttfamily\slshape new value}\kern0.08em\rangle \)\code{)}

\noindent
これは、線上の信号の値を新しい値に変更します。

\item \code{(add\-/action!}\( \;\;\langle\kern0.08em\hbox{\ttfamily\slshape wire}\kern0.08em\rangle\;\;\langle\kern0.08em\hbox{\ttfamily\slshape procedure of no arguments}\kern0.02em\rangle \)\code{)}

\noindent
これは、線上の信号の値が変わったときに、指定された手続きが必ず実行されるようにするものです。
そのような手続きは、線上の信号の値の変化をほかの線に伝える手段となります。
\end{itemize}

\noindent
これらに加え、\code{after\-/delay}という手続きも使います。これは、遅延時間と実行する手続きを
引数に取り、与えられた遅延時間後に与えられた手続きを実行するというものです。

これらの手続きを使って、基本のデジタル論理関数を定義できます。インバータを通して入力と出力を
接続するには、\code{add\-/action!}を使って、入力線上の信号の値が変わるたびに呼ぶ手続きを
入力線に関連づけます。この手続きは入力信号の\code{logical\-/not}(論理否定)を計算し、
そして\code{inverter\-/delay}1単位後に、出力信号にその新しい値をセットします。

\begin{scheme}
(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input invert-input) 'ok)
(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))
\end{scheme}

\noindent
ANDゲートはもうちょっと複雑です。アクション手続きは、入力のどちらかひとつが変化したときに
動くようにする必要があります。アクション手続きは、入力線上の信号の値の
\code{logical\-/and}(論理積)を(\code{logical\-/not}と似たような手続きを使って)求め、
\code{and\-/gate\-/delay}1単位後に出力線上で新しい値への変化が起こるように設定します。

\begin{scheme}
(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay 
       and-gate-delay
       (lambda () (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.28}Exercise 3.28:} 
ORゲートを基本関数箱として定義せよ。\code{or\-/gate}のコンストラクタは
\code{and\-/gate}と似たようなものにすること。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.29}Exercise 3.29:} 
ORゲートを構築する別の方法として、ANDゲートとインバータからなる複合デジタル論理デバイスとして
組み立てるというものがある。これを実現する手続き\code{or\-/gate}を定義せよ。このORゲートの
遅延時間は、\code{and\-/gate\-/delay}と\code{inverter\-/delay}によって表すと、どのようになる
だろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.30}Exercise 3.30:} 
\link{Figure 3.27}は、\( n \)個の全加算器をつなげた\newterm{ripple-carry adder}
(\jnewterm{繰り上がり伝播加算器})を示している。これは、二つの\( n \)ビット二進数を
足すための最も単純な形の並列加算器である。\( A_1 \), \( A_2 \), \( A_3 \), \( \dots \),
\( A_n \)と\( B_1 \), \( B_2 \), \( B_3 \), \( \dots \), \( B_n \)という入力は、
足し合わせる二つの二進数(各\( A_k \), \( B_k \)は0または1)である。
この回路は、和のうちの\( n \)ビットの\( S_1 \), \( S_2 \), \( S_3 \), \( \dots \),
\( S_n \)と、足し算による繰り上がりの\( C \)を生成する。この回路を生成する手続き
\code{ripple\-/carry\-/adder}を書け。この手続きは、\( n \)本の線のリスト三つ---
\( A_k \), \( B_k \), \( S_k \)---と、もうひとつの線\( C \)を引数として取るようにする。
繰り上がり伝播加算器の大きな欠点は、キャリー信号が伝播するのを待つ必要があるということだ。
\( n \)ビットの繰り上がり伝播加算器から完全な出力を得るのにかかる遅延時間は、ANDゲート・
ORゲート・インバータの遅延時間によって表現すると、どのようになるだろうか。
\end{quote}

\begin{figure}[tb]
\phantomsection\label{Figure 3.27}
\centering
\begin{comment}
\heading{Figure 3.27:} A ripple-carry adder for \( n \)-bit numbers.

\begin{example}
   :                                              :   :
   : A_1 B_1   C_1   A_2 B_2   C_2   A_3 B_3   C_3:   : A_n B_n C_n=0
   :  |   |   +---+   |   |   +---+   |   |   +-----  :  |   |   +-
   |  |   |   |   |   |   |   |   |   |   |   |   :   :  |   |   | 
   : ++---+---++  |  ++---+---++  |  ++---+---++  :   : ++---+---++
   : |   FA    |  |  |   FA    |  |  |   FA    |  :   : |   FA    |
   : +--+---+--+  |  +--+---+--+  |  +--+---+--+  :   : +--+---+--+
   :    |   |     |     |   |     |     |   |     :   :    |   |   
C ------+   |     +-----+   |     +-----+   |     :  ------+   |   
   :        |       C_1     |       C_2     |     :   :C_(n-1) |   
   :        |               |               |     :   :        |   
           S_1             S_2             S_3                S_n
\end{example}
\end{comment}
\includegraphics[width=96mm]{fig/chap3/Fig3.27a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.27:} \( n \)bitの数を扱う繰り上がり伝播加算器
\end{figure}

\subsubsection*{回路の表現}

このシミュレーションでは、線は二つの局所状態変数を持つ計算オブジェクトになります。
信号の値\code{signal\-/value}(初期値は0)と、信号の値が変わるときに実行するアクション手続き
\code{action\-/procedures}の集合です。メッセージパッシングスタイルを使い、
局所手続きの集合に適切な局所演算を選ぶ\code{dispatch}手続きを加えたものとして線を実装します。
これは、\link{Section 3.1.1}で単純な銀行口座オブジェクトを実装したときと同じです。

\begin{scheme}
(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures 
            (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation: WIRE" m))))
    dispatch))
\end{scheme}

\noindent
局所手続き\code{set\-/my\-/signal!}は、新しい信号値によって線上の信号が変わるかどうかを
テストします。変わるのであれば、以下の\code{call\-/each}手続きを使って各アクション手続きを
実行します。\code{call\-/each}は、引数なし手続きのリストの各項目を呼び出すというものです。

\begin{scheme}
(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin ((car procedures))
             (call-each (cdr procedures)))))
\end{scheme}

\noindent
局所手続き\code{accept\-/action\-/procedure!}は、与えられた手続きを実行する手続きのリストに
追加し、それから新しい手続きを一回実行します(\link{Exercise 3.31}参照)。

局所手続き\code{dispatch}が上で規定した通りに設定されていれば、以下のいくつかの手続きを
提供することで線に対する局所演算にアクセスできるようになります。
\footnote{\label{Footnote 27}これらの手続きは、通常の手続き的構文によってオブジェクトの
局所手続きにアクセスできるようにするシンタックスシュガーにすぎません。``手続き''と``データ''の
役割がこんなに簡単なやり方で交換できるということは特筆すべきことです。例えば、
もし\code{(wire 'get\-/signal)}と書くようにすると、\code{wire}は\code{get\-/signal}という
メッセージを入力として呼び出す手続きとして考えるということになります。
\code{(get\-/signal wire)}と書くようにすると、\code{wire}は手続き\code{get\-/signal}の
入力となるデータオブジェクトだと考えやすくなります。この問題の実際のところは、手続きを
オブジェクトとして扱う言語においては``手続き''と``データ''の間に根本的な違いはなく、
好きなスタイルでプログラミングできるようにシンタックスシュガーを選ぶことができるという
ことです。}

\begin{scheme}
(define (get-signal wire) (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
\end{scheme}

\noindent
線は、時とともに変化する信号を持ち、接続される装置が増えていくこともあるので、可変オブジェクトの
典型といえます。ここでは、代入によって変化する局所状態変数を持つ手続きとして線をモデル化して
います。新しい線が作られると、状態変数の新しいセットが(\code{make\-/wire}中の\code{let}式によって)
割り当てられ、それらの新しい状態変数を含む環境を持つ新しい\code{dispatch}手続きが構築され、
それが返されることになります。

線は、それに接続されたいろいろなデバイスの間で共有されます。そのため、ひとつのデバイスとの
やりとりによって起こった変化が、その線につながったほかのすべてのデバイスに影響することに
なります。線は、接続時に提供されるアクション手続きを呼ぶことによって、変化を近隣に伝えます。

\subsubsection*{予定表}

後は、\code{after\-/delay}さえあればシミュレータが完成します。ここでの考え方は、
するべきことのスケジュールを持っておく\newterm{agenda}(\jnewterm{予定表})と呼ばれる
データ構造を保持するということです。予定表に対しては、以下の演算が定義されます。

\begin{itemize}

\item
\code{(make\-/agenda)}は、新しい空の予定表を返します。

\item
\code{(empty\-/agenda?}\( \;\;\langle\kern0.08em\hbox{\ttfamily\slshape agenda}\kern0.06em\rangle\hbox{\tt)} \)は、指定した予定表が空のときに真になります。

\item
\code{(first\-/agenda\-/item}\( \;\;\langle\kern0.08em\hbox{\ttfamily\slshape agenda}\kern0.06em\rangle\hbox{\tt)} \)は、予定表の最初の項目を返します。

\item
\code{(remove\-/first\-/agenda\-/item!}\( \;\langle\kern0.08em\hbox{\ttfamily\slshape agenda}\kern0.06em\rangle\hbox{\tt)} \) は、最初の項目を削除することによって、予定表を変更します。

\item
\code{(add\-/to\-/agenda!}\( \;\;\langle\kern0.03em\hbox{\ttfamily\slshape time}\kern0.06em\rangle\;\;\langle\kern0.08em\hbox{\ttfamily\slshape action}\kern0.06em\rangle\;\;\langle\kern0.08em\hbox{\ttfamily\slshape agenda}\kern0.06em\rangle\hbox{\tt)} \)は、指定された時間に実行する
アクション手続きを追加することによって、予定表を変更します。

\item
\code{(current\-/time}\( \;\;\langle\kern0.08em\hbox{\ttfamily\slshape agenda}\kern0.04em\rangle\hbox{\tt)} \)は、現在のシミュレーション時間を返します。
\end{itemize}

\noindent
ここで使う特定の予定表は、\code{the\-/agenda}として示します。手続き\code{after\-/delay}は、
\code{the\-/agenda}に新しい要素を追加します。

\begin{scheme}
(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
\end{scheme}

\noindent
シミュレーションを動かすのは、手続き\code{propagate}(伝播)です。この手続きは
\code{the\-/agenda}を操作し、この予定表に載っているそれぞれの手続きを順番に実行します。
一般的に、シミュレーションが進むにつれ、新しい項目が予定表に追加されていき、\code{propagate}は
予定表に項目が存在する限りずっとシミュレーションを続けます。

\begin{scheme}
(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
\end{scheme}

\subsubsection*{シミュレーション例}

次の手続きは、線に``probe''(プローブ)を置くというもので、シミュレータの動作を表示します。
プローブは、信号値が変わるたびに新しい信号値・現在時刻・線の識別名を表示するよう線に伝えます。

\begin{scheme}
(define (probe name wire)
  (add-action! wire
               (lambda ()
                 (newline)
                 (display name)
                 (display " ")
                 (display (current-time the-agenda))
                 (display "  New-value = ")
                 (display (get-signal wire)))))
\end{scheme}

\noindent
まず、予定表を初期化し、基本関数箱の遅延時間を規定します。

\begin{scheme}
(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
\end{scheme}

\noindent
次に、四つの配線を定義し、そのうち二つにはプローブを設置します。

\begin{scheme}
(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))

(probe 'sum sum)
~\textit{sum 0  New-value = 0}~
(probe 'carry carry)
~\textit{carry 0  New-value = 0}~
\end{scheme}

\noindent
それから、線を(\link{Figure 3.25}のように)半加算器回路に接続し、\code{input\-/1}の信号を
1に設定し、シミュレーションを実行します。

\begin{scheme}
(half-adder input-1 input-2 sum carry)
~\textit{ok}~
\end{scheme}

\begin{scheme}
(set-signal! input-1 1)
~\textit{done}~
\end{scheme}

\begin{scheme}
(propagate)
~\textit{sum 8  New-value = 1}~
~\textit{done}~
\end{scheme}

\noindent
\code{sum}の信号は、時刻8で1に変わります。シミュレーション開始から8単位時間がたったことになります。
ここで、\code{input\-/2}の信号を1に設定し、値が伝播するようにします。

\begin{scheme}
(set-signal! input-2 1)
~\textit{done}~
\end{scheme}

\begin{scheme}
(propagate)
~\textit{carry 11  New-value = 1}~
~\textit{sum 16  New-value = 0}~
~\textit{done}~
\end{scheme}

\noindent
\code{carry}は時刻11で1に変わり、\code{sum}は時刻16で0に変わります。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.31}Exercise 3.31:} 
\code{make\-/wire}の中で定義される内部手続き\code{accept\-/action\-/procedure!}は、
新しいアクション手続きが線に追加されるときに、その手続きがすぐに実行されるということを
規定している。この初期化がなぜ必要なのか説明せよ。具体的には、上の段落の半加算器の例をトレースし、
\code{accept\-/action\-/procedure!}を以下のように定義した場合にシステムの応答がどのように
変わるか述べよ。

\begin{scheme}
(define (accept-action-procedure! proc)
  (set! action-procedures 
        (cons proc action-procedures)))
\end{scheme}
\end{quote}

\subsubsection*{予定表の実装}

最後に、予定表のデータ構造の詳細を記述します。このデータ構造は、将来実行するよう
スケジュールされた手続きを持っておくものです。

予定表は、複数の\newterm{time segment}(\jnewterm{時間区分})によって構成されます。
それぞれの時間区分は、数値(時刻)と、その時間区分の間に実行するようスケジュールされた
手続きを持っておくキュー (\link{Exercise 3.32}参照)からなるペアです。

\begin{scheme}
(define (make-time-segment time queue)
  (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))
\end{scheme}

\noindent
時間区分キューは、\link{Section 3.3.2}で説明したキュー演算によって操作します。

予定表自身は、時間区分の一次元テーブルです。\link{Section 3.3.3}で説明したテーブルと違うのは、
時間区分は時間の前後順に並んでいるという点です。それに加えて、予定表の先頭には
\newterm{current time}(\jnewterm{現在時刻})(最後に処理したアクションの時刻)を保存します。
新しく構築したばかりの予定表には時間区分はなく、現在時刻としては0を持っています。
\footnote{予定表は\link{Section 3.3.3}のような頭つきリストですが、このリストには
時刻というヘッダがあるので、追加のダミーヘッダ(テーブルで使った\code{*table*}記号のようなもの)
の必要はありません。}

\begin{scheme}
(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda) 
  (car (segments agenda)))
(define (rest-segments agenda) 
  (cdr (segments agenda)))
\end{scheme}

\noindent
予定表に時間区分がなければ、その予定表は空だということです。

\begin{scheme}
(define (empty-agenda? agenda)
  (null? (segments agenda)))
\end{scheme}

\noindent
予定表にアクションを追加するには、まず予定表が空かどうかチェックします。空であれば、アクションの
時間区分を作り、それを予定表に組み込みます。空でなければ、それぞれの時間区分の時刻を調べながら
予定表を走査します。指定時刻に時間区分が見つかれば、それに関連づけられたキューに
アクションを追加します。指定時刻以降の時刻にたどり着いたら、その時刻のすぐ前に、新しい
時間区分を挿入します。予定表の最後にたどり着いたら、末尾に新しい時間区分を作る必要があります。

\begin{scheme}
(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
\end{scheme}

\noindent
予定表の先頭の項目を削除する手続きは、先頭の時間区分にあるキューの先頭の項目を削除します。
削除して時間区分が空になるなら、それを時間区分のリストから削除します。
\footnote{この手続きの\code{if}式には\( \langle \)\var{alternative}\( \kern0.08em\rangle \)式が
ありません。このような``片腕\code{if}文''は、二つの式から選ぶというのではなく、何かを
するかどうかを決めるという場合に使います。\code{if}式は、述語が偽であり、かつ
\( \langle \)\var{alternative}\( \kern0.08em\rangle \)が存在しない場合、不定の値を返します。}

\begin{scheme}
(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
\end{scheme}

\noindent
予定表の先頭の項目は、先頭の時間区分のキューの先頭にあります。項目を取り出すたびに、
現在時刻の更新も行います。
\footnote{こうすると、現在時刻は常に直近に処理したアクションの時刻になります。この時刻を
予定表の先頭に格納することで、関連づけられた時間区分が削除されていてもその時刻が確実に
わかるようになっています。}

\begin{scheme}
(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty: FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda 
                           (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.32}Exercise 3.32:} 
予定表の各時間区分で実行するべき手続きはキューに保存される。そのため、各時間区分の
手続きは、予定表に追加した順(最初に入れたものが最初に取り出される)で呼び出される。
どうしてこの順番でなければならないのか説明せよ。具体的には、ひとつの時間区分の中で
入力が0, 1から1, 0に変わるANDゲートのふるまいをトレースし、時間区分の手続きを通常の
リストとして先頭だけで追加と削除を行う(最後に入れたものが最初に取り出される)ようにすると
ふるまいがどのように変わるか述べよ。
\end{quote}


\subsection{制約伝播}
\label{Section 3.3.5}

コンピュータプログラムは伝統的に一方向の計算という構造になっていて、あらかじめ決められた
引数に演算を行い、望む出力を生成します。一方で、いくつかの量の間の関係を使ってシステムを
モデル化するということもよくあります。例えば、機械構造の数学的モデルには、金属棒のたわみ
\( d \)と棒に加わる力\( F \)、棒の長さ\( L \)、断面積\( A \)、弾性係数\( E \)との間に
成り立つ、次の方程式によって表される関係についての情報が含まれるかもしれません。

\begin{comment}

\begin{example}
dAE = FL
\end{example}

\end{comment}
\begin{displaymath}
 dAE = FL. 
\end{displaymath}
このような方程式は一方向ではありません。量のうち任意の四つがあれば、それを使って五つ目の
量を計算することができます。しかし、この方程式を伝統的なコンピュータ言語に翻訳しようとすると、
どの量を残り四つの量を使って計算するのか選ばなければなりません。そのため、断面積\( A \)と
たわみ\( d \)の計算は同じ方程式から導かれるものなのに、\( A \)を計算する手続きは\( d \)を
求めるのには使えないということになります。
\footnote{制約伝播は、Ivan \link{Sutherland (1963)}による、信じられないほどの先進性を持った
\acronym{SKETCHPAD}システムで初登場したものです。Xeroxパロアルト研究センターでは、
Smalltalkベースの美しい制約伝播システムがAlan \link{Borning (1977)}によって開発されました。
Sussman, Stallman, Steeleは、制約伝播を電子回路解析に応用しました
(\link{Sussman and Stallman 1975}; \link{Sussman and Steele 1980})。
TK!Solver(\link{Konopasek and Jayaraman 1984})は、制約に基づく大規模モデリング環境です。}

この節では、関係そのものによってプログラミングできるような言語の設計についての概略を述べます。
この言語の基本要素は\newterm{primitive constraints}(\jnewterm{基本制約})です。これは、量と量の
間に成り立つ関係を記述したものです。例えば、\code{(adder a b c)}は\( a \), \( b \), \( c \)という
量の間に\( a + b = c \)という方程式の関係が成り立っていなければならないということを規定し、
\code{(multiplier x y z)}は、\( xy = z \)という制約を表し、\code{(constant 3.14 x)}は
\( x \)の値が3.14でなければならないということを表しています。

この言語では、基本制約を組み合わせてより複雑な関係を表す方法を提供します。制約を組み合わせるには、
\newterm{connectors}(\jnewterm{コネクタ})を使って制約を接続し、\newterm{constraint networks}
(\jnewterm{制約ネットワーク})を構築します。コネクタは、最低ひとつの制約に含まれる値を
``保持する''オブジェクトです。例を挙げると、華氏温度と摂氏温度には次のような関係があるということを
私たちは知っています。
\begin{comment}

\begin{example}
9C = 5(F - 32)
\end{example}

\end{comment}
\begin{displaymath}
 9C = 5(F - 32). 
\end{displaymath}
このような制約は、加算器・乗算器・不変制約という基本制約からなるネットワーク
(\link{Figure 3.28})として考えることができます。図の中で、左には\( m \)1, \( m \)2, \( p \)
というラベルのついた三つの端子を持つ乗算箱があります。これらの端子は、次のようにして乗算器を
ネットワークのほかの部分と接続します。まず、\( m \)1端子は摂氏の気温を保持するコネクタ\( C \)に
つなげられます。\( m \)2端子は\( w \)というコネクタにつなげられます。このコネクタは9を保持する
定数箱にもつながっています。\( p \)端子は乗算箱によって\( m \)1と\( m \)2の積になるよう
制約されていて、別の乗算箱の\( p \)端子につながっています。この乗算箱では、\( m \)2は整数5に、
\( m \)1は加算の項のうちのひとつに接続されています。

\begin{figure}[tb]
\phantomsection\label{Figure 3.28}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 3.28:} The relation \( 9C = 5(F - 32) \) expressed as a constraint network.

\begin{example}
       +---------+     +---------+   v   +---------+
C -----+ m1      |  u  |      m1 +-------+ a1      |
       |    *  p +-----+ p  *    |       |    *  s +---- F
    +--+ m2      |     |      m2 +--+ +--+ a2      |
    |  +---------+     +---------+  | |  +---------+
  w |                              x| |y
    |    +-----+        +-----+     | |     +-----+
    +----+  9  |        |  5  +-----+ +-----+  32 |
         +-----+        +-----+             +-----+
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=87mm]{fig/chap3/Fig3.28.pdf}
\begin{quote}
\heading{Figure 3.28:} 制約ネットワークとして表現された関係\\
\( 9C = 5(F - 32) \)
\end{quote}
\end{figure}

このようなネットワークによる計算の進行は以下のようになります。コネクタに(ユーザまたは接続された
制約箱によって)値が与えられると、コネクタは関連づけられた制約すべて(そのコネクタを起動した制約を
除き)を起動し、値が与えられたことを知らせます。起動されたそれぞれの制約箱は、それに接続されている
コネクタを調査して、コネクタの値を決めるのに十分な情報があるかどうかを見ます。もし値が決められる
なら、制約箱はそのコネクタに値を設定し、するとそのコネクタは関連づけられた制約すべてを起動し
\( \dots \)という連鎖が続きます。例えば、摂氏と華氏の変換の場合、制約箱によって
\( w \), \( x \), \( y \)はそれぞれ9, 5, 32にすぐに設定されます。それらのコネクタは乗算器と
加算器を起動し、それらは計算を進行させるために十分な情報がないと判断します。もしユーザ
(またはネットワークのどこか別の場所)が\( C \)にある値(例えば25)を設定すると、左端の乗算器が
起動され、\( u \)に\( 25 \cdot 9 = 225 \)を設定します。すると\( u \)は二つ目の乗算器を起動し、
それが\( v \)に45を設定します。そして\( v \)が加算器を起動し、加算器は\( f \)を77に設定します。

\subsubsection*{制約システムを使う}

上で概要を述べた温度計算を制約システムを使って実行するには、まずコンストラクタ
\code{make\-/connector}を読んで\code{C}, \code{F}という二つのコネクタを作り、
それらを適切なネットワークに接続します。

\begin{scheme}
(define C (make-connector))
(define F (make-connector))
(celsius-fahrenheit-converter C F)
~\textit{ok}~
\end{scheme}

\noindent
ネットワークを作る手続きは、次のように定義します。

\begin{scheme}
(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))
\end{scheme}

\noindent
この手続きは内部コネクタ\code{u}, \code{v}, \code{w}, \code{x}, \code{y}を作成し、
基本制約のコンストラクタ\code{adder}, \code{multiplier}, \code{constant}を使って
\link{Figure 3.28}に示したように接続します。\link{Section 3.3.4}のデジタル回路シミュレータの場合と
同じように、基本要素の組み合わせに手続きを使うことによって、この言語は自動的に複合オブジェクトを
抽象化する手段を持つことになります。

ネットワークの動作を見るために、\link{Section 3.3.4}で配線の監視に使ったのと似たような
\code{probe}手続きを使って、コネクタ\code{C}, \code{F}にプローブを置きます。コネクタに
プローブを置くと、コネクタに値が与えられるたびにメッセージを表示するようになります。

\begin{scheme}
(probe "Celsius temp" C)
(probe "Fahrenheit temp" F)
\end{scheme}

\noindent
それから、\code{C}の値を25に設定します。(\code{set\-/value!}への三つ目の引数は、
この指示が\code{user}によるものであることを\code{C}に伝えています)。

\begin{scheme}
(set-value! C 25 'user)
~\textit{Probe: Celsius temp = 25}~
~\textit{Probe: Fahrenheit temp = 77}~
~\textit{done}~
\end{scheme}

\noindent
\code{C}のプローブが起動され、値を報告します。\code{C}はまた、値を上記のネットワークに
伝播させます。それによって\code{F}に77が設定され、それが\code{F}のプローブによって報告されます。

今度は、\code{F}に新しい値、例えば212を設定してみます。

\begin{scheme}
(set-value! F 212 'user)
~\textit{Error! Contradiction (77 212)}~
\end{scheme}

\noindent
コネクタは矛盾を検知したというメッセージを出します。値は77なのに、誰かがそれを212に設定しようと
しているということです。新しい値によってネットワークを再利用するには、\code{C}に古い値を忘れる
よう指示します。

\begin{scheme}
(forget-value! C 'user)
~\textit{Probe: Celsius temp = ?}~
~\textit{Probe: Fahrenheit temp = ?}~
~\textit{done}~
\end{scheme}

\noindent
\code{C}は、最初に値を設定した\code{user}がその値を取り下げたことを検知し、\code{C}はその値を
捨てることに同意します。プローブの結果はそのことを示しています。そして、\code{C}はネットワークの
ほかの部分にその事実を伝えます。この情報は最終的に\code{F}にまで伝播します。\code{F}は、自分の
値が77だと信じ続ける根拠がなくなったことに気づきます。このようにして、\code{F}もまた自分の値を
捨てることになります。これもプローブによって表示されています。

これで\code{F}は値を持たなくなったので、\code{F}に212を設定できるようになります。

\begin{scheme}
(set-value! F 212 'user)
~\textit{Probe: Fahrenheit temp = 212}~
~\textit{Probe: Celsius temp = 100}~
~\textit{done}~
\end{scheme}

\noindent
この新しい値がネットワークを通して伝播されると、\code{C}の値が100に設定され、それが\code{C}のプローブに記録されます。\code{F}から\code{C}を計算するのにも、\code{C}から\code{F}を計算するのにも、
完全に同じネットワークが使われていることに注意してください。この計算の無方向性は、制約ベース
システムの際立った特徴です。

\subsubsection*{制約システムの実装}

制約システムは、\link{Section 3.3.4}のデジタル回路シミュレータとよく似たやり方で、
局所状態を持つ手続きオブジェクトによって実装します。制約システムの基本オブジェクトは
もう少し複雑なものになりますが、予定表や論理遅延について考える必要がない分、システム全体と
してはこちらのほうが単純です。

コネクタに対する基本演算は次の通りです。

\begin{itemize}

\item
\code{(has\-/value? <\var{connector}>)}は、コネクタが値を持っているかどうかを返します。

\item
\code{(get\-/value <\var{connector}>)}は、コネクタの現在の値を返します。

\item
\code{(set\-/value! <\var{connector}> <\var{new\-/value}> <\var{informant}>)}は、informant がコネクタに対して新しい値を設定するよう要求しているということを示しています。

\item
\code{(forget\-/value! <\var{connector}> <\var{retractor}>)}は、retractor が現在の値を忘れるよう要求しているということをコネクタに対して伝えます。

\item
\code{(connect <\var{connector}> <\var{new\-/constraint}>)}は、新しい制約に参加するようコネクタに伝えます。

\end{itemize}

\noindent

コネクタは、手続き\code{inform\-/about\-/value}と\code{inform\-/about\-/no\-/value}によって
制約と通信します。\code{inform\-/about\-/value}は与えられた制約にコネクタが値を持ったことを
伝え、\code{inform\-/about\-/no\-/value}は制約にコネクタが値を失ったことを伝えます。

\code{adder}は、\code{a1}, \code{a2}という加数コネクタと\code{sum}コネクタとの間に
加算器制約を構築するコンストラクタです。加算器は、局所状態(下記の\code{me}手続き)を持つ手続き
として実装します。

\begin{scheme}
(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error "Unknown request: ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
\end{scheme}

\noindent
\code{adder}は、新しい加算器を指定されたコネクタに接続し、その加算器を値として返します。
加算器を表現する手続き\code{me}は、局所手続きを起動するディスパッチの役割を果たしています。

\begin{scheme}
(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))
\end{scheme}

\noindent
加算器の局所手続き\code{process\-/new\-/value}は、コネクタのうちひとつが値を持ったことが
加算器に伝えられたときに呼び出されます。加算器は、まず\code{a1}と\code{a2}の両方が値を
持っているかチェックします。持っているなら、二つの加数の和を値として設定するよう
\code{sum}に伝えます。\code{set\-/value!}の\code{informant}引数は、加算器オブジェクト
自身である\code{me}になります。\code{a1}と\code{a2}の両方が値を持っているわけではない場合、
\code{a1}と\code{sum}が値を持っているかもしれないので、加算器はそれをチェックします。
もしそうなら、\code{a2}にはその二つの差を設定します。最後に、\code{a2}と\code{sum}が値を
持っているなら、加算器には\code{a1}の値を設定するのに十分な情報があることになります。
コネクタのひとつが値を失ったことが加算器に伝えられると、加算器はすべてのコネクタに
値を捨てるよう要求します(実際に捨てられるのはこの加算器によって設定された値だけです)。
それから、加算器は\code{process\-/new\-/value}を実行します。この最後のステップの理由は、
ひとつ以上のコネクタがまだ値を持っているかもしれず(つまり、元々その加算器によって設定された
のではない値を持っていたということ)、それらの値は加算器を通して伝播させ直す必要があるかも
しれないからです。

乗算器は加算器に非常によく似ています。乗算器は、因数の片方が0なら、もう片方の値がわからなくても
\code{product}を0に設定します。

\begin{scheme}
(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) 
                          (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) 
                          (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error "Unknown request: 
                        MULTIPLIER" request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
\end{scheme}

\noindent
\code{constant}コンストラクタは、単純に指定されたコネクタの値を設定します。
\code{I\-/have\-/a\-/value}や\code{I\-/lost\-/my\-/value}のメッセージが定数箱に送られると
エラーを発生させます。

\begin{scheme}
(define (constant value connector)
  (define (me request)
    (error "Unknown request: CONSTANT" request))
  (connect connector me)
  (set-value! connector value me)
  me)
\end{scheme}

\noindent
最後に、プローブは指定されたコネクタに値が設定されたり解除されたりしたことについての
メッセージを表示します。

\begin{scheme}
(define (probe name connector)
  (define (print-probe value)
    (newline) (display "Probe: ") (display name)
    (display " = ") (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value) (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error "Unknown request: PROBE" request))))
  (connect connector me)
  me)
\end{scheme}

\subsubsection*{コネクタの表現}

コネクタは手続きオブジェクトとして表現します。局所状態変数として、コネクタの現在の値
\code{value}、コネクタの値を設定したオブジェクト\code{informant}、コネクタが参加する制約の
リスト\code{constraints}を持ちます。

\begin{scheme}
(define (make-connector)
  (let ((value false) (informant false) (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "Contradiction" (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error "Unknown operation: CONNECTOR"
                         request))))
    me))
\end{scheme}

\noindent
コネクタの局所手続き\code{set\-/my\-/value}は、コネクタの値を設定するよう要求されたときに
呼ばれます。コネクタが現時点で値を持っていなければ、その値を設定し、値の設定を要求してきた
制約を\code{informant}として覚えておきます。
\footnote{\code{setter}は制約とは限りません。温度の例では、\code{user}を\code{setter}として
使いました。}
それからコネクタは、値の設定を要求してきた制約を除き、参加している制約すべてに通知を行います。
これは、次のイテレータによって実現します。このイテレータは、与えられたひとつを除いて、
リストのすべての項目に対して指定された手続きを適用します。

\begin{scheme}
(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))
\end{scheme}

\noindent
コネクタが値を忘れるよう依頼されると、局所手続き\code{forget\-/my\-/value}を実行します。
この手続きは、その要求が元々その値を設定したオブジェクトと同じオブジェクトから来たものか
どうかを確認します。そうであれば、コネクタは関連づけられた制約に値を失ったことを伝えます。

局所手続き\code{connect}は、もしリストになければ、制約リストに新しい制約を加えます。
それから、コネクタが値を持っているなら、新しい制約にその事実を伝えます。

コネクタの手続き\code{me}は、ほかの内部手続きへのディスパッチを行う役割を果たし、また
コネクタのオブジェクトとしての表現にもなっています。以下の手続きは、ディスパッチ用の
構文インターフェイスを提供します。

\begin{scheme}
(define (has-value? connector) (connector 'has-value?))
(define (get-value connector) (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))
\end{scheme}

\begin{quote}\heading{\phantomsection\label{Exercise 3.33}Exercise 3.33:} 
三つのコネクタ\code{a}, \code{b}, \code{c}を入力として取り、\code{c}の値が\code{a}と
\code{b}の値の平均となるような制約を作る手続き\code{averager}を、基本の乗算器・加算器・
定数制約を使って定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.34}Exercise 3.34:} 
Louis Reasonerは、squarerという制約を作りたいと思っている。squarerは二つの端子を持ち、
二つ目の端子のコネクタ\code{b}は常に一つ目の端子の値\code{a}の二乗になる。彼は、ひとつの
乗算器からなる次の単純な装置を提案した。

\begin{scheme}
(define (squarer a b) (multiplier a a b))
\end{scheme}

このアイデアには重大な欠陥がある。説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.35}Exercise 3.35:} 
Ben BitdiddleはLouisに、\link{Exercise 3.34}の問題を避ける方法のひとつは、squarerを
新しい基本制約として定義することだと伝えた。Benが書いた手続き概略の欠けている部分を埋め、
そのような制約を実装せよ。

\begin{scheme}
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "square less than 0: SQUARER" 
                   (get-value b))
            ~\( \dark \langle \)~~\var{\dark alternative1}~~\( \dark \rangle \)~)
        ~\( \dark \langle \)~~\var{\dark alternative2}~~\( \dark \rangle \)~))
  (define (process-forget-value) ~\( \dark \langle \)~~\var{\dark body1}~~\( \dark \rangle \)~)
  (define (me request) ~\( \dark \langle \)~~\var{\dark body2}~~\( \dark \rangle \)~)
  ~\( \dark \langle \)~~\var{\dark rest of definition}~~\( \dark \rangle \)~
  me)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.36}Exercise 3.36:} 
グローバル環境で、次のような式の列を評価するとする。

\begin{scheme}
(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
\end{scheme}

\code{set\-/value!}の評価中のある時点で、コネクタの局所手続きの中の以下の式が評価される
ことになる。

\begin{scheme}
(for-each-except 
  setter inform-about-value constraints)
\end{scheme}

上記の式が評価される環境を表す環境図を描け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.37}Exercise 3.37:} 
\code{celsius\-/fahrenheit\-/converter}手続きは、以下のような式指向スタイルによる定義に
比べると面倒だ。

\begin{scheme}
(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))
(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
\end{scheme}

ここで、\code{c+}, \code{c*}等は``制約''バージョンの数値演算である。例えば、\code{c+}は
二つのコネクタを引数として取り、加算器制約によってそれらと関連づけられたコネクタを返す。

\begin{scheme}
(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
\end{scheme}


似たような手続き\code{c\-/}, \code{c*}, \code{c/}, \code{cv}(定数)を定義し、上記の変換器の
例のように複合制約を定義できるようにせよ。
\footnote｛式指向形式を使うと計算の中間の式に名前をつける必要がなくなるので便利です。
元々の制約言語による定式化は面倒でした。これは、多くの言語で複合データを扱うのが面倒なのと
同じです。例えば、変数がベクトルを表現しているとして、積\( (a + b) \cdot (c + d) \)を
求めたいとすると、指定されたベクトル引数に値をセットするが手続き自身はベクトルを値として
返さないような手続きを使って、``命令型スタイル''で作業をすることもできます。

\begin{smallscheme}
(v-sum a b temp1)
(v-sum c d temp2)
(v-prod temp1 temp2 answer)
\end{smallscheme}

別の方法として、ベクトルを値として返す手続きを使うことによって、式によって扱うことも
可能です。こうすると、明示的に\code{temp1}と\code{temp2}を使う必要がなくなります。

\begin{smallscheme}
(define answer (v-prod (v-sum a b) (v-sum c d)))
\end{smallscheme}
Lispでは、手続きの値として複合オブジェクトを返すことができるので、ここまで命令型スタイルで
作ってきた制約言語を、この練習問題のように式指向のスタイルに変形するということができます。
複合データを扱う手段に乏しいAlgol, Basic, Pascal(明示的にPascalのポインタ変数を使わない限り)
では、複合オブジェクトを操作しようと思うと、命令型スタイルに縛られることになります。式指向
形式の利点を考えると、この節でやったように命令型スタイルでシステムを実装する意味はあるのかと思う
人もいるかもしれません。理由のひとつは、式指向でない制約言語はコネクタオブジェクトだけでなく
制約オブジェクトに対するハンドル(例えば、\code{adder}手続きの値)を提供するということです。
コネクタ演算を通して間接的に制約を扱うのではなく、制約と直接通信する新しい演算によって
システムを拡張したいという場合には、このことが役に立ちます。命令型の実装によって式指向
スタイルを実装するのは簡単なのですが、その逆はとても難しいのです。}
\end{quote}

\section{並行性: 期限厳守}
\label{Section 3.4}

ここまで、モデル化のための道具として、局所状態を持つ計算オブジェクトというものが持つ
力について見てきました。しかし、\link{Section 3.1.3}で警告したように、この力は代償を
伴うものです。その代償とは、参照透明性を失ない、結果として同一性と変化ということについて
厄介な問題を引き起こしたこと、評価の置換モデルを放棄し、より複雑な環境モデルを採用せざるを
得なくなったことです。

状態、等価性、変化の複雑性の下に潜んでいる中心的課題は、代入を導入することによって
計算モデルの中に\newterm{time}(\jnewterm{時間})という概念を含めなければならなくなったという
ことです。代入を導入するまでは、値を持つ式はいつでも同じ値を持つという意味で、プログラムには
時間という概念がありませんでした。それに対して、\link{Section 3.1.1}の最初で導入した、銀行
口座から引き出しを行い差引残高を返すということのモデル化の例を思い出してみましょう。

\begin{scheme}
(withdraw 25)
~\textit{75}~
(withdraw 25)
~\textit{50}~
\end{scheme}

\noindent
ここでは、同じ式を連続して評価して、違う値が返されています。このふるまいは、
代入文(この場合、変数\code{balance}への代入)を実行することが、値が変化する
\newterm{moments in time}(\jnewterm{瞬間})を示していることによります。ある式を評価した結果は、
式そのもの以外に、その評価が起こったのがこれらの瞬間の前なのか、それとも後なのかということに
よっても変わることになります。局所状態を持つ計算オブジェクトによってモデルを構築すると、
プログラミングの本質的な概念として、時間という問題に取り組む必要が出てきます。

物理世界の認知に合うように、計算モデルの構造化をさらに進めることもできます。現実世界の
オブジェクトは、ひとつずつ順番に変化するということはありません。オブジェクトは、
\newterm{concurrently}(\jnewterm{並行})に、つまり同時に動いているように認識されています。
そのため、システムのモデル化する際に、並行に動く計算プロセスの集合という形で行うことが
自然になることはよくあります。別々の局所状態を持ったオブジェクトを使ってモデルを作り上げることに
よってプログラムをモジュール式にできるのと同じように、独立して並行に実行が進むいくつかの
部品に計算モデルを分割するのが向いているということがよくあります。プログラムは逐次型
コンピュータで実行することになるとしても、あたかも並列に実行されるかのようにプログラムを
書くと、プログラマは本質的でない時間の制約を避けるようになり、そのためプログラムのモジュール性が
高まります。

プログラムのモジュール性を高めるほかに、並行計算は逐次計算に対してスピード的な利点もあります。
逐次計算は一度にひとつの演算しか実行できないので、タスクの実行時間は実行する演算の数に比例します。
\footnote{実際のプロセッサの多くは、\newterm{pipelining}(\jnewterm{パイプライン})という
戦略によって、同時にいくつかの演算を実行します。このテクニックはハードウェアの利用効率を
大きく改善するのですが、これは直列の命令列の実行スピードを上げるためだけに使われ、
逐次的プログラムのふるまいはそのままです。}
しかし、もし問題を比較的独立した、時々しか通信を行わないいくつかの部品に分割できるなら、
それぞれの部品を別々のプロセッサに割り当てられる可能性があります。そうすると、使える
プロセッサの数に比例して速度を上げることができるようになります。

残念ながら、並行性という概念を持ち込むと、代入によって生じた複雑性がさらに問題のあるものに
なります。並行実行という現象は、並列に動いているのが現実世界であってもコンピュータであっても、
時間というものの理解をさらに複雑にします。

\subsection{並行システムにおける時間の性質}
\label{Section 3.4.1}

表面的には、時間というものは単純なもののように見えます。時間は、事象につけられる順番です。
\footnote{ケンブリッジの建物の壁に描かれた落書きを引用すると、``時間とは、何もかもが同時に起こらない
ようにするために発明された仕掛けだ''}
任意の事象\( A \)と\( B \)があれば、ありうるパターンは\( A \)が\( B \)の前に起こる、
\( A \)と\( B \)は同時に起こる、\( A \)は\( B \)の後に起こるというどれかになります。
例えば、銀行口座の例に戻って考えてみましょう。最初の時点で100ドル入っている共同口座から
Peterは10ドルを引き出し、Paulは25ドルを引き出して、口座には65ドルが残るとします。二回の引き出しの
順番によって、残高の推移は\( \,\$100 \to \$90 \to \$65\, \)か\( \,\$100 \to \$75 \to \$65\, \)の
どちらかになります。銀行システムのコンピュータ実装では、この変わっていく残高の推移は、
変数\code{balance}への連続した代入としてモデル化できます。

しかし、状況が複雑になると、そのような見方には問題が出てきます。PeterやPaulやほかの人たちが、
世界中に分散したATMのネットワークを通して、同じ銀行口座にアクセスしていると考えてみましょう。
実際の口座残高の推移は、アクセスのタイミングや機械同士の通信の詳細に決定的に依存することに
なります。

このように、イベントの順番が決まっていないということは、並行システムを設計するうえで
深刻な問題になります。例えば、PeterとPaulによる引き出しが、共通の変数\code{balance}を
共有する二つの別々のプロセスとして実装されているとします。各プロセスは、\link{Section 3.1.1}の
手続きによって規定されるものです。

\begin{scheme}
(define (withdraw amount)
  (if (>= balance amount)
      (begin
        (set! balance (- balance amount)) balance)
      "Insufficient funds"))
\end{scheme}

\noindent
もし二つのプロセスが独立に動作するとすると、次のようなことが起こる可能性があります。
まず、Peterは残高を確認して、正当な金額を引き出そうとします。しかし、Peterが
残高を確認してから引き出しを終えるまでの間に、Paulがお金を引き出してしまって、Peterの
確認結果が無効になってしまいます。

もっとひどいことになる可能性もあります。それぞれの引き出しプロセスの一部として、次の式が
実行されるとします。

\begin{scheme}
(set! balance (- balance amount))
\end{scheme}

\noindent
この式は、三つのステップからなります。(1) 変数\code{balance}の値にアクセスし、(2) 新しい残高を
計算し、(3) \code{balance}にこの新しい値を設定する、というものです。もしPeterとPaulの引き出し
手続きがこの文を並行に実行したとすると、二つの手続きが\code{balance}にアクセスして新しい値を
設定する順番が入れ違いになってしまう可能性もあります。

\link{Figure 3.29}のタイミング図は、\code{balance}が100の状態から始まって、Peterが10引き出し、
Paulが25を引き出しているのに、\code{balance}の最終的な値が75となるという状況で、イベントの
発生順を表したものです。図に示したように、こういうおかしなことになった原因は、Paulの
\code{balance}への75の代入が、引き算する\code{balance}の値が100であるという前提のもとで
行われているということです。しかし、この前提はPeterが\code{balance}を90に変更したときに無効に
なっています。システム内のお金の総額が保たれていないので、これは銀行システムとしては
どうしようもない失敗です。二つの取引の前は、お金の総額は100ドルでした。取引の後は、Peterが
10ドル、Paulが25ドル、銀行が75ドルを持っていることになっています。
\footnote{
二つの\code{set!}演算が同時に残高を変更しようとすると、もっとひどい失敗が起こる可能性があります。
この場合、メモリ上に残る実際のデータは、二つのプロセスが書き込んだ情報がでたらめに混ぜ合わされた
ものになってしまうかもしれません。ほとんどのコンピュータでは、基本メモリ書き込み演算には
インターロックがあり、そのような同時アクセスを防いでいます。しかし、このような一見単純な
保護の仕組みさえ、マルチプロセスコンピュータを設計する際には実装上の問題が出てきます。
設計にあたっては、メモリアクセスの速度を上げるために別々のプロセッサの間でデータが
複製(``キャッシュ'')されていても、プロセッサ間で一貫したメモリ内容の見え方を保つことを
保証するために、精巧な\newterm{cache\-/coherence}(\jnewterm{キャッシュコヒーレンス})
プロトコルが必要となります。}

\begin{figure}[tp]
\phantomsection\label{Figure 3.29}
\centering
\begin{comment}
\heading{Figure 3.29:} Timing diagram showing how interleaving the order of events 
in two banking withdrawals can lead to an incorrect final balance.

\begin{example}
 |           Peter              Bank              Paul
 |                              ____
 |                             /    \
 |             .--------------| \$100 |-------------.
 |             |               \____/              |
 |             V                                   V
 |  .----------------------.            .----------------------.           
 |  | Access balance: \$100 |            | Access balance: \$100 |
 |  `----------+-----------'            `----------+-----------'
 |             V                                   V
 |  .----------------------.            .----------------------.           
 |  | new value: 100-10=90 |            | new value: 100-25=75 |
 |  `----------+-----------'            `----------+-----------'
 |             V                                   |
 |  .----------------------.                       |
 |  | set! balance to \$90  |                       |
 |  `----------+-----------'    ____               |
 |             |               /    \              |
 |             `------------->| \$ 90 |             V
 |                             \____/   .----------------------.
 |                                      | new value: 100-25=75 |
 |                              ____    `----------+-----------'
 |                             /    \              |
 |                            | \$ 90 |<------------'
 V                             \____/
time
\end{example}
\end{comment}
\includegraphics[width=109mm]{fig/chap3/Fig3.29b.pdf}
\begin{quote}
\heading{Figure 3.29:} 二回の引き出しで、イベントの順番が入れ違いになって最終的に間違った残高になってしまう様子を示したタイミング図
\end{quote}
\end{figure}

ここでの例は、複数のプロセスが共通の状態変数を共有するという一般的な現象を示しています。
これが面倒なことになるのは、二つ以上のプロセスが同時に共有された状態を操作しようとするかも
しれないということによります。銀行口座の例では、それぞれの取引の間は、それぞれの顧客が
ほかに顧客がいないかのようにふるまうことができる必要があります。ある顧客が口座残高に
依存する形で残高を更新しようとしているとすると、変更のちょうどその前の瞬間まで口座が自分の
考えている通りの残高を持っているという前提で顧客が行動できるようにしなければなりません。

\subsubsection*{並行プログラムの正しいふるまい}

上の例は、並行プログラムに入り込みがちなバグの典型例を示しています。この複雑性の根元には、
異なるプロセスの間で共有される変数に対する代入があります。ここまでですでに、\code{set!}を
使うプログラムを書く際には気をつけなければならないということがわかりました。これは、
計算の結果が代入の起こる順番に依存するからです。
\footnote{\link{Section 3.1.3}の階乗プログラムは、単一の逐次処理の場合にもこの問題が起こることを
示したものです。}
並行プロセスでは、代入には特に気をつける必要があります。これは、別々のプロセスが行う代入の
順番はコントロールできるとは限らないからです。そのような変更が(二人の預金者が共同口座に
アクセスする場合のように)いくつか同時に起こる可能性があるなら、何らかの方法でシステムの
正常な動作を保証しなければなりません。例えば、共同口座からの引き出しの場合であれば、金額が
変わらないことを保証する必要があります。並行プログラムを正常に動作させるためには、
並行実行に何らかの制限を加えることが必要になるかもしれません。

考えられる制限のひとつとして、共有された状態を変更するようなどんな二つの演算も同時に起こっては
ならないと決めてしまうことです。これは非常に厳しい要求です。分散銀行システムの場合であれば、
同時にはひとつの取引しか行えないことを保証するようシステム設計者に要求することになります。
これは非効率で、また保守的すぎます。\link{Figure 3.30}は、PeterとPaulが口座を共有していて
Paulはほかに個人口座も持っているという状況を示したものです。図は、共有口座からの二回の引き出し
(Peterが一回、Paulが一回)と、Paulの個人口座への預金を示しています。
\footnote{それぞれの列は、Peterの財布、(Bank1内の)共同口座、Paulの財布、(Bank2内の)Paulの
個人口座の中身が、それぞれの引き出し(W)と預け入れ(D)の前後でどうなっているかを示しています。
PeterはBank1から10ドルを引き出しています。Paulは5ドルをBank2に預金し、次にBank1から25ドルを
引き出しています。}共有口座からの二回の引き出しは、並行であってはいけません
(どちらも同じ口座にアクセス・更新しているからです)。また、Paulの預金と引き出しは並行であっては
いけません(どちらもPaulの財布にアクセス・更新を行っているからです)。しかし、Paulが自分の
個人口座に預け入れを行うのと、Peterが共有口座から引き出しを行うのは、許可しても問題ないはずです。

\begin{figure}[tb]
\phantomsection\label{Figure 3.30}
\centering
\begin{comment}
\heading{Figure 3.30:} Concurrent deposits and withdrawals from a joint account 
in Bank1 and a private account in Bank2.

\begin{example}
 |    Peter          Bank1          Paul           Bank2
 |    ____           ____           ____           ____  
 |   /    \         /    \         /    \         /    \ 
 |  |  \$7  |--. .--| \$100 |       |  \$5  |--. .--| \$300 |
 |   \____/   V V   \____/         \____/   V V   \____/ 
 |           +---+                         +---+         
 |           | W |                         | D |         
 |    ____   ++-++   ____           ____   ++-++   ____  
 |   /    \   | |   /    \         /    \   | |   /    \ 
 |  | \$17  |<-' `->| \$90  |--. .--|  \$0  |<-' `->| \$305 |
 |   \____/         \____/   V V   \____/         \____/ 
 |                          +---+
 |                          | W |
 |    ____           ____   ++-++   ____           ____  
 |   /    \         /    \   | |   /    \         /    \ 
 |  | \$17  |       | \$65  |<-' `->| \$25  |       | \$305 |
 |   \____/         \____/         \____/         \____/ 
 V
time
\end{example}
\end{comment}
\includegraphics[width=94mm]{fig/chap3/Fig3.30b.pdf}
\begin{quote}
\heading{Figure 3.30:} 銀行1の共同口座と銀行2の個人口座に対する並行な預け入れと引き出し
\end{quote}
\end{figure}

並行性に対するもう少し緩い制限として、各プロセスが何らかの順番で逐次的に実行された場合と
同じ結果になることを保証するというものがあります。この要求には、二つの重要な側面があります。
一つ目は、各プロセスが別々に実行される必要はなく、\emph{あたかも}それらのプロセスが
逐次的に実行されたかのような結果さえ出せばいいということです。\link{Figure 3.30}の例でいうと、
銀行口座システムを設計する人は、Paulの預け入れとPeterの引き出しが同時に起こるようにしても
問題ないことになります。全体としての結果は、二つの操作が逐次的に行われたのと同じことに
なるからです。二つ目は、並行プログラムの実行結果には二つ以上の可能な``正解''がありうるという
ことです。プログラムの結果は、\emph{何らかの}順序で逐次的に実行したものと同じになっていれば
よいからです。例えば、PeterとPaulの共同口座の残高が最初は100ドルで、Peterが40ドルを預け入れる
のと並行にPaulが残高の半額を引き出すという場合について考えてみましょう。この場合、逐次実行では、
残高は最終的に70ドルか90ドルのどちらかになります(\link{Exercise 3.38}参照)。
\footnote{\label{Footnote 39}この考え方をより形式的に表現すると、並行プログラムは本質的に
\newterm{nondeterministic}(\jnewterm{非決定的})であるということになります。つまり、並行
プログラムは単一の値を持つ関数として記述するのではなく、取り得る値の集合という形で結果を持つ
関数として記述することになります。\link{Section 4.3}では、非決定的計算を表現する言語について
学びます。}

並行プログラムを正しく動作させる要件として、これより弱いものもあります。例えば、(物体内での
熱の流れのような)拡散シミュレーションプログラムを数多くのプロセスから構成されるものとして
書く場合について考えてみます。それぞれのプロセスは小さな空間を表現し、値を並行に更新するものと
します。それぞれのプロセスは、自分自身の値と近傍の値の平均を取って、連続して自分の値を変えて
いきます。このアルゴリズムは、演算の行われる順番とは独立に、正しい解に収束します。共有される
値を並行に使用する際に制限を設ける必要はありません。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.38}Exercise 3.38:} 
Peter, Paul, Maryが共同口座を持っていて、最初は100ドル入っているとする。以下に示す
コマンドによって、Peterは10ドルを預け入れ、Paulは20ドルを引き出し、Maryは口座残高の半額を
引き出すということを並行的に行う。

\begin{example}
Peter: (set! balance (+ balance 10))
Paul:  (set! balance (- balance 20))
Mary:  (set! balance (- balance (/ balance 2)))
\end{example}

\begin{enumerate}[a]

\item
これらの3つの取引が完了した後で\code{balance}が取り得る異なる値をすべて列挙せよ。
銀行システムは、三つのプロセスが何らかの順序で逐次的に実行されるようにするとする。

\item
もしシステムがプロセスの実行が入れ違いになることを許すとすると、ほかにどのような値に
なる可能性があるだろうか。\link{Figure 3.29}のようなタイミング図を描き、それらの値が
どのようにして起こるか説明せよ。
\end{enumerate}
\end{quote}

\subsection{並行性制御メカニズム}
\label{Section 3.4.2}

ここまで見てきたように、並行プロセスを扱ううえで難しいところは、別々のプロセスのイベントの
順番が入れ違いになることを考えないといけないことによるものです。例えば、二つのプロセスがあって、
片方は\( (a, b, c) \)、もう片方は\( (x, y, z) \)という、それぞれ順序つきの三つのイベントを
持っているとします。もし二つのプロセスが、実行が入れ違いになることに対する制限がない状態で
並行して動作するとすると、個別プロセス内での順序と矛盾しないイベントの順序として、20通りが
考えられることになります。

\begin{example}
(a,b,c,x,y,z)  (a,x,b,y,c,z)  (x,a,b,c,y,z)  (x,a,y,z,b,c)
(a,b,x,c,y,z)  (a,x,b,y,z,c)  (x,a,b,y,c,z)  (x,y,a,b,c,z)
(a,b,x,y,c,z)  (a,x,y,b,c,z)  (x,a,b,y,z,c)  (x,y,a,b,z,c)
(a,b,x,y,z,c)  (a,x,y,b,z,c)  (x,a,y,b,c,z)  (x,y,a,z,b,c)
(a,x,b,c,y,z)  (a,x,y,z,b,c)  (x,a,y,b,z,c)  (x,y,z,a,b,c)
\end{example}

\noindent
プログラマがこのシステムを設計するにあたっては、これら20通りの順序の効果を考え、それぞれの
ふるまいが受け入れられるものかどうかチェックしなければならなくなります。そのようなやり方は、
プロセスとイベントの数が増えるにつれて、あっという間に手に負えなくなります。

より現実的な並行システムの設計アプローチとしては、プログラムのふるまいの正しさを保証できる形で
並行プロセスの入れ違い方を制約できるような一般的なメカニズムを考えるというものがあります。
これまで、このことを目的とした多くのメカニズムが開発されてきました。この節では、その中の
ひとつである\newterm{serializer}(\jnewterm{直列変換器})について説明します。

\subsubsection*{共有状態へのアクセスの直列化}

直列化というのは、次のような考え方を実装したものです。「プロセスは並行して実行されるが、
並行して実行できない手続きの集合がある」。より正確には、直列化では互いに区別される複数の
手続きの集合を作り、それぞれの直列化された集合の中では同時にひとつのプロセスしか実行
されないようにするというものです。集合内の手続きが実行されているときには、その集合内の
何かの手続きを実行しようとするプロセスは、一つ目の実行が終わるまで待たされることになります。

直列化は共有変数へのアクセスの制御に使えます。例えば、共有変数の値をその変数のそれまでの
値に基づいて更新したいというとき、その変数のそれまでの値に対するアクセスとその変数への
新しい値の割り当てを同じ手続き内に置くようにします。それから、その変数に値を割り当てる
ほかの手続きもすべて同じ直列変換器にまとめることで、この手続きとそれらの手続きが同時に
実行されないようにします。こうすることで、変数へのアクセスとそれに対応する値の割り当てとの間で
変数の値が変更されないことが保証できます。

\subsubsection*{Schemeのシリアライザ}

上のメカニズムをもう少し具体的に考えるために、\code{parallel\-/execute}という手続きを持つ
拡張Schemeがあると仮定します。

\begin{scheme}
(parallel-execute ~\( \dark \langle \)~~\( \dark p_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark p_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark p_k \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
各\( \langle \)\( p \)\( \kern0.08em\rangle \)は、引数なしの手続きである必要があります。
\code{parallel\-/execute}は、各\( \langle \)\( p \)\( \kern0.08em\rangle \)に対して
独立したプロセスを作り、それらのプロセスは\( \langle \)\( p \)\( \kern0.08em\rangle \)を
(引数なしで)適用します。これらのプロセスは、すべて並行に実行されます。
\footnote{\code{parallel\-/execute}は標準Schemeの一部ではありませんが、\acronym{MIT} Schemeで
実装することができます。ここでの実装では、新しい並行プロセスはオリジナルのSchemeプロセスと
並行に実行できます。また、ここでの実装では、\code{parallel\-/execute}によって返される値は、
新しく作ったプロセスを停止させるのに使える特別なコントロールオブジェクトです。}

これの使い方の例として、以下のものについて考えてみましょう。

\begin{scheme}
(define x 10)
(parallel-execute
 (lambda () (set! x (* x x)))
 (lambda () (set! x (+ x 1))))
\end{scheme}

\noindent
これは、二つの並行プロセスを作ります。\code{x}に\code{x}かける\code{x}を設定する\( P_1 \)と、
\code{x}に1を足す\( P_2 \)です。実行が終わった後には、\( P_1 \)と\( P_2 \)のイベントの入れ違い
具合によって、\code{x}は可能な五通りの値のうちのひとつになります。

\begin{scheme}
101: ~\textrm{\( P_1 \)が\code{x}に100を設定し、次に\( P_2 \)が\code{x}を101に増やす}~
121: ~\textrm{\( P_2 \)が\code{x}を11に増やし、次に\( P_1 \)が\code{x}を\code{x} \code{*} \code{x}に設定する}~
110: ~\textrm{\( P_1 \)が\code{(* x x)}を評価する際の\code{x}の値に対する二回のアクセスの間に} ~
     ~\textrm{\( P_2 \)が\code{x}を10から11に変える}~
 11: ~\textrm{\( P_2 \)が\code{x}にアクセスし, それから\( P_1 \)が\code{x}を100に設定し、}~
     ~\textrm{それから\( P_2 \)が\code{x}を設定する}~
100: ~\textrm{\( P_1 \)が\code{x}に(二回)アクセスし、それから\( P_2 \)が\code{x}を11に設定し、}~
     ~\textrm{それから\( P_1 \)が\code{x}を設定する}~
\end{scheme}

\noindent
直列化手続きを使うことによって、並行性に制約を加えることができます。直列化手続きは、
\newterm{serializers}(\jnewterm{シリアライザ})によって作ります。シリアライザは、
\code{make\-/serializer}により構築されます。この実装は後で示します。シリアライザは手続きを
引数に取り、元の手続きと同じようにふるまう直列化手続きを返します。あるひとつのシリアライザに
対する呼び出しは、すべて同じ集合に属する直列化手続きを返します。

このため、次のものを実行すると、上の例とは異なり、\code{x}の二つの可能な値である101または121しか
返しません。

\begin{scheme}
(define x 10)
(define s (make-serializer))
(parallel-execute
 (s (lambda () (set! x (* x x))))
 (s (lambda () (set! x (+ x 1)))))
\end{scheme}

\noindent
ほかの可能性は排除されています。これは、\( P_1 \)と\( P_2 \)の実行が入れ違いにならないように
なっているからです。

\link{Section 3.1.1}の\code{make\-/account}手続きの、預け入れと引き出しが直列化されたバージョンを
以下に示します。

\begin{scheme}
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance) balance)
            (else (error "Unknown request: MAKE-ACCOUNT"
                         m))))
    dispatch))
\end{scheme}

\noindent
この実装では、二つのプロセスがひとつの口座に並行に預け入れをしたり引き出しをしたりすることは
できなくなっています。こうすることで、\link{Figure 3.29}で図示したような、Paulが新しい値を
計算するために残高にアクセスしてからPaulが実際に代入を行うまでの間にPeterが口座残高を
変えてしまうといったエラーの原因は排除されます。一方、二つの口座はそれぞれ自分のシリアライザを
持っているので、別々の口座に対する預け入れと引き出しは並行に行うことができます。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.39}Exercise 3.39:} 
並行実行の結果として上で示した五つの可能な値のうち、実行を次のように直列化したら、どれが
残るだろうか。

\begin{scheme}
(define x 10)
(define s (make-serializer))
(parallel-execute 
 (lambda () (set! x ((s (lambda () (* x x))))))
 (s (lambda () (set! x (+ x 1)))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.40}Exercise 3.40:}
以下のものを実行したときに\code{x}が取り得る値をすべて列挙せよ。

\begin{scheme}
(define x 10)
(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
\end{scheme}

以下の直列化手続きを使うと、これらの可能性のうちどれが残るだろうか。

\begin{scheme}
(define x 10)
(define s (make-serializer))
(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.41}Exercise 3.41:} 
Ben Bitdiddleは、次のように銀行口座を実装したほうがいいのではないかと心配している
(変更箇所はコメントつきの行)。

\begin{scheme}
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance 
                     (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
             ((protected 
               (lambda () balance)))) ~\textrm{; 直列化}~
            (else
             (error "Unknown request: MAKE-ACCOUNT"
                    m))))
    dispatch))
\end{scheme}

\noindent
その理由は、銀行口座に対する非直列化アクセスを許していると、異常なふるまいが起こるかも
しれないということだ。その意見に賛成するか。Benの心配を実証するようなシナリオは存在するだろうか。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.42}Exercise 3.42:} 
Ben Bitdiddleは、\code{withdraw}と\code{deposit}メッセージが来るたびに新しい直列化手続きを
作るのは時間の無駄だと提案した。彼の意見は、\code{make\-/account}を変更して、
\code{protected}に対する呼び出しを\code{dispatch}手続きの外で行うようにしたらいいという
ものだ。つまり、口座が引き出し手続きを要求されるたびに、(口座作成と同時に作った)同じ直列化
手続きを返すことになる。

\begin{scheme}
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (let ((protected-withdraw (protected withdraw))
          (protected-deposit (protected deposit)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) protected-withdraw)
              ((eq? m 'deposit) protected-deposit)
              ((eq? m 'balance) balance)
              (else 
               (error "Unknown request: MAKE-ACCOUNT"
                      m))))
      dispatch)))
\end{scheme}

これは安全な変更だろうか。具体的には、これら二つのバージョンの\code{make\-/account}によって
許される並行性に違いはあるだろうか。
\end{quote}

\subsubsection*{複数の共有リソース使う際の複雑性}

シリアライザは、並行プログラムの複雑性を隔離し、複雑性を注意深く、また(おそらくは)正しく
扱うことができるように、強力な抽象化を提供しています。しかし、共有リソースが
(ひとつの銀行口座のように)ひとつしかない場合にはシリアライザを使うのは比較的素直に
うまくいくのですが、共有リソースが複数ある場合には、並行プログラミングは落とし穴の多い
難しいものになることがあります。

起こりうる困難のひとつを示すため、二つの銀行口座の残高を交換したいという例について考えます。
この場合、それぞれの口座にアクセスして残高を調べ、残高同士の差を計算し、その差の分だけ
片方の口座から引き出し、もうひとつの口座に預け入れることになります。これは、次のように
実装できます。
\footnote{\code{deposit}メッセージが負の金額を受け入れるということを利用して\code{exchange}を
簡単にしています(これはこの銀行システムの深刻なバグです！)。}

\begin{scheme}
(define (exchange account1 account2)
  (let ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))
\end{scheme}

\noindent

この手続きは、交換をしようとしているのがひとつのプロセスだけの場合にしかうまくいきません。
ここで、PeterとPaulの二人が両方とも口座\( a \)1, \( a \)2, \( a \)3にアクセスし、
Peterが\( a \)1と\( a \)2を交換する間にPaulが並行に\( a \)1と\( a \)3を交換するという場合に
ついて考えてみましょう。個別口座に対する預け入れと引き出しが(この節の上で示した
\code{make\-/account}手続きのように)直列化されていたとしても、\code{exchange}はやはり不正確な
結果になる可能性があります。例えば、Peterが\( a \)1と\( a \)2の残高の差を求めるとき、Peterが
交換を終える前にPaulが\( a \)1の残高を変更してしまうかもしれません。
\footnote{口座残高が最初10ドル, 20ドル, 30ドルだったとすると、並列の交換を何回行っても、
順番はともかく、残高は10ドル, 20ドル, 30ドルのままでなければなりません。個別口座に対する預け入れを
直列化するだけでは、このことを保証するには十分ではありません。\link{Exercise 3.43}参照。}
正しいふるまいをさせるためには、交換が終わるまでの間ずっと、どちらの口座からもほかの並行アクセスを
排除するように配慮する必要があります。

これを実現する方法のひとつとして、両方の口座のシリアライザを使って\code{exchange}手続き全体を
直列化するというものがあります。そのためには、口座のシリアライザにアクセスする準備をします。
シリアライザを露出させることで、銀行口座オブジェクトのモジュール性を意図的に破っていることに
注意してください。\code{make\-/account}の以下のバージョンは、\link{Section 3.1.1}の元の
バージョンと同じですが、balance変数を守るためにシリアライザが提供されていることと、
そのシリアライザがメッセージパッシングによってエクスポートされていることが違います。

\begin{scheme}
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else 
             (error "Unknown request: MAKE-ACCOUNT"
                    m))))
    dispatch))
\end{scheme}

\noindent
これを使って、預け入れと引き出しを直列化して行うことができます。しかし、前の直列化口座とは
違って、直列化を明示的に管理するのは銀行口座オブジェクトのそれぞれのユーザの責任になっています。
以下はその一例です。
\footnote{\link{Exercise 3.45}では、なぜ預け入れと引き出しを自動的に口座によって直列化されない
ようにしているのかを調査します。}

\begin{scheme}
(define (deposit account amount)
  (let ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))
\end{scheme}

\noindent
このようにシリアライザをエクスポートすることによって柔軟性が得られ、交換プログラムを直列化した
ものを実装できるようになります。単純に、両方の口座のシリアライザによって元の\code{exchange}手続きを
直列化するだけです。

\begin{scheme}
(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 (serializer2 exchange))
     account1
     account2)))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.43}Exercise 3.43:} 
三つの口座の残高が最初は10ドル、20ドル、30ドルで、それから複数のプロセスが実行されて
口座の残高を交換するとする。プロセスが逐次的に実行されるとしたら、並列の残高交換を
何回行ったとしても、口座残高は何らかの順番で10ドル、20ドル、30ドルであるということを論証せよ。
この章の最初のバージョンのaccount-exchangeプログラムを使って残高交換を実装すると
この条件が破られることもあるということを、\link{Figure 3.29}のようなタイミング図を描いて示せ。
一方、この\code{exchange}プログラムを使ったとしても、口座残高の合計は保存されることを論証せよ。
個別口座の取引を直列化しなければこの前提まで破られるということをタイミング図を描いて示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.44}Exercise 3.44:} 
ある口座から別の口座に振込をするという問題について考える。Ben Bitdiddleは、たとえ複数の人々が
複数の口座間で並行にお金の振込をするという場合であっても、以下の手続きによって達成できると
主張している。この手続きでは、例えば上で出てきたバージョンの\code{make\-/account}のように、
預け入れと引き出しの取引を直列化する口座側の何らかのメカニズムを使う。

\begin{scheme}
(define (transfer from-account to-account amount)
  ((from-account 'withdraw) amount)
  ((to-account 'deposit) amount))
\end{scheme}

Louis Reasonerは、これには問題があり、残高交換問題を扱う際に必要となったような、より洗練された
手法を使う必要があると主張する。Louisは正しいだろうか。もし正しくないとしたら、振込問題と
残高交換問題の本質的な違いは何だろうか(\code{from\-/account}の残高は\code{amount}以上あると
考える)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.45}Exercise 3.45:} 
Louis Reasonerは、預け入れと引き出しが自動的に直列化されないようになったことで、
この銀行口座システムが必要以上に複雑になり、またエラーが起こりやすくなったと考えている。
彼は、\code{make\-/account\-/and\-/serializer}が(\code{serialized\-/exchange}のような
手続きで使えるように)シリアライザをエクスポートするだけでなく、その上で
\code{make\-/account}のように口座と預け入れを直列化するためにもそれを使うようにしたほうが
いいと提案した。彼は、口座を次のように再定義することを提案している。

\begin{smallscheme}
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount)) balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount)) balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch))
\end{smallscheme}

すると、預け入れは元の\code{make\-/account}と同じように扱われることになる。

\begin{scheme}
(define (deposit account amount)
  ((account 'deposit) amount))
\end{scheme}

Louisの考えのどこがおかしいのか説明せよ。具体的には、\code{serialized\-/exchange}が
呼ばれたときにどうなるか考えよ。
\end{quote}

\subsubsection*{シリアライザの実装}

シリアライザは、\newterm{mutex}(\jnewterm{ミューテックス})と呼ばれる、より基本的な
同期メカニズムによって実装します。ミューテックスは、\newterm{acquire}(\jnewterm{獲得})と
\newterm{release}(\jnewterm{解放})という二つの演算をサポートするオブジェクトです。
ミューテックスが一度獲得されると、そのミューテックスに対するほかの獲得演算は、その
ミューテックスが解放されるまで続行できません。
\footnote{``mutex''という用語は\newterm{mutual exclusion}(\jnewterm{相互排除})
の短縮形です。並行プロセスがリソースを安全に共有できる仕組みを準備するという一般的な問題は、
相互排除問題と呼ばれます。ここでのミューテックスは、\newterm{semaphore}(\jnewterm{セマフォ})
メカニズムをちょっと変えて単純にしたものです(\link{Exercise 3.47}参照)。セマフォという
メカニズムは、アイントホーフェン技術大学で開発された``THE''マルチプログラミングシステムで
導入されたものです。``THE''という名前は、この大学のオランダ語のイニシャルに由来します
(\link{Dijkstra 1968a})。獲得と解法の演算は、元はPとVと呼ばれていました。これらは鉄道で使われる
腕木信号との関連で、オランダ語の単語\emph{passeren}(渡す)と\emph{vrijgeven}(解放する)から来ています。
ダイクストラの有名な解説(\link{Dijkstra 1968b})は、明確に並行性制御の問題を提示した最初期の
もののひとつで、セマフォを使ってさまざまな並行性の問題を扱う方法を示しています。}
ここでの実装では、それぞれのシリアライザは関連づけられたミューテックスをひとつ持っています。
手続き\code{p}が与えられると、シリアライザはミューテックスを獲得し、\code{p}を実行し、
それからmutexを解放するという手続きを返します。これによって、このシリアライザによって生成された
手続きのうちひとつしか同時に実行されないことを保証します。これこそが、保証しなければならない
直列化の特性です。

\begin{scheme}
(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))
\end{scheme}

\noindent
ミューテックスは、真または偽の値を持つことができる可変オブジェクト(ここでは1要素のリストを使い、
それを\newterm{cell}(\jnewterm{セル})と呼ぶことにします)です。値が偽のときはミューテックスは
獲得可能です。値が真のときはミューテックスは使用中で、このミューテックスを獲得しようとする
プロセスは待たされることになります。

ここでのミューテックスのコンストラクタ\code{make-mutex}は、まずセルの中身を偽に初期化します。
このミューテックスを獲得するには、セルを確認します。もしミューテックスが使用可能であれば、
セルの中身を真にして続行します。そうでなければ、ミューテックスが使用可能になるまで、
ループしながら何度も獲得を試みます。\footnote{ほとんどの時分割OSでは、ミューテックスで
ブロックされたプロセスは、上記のように``ビジーウェイト''で時間を無駄にすることはありません。
そうする代わりに、システムは最初のプロセスの待ち時間の間にほかのプロセスが動くようにスケジュールし、
ブロックされたプロセスはミューテックスが使用可能になったときに起こされることになります。}
ミューテックスを解放するには、セルの中身に偽を設定します。

\begin{scheme}
(define (make-mutex)
  (let ((cell (list false)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire))) ~\textrm{; retry}~
            ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (clear! cell) (set-car! cell false))
\end{scheme}

\noindent
\code{test\-/and\-/set!}は、セルをテストし、テスト結果を返します。それに加えて、もしテストが
偽であれば、\code{test\-/and\-/set!}は偽を返す前にセルの中身に真を設定します。
このふるまいは、次のような手続きとして表現できます。

\begin{scheme}
(define (test-and-set! cell)
  (if (car cell) true (begin (set-car! cell true) false)))
\end{scheme}

\noindent
しかし、この\code{test\-/and\-/set!}の実装は現状では十分ではありません。ここに非常に重要な難しい
問題があります。これは並行性制御がシステムに入り込むことになる根本的なところなのですが、
それは\code{test\-/and\-/set!}演算は\newterm{atomically}(\jnewterm{アトミック}に)
実行されなければいけないということです。これは、あるプロセスがセルをテストし偽だと知ったら、
ほかのプロセスがそのセルをテストするより前に、そのセルの内容は実際に真に設定されるよう
保証しなければならないということを意味します。この保証をしなければ、\link{Figure 3.29}で銀行口座
が失敗したのと同じように、ミューテックスが失敗することになります(\link{Exercise 3.46}参照)。

\code{test\-/and\-/set!}の実際の実装は、システムが並行プロセスをどのように実行するかに
依存します。例えば、並行プロセスを動かすのに、逐次的なプロセッサ上で時分割メカニズムを使い、
各プロセスに短い時間を割り当てて動かしたのちに割り込みをして次のプロセスに処理を移すという
やり方でプロセスを巡回するというやり方があります。この場合、\code{test\-/and\-/set!}はテストと
値の設定の間は時分割を停止するということによってうまくいきます。
\footnote{
シングルプロセッサ向けの\acronym{MIT} Schemeは時分割モデルを使うので、\code{test\-/and\-/set!}は
以下のように実装できます。

\begin{smallscheme}
(define (test-and-set! cell)
  (without-interrupts
   (lambda ()
     (if (car cell)
         true
         (begin (set-car! cell true)
                false)))))
\end{smallscheme}

\noindent
\code{without\-/interrupts}は、引数の手続きが実行されている間、時分割割り込みを無効にするものです。
}
また、マルチプロセスコンピュータはアトミック演算を直接ハードウェアでサポートする命令を提供します。
\footnote{そのような命令には、test\-/and-set, test-and-clear, swap, compare-and-exchange,
load-reserve, store-conditionalなど、さまざまなものがあります。これらの設計は、その機械の
プロセッサ-メモリ間インターフェイスに注意深く合わせたものでなければいけません。
ここで起こる問題のひとつとして、そのような命令を使って二つのプロセスがちょうど同じ時間に
同じリソースを獲得しようとした場合に何が起こるかを決めるということがあります。この場合には、
どちらのプロセスが制御を得るかについての決断をするメカニズムが必要になります。そのような
メカニズムは、\newterm{arbiter}(\jnewterm{アービタ})と呼ばれます。アービタは通常、最終的には
何らかのハードウェアデバイスに行き着きます。残念なことに、アービタの決定に任意の長い時間を
許さない限り、100\%の確率でちゃんと動作する公平なアービタを構築することは物理的に不可能だと
証明可能です。ここでの基本的な現象について最初に触れているのは、アリストテレスの
\textit{天体論}に対する14世紀のフランス人哲学者ジャン・ビュリダンの注釈です。
ビュリダンは、等しく魅力的な二つの食べ物の間に置かれた完全に理性的な犬は、
どちらに最初に行くか決めることができないため飢え死にすると主張しました。}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.46}Exercise 3.46:} 
テキストで示したように、\code{test\-/and\-/set!}を通常の手続きを使って実装し、
演算をアトミックにしようとはしないと仮定する。\link{Figure 3.29}のようなタイミング図を描き、
このミューテックスの実装が、二つのプロセスが同時にミューテックスを獲得するのを許してしまう
という失敗を犯すことになるのはどのような場合か示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.47}Exercise 3.47:} 
(サイズ\( n \)の)セマフォとは、ミューテックスの一般化である。ミューテックスと同じように、
セマフォは獲得と解放の演算をサポートするが、並行に\( n \)プロセスまで獲得できるという意味で
より一般的になっている。それ以上のプロセスがセマフォを獲得しようとすると、解放演算を待つ
必要がある。セマフォの実装を、以下それぞれの条件で行え。

\begin{enumerate}[a]

\item
ミューテックスを使う

\item
アトミックな\code{test\-/and\-/set!}演算を用いる

\end{enumerate}
\end{quote}

\subsubsection*{デッドロック}

シリアライザの実装方法について学んだため、今度は上記の\code{serialized\-/exchange}を使っても
口座の残高交換にはまだ問題があるというところを見ていきます。ここで、Peterが\( a \)1と\( a \)2の
残高を交換しようとしたとき、Paulが並行に\( a \)2と\( a \)1の残高を交換しようとしていると
想像してみましょう。Peterのプロセスは、\( a \)1を保護する直列化手続きに入った時点に達し、
そのすぐ後に、Paulのプロセスが\( a \)2を保護する直列化手続きに入ったとします。
このとき、\( a \)2を保護する直列化手続きからPeterが抜けるまで、Peterは進む(\( a \)2を保護する
直列化手続きに入る)ことができません。同じように、\( a \)1を守る直列化手続きからPeterが抜けるまで、
Paulは進むことができません。どちらのプロセスも、お互いを待って、永遠に立ち往生することになります。
この状況は\newterm{deadlock}(\jnewterm{デッドロック})と呼ばれます。複数の共有リソースに対して
並行なアクセスを提供するシステムでは、常にデッドロックに気をつける必要があります。

この状況でデッドロックを避けるひとつの方法として、それぞれの口座に固有のID番号を振り、
プロセスが手続きに入る際に最小の番号を持つ口座を最初に保護するように
\code{serialized\-/exchange}を書き換えるというものがあります。この手法は交換問題には
うまくいくのですが、さらに洗練されたデッドロック回避テクニックが必要になる状況や、
デッドロックがまったく防げないという状況もあります(\link{Exercise 3.48}、\link{Exercise 3.49}参照)
\footnote{共有リソースに番号を振り、順番に獲得するという一般的なデッドロック回避技術は、
\link{Havender (1968)}によります。デッドロックが防げない状況では、\newterm{deadlock\-/recovery}
(\jnewterm{デッドロック回復})手法が必要となります。そのような手法では、プロセスに
デッドロック状態から``身を引かせて''、再試行させます。デッドロック回復メカニズムは
データベース管理システムで広く使用されています。これについては、\link{Gray and Reuter 1993}で
詳しく取り上げられています。}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.48}Exercise 3.48:} 
上で説明したデッドロック回避手法(口座に番号を振り、各プロセスは小さな番号の口座から獲得を試みる)
によって、残高交換問題でのデッドロックが防げるのはなぜか、詳細に解説せよ。
この考え方を取り入れるように\code{serialized\-/exchange}を書き直せ
(\code{make\-/account}も変更して、各口座が番号つきで作られ、適切なメッセージを送ることによって
その番号にアクセスできるようにする必要がある)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.49}Exercise 3.49:} 
上で説明したデッドロック回避メカニズムがうまくいかない場合のシナリオを示せ
(ヒント:残高交換問題では、各プロセスは自分がどの口座にアクセスする必要があるか事前に知っている。
プロセスが、どの追加リソースが必要になるかわからない状態で共有リソースにアクセスする必要が
あるという状況を考えよ)。

\end{quote}

\subsubsection*{並行性、時間、通信}

ここまで、並行システムのプログラミングでは、異なるプロセスが共有状態にアクセスする際に
イベントの順番を制御することが必要となるということを見てきました。さらに、シリアライザを
うまく使うことによってその制御を行う方法についても見ました。しかし、並行性の問題はこれよりも
深いところにあります。根本的な観点から見ると、``共有状態''というものが何を意味するかが
常にはっきりしているとは限らないからです。

\code{test\-/and\-/set!}のようなメカニズムは、任意の時間にグローバルな共有フラグを調べることを
プロセスに要求します。これは、現代の高速なプロセッサで実装するには問題が多く、効率がよくありません。
そのようなプロセッサでは、パイプラインやキャッシュメモリといった最適化技術のために、
すべての瞬間にメモリの内容が一貫した状態にあるとは限らないからです。そのため、最近の
マルチプロセスシステムでは、シリアライザという枠組みは新しい並行性制御法に
取って代わられつつあります。
\footnote{このような直列化の代替手段のひとつとして、
\newterm{barrier synchronization}(\jnewterm{バリア同期})と呼ばれるものがあります。
プログラマは並行プロセスを好き勝手に実行させますが、ある一定の同期ポイント(``バリア'')を
設定しておき、すべてのプロセスがそのバリアに着くまで先に進めないようにするというものです。
現代のプロセッサは、一貫性が必要となる部分にプログラマが同期ポイントを設定できるよう、
機械語命令を提供しています。例えば、\acronym{PowerPC}はこの目的のために\acronym{SYNC}(同期)と
\acronym{EIEIO}(Enforced In\-/order Execution of Input/Output)と呼ばれる二つの命令を含んでいます。}

共有状態の難しい側面は、大きな分散システムでも問題になります。例えば、分散銀行システムで、
個別の支店が残高のローカルな値を保持していて、これらの値をほかの支店で保持されているものと
定期的に比較するという場合について想像してみましょう。そのようなシステムでは、``口座残高''の値は
同期直後以外では不確定になります。もしPeterが、Paulとの共同口座にお金を預けたとしたら、
口座残高が変わったのはいつということになるでしょうか。地域支店が残高を変更したときでしょうか、
それとも同期の後でしょうか。また、もしPaulが別の支店から口座にアクセスしたとすると、
ふるまいが``正しい''といえるようなものにするためには、銀行システムにどのような制約を加えるのが
妥当でしょうか。正しさについて考えるうえで意味があるのは、PeterとPaulによって個別に観測される
ふるまいと、同期直後の口座の``状態''のみです。``本当の''口座残高がいくらかとか、同期の間の
イベントの順番というものは、重要でなかったり、意味がなかったりするかもしれません。
\footnote{これは奇妙な見方のように思えるかもしれません。しかし、このように動くシステムは存在します。
例えば、クレジットカードの口座に対する国際課金は、通常は国ごとに精算され、別々の国で
行われた課金は定期的に調整されます。このため、口座残高が国によって異なるということがありえます。}

ここでの基本的な現象は、異なるプロセスの同期や、共有状態の設定や、イベントの順番を割り当てるといった
ことには、プロセス間の通信が必要となるということです。本質的に、並行性制御における時間という
概念は、通信と密接に結びついている必要があります。
\footnote{分散システムでは、この視点は\link{Lamport (1978)}によって深く研究されています。
彼は、通信によって``グローバル時計''を作り、それを使って分散システムでイベントの順番を確立する
方法を示しました。}
面白いことに、相対論でも時間と通信との間には似たようなつながりがあります。相対論では、
光速(イベントの同期に使える最も高速な信号)は、時間と空間に関する基本的な定数です。
計算モデルの中での時間と状態を扱う際に遭遇する複雑性は、実際のところ、物理的宇宙の
基本的な複雑性を反映しているのかもしれません。

\section{ストリーム}
\label{Section 3.5}

ここまででは、モデリングの道具としての代入について理解し、また代入が引き起こす複雑な問題に
対して評価してきました。ここからは、別の取り組み方をすることによってこれらの問題のいくつかを
回避することはできなかったのかということについて考えていきます。この節では、状態をモデル化する
別のアプローチについて検討します。このアプローチは、\newterm{streams}(\jnewterm{ストリーム})と
呼ばれるデータ構造に基づくものです。ここから先で見ていくように、状態をモデル化する際に生じる
複雑性の一部をストリームによって軽減することができます。

一歩下がって、この複雑性というものがどこから来ているのか再検討してみましょう。現実世界の
現象をモデル化しようとする中で、見たところもっともな決定をいくつかしてきました。
局所状態を持つ現実世界のオブジェクトを局所変数を持つ計算オブジェクトによってモデル化し、
現実世界の時間の変化をコンピュータ上の時間変化と同一視し、コンピュータ上のモデル
オブジェクトの状態の経時変化はモデルオブジェクトの局所変数に対する代入として実装しました。

ほかのアプローチはあるでしょうか。モデル対象の世界での時間とコンピュータ上の時間を同一視する
ことは避けられないのでしょうか。変化する世界での現象をモデル化するには、時間とともに
モデルを変化させるしかないのでしょうか。この問題について、数学関数を使って考えてみましょう。
量\( x \)の時間によって変化するふるまいは、時間の関数\( x(t) \)として記述できます。
もし時刻ごとの\( x \)に注目するなら、それを変化する量としてとらえることになります。
しかし、全時間を通しての値の履歴に注目するなら、変化については重要視しないことになります。
関数そのものは変化しないことになるからです。
\footnote{物理学では、運動について考える手段として粒子の``世界線''を導入することによって、
この見方を採用することがあります。また、\link{Section 2.2.3}では、信号処理システムに関して
考えるうえではこれが自然な方法であると述べました。ストリームを信号処理に適用することについては、
\link{Section 3.5.3}で検討します。}

もし時間を離散ステップで測るのであれば、時間関数は(無限かもしれない)列としてモデル化できます。
この節では、モデル化対象システムの時間履歴を表現する列によって変化をモデル化する方法について
見ていきます。これを達成するために、\newterm{stream}(\jnewterm{ストリーム})と呼ばれる新しい
データ構造を導入します。抽象的な視点から見ると、ストリームはただの列です。しかし、ストリームを
(\link{Section 2.2.1}のように)素直にリストとして実装したものでは、ストリーム処理の本来の力が
見えてきません。その代わりに、ここでは\newterm{delayed evaluation}(\jnewterm{遅延評価})という
テクニックを導入します。遅延評価を使うことによって、非常に大きな(無限でもありうる)列を
ストリームして表現することが可能になります。

ストリーム処理によって、状態のあるシステムを代入や可変データを使わずにモデル化することが
できるようになります。このことは、論理的にも実用的にも大きな意味があります。代入の導入に
つきもののマイナス点を避けてモデルを構築できるからです。一方、ストリームという枠組みには
それはそれで難しいところがあります。どちらのモデル化テクニックが、よりモジュール化され、
よりメンテナンスしやすいシステムの実現につながるかということは、未解決の問題です。

\subsection{ストリーム＝遅延リスト}
\label{Section 3.5.1}

\link{Section 2.2.3}で見てきたように、列はプログラムモジュールを組み合わせるための標準
インターフェイスとして使うことができます。また、\code{map}, \code{filter}, \code{accumulate}
のような列操作の強力な抽象化について定式化してきました。これらは、簡潔でエレガントに広い範囲の
演算を表すことができるものです。

残念ながら、列をリストとして表すと、エレガントさのために計算に必要な時間と空間の効率性を
大幅に犠牲にすることになります。列の操作をリストの変形として表すと、プログラムは処理の
各ステップで(非常に大きいかもしれない)データ構造を構築し、コピーしないといけないことに
なります。

このことを確認するために、ある区間のすべての素数の和を求めるプログラム二つを比較してみましょう。
一つ目のプログラムは、標準的な繰り返しスタイルで書かれています。
\footnote{(\link{Section 1.2.6}で出てきたような)素数性をテストする述語\code{prime?}は
すでにあるとします。}

\begin{scheme}
(define (sum-primes a b)
  (define (iter count accum)
    (cond ((> count b) accum)
          ((prime? count) 
             (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
\end{scheme}

\noindent
二つ目のプログラムは、同じ計算を\link{Section 2.2.3}の列演算を使って行います。

\begin{scheme}
(define (sum-primes a b)
  (accumulate +
              0
              (filter prime? 
                      (enumerate-interval a b))))
\end{scheme}

\noindent
計算を実行する際に、一つ目のプログラムは、蓄積している和だけ格納すれば十分です。
それに対して、二つ目のプログラムのフィルタは、\code{enumerate\-/interval}が区間内の
数の完全なリストを構築し終わるまで、まったくテストを行うことができません。フィルタは
別のリストを生成し、それが\code{accumulate}に渡され、その後に和に畳み込まれます。
そのような大きな中間ストレージは一つ目のプログラムでは必要ありません。一つ目のプログラムは、
区間を順次列挙し、素数を生成しながら和に足していくと考えることができます。

リストを使うことによる非効率性は、次のような例で痛切に明らかになります。10,000から1,000,000の
区間に含まれる二番目の素数を計算するのに、列のパラダイムを使って、次の式を評価することによって
行うような場合です。

\begin{scheme}
(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000))))
\end{scheme}

\noindent
この式は、確かに二番目の素数を見つけます。しかし、計算のオーバーヘッドはものすごい
ものになります。約100万の整数のリストを構築し、各要素の素数性をテストしてこのリストを
フィルタし、それからほとんどすべての結果を無視することになってしまいます。より伝統的な
プログラミングスタイルでは、数え上げとフィルタをひとつにまとめ、二つ目の素数に到達した
時点で停止することになるでしょう。

ストリームは、列をリストとして操作するコストを発生させることなしに列操作を使えるように
する巧妙な考え方でえす。ストリームを使うと、二つの世界のいいとこ取りができます。
列操作としてプログラムをエレガントに定式化しながら、順次計算の効率性も得ることが
できるのです。基本的な考え方は、ストリームを部分的しか構築しないで、構築した一部を
そのストリームを消費するプログラムに渡すというものです。消費プログラムがストリームの
まだ構築していない部分にアクセスしようとしたら、ストリームは自動的に必要な部分だけを
構築し、ストリーム全体が存在するという幻想を維持します。言い換えると、プログラムは
あたかも完全な列を扱っているかのように書くのですが、ストリームの実装は、ストリームの構築と
ストリームの使用が自動的かつ透過的に組み合わせられるように設計します。

表面的には、ストリームはただのリストで、それを走査する手続きの名前が違うだけです。
ストリームにはコンストラクタ\code{cons\-/stream}と二つのセレクタ\code{stream\-/car},
\code{stream\-/cdr}があり、セレクタは以下の制約を満たしています。

\begin{example}
(stream-car (cons-stream x y)) = x
(stream-cdr (cons-stream x y)) = y
\end{example}

\noindent
さらに、識別可能なオブジェクト\code{the\-/empty\-/stream}があります。これは決して
\code{cons\-/stream}演算の結果になることがなく、述語\code{stream\-/null?}によって識別可能です。
\footnote{\acronym{MIT}の実装では、\code{the\-/empty\-/stream}は空のリスト\code{'()}と同じもので、
\code{stream\-/null?}は\code{null?}と同じものとなっています。}
これによって、リストを作ったり使ったりするのとまったく同じようにストリームを作ったり使ったりする
ことができ、列という形になっている集約データを表現することができます。具体的には、
\link{Chapter 2}で学んだ\code{list\-/ref}, \code{map}, \code{for\-/each}のようなリスト演算について、
ストリーム版を構築することが可能です。
\footnote{ここは気になるところだと思います。ストリームとリストに対してこのような似通った手続きを
定義しているということは、何か隠れた抽象化を見逃しているということです。残念ながら、この抽象化を
利用するためには、評価プロセスに対する細かい制御が必要なのですが、それは現時点ではまだできません。
この点については、\link{Section 3.5.4}の末尾で詳しく検討します。\link{Section 4.2}では、リストと
ストリームを統合する枠組みを開発します。}

\begin{scheme}
(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))
(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))
(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
\end{scheme}

\noindent
\code{stream\-/for\-/each}はストリームを見るのに便利です。

\begin{scheme}
(define (display-stream s) 
  (stream-for-each display-line s))
(define (display-line x) (newline) (display x))
\end{scheme}

\noindent
ストリームが自動的かつ透過的にストリームの構築と使用を組み合わせるよう実装するために、
ストリームの\code{cdr}は、ストリームが\code{cons\-/stream}によって構築されたときでなく、
\code{stream\-/cdr}手続きによってアクセスされたときに評価されるようにします。
ここでの実装の選択は、\link{Section 2.1.2}で有理数について検討したときと似ています。
有理数を実装する際には、分母と分子を既約にするのを構築時にするか選択時にするかを選ぶことが
できるということを見てきました。どちらの有理数の実装も結果として同じデータ抽象化になりますが、
どちらを選ぶかによって効率に影響があります。ストリームと通常のリストの間にも、似たような関係が
あります。データ抽象化としては、ストリームはリストと同じです。違うのは要素が評価される
タイミングです。通常のリストでは、\code{car}も\code{cdr}も構築時に評価されます。ストリームでは、
\code{cdr}は選択時に評価されます。

ここでは、\code{delay}という特殊形式に基づいてストリームを実装します。
\code{(delay <\var{exp}>)}を評価しても、式\( \langle \)\var{exp}\( \kern0.08em\rangle \)は
評価されず、代わりにいわゆる\newterm{delayed object}(\jnewterm{遅延オブジェクト})を返します。
これは、ある将来の時点で\( \langle \)\var{exp}\( \kern0.08em\rangle \)を評価するという``約束''
と考えることができます。\code{delay}と対になるものとして、\code{force}という手続きがあります。
これは、遅延オブジェクトを引数として取り、評価を実行するというものです。つまり、\code{delay}に
約束の遂行を迫るということになります。\code{delay}と\code{force}の実装方法については後ほど
見ていくとして、まずはこれらを使ってストリームを構築してみましょう。

\noindent
\code{cons\-/stream}は、次の形が

\begin{scheme}
(cons-stream ~\( \dark \langle \)~~\var{\dark a}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark b}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
以下と等価になるよう定義された特殊形式です。

\begin{scheme}
(cons ~\( \dark \langle \)~~\var{\dark a}~~\( \dark \rangle \)~ (delay ~\( \dark \langle \)~~\var{\dark b}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
つまり、ストリームを構築するのにはペアを使うということです。しかし、ストリームの残りの値を
\code{cdr}に入れる代わりに、要求されることがあれば残りを計算するという約束を入れることにします。
これで、\code{stream\-/car}と\code{stream\-/cdr}が次のように手続きとして定義できるように
なります。

\begin{scheme}
(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))
\end{scheme}

\noindent
\code{stream\-/car}はペアの\code{car}を選択します。\code{stream\-/cdr}はペアの\code{cdr}を選択し、
そこに置かれた遅延表現を評価し、ストリームの残りを取得します。
\footnote{\code{stream\-/car}と\code{stream\-/cdr}は手続きとして定義できるのですが、
\code{cons\-/stream}は特殊形式である必要があります。\code{cons\-/stream}が手続きだったとすると、
私たちの評価モデルによると、\code{(cons\-/stream <\var{a}> <\var{b}>)}を評価すると自動的に
\( \langle \)\var{b}\( \kern0.08em\rangle \)が評価されることになります。これは避けたいところです。
同じ理由から、\code{delay}も特殊形式でなければなりません。しかし、\code{force}は通常の手続きでも
大丈夫です。}

\subsubsection*{ストリーム実装の動作}

この実装のふるまいを見るために、上で見た``とんでもない''素数計算をストリームによって
定式化し直したものを解析してみましょう。

\begin{scheme}
(stream-car
 (stream-cdr
  (stream-filter prime? 
                 (stream-enumerate-interval 
                  10000 1000000))))
\end{scheme}

\noindent
これが実際に効率的に動くということを見ていきます。

まず、\code{stream\-/enumerate\-/interval}を10,000と1,000,000という引数で呼び出します。
\code{stream\-/enumerate\-/interval}は、\code{enumerate\-/interval} (\link{Section 2.2.3})の
ストリーム版です。

\begin{scheme}
(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))
\end{scheme}

\noindent
つまり、\code{stream\-/enumerate\-/interval}に返される結果は、\code{cons\-/stream}によって作られた
次のようなものになります。
\footnote{ここで示した数値は、実際には遅延オブジェクトの中にはありません。実際にあるのは
元の式で、環境の中で変数が適切な数値に束縛されています。例えば、\code{10001}と示した場所には
実際には\code{(+ low 1)}があり、その\code{low}が10,000に束縛されています。}

\begin{scheme}
(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
\end{scheme}

\noindent
つまり、\code{stream\-/enumerate\-/interval}はストリームを返すのですが、そのストリームの
\code{car}には10,000が入っていて、\code{cdr}には、要求されたら区間の数え上げを続けるという
約束が入っていることになります。次に、このストリームにフィルタをかけて素数を残します。
それには、ストリーム版の\code{filter}手続き(\link{Section 2.2.3})を使います。

\begin{scheme}
(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter 
                       pred
                       (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
\end{scheme}

\noindent
\code{stream\-/filter}は、ストリームの\code{stream\-/car}(ペアの\code{car}、つまり10,000)を
テストします。これは素数ではないので、\code{stream\-/filter}は入力ストリームの\code{stream\-/cdr}を
調べます。\code{stream\-/cdr}を呼び出すと、遅延化された\code{stream\-/enumerate\-/interval}の
評価を強制します。評価すると、次のものが返ってきます。

\begin{scheme}
(cons 10001
      (delay (stream-enumerate-interval 10002 1000000)))
\end{scheme}

\noindent
\code{stream\-/filter}は、今度はこのストリームの\code{stream\-/car}、つまり10,001を見て、
これも素数ではないので、さらに\code{stream\-/cdr}を強制します。これを
\code{stream\-/enumerate\-/interval}が素数10,007を作り出すまで繰り返します。
10,007が返ってくると、\code{stream\-/filter}は定義通りに次のものを返します。

\begin{scheme}
(cons-stream (stream-car stream)
             (stream-filter pred (stream-cdr stream)))
\end{scheme}

\noindent
この場合は、以下のようになります。

\begin{scheme}
(cons 10007
      (delay (stream-filter
              prime?
              (cons 10008
                    (delay (stream-enumerate-interval
                            10009
                            1000000))))))
\end{scheme}

\noindent
この結果が、元の式の\code{stream\-/cdr}に渡されることになります。これによって、遅延化された
\code{stream\-/filter}が強制評価され、\code{stream\-/filter}は次の素数である10,009が見つかるまで
遅延化された\code{stream\-/enumerate\-/interval}の強制評価を続けます。
最終的に、元の式の\code{stream\-/car}に渡される結果は次のようになります。

\begin{scheme}
(cons 10009
      (delay (stream-filter
              prime?
              (cons 10010
                    (delay (stream-enumerate-interval
                            10011
                            1000000))))))
\end{scheme}

\noindent
\code{stream\-/car}は10,009を返し、これで計算が完了します。二つ目の素数を見つけるために
必要なだけの整数のみがテストされ、素数フィルタに与えるのに必要な分だけの区間だけが列挙
されています。

一般的に、遅延評価は``要求駆動''プログラミングと考えることができます。要求駆動プログラミングでは、
ストリーム処理の各段階は、次の段階を満足させるのに十分なだけしか動かされません。ここまでで
やったことは、計算の中で起こることの実際の順番と、手続きの見かけ上の構造とを切り離すという
ことです。手続きを書くときには、ストリームが``すべて同時に''存在するかのように考えて書くのですが、
実際には、計算は伝統的なプログラミングスタイルの場合と同じように漸進的に実行されることになります。

\subsubsection*{\code{delay}と\code{force}の実装}

\code{delay}と\code{force}はミステリアスな演算に見えるかもしれませんが、実際のところ、
実装はとても単純です。\code{delay}は、後で要求されたときになって評価するように、
式をパッケージする必要があります。これは、単純に式を手続きの本体として扱うことによって
実現できます。\code{delay}は、次のようなシンタックスシュガーによって

\begin{scheme}
(delay ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
以下のものを表すような特殊形式として実装できます。

\begin{scheme}
(lambda () ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
\code{force}は、\code{delay}によって生成された(引数なしの)手続きを呼び出すだけです。
ですので、\code{force}は次のような手続きとして実装できます。

\begin{scheme}
(define (force delayed-object) (delayed-object))
\end{scheme}

\noindent
\code{delay}と\code{force}が仕様通りに動くようにするだけなら、この実装で十分です。しかし、
重要な最適化をひとつ取り入れる余地があります。多くの応用では、同じ遅延オブジェクトを
何回も強制評価するはめになります。これは、ストリームを使った再帰プログラムで、深刻な
非効率性の原因となることがあります(\link{Exercise 3.57}参照)。これを解決するには、遅延
オブジェクトが最初に強制評価される際に計算した値を格納するように遅延オブジェクトを構築します。
二回目以降の強制評価では、計算を繰り返すことはしないで、格納した値をそのまま返します。
つまり、\link{Exercise 3.27}で説明したものと同じような、特殊目的のメモ化手続きとして
\code{delay}を実装するということです。これを実現する方法のひとつとして、(引数なしの)
手続きをひとつ引数として取り、その手続きのメモ化バージョンを返す手続きを使うというものが
あります。以下にその手続きを示します。メモ化手続きが一回目に実行されると、計算結果を
格納します。二回目以降の評価では、その結果をそのまま返します。

\begin{scheme}
(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
\end{scheme}

\noindent
そして、\code{(delay <\var{exp}>)}が以下と等価になるように\code{delay}を定義します。

\begin{scheme}
(memo-proc (lambda () ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
\code{force}は以前の定義そのままです。
\footnote{ストリームの実装は、この節で説明したもの以外にもいろいろ考えられます。
ストリームを実用的なものにする鍵となっている遅延評価は、Algol 60では
\newterm{call\-/by\-/name}(\jnewterm{名前呼び})という引数渡し手法にもともと備わっていました。
このメカニズムを使ってストリームを実装するという考え方は、\link{Landin (1965)}で初めて記述
されたものです。ストリームの遅延評価は、\link{Friedman and Wise (1976)}によってLispに導入されました。
この実装では、\code{cons}は常に引数の評価を遅延させるようになっていて、そのためリストは自動的に
ストリームとしてふるまうようになっていました。メモ化による最適化は、\newterm{call\-/by\-/need}
(\jnewterm{必要呼び})としても知られています。Alogolコミュニティであれば、ここでの元々の
遅延オブジェクトは\newterm{call\-/by\-/name thunks}(\jnewterm{名前呼びサンク})と呼び、
最適化されたバージョンは\newterm{call\-/by\-/need thunks}(\jnewterm{必要呼びサンク})と呼ぶところ
です。}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.50}Exercise 3.50:} 
以下の定義を完成させよ。これは、\link{Section 2.2.1}\link{Footnote 12}の\code{map}と同じように、
複数の引数を取る手続きを使えるよう\code{stream\-/map}を一般化するものである。

\begin{scheme}
(define (stream-map proc . argstreams)
  (if (~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ (car argstreams))
      the-empty-stream
      (~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
       (apply proc (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ argstreams))
       (apply stream-map
              (cons proc (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ argstreams))))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.51}Exercise 3.51:} 
遅延評価についてより詳しく観察するために、引数を表示してからそのまま返すだけの以下の手続きを
使うことにする。

\begin{scheme}
(define (show x)
  (display-line x)
  x)
\end{scheme}

以下のような一連の式を評価させると、インタプリタはどのような表示をするだろうか。

\footnote{\link{Exercise 3.51}や\link{Exercise 3.52}のような課題は、
\code{delay}の動作についてちゃんと理解しているかどうかを確認できるという意味で、価値のあるものです。
一方、遅延評価と表示を混在させると、頭が混乱しやすくなります。代入まで入ってくると、ますます
ひどくなります。コンピュータ言語の授業では、この節に出てきたような試験問題で講師が学生を苦しめる
ということが、伝統的によく行われてきています。言うまでもないことですが、そのような難しいところに
依存するようなプログラムを書くというのは、醜いプログラミングスタイルです。ストリーム処理の力の
一部は、プログラムの中で実際に出来事が起こる順番を考えなくていいというところから来ています。
残念ながら、代入があると、このような考え方はできません。代入を使うときには、時間と変化について
考えることが避けられないからです。}

\begin{scheme}
(define x 
  (stream-map show 
              (stream-enumerate-interval 0 10)))
(stream-ref x 5)
(stream-ref x 7)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.52}Exercise 3.52:} 
以下の一連の式について考える。

\begin{scheme}
(define sum 0)
(define (accum x) (set! sum (+ x sum)) sum)
(define seq 
  (stream-map accum
              (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z 
  (stream-filter (lambda (x) (= (remainder x 5) 0))
                 seq))
(stream-ref y 7)
(display-stream z)
\end{scheme}

上記の式をそれぞれ評価した後、\code{sum}の値はいくつになるだろうか。式\code{stream\-/ref}と
\code{display\-/stream}を評価したとき、どのような応答が表示されるだろうか。
\code{(delay <\var{exp}>)}を単純に\code{(lambda () <\var{exp}>)}として実装し、
\code{memo\-/proc}によって提供される最適化を使用しない場合、これらの応答は異なるものになるだろうか。
説明せよ。
\end{quote}

\subsection{無限ストリーム}
\label{Section 3.5.2}

ここまで、実際にはアクセスする必要のある分しかストリームの計算をしていないのに、ストリームを
完全な実体として扱っているという幻想を維持する方法について見てきました。このテクニックを使うと、
列が非常に長いものでも、効率的にストリームとして表現することができます。さらに特筆すべきこととして、
ストリームを使うと無限に長い列を表すこともできます。例えば、以下に示す正の整数のストリームの定義に
ついて考えてみましょう。

\begin{scheme}
(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))
(define integers (integers-starting-from 1))
\end{scheme}

\noindent
これは筋が通っています。\code{integers}は、\code{car}が1で、\code{cdr}が
``2から始まる整数を生成する約束''というペアになります。
これは無限に長いストリームですが、しかしある時間のうちに調べられるのはそのその有限な一部だけです。
そのため、プログラムからは無限ストリーム全体が存在するわけではないということはわかりません。

\code{integers}を使って、別の無限のストリームを定義することができます。例えば、7で割り切れない
整数のストリームは以下のようになります。

\begin{scheme}
(define (divisible? x y) (= (remainder x y) 0))
(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
                 integers))
\end{scheme}

\noindent
こうすると、このストリームの要素にアクセスするだけで、7で割り切れない整数を探すことができます。

\begin{scheme}
(stream-ref no-sevens 100)
~\textit{117}~
\end{scheme}

\noindent
\code{integers}と同じようなやり方で、フィボナッチ数の無限ストリームを定義することもできます。

\begin{scheme}
(define (fibgen a b) (cons-stream a (fibgen b (+ a b))))
(define fibs (fibgen 0 1))
\end{scheme}

\noindent
\code{fibs}は、\code{car}が0で、\code{cdr}が``\code{(fibgen 1 1)}を評価する約束''というペアです。
この遅延化した\code{(fibgen 1 1)}を評価すると、\code{car}が1で、\code{cdr}が
``\code{(fibgen 1 2)}を評価する約束''というペアを生成し\( \dots \)という繰り返しになります。

もっと刺激的な無限ストリームについても見てみましょう。\code{no\-/sevens}の例を一般化すると、
\newterm{sieve of Eratosthenes}(\jnewterm{エラトステネスのふるい})という手法によって
素数の無限ストリームを構築することができます。
\footnote{エラトステネスは紀元前3世紀のアレキサンドリア学派のギリシャ人哲学者で、地球の外周を
最初に正しく推測したことで有名です。彼は、夏至の日の正午の影を観察することによってこれを
計算しました。エラトステネスのふるいは非常に古いものですが、最近まで巨大素数を見つける
最も強力なツールであった特殊目的ハードウェアによる``ふるい''は、このエラトステネスのふるいを
基礎としています。しかし、70年代からは、これらの手法は\link{Section 1.2.6}で検討したような
確率的な技術の発展によって取って代わられています。}
まず、最初の素数である2から始まる整数列を考えます。残りの素数を得るには、まず整数列の残りから
2の倍数をフィルタリングします。こうすると、次の素数である3から始まるストリームができます。
次に、このストリームの残りから3の倍数をフィルタリングします。こうすると、次の素数である
5から始まるストリームができます。これをずっと続けていきます。これは、言い換えると次のような
ふるいのプロセスで素数列を作るということになります。あるストリーム\code{S}について、
\code{S}の最初の要素を最初の要素とし、\code{S}の残りから\code{S}の最初の要素の倍数をフィルタリング
した結果をふるいにかけたものを残りの要素とするようなストリームを作ることによって、
\code{S}にふるいをかけるということです。このプロセスは、ストリーム演算によってすぐに記述できます。

\begin{scheme}
(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))))
(define primes (sieve (integers-starting-from 2)))
\end{scheme}

\noindent
これで、質問をするだけで特定の素数を得ることができるようになります。

\begin{scheme}
(stream-ref primes 50)
~\textit{233}~
\end{scheme}

\noindent

\code{sieve}によって作られる信号処理システムに注目すると面白いことがわかります。このシステムを
``ヘンダーソン図''として\link{Figure 3.31}に示します。
\footnote{私たちはPeter Hendersonにちなんでこれらの図をヘンダーソン図と呼んでいます。ストリーム処理に
ついて考える方法のひとつとして、この種の図を初めて見せてくれたのがHendersonだったからです。
各実践は、転送される値のストリームを表しています。\code{car}から\code{cons}と\code{filter}に
伸びる点線は、これがストリームではなく、単一の値であることを示しています。}
入力ストリームは``un\code{cons}er''に流し込まれ、そこでストリームの最初の要素がストリームの
残りから切り離されます。最初の要素を使って整除性フィルタが構築され、ストリームの残りがその
フィルタを通ります。このフィルタの出力は、また別のふるい箱に流されます。そして、元の最初の
要素が内部のふるいの出力と\code{cons}され、それが出力ストリームとなります。つまり、無限なのは
ストリームだけではなく、信号処理器も無限だということです。ふるいは中にふるいを持っているからです。

\begin{figure}[tb]
\phantomsection\label{Figure 3.31}
\centering
\begin{comment}
\heading{Figure 3.31:} The prime sieve viewed as a signal-processing system.

\begin{example}
  +---------------------------------------------------------------+
  | sieve                                                         |
  |                                                               |
  |        __/|                                        |\__       |
  |     __/car|........................................|   \__    |
  |   _/      |           :                            |      \_  |
----><_       |           V                            |  cons _>---->
  |    \__    |    +------------+    +------------+    |    __/   |
  |       \cdr|--->| filter:    |    | sieve      |--->| __/      |
  |          \|    |            |--->|            |    |/         |
  |                | not        |    |            |               |
  |                | divisible? |    |            |               |
  |                +------------+    +------------+               |
  +---------------------------------------------------------------+
\end{example}
\end{comment}
\includegraphics[width=111mm]{fig/chap3/Fig3.31.pdf}
\par\bigskip
\noindent
\heading{Figure 3.31:} 信号処理システムとして見た素数のふるい
\end{figure}

\subsubsection*{ストリームの暗黙定義}

上記の\code{integers}と\code{fibs}のストリームは、明示的にストリーム要素をひとつずつ計算する
``生成''手続きを規定することによって定義されていました。ストリームを規定する別のやり方として、
遅延評価を利用して暗黙的にストリームを定義するというものがあります。例えば、次の式は
\code{ones}というストリームを1の無限ストリームとして定義します。

\begin{scheme}
(define ones (cons-stream 1 ones))
\end{scheme}

\noindent
これは再帰手続きの定義と同じような仕組みです。\code{ones}は、\code{car}が1で、\code{cdr}が
\code{ones}を評価する約束というペアになります。\code{cdr}を評価すると、1と、\code{ones}を
評価する約束がまた得られます。この繰り返しです。

演算によってストリームを操作すると、もっと面白いことができます。例えば、\code{add\-/streams}という、
二つの与えられたストリームの要素ごとの和を生成する演算について考えます。
\footnote{これは、\link{Exercise 3.50}で出てきた一般化されたバージョンの\code{stream\-/map}を
利用しています。}

\begin{scheme}
(define (add-streams s1 s2) (stream-map + s1 s2))
\end{scheme}

\noindent
こうすると、整数列を次のように定義することができます。

\begin{scheme}
(define integers 
  (cons-stream 1 (add-streams ones integers)))
\end{scheme}

\noindent
これは、一つ目の要素が1で、残りが\code{ones}と\code{integers}の和であるようなものとして、
\code{integers}を定義するものです。つまり、\code{integers}の二つ目の要素は、1 \code{+}
\code{integers}の一つ目の要素で、2になります。\code{integers}の三つ目の要素は、1 \code{+}
\code{integers}の二つ目の要素で、3になります。この繰り返しです。この定義がうまくいくのは、
どの時点でも十分な\code{integers}ストリームが生成されているので、それを定義にフィードバックする
ことによって次の整数が生成できるからです。

フィボナッチ数も同じスタイルで定義できます。
%%%

\begin{scheme}
(define fibs 
  (cons-stream
   0
   (cons-stream 1 (add-streams (stream-cdr fibs) fibs))))
\end{scheme}

\noindent
この定義は\code{fibs}は0と1で始まるストリームであり残りのストリームは\code{fibs}を
自身に1つずらして足すことで生成することができると述べています。

\begin{scheme}
      1  1  2  3  5  8   13  21  ~\( \dots \)~  =  ~\code{(stream\-/cdr fibs)}~
      0  1  1  2  3  5   8   13  ~\( \dots \)~  =  ~\code{fibs}~
0  1  1  2  3  5  8  13  21  34  ~\( \dots \)~  =  ~\code{fibs}~
\end{scheme}

\noindent
\code{scale\-/stream}はまた別の、そのようなストリーム定義を形成するのに便利な手続きです。
これはストリームの各要素に与えられた定数を掛けます。

\begin{scheme}
(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor))
              stream))
\end{scheme}

\noindent
例として

\begin{scheme}
(define double (cons-stream 1 (scale-stream double 2)))
\end{scheme}

\noindent
は2の冪乗のストリームを生成します：1, 2, 4, 8, 16, 32, \( \dots \)



素数ストリームの代替定義は整数で始まり、それらの素数性をテストすることでフィルタリング
することでも与えられます。最初の素数、2を開始に必要とします。

\begin{scheme}
(define primes
  (cons-stream
   2
   (stream-filter prime? (integers-starting-from 3))))
\end{scheme}

\noindent
この定義はあまり見かけほど簡単ではありません。\( n \)が(任意の整数でなく)\( \sqrt{n} \)以下の
素数で割り切れるかどうかをチェックすることにより数\( n \)が素数であるかを決めるためです。

\begin{scheme}
(define (prime? n)
  (define (iter ps)
    (cond ((> (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))
\end{scheme}

\noindent
これは再帰定義であり、\code{primes}が\code{primes}を用いる\code{prime?}述語を用いて定義されています。
この手続きがうまく行く訳は、任意の時点で、十分な\code{primes}ストリームが生成されており、
次にチェックするのに必要な数の素数性をテストできるからです。全ての\( n \)に対して素数性を
テストします。例え\( n \)が素数でなくても(この場合、それを割り切れる素数が既に生成されています。),
例え\( n \)が素数(この場合、素数が既に生成されています---言い換えれば、\( \sqrt{n} \)より大きく\( n \)未満の
素数)であってもです。\footnote{この最後の点はとても微妙で\( p_{n+1} \le p_n^2 \)という事実に依存して
います。(ここで\( p_k \)は\( k \)番目の素数を示します)。このような予測を立証するのはとても難しいです。
ユークリッドによる太古の証明による、ある素数が無限に存在することが\( p_{n+1} \le p_1 p_2 \ldots p_n + 1 \)を
示しています。そして実質的にはより良い結果が証明されることは1851年までありませんでした。
この年、ロシア人の数学者P. L. Chebyshev(パフヌティ・チェビシェフ)は全ての\( n \)に対し\( p_{n+1} \le 2p_n \)で
あることを証明しました。最初に1845年に予想されたこの結果は\newterm{Bertrand's hypothesis}(\jnewterm{ベルトランの
仮説})として知られています。証明は\link{Hardy and Wright 1960}の節22.3に見つかります。}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.53}Exercise 3.53:} 
プログラムを実行すること無しに以下により定義されたストリームの要素について
説明せよ。

\begin{scheme}
(define s (cons-stream 1 (add-streams s s)))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.54}Exercise 3.54:} 
\code{add\-/streams}と類似の手続き\code{mul\-/streams}を定義せよ。これは2つの入力ストリームの
要素同士の積を生成する。これを\code{integers}ストリームと共に用いて以下のストリームの
定義を完成させよ。これの\( n \)番目の要素(0で開始)は\( n + 1 \)の階乗である。

% \begin{scheme}
~%~ (define factorials (cons\-/stream 1 (mul\-/streams ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
~%~ \end{scheme}
\noindent
\code{(define factorials (cons\-/stream 1 (mul\-/streams}\( \kern0.7ex\langle \)\code{?}\( \rangle \)\( \kern0.7ex\langle \)\code{?}\( \rangle \)\code{)))}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.55}Exercise 3.55:} 
手続き\code{partial\-/sums}を定義せよ。これはストリーム\( S \)を引数として取り、要素が
\( S_0 \), \( S_0 + S_1 \), \( S_0 + S_1 + S_2, \dots \)であるストリームを返す。
例えば\code{(partial\-/sums integers)}は1, 3, 6, 10, 15, \( \dots \)のストリームにならねば
ならない。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.56}Exercise 3.56:} 
R. Hamming(リチャード ハミング)により取り上げられた有名な問題に、昇順に、重複無く、
2, 3, 5以外の素因数を持たない正の整数を列挙せよというものがある。これを行う
1つの明らかな方法は単純に各整数を順に2, 3, 5以外の素因数を持つかどうかテストする
方法です。しかしこれはとても非効率です。整数が大きくなる程に要求に合う数はより
少なくなるためです。代替法として、要求された数のストリームを\code{S}と呼び、以下の
事実について注目してみましょう。

\begin{itemize}

\item
\code{S}は1で始まる。

\item
\code{(scale\-/stream S 2)}の要素もまた\code{S}の要素である。

\item
同じことが\code{(scale\-/stream S 3)}と\code{(scale\-/stream 5 S)}に対しても真である。

\item
これらは全て\code{S}の要素である。

\end{itemize}

さて私達が行わなければならないこと全てはこれらの情報から要素を結合することである。
このために2つの順序有りストリームを重複を省き1つの順序付けられた結果のストリームに結合する
手続き\code{merge}を定義する。

\begin{scheme}
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream 
                   s1car 
                   (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream 
                   s2car 
                   (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream 
                   s1car
                   (merge (stream-cdr s1)
                          (stream-cdr s2)))))))))
\end{scheme}

次に要求されたストリームが\code{merge}を用いて以下のよう構築されるだろう。

\begin{scheme}
(define S (cons-stream 1 (merge ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
\end{scheme}

上で\( \langle \)\var{??}\( \kern0.08em\rangle \)とマークされた箇所の欠けた式を埋めよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.57}Exercise 3.57:} 
\( n \)番目のフィボナッチ数を\code{add\-/streams}手続きを基にした\code{fibs}の定義を用いて
計算した場合に加算は何回実行されるか? 加算回数が\code{(delay <\var{exp}>)}を単純に
\link{Section 3.5.1}で説明した\code{memo\-/proc}手続きにより提供される最適化を用いずに、
\code{(lambda () <\var{exp}>)}として実装した場合に指数関数的に増加することを示せ。\footnote{この課題は
call\-/by\-/needが\link{Exercise 3.27}で説明された通常のメモ化に密接に関係していることを示します。
その課題では代入を明示的にローカルの表の構築に用いました。私達のcall-by-needストリームの
最適化は効果的にそのようなテーブルを自動的に構築し、ストリームの以前に強制された部分の値を
格納します。}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.58}Exercise 3.58:} 
以下の手続きにより計算されるストリームの解説を与えよ。

\begin{scheme}
(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))
\end{scheme}


(\code{quotient}はプリミティブであり、2つの整数の、整数の商を返す)。
\code{(expand 1 7 10)}により生成される一連の要素は何か?
\code{(expand 3 8 10)}では何が生成されるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.59}Exercise 3.59:} 
\link{Section 2.5.3}にて多項式を項のリストとして表現する多項式数値演算システムをどのように
実装するかについて学んだ。同様な方法で以下のような\newterm{power series}(\jnewterm{べき級数})に
ついても扱うことができる。
\begin{comment}

\begin{example}
               x^2     x^3       x^4
e^x = 1 + x + ----- + ----- + --------- + ...
                2     3 * 2   4 * 3 * 2

             x^2       x^4
cos x = 1 - ----- + --------- - ...
              2     4 * 3 * 2

             x^3         x^5
sin x = x - ----- + ------------- - ...
            3 * 2   5 * 4 * 3 * 2
\end{example}

\end{comment}
\begin{displaymath}
e^x = 1 + x + \displaystyle\frac{x^2}{2} + \displaystyle\frac{x^3}{3 \cdot 2} + \displaystyle\frac{x^4}{4 \cdot 3 \cdot 2} + \dots, 
\end{displaymath}
\begin{displaymath}
\cos x = 1 - \displaystyle\frac{x^2}{2} + \displaystyle\frac{x^4}{4 \cdot 3 \cdot 2} - \dots, 
\end{displaymath}
\begin{displaymath}
\sin x = x - \displaystyle\frac{x^3}{3 \cdot 2} + \displaystyle\frac{x^5}{5 \cdot 4 \cdot 3 \cdot 2} - \dots 
\end{displaymath}
\noindent
これらは無限ストリームとして表現されている。数列\( a_0 +
a_1 x + a_2 x^2 + a_3 x^3 + \dots \)を要素が係数\( a_0 \), \( a_1 \), \( a_2 \), \( a_3 \), \( \dots \)
のストリームとして表すことにする。

\begin{enumerate}[a]

\item
級数\( a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \dots \)の積分は次の級数になる。
\begin{comment}

\begin{example}
             1             1             1
c + a_0 x + --- a_1 x^2 + --- a_2 x^3 + --- a_3 x^4 + ...
             2             3             4
\end{example}

\end{comment}
\begin{displaymath}
 c + a_0 x + {1\over2} a_1 x^2 + {1\over3} a_2 x^3 + {1\over4} a_3 x^4 + \dots, 
\end{displaymath}
\noindent
ここで\( c \)は任意の定数である。羃級数を表すストリーム\( a_0 \), \( a_1 \), \( a_2 \), \( \dots \)を
入力として取り、その級数の積分の非定数項の係数のストリーム\( a_0 \), \( {1\over2}a_1 \), \( {1\over3}a_2 \), \( \dots \)を
返す手続き\code{integrate\-/series}を定義せよ。(結果が定数項を持たないため、それは羃級数では無い。
\code{integrate\-/series}を使う時、後で適切な定数を\code{cons}する。)

\item
関数\( x \mapsto e^x \)はそれ自身導関数である。これは\( e^x \)と\( e^x \)の不定積分が
定数項を除いて同じ級数になることを暗示する。定数項は\( e^0 = 1 \)である。結果的に、
\( e^x \)の級数を次のように生成できる。

\begin{scheme}
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
\end{scheme}



sinとcosの級数をどのように生成するか示せ。sinの導関数がcosであり、cosの導関数が
負のsinであることから始めよ。

\begin{scheme}
(define cosine-series (cons-stream 1 ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))
(define sine-series (cons-stream 0 ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))
\end{scheme}
\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.60}Exercise 3.60:}
\link{Exercise 3.59}における係数ストリームとして表現された羃級数を用いて、級数の加算
は\code{add\-/streams}により実装される。級数を乗算するための以下の手続きの定義を完成させよ。

\begin{scheme}
(define (mul-series s1 s2)
  (cons-stream ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ (add-streams ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
\end{scheme}



手続きができたら\link{Exercise 3.59}の級数を用いて\( \sin^2 x +
\cos^2 x = 1 \)を確認せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.61}Exercise 3.61:}
\( S \)が定数項が1の羃級数(\link{Exercise 3.59})であるとする。
羃級数\( 1 / S \)を見つけたいとする。つまり\( SX = 1 \)となるような級数\( X \)である。
\( S_R \)が\( S \)の定数項の後の部分である場合に\( S = 1 + S_R \)を書け。
そうすれば\( X \)を以下のようにして求めることができる。
\begin{comment}

\begin{example}
        S * X = 1
(1 + S_R) * X = 1
  X + S_R * X = 1
            X = 1 - S_R * X
\end{example}

\end{comment}
\begin{displaymath}
%  \eqalign{
% 	        S \cdot X 	&= 1, \cr
% 	(1 + S_R) \cdot X 	&= 1, \cr
% 	  X + S_R \cdot X 	&= 1, \cr
% 	            	X 	&= 1 - S_R \cdot X. \cr
% } 
\begin{array}{r@{{}={}}l}
	        S \cdot X 	& 1, \\
	(1 + S_R) \cdot X 	& 1, \\
	  X + S_R \cdot X 	& 1, \\
	            	X 	& 1 - S_R \cdot X. 
\end{array}
\end{displaymath}
言い換えれば、\( X \)は定数項が1であり高次項が負の\( S_R \)と\( X \)の積により与え
られる羃級数である。この考えを用いて定数項1を持つ羃級数\( S \)に対する
\( 1 / S \)を求める手続き\code{invert\-/unit\-/series}を書け。\link{Exercise 3.60}の
\code{mul\-/series}を用いる必要がある。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.62}Exercise 3.62:} 
\link{Exercise 3.60}と\link{Exercise 3.61}の結果を用いて2つの羃級数を割る
手続き\code{div\-/series}を定義せよ。\code{div\-/series}は任意の2つの級数に対して利用できねば
ならず分母の級数は非ゼロな定数項で始まらねばならない。(もし分母がゼロの定数項を
持つならば\code{div\-/series}はエラーを発すこと)。\code{div\-/series}を\link{Exercise 3.59}の
結果と一緒にどのように用いてtanの羃級数を生成するか示せ。
\end{quote}

\subsection{ストリームパラダイムの利用}
\label{Section 3.5.3}


遅延評価を伴なうストリームは強力なモデリングツールにすることができ、局所状態と
代入の利点の多くを提供する。さらにプログラミング言語への代入の導入に伴う、
いくつかの理論的な混乱を防ぎます。



ストリームのアプローチは私達に、状態変数への代入の周りに体系化されたシステムよりも、
異なるモジュール境界を伴なうシステムを構築することを可能にするため、啓発的です。
例えば私達は個別の瞬間における状態変数の値としてではなく、
時系列(または信号)全体を興味の中心として考えることができます。
このことが異なる瞬間の状態のコンポーネントの比較と接続を行うのにより便利にします。

\subsubsection*{反復をストリームプロセスとして定式化する}



\link{Section 1.2.1}において、反復プロセスを紹介しました。これは状態変数を更新することで
進行されます。私達は今、状態を更新される変数の集合としてではなく、
``永遠''の値のストリームとして表すことができます。\link{Section 1.1.7}の平方根手続きへの
再訪問にこの視点を導入しましょう。考え方は推測値を改善する手続きを何度も適用することで
\( x \)の平方根の推測値をより良い値の列を生成するということを思い出して下さい。

\begin{scheme}
(define (sqrt-improve guess x)
  (average guess (/ x guess)))
\end{scheme}

\noindent
私達の元の\code{sqrt}手続きでは、これらの推測値を状態変数の一連の値にしました。
代わりに推測値の無限ストリームを作ることができます。推測値の初期値は1で
始めます。\footnote{\code{let}をローカル変数\code{guesses}を束縛するのに使うことは
できません。\code{guesses}の値は\code{guesses}自身に依存するためです。
\link{Exercise 3.63}はなぜここで局所変数を欲しがるのかを扱います。}

\begin{scheme}
(define (sqrt-stream x)
  (define guesses
    (cons-stream
     1.0
     (stream-map (lambda (guess) (sqrt-improve guess x))
                 guesses)))
  guesses)

(display-stream (sqrt-stream 2))
~\textit{1.}~
~\textit{1.5}~
~\textit{1.4166666666666665}~
~\textit{1.4142156862745097}~
~\textit{1.4142135623746899}~
~\( \dots \)~
\end{scheme}

\noindent
より多くのストリームの項を生成することでより良い推測値を得ることができます。
もし望むなら、解答が十分に良くなるまで項の生成を続ける手続きを書くことも可能です。
(\link{Exercise 3.64}参照)。


同じ方法で扱えるもう1つの反復は\( \pi \)の近似値を\link{Section 1.3.1}で見た
交項級数(交代級数)を基にして生成することが可能です。
\begin{comment}

\begin{example}
[pi]        1     1     1
-\-/\-/- = 1 - -\-/- + -\-/- - -\-/- + ...
  4         3     5     7
\end{example}

\end{comment}
\begin{displaymath}
 {\pi\over4} = 1 - {1\over3} + {1\over5} - {1\over7} + \dots. 
\end{displaymath}
最初に級数の加数(符号が交互に代わる奇数の逆数)のストリームを生成します。次に
(\link{Exercise 3.55}の\code{partial\-/sums}手続きを用いてより多くの項の
和のストリームを取り、結果を4倍します。

\begin{scheme}
(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (pi-summands (+ n 2)))))
(define pi-stream
  (scale-stream (partial-sums (pi-summands 1)) 4))

(display-stream pi-stream)
~\textit{4.}~
~\textit{2.666666666666667}~
~\textit{3.466666666666667}~
~\textit{2.8952380952380956}~
~\textit{3.3396825396825403}~
~\textit{2.9760461760461765}~
~\textit{3.2837384837384844}~
~\textit{3.017071817071818}~
~\( \dots \)~
\end{scheme}

\noindent
これはより良い\( \pi \)の近似値のストリームを提供します。しかし、近似値の
収束はとても遅いです。列の8個の項は\( \pi \)の値を3.284から3.017の間に
束縛されます。


今の所、状態のストリームを使用する取り組みは状態変数を更新する物から大きくは
異なりません。しかしストリームはある面白いトリックを行う機会を提供します。
例えば、近似値の列を、同じ値に、ただしより速く収束する列に変換する
\newterm{sequence accelerator}(\jnewterm{列アクセラレータ})を用いてストリームを
変換することができます。


18世紀のスイスの数学者Leonhard Euler(レオンハルト オイラー)によるそのようなアクセラレータの1つは
交項級数(符号を互い違いにする項の列)の部分和である列とうまく働きます。
オイラーの手法においては、もし\( S_n \)が元の和の列の\( n \)番目の項であるなら、
加速された列は以下の項を持ちます。
\begin{comment}

\begin{example}
             (S_(n+1) - S_n)^2
S_(n+1) - ------------------------
          S_(n-1) - 2S_n + S_(n+1)
\end{example}

\end{comment}
\begin{displaymath}
 S_{n+1} - {(S_{n+1} - S_n)^2 \over S_{n-1} - 2S_n + S_{n+1}}\,. 
\end{displaymath}
従って元の列が値のストリームとして表現されるならば、変換された列は以下により与えられる。

\begin{scheme}
(define (euler-transform s)
  (let ((s0 (stream-ref s 0))     ~\textrm{; \( S_{n-1} \)}~
        (s1 (stream-ref s 1))     ~\textrm{; \( S_n \)}~
        (s2 (stream-ref s 2)))    ~\textrm{; \( S_{n+1} \)}~
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))
\end{scheme}

\noindent
オイラーによる加速を私達の\( \pi \)の近似値の列を用いて実演できます。

\begin{scheme}
(display-stream (euler-transform pi-stream))
~\textit{3.166666666666667}~
~\textit{3.1333333333333337}~
~\textit{3.1452380952380956}~
~\textit{3.13968253968254}~
~\textit{3.1427128427128435}~
~\textit{3.1408813408813416}~
~\textit{3.142071817071818}~
~\textit{3.1412548236077655}~
~\( \dots \)~
\end{scheme}

\noindent
さらに良くなるよう、加速された列を加速でき、そして再帰的にそれの加速を繰り返すことが可能です。
すなわち、ストリームのストリーム(\newterm{tableau}(\jnewterm{タブロー})と呼ぶ構造)を作り、
その中では各ストリームは1つ前の変換です。

\begin{scheme}
(define (make-tableau transform s)
  (cons-stream s (make-tableau transform (transform s))))
\end{scheme}

\noindent
タブローは以下の形を取ります。
\begin{comment}

\begin{example}
s_00   s_01   s_02   s_03   s_04   ...
       s_10   s_11   s_12   s_13   ...
              s_20   s_21   s_22   ...
                            ...
\end{example}

\end{comment}
\begin{displaymath}
 \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil & 
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil \cr

$ s_{00} $ 	&  $ s_{01} $ 	&  $ s_{02} $ 	&  $ s_{03} $ 	&  $ s_{04} $ 	&  $ \dots $ \cr
		&  $ s_{10} $ 	&  $ s_{11} $ 	&  $ s_{12} $ 	&  $ s_{13} $ 	&  $ \dots $ \cr
		& 		&  $ s_{20} $ 	&  $ s_{21} $ 	&  $ s_{22} $ 	&  $ \dots $ \cr
		& 		& 		&  $ \dots $ 	& 		&  \cr }
} 
\end{displaymath}
最後にタブローの各行の最初の項を取ることで列を形成します。

\begin{scheme}
(define (accelerated-sequence transform s)
  (stream-map stream-car (make-tableau transform s)))
\end{scheme}

\noindent
\( \pi \)の列のこの種の``超加速''を実演することができます。

\begin{scheme}
(display-stream
 (accelerated-sequence euler-transform pi-stream))
~\textit{4.}~
~\textit{3.166666666666667}~
~\textit{3.142105263157895}~
~\textit{3.141599357319005}~
~\textit{3.1415927140337785}~
~\textit{3.1415926539752927}~
~\textit{3.1415926535911765}~
~\textit{3.141592653589778}~
~\( \dots \)~
\end{scheme}

\noindent
結果は感動的です。列の8つの項を得ることで\( \pi \)の小数点以下14桁の正しい値が
もたらせられます。もし元の\( \pi \)の列のみを使用したなら、\( 10^{13} \)のオーダーの
演算をする必要が(すなわち列の個々の項が\( 10^{-13} \)よりも小さくなるまで十分に長く
展開する必要が)同じ程度の正確さを得るためには必要です！



これらの加速テクニックをストリームを用いずに実装することもできました。
しかしストリームによる定式化はとりわけエレガントで便利です。状態の列全体が
統一された命令の集合により操作可能なデータ構造として使用できるからです。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.63}Exercise 3.63:} 
Louis Reasonerはなぜ\code{sqrt\-/stream}手続きが以下のより簡単な方法で、局所変数
\code{guesses}無しで実装されていないのか尋ねた。

\begin{scheme}
(define (sqrt-stream x)
  (cons-stream 1.0 (stream-map
                    (lambda (guess)
                      (sqrt-improve guess x))
                    (sqrt-stream x))))
\end{scheme}



Alyssa P. Hackerが問題の手続きのこの版は冗長な演算を行うため、かなり非効率であるからと答えた。
Alyssaの答を説明せよ。もし\code{delay}の実装が\code{memo\-/proc} (\link{Section 3.5.1})で提供された最適化を
用いずに\code{(lambda () <\var{exp}>)}のみを使用したならば2つの版の間に依然として効率上の
違いは存在するだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.64}Exercise 3.64:} 
引数としてストリームと許容値の数値を取る手続き\code{stream\-/limit}を書け。
差の絶対値が許容値未満である2つの連続する要素を見つけるまでストリームを検査し、
その2つの要素の2番目を返す。これを用いて与えられた許容誤差以内の平方根を求める
ことができるだろう。

\begin{scheme}
(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.65}Exercise 3.65:} 
以下の級数を用いて、
\begin{comment}

\begin{example}
            1     1     1
ln 2 = 1 - --- + --- - --- + ...
            2     3     4
\end{example}

\end{comment}
\begin{displaymath}
 \ln 2 = 1 - {1\over2} + {1\over3} - {1\over4} + \dots 
\end{displaymath}
\noindent
\( \pi \)に対して上で行ったのと同様に、2の自然対数の近似値を3種の近似値の列を
求めよ。これらの列はどれだけ早く収束するか?

\end{quote}

\subsubsection*{ペアの無限ストリーム}


\link{Section 2.2.3}において列パラダイムがどのように伝統的な入れ子ループをペアの列上に
定義された手続きとして扱うかについて学びました。もしこのテクニックを無限ストリームに
対しても一般化すれば簡単には繰り返しとしては表現されないプログラムを書くことが
できます。なぜなら``ループ''を無限集合の範囲にも渡らせなければなりません。



例えば\link{Section 2.2.3}の\code{prime\-/sum\-/pairs}手続きを一般化して、整数\emph{全て}の
ペア\( (i, j) \)、但し\( i \le j \)で\( i + j \)が素数である場合の
ストリームを生成します。もし\code{int\-/pairs}が\( i \le j \)における全ての整数のペア
\( (i, j) \)の列であるのならば、私達が必要とするストリームは単純に以下のように
定義されます。\footnote{\link{Section 2.2.3}にもある通り、私達は整数のペアをLispのペアでは
なく、リストにて表現します。}

\begin{scheme}
(stream-filter
 (lambda (pair) (prime? (+ (car pair) (cadr pair))))
 int-pairs)
\end{scheme}

\noindent
すると問題は\code{int\-/pairs}ストリームを生成することになります。より一般的には、
2つのストリーム、\( S = (S_i) \)と\( T = (T_j) \)を持っているとした場合に、
無限の長方形の配列を想像してみて下さい。
\begin{comment}

\begin{example}
(S_0, T_0)  (S_0, T_1)  (S_0, T_2)  ...
(S_1, T_0)  (S_1, T_1)  (S_1, T_2)  ...
(S_2, T_0)  (S_2, T_1)  (S_2, T_2)  ...
   ...
\end{example}

\end{comment}
\begin{displaymath}
 \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil & 
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil \cr

	$ (S_0, T_0) $ & $ (S_0, T_1) $ & $ (S_0, T_2) $ & $ \dots $ \cr
	$ (S_1, T_0) $ & $ (S_1, T_1) $ & $ (S_1, T_2) $ & $ \dots $ \cr
	$ (S_2, T_0) $ & $ (S_2, T_1) $ & $ (S_2, T_2) $ & $ \dots $ \cr
	$ \dots $ & & & \cr }
} 
\end{displaymath}
配列内の、対角線上かその上部の全てのペアを含むストリームを生成したいと考えます。
つまり、以下のペアです。
\begin{comment}

\begin{example}
(S_0, T_0)  (S_0, T_1)  (S_0, T_2)  ...
            (S_1, T_1)  (S_1, T_2)  ...
                        (S_2, T_2)  ...
                                    ...
\end{example}

\end{comment}
\begin{displaymath}
 \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil & 
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil \cr

$ (S_0, T_0) $ 	& $ (S_0, T_1) $ 	& $ (S_0, T_2) $ 	& $ \dots $ \cr
		& $ (S_1, T_1) $ 	& $ (S_1, T_2) $ 	& $ \dots $ \cr
		& 			& $ (S_2, T_2) $ 	& $ \dots $ \cr
		& 			& 			& $ \dots $ \cr }
} 
\end{displaymath}
\noindent
(もし\( S \)と\( T \)の両方を整数のストリームとして取るなら、これが望んだストリーム\code{int\-/pairs}です。)


一般的なペアのストリームを\code{(pairs S T)}と呼び、それが3つの部分から組み立てられていると考えます。
ペア\( (S_0, T_0) \)、最初の行の残りのペア、残りのペアです。\footnote{なぜ私達が分解を選ぶのかについての
見識については\link{Exercise 3.68}を参照して下さい。}
\begin{comment}

\begin{example}
(S_0, T_0) | (S_0, T_1)  (S_0, T_2)  ...
-----------+-----------------------------
           | (S_1, T_1)  (S_1, T_2)  ...
           |             (S_2, T_2)  ...
           |                         ...
\end{example}

\end{comment}
\begin{displaymath}
 \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil & \vrule
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil \cr

$ (S_0, T_0) $ 	& $ (S_0, T_1) $ 	& $ (S_0, T_2) $ 	& $ \dots $ \cr
\noalign{\hrule}
		& $ (S_1, T_1) $ 	& $ (S_1, T_2) $ 	& $ \dots $ \cr
		& 			& $ (S_2, T_2) $ 	& $ \dots $ \cr
		& 			& 			& $ \dots $ \cr }
} 
\end{displaymath}
この分解の3つ目の断片(最初の行にないペア)は(再帰的に)\code{(stream\-/cdr S)}と\code{(stream\-/cdr T)}から
形成されることに注意して下さい。また2番目の断片(最初の行の残り)は以下により求められます。

\begin{scheme}
(stream-map (lambda (x) (list (stream-car s) x))
            (stream-cdr t))
\end{scheme}

\noindent
従って私達のペアのストリームは以下により形成できます。

\begin{scheme}
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (~\( \dark \langle \)~~\var{\dark combine-in-some-way}~~\( \dark \rangle \)~
     (stream-map (lambda (x) (list (stream-car s) x))
                 (stream-cdr t))
     (pairs (stream-cdr s) (stream-cdr t)))))
\end{scheme}

\noindent
手続きを完成させるためには、2つの内部ストリームを接続する何らかの方法を選択せねばなりません。
アイデアの1つは\link{Section 2.2.1}の\code{append}手続きの類似ストリームを用いる方法です。

\begin{scheme}
(define (stream-append s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (stream-append (stream-cdr s1) s2))))
\end{scheme}

\noindent
しかし、これは無限ストリームには不適切です。なぜならばこれは最初のストリームからの
要素を全て、2つ目のストリームとの合併前に取ります。具体的には、もし全ての正の整数
のペアを以下のようにして生成しようとすると、

\begin{scheme}
(pairs integers integers)
\end{scheme}

\noindent
結果のストリームは最初に1番目の整数が1の場合の全てのペアを通して実行しようとします。
そしてそれ故に1番目の整数が他の値のペアを全く生成することができません。


無限ストリームを扱うためには、プログラムを十分に長く実行したならば全ての要素がいつかは
得られることを保証する組み合わせの順を工夫する必要があります。これを達成する洗練された
方法は以下の\code{interleave}(相互配置)手続きを用います。\footnote{組み合わせの順に要求された属性
を正しく上げると次にようになります。2つの引数を取る関数が必須であり、最初のストリームの要素
\( i \)と2つ目のストリームの要素\( j \)に対応するペアは出力ストリームの\( f(i, j) \)番目として
現れます。\code{interleave}を用いてこれを達成するトリックは、KRC言語にこれを採用したDavid Turnerにより
示されました。(\link{Turner 1981})}

\begin{scheme}
(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))
\end{scheme}

\noindent
\code{interleave}は2つのストリームから交代に要素を得るため、2つ目のストリームの各要素が
いつかは相互配置ストリームへ入ることが、例え最初のストリームが無限でもわかります。



従って要求されたペアのストリームを以下のように生成できます。

\begin{scheme}
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.66}Exercise 3.66:} 
ストリーム\code{(pairs integers integers)}を試験せよ。pairsがストリーム内に配置する順に
ついて全体的なコメントを行え。例えばペア(1, 100)の前にはおよそどれだけの数のペアが
先行するか? (99, 100)と(100, 100)の場合についても答えよ。(もし正確な数学上の説明が
できるなら、なおさら良い。しかし行き詰まったと感じるのならばより程度的な回答を
気楽に上げて欲しい。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.67}Exercise 3.67:} 
\code{pairs}手続きを変更し、\code{(pairs integers integers)}が\emph{全て}の整数のペア\( (i, j) \)を
(\( i \le j \)という条件無しで)生成するようにせよ。ヒント：追加のストリームを混ぜ合わせる
必要がある。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.68}Exercise 3.68:} 
Louis Reasonerは3つの部分からペアストリームを構築することは不必要に複雑なのではないかと
考えた。最初の行のペア\( (S_0, T_0) \)を残りのペアから分離する代わりに、以下のように
最初の行全体を用いて行うことを提案した。

\begin{scheme}
(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
\end{scheme}


これはうまく行くだろうか?  \code{(pairs integers integers)}をLouisの\code{pairs}の
定義を用いて評価した場合に何が起こるか考えよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.69}Exercise 3.69:}
3つの無限ストリーム、\( S \), \( T \), \( U \)を取り、三つ組\( (S_i, T_j, U_k) \)の
ストリームを生成する手続き\code{triples}を書け。但し\( i \le j \le k \)とする。
\code{triples}を用いて全ての正の整数のピタゴラス数の3つ組のストリームを生成せよ。
すなわち三つ組\( (i, j, k) \)は\( i \le j \)、かつ\( i^2 + j^2 = k^2 \)である。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.70}Exercise 3.70:} 
\emph{アドホック}(その場その場)な相互配置処理の結果の順ではなく、
ペアが何らかの便利な順で現れるストリームを生成できれば便利だろう。
もし整数の1つのペアが別のペアよりも``小さい''と言える方法を定義できるならば
\link{Exercise 3.56}の\code{merge}手続きに似たテクニックを用いることができる。
これを行う1つの方法は``重み関数''\( W(i, j) \)を定義し
\( W(i_1, j_1) < W(i_2, j_2) \)であるなら
\( (i_1, j_1) \)は\( (i_2, j_2) \)未満であると取り決める。
\code{merge}に似た手続き\code{merge\-/weighted}を書け。ただし\code{merge\-/weighted}は追加の引数
\code{weight}を取り、\code{weight}はペアの重みを計る手続きでありマージされた結果のストリームの中で
どの要素が現れるべきかの順を決定するのに利用される。\footnote{ペアの重みがペアの配列の中で
行に沿って外へ動くか、列に沿って下った場合に増えるように重み関数に対して要求するだろう。}
重み関数を計算する手続きと一緒にこれを用いて、
\code{pairs}を2つのストリームを取る手続き\code{weighted\-/pairs}に一般化し、
重みに従った順のペアのストリームを生成する。
作成した手続きを用いて以下を生成せよ。

\begin{enumerate}[a]

\item
全ての正の整数のペア\( (i, j) \)のストリームを\( i \le j \)の条件で、和\( i + j \)に
従った順で生成する

\item
全ての正の整数のペア\( (i, j) \)のストリームを\( i \le j \)かつ\( i \)とmath{j}が
どちらも2, 3, 5で割り切れない条件で、和\( 2i + 3j + 5i\!j \)に従う順序で生成する

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.71}Exercise 3.71:} 
2つの立方数の和で表す方法が複数ある数は時折\newterm{Ramanujan numbers}(\jnewterm{ラマヌジャン数})と
呼ばれる。これは数学者Srinivasa Ramanujan(シュリニヴァーサ・ラマヌジャン)に敬意を表して
いる。\footnote{G. H. Hardy(ゴッドフレイ・ハロルド・ハーディ)によるラマヌジャンの
死亡告知(\link{Hardy 1921})から引用すれば、``Mr. Littlewoodこそが`全ての自然数が彼の友達であった'と
述べられた(私が信じる)人だ。私は彼がPutneyで病気で倒れた
時に1度会いに行った。その時私は車番1729のタクシーに乗ったのでとてもつまらない数に見えたと
告げ、それが良くない前触れでないことを祈ると伝えた。`いいえ'と彼が答えた。`それはとても
面白い数です。それは2つの立方数の和により表現する方法が2つ有る最小の数です'''
ラマヌジャン数を生成する重み付けられたペアのトリックはCharles Leisersonにより私達に
示されました。}
ペアの順序有りストリームはこれらの数を計算する問題に対し洗練された解法を提供する。
2つの立方数の和として表現する方法が2つある数を見付けるためには、\( i^3 + j^3 \)の和に従い
重み付けられた整数のペア\( (i, j) \)のストリームを生成し(\link{Exercise 3.70}参照)、次に
ストリームから同じ重みを持つ連続したペアを探すだけで良い。ラマヌジャン数を生成する
手続きを書け。そのような最初の数は1,729である。次の5つは何か?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.72}Exercise 3.72:} 
\link{Exercise 3.71}と同様な方法で2つの平方数の和として3つの異なる方法で書ける全ての数の
ストリームを生成せよ。(それらがどのようにして、そう書けるのか示せ)。
\end{quote}

\subsubsection*{信号としてのストリーム}



ストリームの議論を信号処理システムにおける``信号''の計算可能な同類であると説明する
ことから始めました。実際に、ストリームを用いて信号処理システムをとても直接的な方法で
モデル化することができ、連続する時間区間の信号の値をストリームの連続する要素として
表現します。例えば\newterm{integrator}(\jnewterm{積分器})、つまり\newterm{summer}(\jnewterm{アナログ加算器})を実装し、
入力ストリーム\( x = (x_i) \)と初期値\( C \)、小さな増分\( dt \)に対し、以下の
合計を累算し、
\begin{comment}

\begin{example}
           i
          ---
S_i = C + >   x_j dt
          ---
          j=1
\end{example}

\end{comment}
\begin{displaymath}
 S_i = C + \sum_{j=1}^i x_j dt 
\end{displaymath}
\noindent
値\( S = (S_i) \)のストリームを返します。以下の\code{integral}手続きは(\link{Section 3.5.2})の
整数ストリームの``暗黙的なスタイル''の定義を思い出させます。

\begin{scheme}
(define (integral integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
  int)
\end{scheme}

\noindent
\link{Figure 3.32}は\code{integral}手続きに相当する信号処理システムの絵です。入力ストリームは
\( dt \)によりスケール(拡大)され加算器を通して渡され、その出力は同じ加算器に
戻されます。\code{int}の定義内の自己参照が図では加算器の出力が入力の1つに接続される
フィードバックループにより反映されています。

\begin{figure}[tb]
\phantomsection\label{Figure 3.32}
\centering
\begin{comment}
\heading{Figure 3.32:} The \code{integral} procedure viewed as a signal-processing system.

\begin{example}
                             initial-value
                                  |
       +-----------+              |   |\__
input  |           |      |\__    +-->|   \_  integral
------>| scale: dt +----->|   \_      |cons_>--*------->
       |           |      | add_>---->| __/    |
       +-----------+  +-->| __/       |/       |
                      |   |/                   |
                      |                        |
                      +------------------------+
\end{example}
\end{comment}
\includegraphics[width=102mm]{fig/chap3/Fig3.32.pdf}
\begin{quote}
\heading{Figure 3.32:} 信号処理システムとして見た\code{integral}手続き
\end{quote}
\end{figure}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.73}Exercise 3.73:} 
電子回路をストリームを用いて一連の時間の時系列電流や電圧の値を表すことでモデル化できる。
例えば、抵抗値\( R \)の抵抗と静電容量\( C \)のコンデンサから成る\newterm{RC circuit}(\jnewterm{RC回路})を
連続して持っているとする。入力された電流\( i \)に対する回路の電圧レスポンス\( v \)は
\link{Figure 3.33}の式により決定し、その構造は添付の信号フロー図により示される。

\clearpage
\begin{figure}[tb]
\phantomsection\label{Figure 3.33}
\centering
\begin{comment}
\heading{Figure 3.33:} An RC circuit and the associated signal-flow diagram.

\begin{example}
  +        v        -

 ->----'\/\/\,---| |---
  i       R         C


                  / t
               1  |
 v  =  v   +  --- |  i dt  +  R i
        0      C  |
                  / 0

         +--------------+
     +-->|   scale: R   |---------------------+   |\_
     |   +--------------+                     |   |  \_
     |                                        +-->|    \   v
  i  |   +--------------+     +------------+      | add >--->
 ----+-->|  scale: 1/C  |---->|  integral  |----->|   _/
         +--------------+     +------------+      | _/
                                    |             |/
				   v
				    0
\end{example}
\end{comment}
\includegraphics[width=94mm]{fig/chap3/Fig3.33.pdf}
\par\bigskip
\noindent
\heading{Figure 3.33:} RC回路と対応する信号処理図
\end{figure}



この回路をモデル化する手続き\code{RC}を書け。\code{RC}は入力として\( R \), \( C \), \( dt \)を
取り、手続きを返さねばならない。返り値の手続きは入力として電流\( i \)を表すストリームと
コンデンサの初期電圧\( v_0 \)を取り、出力として電圧\( v \)のストリームを生成する。
例えば\code{RC}を用いて\( R \)が5[Ω]、\( C \)が1[F]、タイムステップが0.5秒のRC回路を
\code{(define RC1 (RC 5 1 0.5))}を評価することでモデル化できなければならない。
これは\code{RC1}を電流の時系列を表すストリームとコンデンサの初期電圧を取り電圧の出力ストリーム
を生成する。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.74}Exercise 3.74:} 
Alyssa P. Hackerは物理センサから来る信号を処理するシステムを設計している。
彼女が作りたい重要な機能は入力信号の\newterm{zero crossings}(\jnewterm{ゼロ交差})を記録する信号である。
結果の信号は入力信号が負から正に変わった時に\( +1 \)、正から負に変わった時に\( -1 \)、
その他の場合は0である。(入力が0の場合の符号は正とする)。例えば典型的な入力信号とその関連する
ゼロ交差信号は以下のようになる。

\begin{scheme}
~\( \dots \)~ 1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 ~\( \dots \)~
~\( \dots \)~ 0 0  0  0  0   -1   0  0  0   0   1  0 0 ~\( \dots \)~
\end{scheme}

% \begin{smallscheme}
~%~ ~\( \dots \)~1  2  1.5  1  0.5  -0.1  -2  -3  -2  -0.5  0.2  3  4~\( \dots \)~
~%~ ~\( \dots \)~0  0   0   0   0    -1    0   0   0    0    1   0  0~\( \dots \)~
~%~ \end{smallscheme}


Alyssaのシステムではセンサからの信号はストリーム\code{sense\-/data}で表され、
ストリーム\code{zero\-/crossings}が関連するゼロ交差のストリームである。
Alyssaは最初に手続き\code{sign\-/change\-/detector}を書いた。これは2つの値を引数として
取り値の符号を比べ値に対応した0, 1, -1を生成する。次にゼロ交差ストリームを以下の
ように構築した。

\begin{scheme}
(define (make-zero-crossings 
         input-stream last-value)
  (cons-stream
   (sign-change-detector
    (stream-car input-stream) 
    last-value)
   (make-zero-crossings
    (stream-cdr input-stream)
    (stream-car input-stream))))
(define zero-crossings
  (make-zero-crossings sense-data 0))
\end{scheme}


Alyssaの上司、Eva Lu Atorが歩み寄り、このプログラムは以下の、\link{Exercise 3.50}の
\code{stream-map}を一般化した版を使用した物とほぼ同じであると提案した。

\begin{scheme}
(define zero-crossings
  (stream-map sign-change-detector
              sense-data
              ~\( \dark \langle \)~~\var{\dark expression}~~\( \dark \rangle \)~))
\end{scheme}



\( \langle \)\var{expression}\( \rangle \)で示された部分を与えてプログラムを完成させよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.75}Exercise 3.75:} 
残念なことに、\link{Exercise 3.74}のAlyssaのゼロ交差判別器は十分でないことが証明された。
センサからのノイズの多い信号が誤ったゼロ交差へと導くためである。ハードウェアのスペシャリスト、
Lem E. TweakitはAlyssaにゼロ交差を試験する前にノイズを排除するために信号を滑らかに
することを提案した。Alyssaは彼のアドバイスを受け入れ、センサのデータの各値を前の値との
平均を取ることで構築された信号からゼロ交差を抽出することを決めた。彼女は問題を彼女の
アシスタント、Louis Reasonerに伝えた。彼はその考えを実装しようと試み、Alyssaのプログラムを
以下のように変更した。

\begin{scheme}
(define (make-zero-crossings
         input-stream last-value)
  (let ((avpt (/ (+ (stream-car input-stream) 
                    last-value) 
                 2)))
    (cons-stream
     (sign-change-detector avpt last-value)
     (make-zero-crossings 
      (stream-cdr input-stream) avpt))))
\end{scheme}



これはAlyssaの計画を正しく実装していない。Louisが入れてしまったバグを見つけ
プログラムの構造を変更せずに直せ。(ヒント：\code{make\-/zero\-/crossings}の引数の数を
増やす必要がある。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.76}Exercise 3.76:} 
Eva Lu Atorは\link{Exercise 3.75}におけるLouisの取り組み方を批判した。彼が書いた
プログラムはモジュラ化されていない。滑らかにする操作とゼロ交差抽出が混ざってしまって
いるためである。例えば抽出器はAlyssaが入力信号を調整するより良い手段を見つければ
変更する必要が無かった。Louisを手助けし、入力としてストリームを取り、2つの連続する
入力ストリームの要素の平均を要素とするストリームを生成する手続き\code{smooth}を書け。
次に\code{smooth}をゼロ交差判定機を実装するためのコンポーネントとしてよりモジュラー化
スタイルにて用いよ。
\end{quote}

\subsection{ストリームと遅延評価}
\label{Section 3.5.4}



先の節の終わりの\code{integral}手続きはどのようにストリームを用いてフィードバックループを
持つ信号処理システムをモデル化できるかを示しています。\link{Figure 3.32}に示される加算器の
フィードバックループは\code{integral}の内部ストリーム\code{int}がそれ自身を用いて定義されている
事実によりモデル化されています。

\begin{scheme}
(define int
  (cons-stream
   initial-value
   (add-streams (scale-stream integrand dt)
                int)))
\end{scheme}

\noindent
暗黙的定義のような物を扱うインタプリタの能力は\code{cons\-/stream}に組込まれている
\code{delay}に依存している。この\code{delay}無しではインタプリタは、\code{int}が既に定義されている
ことを要件とする\code{cons\-/stream}への引数両方を評価する前には\code{int}を構築することができませんでした。
一般的に、\code{delay}はストリームを用いてループを含む信号処理システムをモデル化するのに不可欠です。
\code{delay}無しでは任意の信号処理コンポーネントへの入力が、出力を生成する前に
完全に評価されるように、私達のモデルが定式化されなければなりません。

\begin{figure}[tb]
\phantomsection\label{Figure 3.34}
\centering
\begin{comment}
\heading{Figure 3.34:} An ``analog computer circuit'' that solves the equation \( dy / dt = f(y) \).

\begin{example}
                            y_0
                             |
                             V
    +----------+  dy   +----------+     y
+-->|  map: f  +------>| integral +--*----->
|   +----------+       +----------+  |
|                                    |
+------------------------------------+
\end{example}
\end{comment}
\includegraphics[width=67mm]{fig/chap3/Fig3.34.pdf}
\par\bigskip
\noindent
\heading{Figure 3.34:} 方程式\( dy / dt = f(y) \)を解く``アナログ演算回路''
\end{figure}

残念なことに、ループを伴うシステムのストリームモデルは\code{cons\-/stream}により提供される
``隠れた''\code{delay}を越えて、\code{delay}の使用を要求します。例えば\link{Figure 3.34}は
\( f \)が与えられた関数である場合に微分方程式信号\( dy / dt = f(y) \)を
解く処理システムを示しています。図は\( f \)をその入力信号に適用するマッピング
コンポーネント(map)を示しています。mapはフィードバックループの中に積分器へ向けて
実際にそのような方程式を解くために利用されているアナログ計算機回路にとても似た作法で
接続されています。



\( y \)に対し初期値\( y_0 \)を与えられたとした時、このシステムを以下の手続きを用いて
モデル化を試みることができるでしょう。

\begin{scheme}
(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (stream-map f y))
  y)
\end{scheme}

\noindent
この手続きはうまく行きません。\code{solve}の最初の行にて\code{integral}の呼出は
入力\code{dy}が定義されてることを要求します。これは\code{solve}の二行目までは
起こり得ません。


一方で、私達の定義の意図もつじつまが合いません。原理上は、\code{y}ストリームを
\code{dy}を知らずに生成し始めることができます。再に\code{integral}や他の多くのストリーム
命令は\code{cons\-/stream}に、引数に関する部分的な情報を与えられただけで応答の部分を
生成できるという点で似た性質を持っています。\code{integral}では出力ストリームの
最初の要素は\code{initial\-/value}で与えられます。従って出力ストリームの最初の要素を
被積分関数\code{dy}を評価せずに生成することができます。一度\code{y}の最初の要素を知る
ことができれば、\code{solve}の2行目の\code{stream\-/map}は\code{dy}の最初の要素を生成する
仕事を開始できます。これにより\code{y}の次の要素を生成することもでき、以下繰り返し
となります。


この考えの利点を得るために、\code{integral}を再定義し、被積分関数ストリームが
\newterm{delayed argument}(\jnewterm{遅延引数})を要求するようにします。\code{Integral}は
出力ストリームの最初の要素より多くを生成することを要求された時のみ、被積分関数を
\code{force}し評価させます。

\begin{scheme}
(define (integral delayed-integrand initial-value dt)
  (define int
    (cons-stream
     initial-value
     (let ((integrand (force delayed-integrand)))
       (add-streams (scale-stream integrand dt)
                    int))))
  int)
\end{scheme}

\noindent
これで\code{solve}手続きの実装が、\code{y}の定義内で\code{dy}を遅延させればできます。\footnote{この
手続きは全てのScheme実装で動くことが保証されていません。とはいえ、任意の実装に対して簡単な
変更で動作します。問題はScheme実装の内部定義の扱い方に関係があります。(\link{Section 4.1.6}参照)}

\begin{scheme}
(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
\end{scheme}

\noindent
全体的に、\code{integral}を呼び出す者は今では被積分関数を\code{delay}しなければなりません。
\( e \approx 2.718 \)の近似値を微分方程式\( dy / dt = y \)に対する
解が\( y = 1 \)の場合の値を初期条件\( y(0) = 1 \)で求めることで\code{solve}手続きが
うまく働くことを実演できます。

\begin{scheme}
(stream-ref (solve (lambda (y) y) 1 0.001) 1000)
~\textit{2.716924}~
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.77}Exercise 3.77:} 
上で使用された\code{integral}手続きは\link{Section 3.5.2}の整数無限ストリームの``暗示的''定義に
似ている。代替的に、より\code{integers\-/starting\-/from}に似た\code{integral}の定義を
与えることができない。(これも\link{Section 3.5.2}参照)

\begin{smallscheme}
(define (integral integrand initial-value dt)
  (cons-stream
   initial-value
   (if (stream-null? integrand)
       the-empty-stream
       (integral (stream-cdr integrand)
                 (+ (* dt (stream-car integrand))
                    initial-value)
                 dt))))
\end{smallscheme}


ループを持つシステム内で利用された場合、この手続きは\code{integral}の元の版が抱えた
問題と同じ問題を持つ。手続きを変更して\code{integrand}に対し遅延された引数を要求する
ようにし、それ故に上で示されたように\code{solve}手続きで利用できるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.78}Exercise 3.78:} 
単項二次線形微分方程式を学ぶための信号処理システムの設計問題について考えよ。
\begin{comment}

\begin{example}
d^2 y        d y
-----  -  a -----  -  by  =  0
d t^2        d t
\end{example}

\end{comment}
\begin{displaymath}
 {d^2y \over dt^2} - a {dy \over dt} - by = 0. 
\end{displaymath}
\( y \)をモデル化する出力ストリームはループを含むネットワークにより生成される。
これは\( d^2y / dt^2 \)の値が\( y \)と\( dy / dt \)の値に依存し、
これらの両方が\( d^2y / dt^2 \)を積分することにより決定されるからである。
\link{Figure 3.35}に示される図の符号化を行いたい。定数\( a \), \( b \), \( dt \)と
初期値、\( y \)に対する\( y_0 \)と\( dy_0 \)を引数として取り、\( y \)の一連の値の
ストリームを生成する手続き\code{solve-2nd}を書け。
\end{quote}

\begin{figure}[tb]
\phantomsection\label{Figure 3.35}
\centering
\begin{comment}
\heading{Figure 3.35:} Signal-flow diagram for the solution to a second-order linear differential equation.

\begin{example}
               dy_0                y_0
                |                   |
                V                   V
   ddy     +----------+    dy  +----------+    y
+--------->| integral +-----*--+ integral +--*--->
|          +----------+     |  +----------+  |
|                           |                |
|            +----------+   |                |
|     __/|<--+ scale: a |<--+                |
|   _/   |   +----------+                    |
+--<_add |                                   |
     \__ |   +----------+                    |
        \|<--+ scale: b |<-------------------+
             +----------+
\end{example}
\end{comment}
\includegraphics[width=91mm]{fig/chap3/Fig3.35a.pdf}
\begin{quote}
\heading{Figure 3.35:} 二次線形微分方程式の解のための信号フロー図
\end{quote}
\end{figure}


\begin{quote}
\heading{\phantomsection\label{Exercise 3.79}Exercise 3.79:} 
\link{Exercise 3.78}の\code{solve\-/2nd}手続きを一般化し、一般的な二次微分方程式\( d^2y / dt^2 =
f(dy / dt, y) \)を解くのに使用できるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.80}Exercise 3.80:} 
\newterm{series RLC circuit}(\jnewterm{連続RLC回路})は抵抗、コンデンサ、インダクタンスが\link{Figure 3.36}に
示されるように連結されている。\( R \), \( L \), \( C \)が抵抗、インダクタンス、コンデンサである
場合、3つのコンポーネントに対する電圧(\( v \))と電流(\( i \))の間の関係は以下の方程式により
説明される。
\begin{comment}

\begin{example}
v_R = i_R R

         d i_L
v_L = L -------
          d t

         d v_C
i_C = C -------
          d t
\end{example}

\end{comment}
\begin{displaymath}
 	v_R 	= 	i_R R, \qquad\quad
	v_L 	= 	L {di_L \over dt}\,, \qquad\quad
	i_C 	= 	C {dv_C \over dt}\,, 
\end{displaymath}
そして回路の接続が以下の関係を決定する。
\begin{comment}

\begin{example}
i_R = i_L = -i_C

v_C = v_L + v_R
\end{example}

\end{comment}
\begin{displaymath}
 	i_R 	= 	i_L = -i_C\,, \qquad\quad
	v_C 	= 	v_L +  v_R\,.  
\end{displaymath}
これらの方程式の組み合わせは(コンデンサに渡る電圧\( v_C \)とインダクタンスの
電流\( i_L \)にてまとめれば)回路の状態が以下の微分方程式のペアで説明されることを
示している。
\begin{comment}

\begin{example}
d v_C        i_L
-----  =  -  ---
 d t          C

d i_L      1           R
-----  =  --- v_C  -  --- i_L
 d t       L           L
\end{example}

\end{comment}
\begin{displaymath}
  {dv_C \over dt}  =  -{i_L \over C}\,, \qquad\quad
    {di_L \over dt}  =   {1   \over L} v_C - {R \over L} i_L\,. 
\end{displaymath}
この微分方程式のシステムを表す信号フロー図は\link{Figure 3.37}に示される。
\end{quote}

\begin{figure}[tb]
\phantomsection\label{Figure 3.36}
\centering
\begin{comment}
\heading{Figure 3.36:} A series RLC circuit.

\begin{example}
              + v_R -
        i_R
     +--->----'\/\/\,--------+
     |                       |  i_L
    \|/          R          \|/
  +  |  i_C                  |_   +
    -+-                       _)
v_C -+- C                     _)  v_L
     |                        _)
  -  |                       |    -
     +-----------------------+
\end{example}
\end{comment}
\includegraphics[width=60mm]{fig/chap3/Fig3.36.pdf}
\par\bigskip
\noindent
\heading{Figure 3.36:} 連続RLC回路
\end{figure}

\begin{quote}
引数として回路のパラメタ\( R \), \( L \), \( C \)と時間の増分\( dt \)を取る
手続き\code{RLC}を書け。ある意味では\link{Exercise 3.73}の\code{RC}手続きのそれに似ているが、
\code{RLC}は状態変数の初期値\( v_{C_0} \)と\( i_{L_0} \)を取り、(\code{cons}を用いて)
\( v_C \)と\( i_L \)の状態のストリームのペアを生成する手続きを生成せねばならない。
\code{RLC}を用いて、連結RLC回路の振舞をモデル化するストリームのペアを生成せよ。
ただし\( R \) = 1[Ω], \( C \) = 0.2[F], \( L \) = 1 henry, \( dt \)
= 0.1[s], soreni初期値 \( i_{L_0} \) = 0[A], \( v_{C_0} \) = 10[V]とする。
\end{quote}

\begin{figure}[tb]
\phantomsection\label{Figure 3.37}
\centering
\begin{comment}
\heading{Figure 3.37:} A signal-flow diagram for the solution to a series RLC circuit.

\begin{example}
                 +-------------+
+----------------+  scale: l/L |<--+
|                +-------------+   |
|                                  |
|                +-------------+   |  v_C
|       dv_C +-->|   integral  +---*------>
|            |   +-------------+
|            |        ^
|            |        | v_(C_0)
|            |
|            |   +-------------+
|            +---+ scale: -l/C |<--+
|                +-------------+   |
|  |\__                            |
+->|   \_  di_L  +-------------+   |  i_L
   | add_>------>|   integral  +---*------>
+->| __/         +-------------+   |
|  |/                 ^            |
|                     | i_(L_0)    |
|                                  |
|                +-------------+   |
+----------------+ scale: -R/L |<--+
                 +-------------+
\end{example}
\end{comment}
\includegraphics[width=68mm]{fig/chap3/Fig3.37a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.37:} 連続RLC回路の解のための信号フロー図
\end{figure}

\subsubsection*{正規順評価}

この節の例は明示的な\code{delay}と\code{force}の使用がどのようにして大きなプログラミングの
柔軟性を与えるかについて説明します。しかし同じ例がまたこのことがどのようにして私達の
プログラムをより複雑にするかについても示します。例として私達の新しい\code{integral}手続きは
ループを伴うシステムをモデル化するための力を与えます。しかし今では\code{integral}が
遅延化された被積分関数と共に呼び出されなければならないことを忘れてはならなくなりました。
そして\code{integral}を使用する全ての手続きはこのことについて注意しなければなりません。
実際には、手続きの2つの組を作りました。通常の手続きと遅延化された引数を取る手続きです。
一般的に、分離された手続きの組を作ることは私達に分離された高階手続きの組もまた作ることを
強います。\footnote{これはPascalの様な旧来の強い方の言語が高階手続きをこなす場合に持つ
困難さの(Lispにとっては)小さな反射です。そのような言語ではプログラマは必ず各手続きの引数と
結果のデータ型を指定せねばなりません。数値、論理値、配列、等です。その結果として
``与えられた手続き\code{proc}を列の全ての要素にmapする''ような抽象化を\code{stream\-/map}のような
単一の高階手続きにて表すことができませんでした。それどころか\code{proc}に
対して指定されるかもしれない異なる引数と結果のデータ型の組み合わせ全てに対して
異なるマッピング手続きを必要としました。高階手続きの存在における``データ型''の実用的な
概念を維持することは多くの困難な問題を提起しました。この問題を処理する1つの方法は
言語ML(\link{Gordon et al. 1979})により説明され、その``多層データ型''はデータ型間の
高階変換のためのテンプレートを含んでいます。さらにMLのほとんどの手続きデータ型は
明示的にプログラマにより宣言されることはありません。その代わりにMLは
\newterm{type\-/inferencing}(\jnewterm{型推論})メカニズムを含み、環境の情報を用いて新しく定義された
手続きのデータ型を推論します。}


2つの異なる手続きの組の必要性を防ぐ1つの方法は全ての手続きに対し遅延引数を取らせることです。
手続きに対する全ての引数が自動的に遅延化され、引数が実際に必要とされる時(例えばプリミティブ
命令に要求された時)強制される評価のモデルを受け入れることができるでしょう。これは
私達の言語を正規順評価を用いるように変形します。これは私達が\link{Section 1.1.5}の評価の置換
モデルを紹介した時、最初に説明しました。正規順評価への変換は統一、洗練された方法で
遅延評価の利用を簡易化します。そしてこれはストリーム処理のみについて考慮するのならば
受け入れるべき自然な戦略です。\link{Section 4.2}では評価機を学んだ後に、私達の言語をどのように
してこのように変形するのかについて学びます。残念なことに手続き呼出に遅延を導入することは
イベント順に依存するプログラムを設計する能力に混乱をもたらします。例えば代入を利用する、
データを変更する、入出力を実行するプログラムです。例え1つの\code{cons\-/stream}内の\code{delay}でも
\link{Exercise 3.51}や\link{Exercise 3.52}で説明された大きな混乱を招きます。誰もが知っている
ように、変更可能性と遅延評価はプログラミング言語の中でうまく混ざりません。
そしてこれらの両方を一度に取り扱う方法の発明は活発な研究領域です。

\subsection{関数型プログラムのモジュール化とオブジェクトのモジュール化}
\label{Section 3.5.5}


\link{Section 3.1.2}で学んだように、代入の導入の主な利点の1つは巨大システムの状態の一部を
ローカル変数の中にカプセル化、または``隠す''ことによりシステムのモジュール化の
容易性を増すことができます。ストリームモジュールは同等なモジュールの容易性を
代入の使用成しに提供可能です。例として\( \pi \)のモンテカルロ推定を再実装して
みましょう。\link{Section 3.1.2}にてこれをストリーム処理の視点から試しました。



モジュール化容易性の鍵となる問題は、乱数生成器の内部状態を乱数を使用するプログラムから
隠したいと願ったことです。手続き\code{rand\-/update}から始めました。これの連続する値が
私達の乱数を供給し、そしてこれを乱数生成器を作り出すのに使用しました。

\begin{scheme}
(define rand
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))
\end{scheme}

\noindent
ストリームの定式化においては乱数生成器が単体では存在しません。乱数のストリームがただ
\code{rand\-/update}を連続して呼ぶことで生成されます。

\begin{scheme}
(define random-numbers
  (cons-stream random-init
               (stream-map rand-update random-numbers)))
\end{scheme}

\noindent
これを用いて乱数ストリームにおける連続したペア上で行われたCes\`aro(チェザロ)の実験
の結果のストリームを構築します。

\begin{scheme}
(define cesaro-stream
  (map-successive-pairs
   (lambda (r1 r2) (= (gcd r1 r2) 1))
   random-numbers))
(define (map-successive-pairs f s)
  (cons-stream
   (f (stream-car s) (stream-car (stream-cdr s)))
   (map-successive-pairs f (stream-cdr (stream-cdr s)))))
\end{scheme}

\noindent
\code{cesaro\-/stream}が次に\code{monte\-/carlo}手続きに与えられます。これは確率の推測のストリームを
生成します。するとその結果は\( \pi \)の推測値のストリームへと変換されます。
このプログラムのこの版は何回試行を行うかのパラメタが必要ありません。より良い\( \pi \)の
推測値(より多くの試行からの)はより多くの\code{pi}ストリームを見ることで得られます。

\begin{scheme}
(define (monte-carlo experiment-stream passed failed)
  (define (next passed failed)
    (cons-stream
     (/ passed (+ passed failed))
     (monte-carlo
      (stream-cdr experiment-stream) passed failed)))
  (if (stream-car experiment-stream)
      (next (+ passed 1) failed)
      (next passed (+ failed 1))))
(define pi
  (stream-map
   (lambda (p) (sqrt (/ 6 p)))
   (monte-carlo cesaro-stream 0 0)))
\end{scheme}

\noindent
考慮すべきモジュール化容易性がこの取り組み方には存在します。なぜなら依然として
任意の実験を取り扱うことが可能な一般的な\code{monte\-/carlo}手続きを定式化できるためです。
その上、代入やローカル変数が存在しません。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.81}Exercise 3.81:} 
\link{Exercise 3.6}は乱数生成器に乱数列のリセットを許可することで``ランダム''な
数の列を繰り返し生成させる一般化について議論した。
入力ストリームの要求に従い操作する これと同じ生成器のストリーム定式化を実現せよ
ストリームの要素が\code{generate}なら新しい乱数を生成し、また\code{reset}なら指定された値に列をリセットすることで
希望の乱数列を生成する。
代入は使用しないこと。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.82}Exercise 3.82:} 
\link{Exercise 3.5}のモンテカルロ積分をストリームを用いて再度行え。
ストリーム版の\code{estimate\-/integral}は何度試行を行うのか伝える引数は持たない。
その代わり連続するより多くの試行を基に推測値のストリームを生成する。
\end{quote}

\subsubsection*{時間の関数型プログラミング的視点}


さて、この章の始めに提起されたオブジェクトと状態の問題に戻り新しい光の下で調査
しましょう。私達は代入とミュータブルオブジェクトを導入し状態を持つシステムのモデル化
を行うプログラムのモジュラー方式の構築のための仕組みを提供しました。ローカル状態変数
を持つ計算オブジェクトを構築し、代入を用いてこれらの変数を変更しました。
世界のオブジェクトの一時的な振舞を相当する計算オブジェクトの一時的な振舞により
モデル化しました。



今までストリームが局所状態を持つオブジェクトのモデル化する代替法を提供することを学んで
きました。何らかのオブジェクトの局所状態のような変化する数量を、連続する状態の時刻歴を
表現するストリームを用いてモデル化できます。
本質的に、私達はストリームを用いることで時間を明示的に表現しています。そうすることで
私達のシミュレートされた世界の時間を評価の間に現れる一連のイベントから分断しています。
実際に、\code{delay}の存在のため、モデルのシミュレートされた時間と評価中のイベントの順の
間には何の関係も無いでしょう。



これらの2つのモデル化の取り組み方を対比するために、``銀行の引き出し機''の実装について
再考してみましょう。これは銀行口座の残高を監視します。\link{Section 3.1.3}ではそのような処理機
の単純化された版を実装しました。

\begin{scheme}
(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
\end{scheme}

\noindent
\code{make\-/simplified\-/withdraw}への呼出は計算オブジェクトを生成します。各計算
オブジェクトは局所状態変数\code{balance}を個別に持ち、そのオブジェクトを続けて呼ぶと
\code{balance}は減少します。銀行口座のユーザが連続したそのようなオブジェクトに対する
入力を打ち、ディスプレイの画面に表われる一連の返り値を観察するのを想像できます。


代替的に、引き出し処理機を入力として残高と引き出す金額のストリームを取り口座の一連の
残高のストリームを生成する手続きとしてモデル化することが可能です。

\begin{scheme}
(define (stream-withdraw balance amount-stream)
  (cons-stream
   balance
   (stream-withdraw (- balance (stream-car amount-stream))
                    (stream-cdr amount-stream))))
\end{scheme}

\noindent
\code{stream\-/withdraw}は明確な数学上の関数を実装し、関数の出力はその入力のみにより
完全に決定します。しかし入力\code{amount\-/stream}がユーザにより打鍵された一連の値の
ストリームであり結果の残高ストリームが表示されたと考えてみて下さい。すると、
値を入力し結果を見ているユーザの視点からはストリーム処理が\code{make\-/simplified\-/withdraw}に
より作成されたかのように、同じ振舞をしています。
しかしストリーム版では代入が無く、局所状態変数が無く、それ故に\link{Section 3.1.3}で遭遇した
論理的な困難に存在しません。それにもかかわらずシステムは状態を持っています！



これは本当に驚くべきことです。\code{stream\-/withdraw}は明確な数学上の関数を実装し
その振舞は代わらないのに、ここでのユーザの知覚はシステムとの相互作用の1つであり変化
する状態を持ちます。このパラドックスを解決する1つの方法はユーザの一時的な存在が
システムに状態を与えていると認識することです。もしユーザが相互作用から一歩離れて
個々の取引でなく、残高のストリームに関して考えれば、システムはステートレス(状態が
無く)として現われるでしょう。\footnote{物理でも同様に、私達が移動点を観察する時、
点の位置(状態)は変化していると言えます。しかし、移動点の時空の世界線の視点からは
何の変化も起こってはいません。}



複雑な処理のある部分の視点からは、他の部分は時間と共に変化するように見えます。
それらは隠された時間と伴に変化する局所状態を持ちます。もし私達がこの種の自然な
分解を私達の世界において(世界の一部である私達の視点から見たままに)計算機内の
モデル化したプログラムを計算機内の構造を用いて書きたいのならば、関数型でない
計算オブジェクトを作成します。それらは時間と共に変化します。状態を局所状態変数で
モデル化し、そして状態の変化をそれらの変数への代入を用いてモデル化します。
これを行うことにより計算の実行時間を、私達がその一部である世界の時間のモデルと
し、従って私達は``オブジェクト''を計算機の中に得ることになります。



オブジェクトを用いるモデリングは強力、かつ直感的です。その理由の多くはこれが
私達がその一部である世界との相互作用の視点に合うためです。
しかしこの章を通して繰り返し学んできた様に、これらのモデルは悩ましい
イベント順の制約とと複数の処理間の同期の問題を提起します。
これらの問題を防ぐ可能性から\newterm{functional programming languages}(\jnewterm{関数型プログラミング言語})の
開発が促進されてきました。これは代入や変更可能なデータを提供しません。そのような言語では
全ての手続きは引数の明確な数学の関数を実装し、その振舞は変化しません。関数型の取り組み方は
並行システムを扱うのにとても魅力的です。\footnote{Fortranの開発者であるJohn Backusは
1978年に\acronym{ACM}のチューリング賞を授与された時に関数型プログラミングに高い知名度を
与えました。彼の受賞スピーチ(\link{Backus 1978})は関数型のアプローチを強く支持しました。
関数型プログラミングの良い概観は\link{Henderson 1980}と\link{Darlington et al. 1982}で
与えられます。}


一方で、もしきっちりと見てみれば時間に関係する問題が関数型のモデルにも潜んでいることが見えます。
ある特に厄介な領域がインタラクティブシステム(応答システム)を設計したい時に、特に独立した要素の間で相互作用を
行うシステムにおいて提起されます。例として、もう1度連結銀行口座を許可する銀行システムについて
考えてみましょう。代入とオブジェクトを用いる保守的なシステムでは、PeterとPaulが口座を共有している
という事実をモデル化します。共有は\link{Section 3.1.3}で見たように、PeterとPaulの両者が彼等の取引要求を
同じ銀行口座オブジェクトに送ることにより行われます。ストリームの視点からは、``オブジェクト''それ自身は
無いため、銀行口座を取引要求の操作を行う処理としてモデル化し、応答のストリームを生成できる
ことが既に示されています。従って、PeterとPaulが連結銀行口座を持つことが、\link{Figure 3.38}で示すように
Peterの取引要求ストリームとPaulの取引要求リクエストをマージし、その結果を銀行口座ストリーム処理へ渡すと
いう事実をモデル化することができるでしょう。

\begin{figure}[tb]
\phantomsection\label{Figure 3.38}
\centering
\begin{comment}
\heading{Figure 3.38:} A joint bank account, modeled by merging two streams of transaction requests.

\begin{example}
Peter's requests   +---------+     +---------+
------------------>|         |     |         |
Paul's requests    |  merge  |---->| bank    |---->
------------------>|         |     | account |
                   +---------+     +---------+
\end{example}
\end{comment}
\includegraphics[width=88mm]{fig/chap3/Fig3.38.pdf}
\begin{quote}
\heading{Figure 3.38:} 取引要求リクエストの2つのストリームをマージすることでモデル化した連結銀行口座
\end{quote}
\end{figure}

この定式化に伴う問題は\newterm{merge}(\jnewterm{マージ})という概念にあります。これは2つの
ストリームを単純に交互にPeterの要求を1つ、Paulの要求を1つと取りマージすることは
しません。Paulが口座にとても稀にしかアクセスしないと考えてみましょう。
Peterに対し、彼が2つ目の取引を発行できる前にPaulが口座にアクセスするのを待つよう
強いることはできません。しかしそのようなマージが実装された場合、
PeterとPaulにより知覚される``実時間''に制約された何らかの方法で2つの取引ストリームを
相互配置しなければなりません。何らかの方法とはもしPeterとPaulが会えば、いくつかの取引が会う
前に処理され、他の取引が会った後に処理されることに合意できるという意味でです。\footnote{任意の
2つのストリームに対し一般的に複数の受け入れ可能な相互配置の順が存在することに
注意して下さい。従って技術的には``マージ''は関数ではなく関係です。その答は
入力の決定的な関数ではありません。私達は既に(\link{Footnote 39})で非決定論が
並行の扱いの本質であると述べました。マージの関係は同じ本質的な非決定論を関数型の
視点から説明します。\link{Section 4.3}では非決定論をまた別の視点から見ることになります。}
これは正確に、\link{Section 3.4.1}で扱わねばならなかったのと同じ制約です。そこでは状態を
持つオブジェクトの並行処理におけるイベントの``正しい''順を保証する明示的な同期の
導入の必要性が見つかりました。従って、関数型のスタイルをサポートする取り組みにおいて、
異なる要因からの入力のマージの必要性は関数型のスタイルが排除するはずだった同じ問題
を再び導入します。


私達はこの章を、私達がモデル化しようとする実際の世界の私達の視点に合う構造を持つ
計算モデルの構築をゴールとして始めました。
世界を分離した、時間制約のある、相互応答する、状態を持つオブジェクトでモデル化できます。
または世界を単一の、時間制約のない、状態の無い、個体によりモデル化できます。
それぞれの視点が強力な利点を持ちますが、どちらの視点も単独では十分ではありません。
大統一は未だ現われてはいません。\footnote{オブジェクトモデルは世界を分割し分離した
部分にすることで近似します。関数型モデルはオブジェクト境界に従ってモジュラ化はしません。
オブジェクトモデルは``オブジェクト''の非共有下の状態が共有されている状態よりも
とても大きい場合に便利です。オブジェクトの視点が失敗する場合の例は量子力学です。
そこでは物を個別の点として考えることは逆説と混乱を招きます。オブジェクトの視点を
関数型の視点と統一することはプログラミングとはあまり関係が無いかもしれません。
しかしより根本的な認識論の問題と関係するのです。}

\chapter{メタ言語抽象化}
\label{Chapter 4}

\begin{quote}


\( \dots \) 魔法とは言葉の中にある---アブラカダブラ、開けゴマ、その他もろもろ---しかしあるお話の
魔法の言葉は次のお話では魔法ではない。真の魔法とはどの言葉が、いつ、何に対して働くか
を知ることだ。トリックを学ぶことがトリックなんだ。



\( \dots \) そしてそれらの言葉は私達のアルファベットの文字から出来ている。
ペンで書ける2、3ダースの走り書きだ。これが鍵なんだ！
そして宝でもある、もしそれに手をつけることさえできれば！
それはまるで---まるで宝の鍵こそが宝のようだ！

---John Barth, \textit{Chimera}
\end{quote}

\vspace{0.8em}

\noindent
プログラム設計の学習において、エキスパートなプログラマが設計の複雑さを
全ての複雑なシステムの設計者が用いるのと同じ一般的な技術を用いてコントロール
することを学んできました。彼等はプリミティブな要素を接続して複合オブジェクトを
形成し、複合オブジェクトを抽象化することでより高いレベルの建築ブロックを形成し
そして適切な大規模のシステム構造の見方を受け入れることでモジュール化方式は維持しました。
これらのテクニックの説明において、私達はLispをプロセスを記述するための言語として
用い、また計算データオブジェクトと実世界の複雑な現象をモデル化する処理を構築する
ためにも用いてきました。しかし、複雑さを増す問題に取り組むにつれ、Lisp、または
どのような固定されたプログラミング言語も、我々の必要には十分でないことを知る
ことでしょう。私達は、私達の考えをより効果的に表現するために、耐えず新しい言語に
向かわねばなりません。新しい言語を定めることは工学上の設計の複雑さをコントロール
するための強力な戦略です。私達は良く、問題を異なった方法
で記述できる(そしてそれ故に考えることができる)新しい言語を受け入れることで、
複雑な問題への対処能力を拡張することができます。プリミティブな、組み合わせの
手段や抽象化の手段を、目前の問題に特によく合ったものを用います。\footnote{同じ考えが
工学全てに渡り普及しています。例えば電子工学は多くの異なる言語を回路の記述に
用います。これらの内2つは電子ネットワークの言語と電子システムの言語です。
ネットワーク言語は別個の電子素子に関する装置の物理モデリングを重視します。
ネットワーク言語のプリミティブなオブジェクトはプリミティブな抵抗や、キャパシタ(コンデンサ)、
コイルやトランジスタ等の電子コンポーネントであり電圧と電流と呼ばれる物理的変数を
用いて特徴付けられます。回路をネットワーク言語で記述する時、技術者は設計の物理
特性に関心を持ちます。逆に、システム言語のプリミティブなオブジェクトはフィルタや
アンプのような信号処理モジュールです。モジュールの機能上の振舞のみが関係し、信号は
それらの電圧や電流のような物理的な認識に関心を持ちません。
信号処理システムの要素が電子ネットワークから構築
される意味の上ではシステム言語はネットワーク言語の上に組み立てられます。
しかしここでは関心事は与えられた応用問題を解くための大規模な電子装置の編成にあります。
パーツの物理的実現可能性は当然と考えられています。この階層化された言語の集合は
\link{Section 2.2.4}の図形言語にて説明された階層化された設計テクニックのまた別の
例になります。}



プログラミングは数多くの言語により生じます。特定のコンピュータのための
機械語のような物理言語も存在します。これらの言語は個別のストレージの断片と
プリミティブな機械命令を用いてデータとコントロールの表現に関係します。
機械語プログラマは与えられたハードウェアの使用に関心を持つことでリソースに
限りある演算の効率的な実装のためのシステムとユーティリティを組み立てます。
高級言語は機械語の素地の上にありますが、データをビットの集合として表したり、
プログラムをプリミティブな命令の列で表すという懸念を隠します。これらの言語は
手続き定義のような組み合わせと抽象化の手段を持ち大規模なシステム構成に適しています。



\newterm{Metalinguistic abstraction}(\jnewterm{メタ言語抽象化})---新しい言語を構築すること---が
工学設計の全ての部門にて重要な役割を果たします。これは計算機プログラミングでとても
重要です。プログラミングでは新しい言語を形成するだけでなく、これらの言語を評価機を
構築することで実装することもできるからです。プログラミング言語の\newterm{evaluator}(\jnewterm{評価機})(または
\newterm{interpreter}(\jnewterm{インタプリタ}))は手続きであり、言語の式に対して適用された時、
その式を評価するために要求される行動を実行します。



プログラミングにおける考えで最も根本的な物と見做すことに何の誇張もありません。

\begin{quote}
評価機はプログラミング言語の評価手段を決定するが、それ自体は別のプログラムである。
\end{quote}

\noindent
この点を理解することはプログラマとしての私達自身のイメージを変更することです。
私達は私達自身を、他人が設計した言語のユーザとしてのみではなく、
言語の設計者として見る時点に辿りつきました。


実際に、私達はほとんど全てのプログラムをある言語の評価機だと見做すことができます。
例えば、\link{Section 2.5.3}の多項式操作システムは多項式の数値演算のルールを具象化し、
リスト構造データ上の命令を用いて実装しました。もし私達がこのシステムを多項式を
読み込み、表示する手続きと共に拡張したなら、記号数学の問題を扱う特定目的言語の
コア(核)を持つことになります。\link{Section 3.3.4}のデジタル論理シミュレータと\link{Section 3.3.5}の
制約伝播はそれら自身の正しさにおける論理的言語であり、それぞれがそれ自身の
プリミティブと組み合わせの手段、抽象化の手段を持ちます。この視点から見れば
大規模計算機システムをこなす技術は新しい計算機言語を構築する技術と結合し、
計算機科学それ自身が適切な記述言語を構築する分野それ以上でも以下でもなくなります。



私達は今から他言語を用いて言語が構築される技術を巡り始めます。この章では
Lispを基盤として用い、評価機をLispの手続きとして実装します。Lispはこの任務に
とても良く合います。記号式を表現し、操作する能力がその理由です。
私達はLisp自身の評価機を構築することで言語がどのように実装されているかを
理解することから最初の一歩を踏み出します。私達の評価機により実装される
言語はこの本で用いるLipsのScheme方言の部分集合となります。この章で説明される
評価機がLispの特定の方言に向けて書かれていても、逐次式計算機のプログラムを
書くために設計された任意の式指向言語のための評価機の本質的な構造を含みます。
(実際に、多くの言語処理機がそれらの奥深くに小さな``Lisp''評価機を含んでいるのです。)
評価機は説明と議論のために簡略化されており、製品品質のLispシステム
に含まれるべき重要な機能が省略されています。
それにもかかわらず、この単純な評価機はこの本に現われる多くのプログラムを実行するのに
適しています。\footnote{私達の評価機が取り除いた最も重要な機能はエラーを扱う仕組みと
デバッグのサポートです。評価機のより広範囲の議論については\link{Friedman et al. 1992}を
参照して下さい。これはSchemeで書かれた一連の評価機を通して進められたプログラミング言語
の解説を与えます。}


評価機をLispプログラムとして利用可能にする重要な利点は代替となる評価ルールを
評価機プログラムへの変更として記述することで実装できることです。
この力を良い効果として用いることが可能な箇所として、\link{Chapter 3}の議論の
まさに中心であった、計算モデルが時間の概念を統合する方法に対し特別な
コントロールを得ることです。そこではストリームを用いて世界の時間表現を計算機の
時間から分離することで、状態と代入の複雑さのいくらかを緩和しました。
しかし、私達のストリームプログラムは時々扱いにくい物でした。Schemeの評価の
適用順により制約されていたためです。
\link{Section 4.2}ではより洗練された取り組み方を準備するために、
\newterm{normal-order evaluation}(\jnewterm{正規順評価})に対応する様に評価機を変更することで
基盤となる言語を変更します。


\link{Section 4.3}では式が単一の値のみでなく多くの値を持つ場合において、より野心的な言語の変更を実装します。
この\newterm{nondeterministic computing}(\jnewterm{非決定的演算})の言語においては、式の
全ての可能な値を生成する過程を生成し、次にそれらの値からいくつかの
制約を充足する値を探索することが自然に表現できます。。計算と時間のモデルにを用いれば、これは``可能な未来''の集合
を成す時間の分岐を持ち、次に適切な時系列を探すような物です。私達の
非決定的評価機を用いる複数の値の追跡と探索の実行は、根底に存在する言語の
仕組みにより自動的に取り扱われます。



\link{Section 4.4}では\newterm{logic\-/programming}(\jnewterm{論理プログラミング})言語を実装します。
それにより知識が入出力を伴なう計算を用いてではなく、関係性を用いて表現されます。
これは言語をLispから、または本当に全ての従来の言語から大幅に異なる物にしますが、
論理プログラミング評価機がLisp評価機の本質的な構造を共有することを学びます。



\section{メタ循環評価機}
\label{Section 4.1}



私達のLisp評価機はLispプログラムとして実装されます。LispプログラムをLispで実装
された評価機を用いて評価することについて考えることは循環論に見えるかもしれません。
しかし評価はプロセス(処理、過程)であり、従って評価過程をLispを用いて説明することは適切
です。Lispは結局の所、プロセスを記述するためのツールなのです。\footnote{例え
そうだとしても、私達の評価機により説明されない評価プロセスの重要な側面が残り
ます。これらの最も重要なことは手続きが他の手続きを呼び出し、そしてそれらを呼び出した
物に値を返す原因となる詳細な仕組みです。これらの問題は\link{Chapter 5}で解明
します。そこで私達は評価機を簡単なレジスタマシンとして実装することで評価プロセスに
より詳細に調べます。}評価する対象と同じ言語で書かれた評価機は
\newterm{metacircular}(\jnewterm{メタ循環})と呼ばれます。


メタ循環評価機は本質的には\link{Section 3.2}で説明された評価の環境モデルのScheme形式化です。
モデルには以下の2つの基本的パーツがあることを思い出して下さい

\begin{enumerate}

\item
組み合わせ(特殊な形式を除く複合式)を評価するためには、部分式を評価し、次に
演算子部分式をオペランド部分式の値に適用する。

\item
複合手続きを引数の集合に適用するためには、手続きのボディを新しい環境で評価する。
この環境を構築するためには、手続きオブジェクトの環境部分をフレームにより拡張する。
フレームの中ではその手続きの形式パラメタが、その手続きが適用される引数に対して
束縛される
\end{enumerate}

\noindent
これら2つのルールが評価プロセスの本質を説明します。環境の中で式が評価される
基本的なサイクルは引数に適用される手続きに簡約され、引数は順に新しい環境で評価される
新しい式へと簡約され、以下、値がその環境の中で見つかるシンボルか直接適用される
プリミティブな手続き(\link{Figure 4.1}参照)に辿り着くまで繰り返されます。\footnote{
もし私達自身にプリミティブを適用する能力を与えるのであれば、評価機の実装には何が残って
いるのでしょうか? 評価機の仕事は言語のプリミティブを指定することではなく、
結合組織---組み合わせと抽象化の手段---を提供することであり、それがプリミティブの
集合を言語を形成するために束縛します。具体的には、



\( \bullet \) 評価機は入れ子の式の取扱を許可します。例えば単純にプリミティブを適用することは
式\code{(+ 1 6)}を評価するのには十分ですが、\code{(+ 1 (* 2 3))}を取り扱うには十分ではありません。
プリミティブな手続き\code{+}が対象である限り、その引数は数値でなければならなず、もし
式\code{(* 2 3)}を引数として渡せば失敗します。評価機の重要な役割の1つは手続き合成を演出することで、
\code{(* 2 3)}を\code{+}に引数として渡す前に6に簡約します。



\( \bullet \) 評価機は変数の使用を許可します。例えば加算のためのプリミティブな手続きは
\code{(+ x 1)}のような式に対応する手段を持ちません。私達は評価機に変数を追跡しその値を
プリミティブな手続きを実行する前に得るようにする必要があります。



\( \bullet \) 評価機は複合手続きの定義を許可します。これは手続き定義の追跡を含み、
これらの手続きを式評価においてどのように使用するかを知っています。そして手続きに
引数を受け入れることを許可する仕組みを提供します。


\( \bullet \) 評価機は特殊形式を提供します。これは手続き呼出と異なった形で評価されねば
なりません。} 


この評価サイクルは評価機内の2つの重大な手続き、\code{eval}と\code{apply}の間の相互作用により
具体化されます。これらの手続きは\link{Section 4.1.1}にて説明されます。(\link{Figure 4.1}参照)



評価機の実装は評価される式の\newterm{syntax}(\jnewterm{構文})を定義する手続きに依存します。
私達はデータ抽象化を用いて評価機を言語の表現に非依存にします。
例えば代入はシンボル\code{set!}で始まるリストにより表現されるべきという選択に
委ねるのではなく、代入のためのテストに抽象述語\code{assignment?}を用い、そして
代入の部品にアクセスするために抽象セレクタ\code{assignment\-/variable}と\code{assignment\-/value}を
用います。式の実装については\link{Section 4.1.2}で詳細に説明されます。また\link{Section 4.1.3}で
説明される``命令''もあり、これは手続きと環境の表現を指定します。例えば\code{make\-/procedure}は
複合手続きを構築し、\code{lookup\-/variable\-/value}は変数の値にアクセスし、
\code{apply\-/primitive\-/procedure}はプリミティブな手続きを与えられた引数のリストに対し
適用します。

\begin{figure}[tb]
\phantomsection\label{Figure 4.1}
\centering
\begin{comment}
\heading{Figure 4.1:} The \code{eval}-\code{apply} cycle exposes the essence of a computer language.

\begin{example}
                           .,ad88888888baa,
                  _    ,d8P"""        ""9888ba.      _
                 /  .a8"          ,ad88888888888a   |\
               /   aP'          ,88888888888888888a   \
              /  ,8"           ,88888888888888888888,  \
             |  ,8'            (888888888888888888888, |
            /  ,8'             `8888888888888888888888  \
            |  8)               `888888888888888888888, |
Procedure,  |  8                  "88888 Apply 8888888) | Expression
Arguments   |  8     Eval          `888888888888888888) | Environment
            |  8)                    "8888888888888888  |
            \  (b                     "88888888888888'  /
             | `8,                     8888888888888)  |
             \  "8a                   ,888888888888)  /
              \   V8,                 d88888888888"  /
              _\| `8b,             ,d8888888888P' _/
                     `V8a,       ,ad8888888888P'
                        ""88888888888888888P"
                             """"""""""""

                               [graphic by Normand Veillux, modified]
\end{example}
\end{comment}
\includegraphics[width=100mm]{fig/chap4/Fig4.1.pdf}
\begin{quote}
\heading{Figure 4.1:} \code{eval}-\code{apply}サイクルがコンピュータ言語の本質を顕在化させる
\end{quote}
\end{figure}



\subsection{評価機の核}
\label{Sec. 4.1.1}
\label{Section 4.1.1}



評価プロセスは2つの手続き\code{eval}と\code{apply}の相互作用であると説明可能です。

\subsubsection*{Eval}



\code{eval}は引数として式と環境を取ります。これは式と分類しその評価を監督します。
\code{eval}は評価される式の構文上の方の事例分析として構造化されます。
手続きの一般性を保つため、式の型の決定を抽象的に表現し、多種の式に対するどんな
特定の表現にも委託しません。式の各型はそれをテストする述語と、その部分を選択する
抽象手段を持ちます。この\newterm{abstract syntax}(\jnewterm{抽象構文})は同じ評価機を用いつつ、
異なる構文手続きの集合と合わせることで、言語の文法をどのようにして変更できるかについて
知ることを簡単にします。

\noindent
\textbf{プリミティブな式}

\begin{itemize}

\item
数値のような自己評価式に対しては\code{eval}は式それ自身を返す。

\item
\code{eval}は環境の中で変数をその値を見つけるために探さなければならない。

\end{itemize}

\noindent
\textbf{特殊形式}

\begin{itemize}

\item
クォートされた式に対しては\code{eval}はクォートされた式を返す。

\item
変数への代入(または定義)は再帰的に\code{eval}を呼び出し変数に関連付けられる新しい値を
計算しなければならない。環境は変数の束縛を変更(または作成)しなければならない。

\item
\code{if}式はその部品に対し特別な処理を要求する。もし述語が真であれば
consequent(結果)を評価し、そうでなければalternative(代替)を評価するためである。

\item
\code{lambda}(ラムダ)式は適用可能な手続きに変形しなければならない。変形はラムダ式により
指定されたパラメタとボディを評価の環境と共にパッケージ化することにより行う。

\item
\code{begin}式はその一連の式をそれらが現れる順で評価する必要がある。

\item
事例分析(\code{cond})は入れ子の\code{if}式に変形し、それから評価する。

\end{itemize}

\noindent
\textbf{組み合わせ}

\begin{itemize}

\item
手続きの適用に対して、\code{eval}は再帰的に組み合わせの演算子とオペランドの部分を評価
しなければならない。結果となる手続きと引数は\code{apply}に渡す。これは実際の
手続き適用を取り扱う。

\end{itemize}

\noindent
以下に\code{eval}の定義を示します。

\begin{scheme}
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type: EVAL" exp))))
\end{scheme}

\noindent
明快さのために、\code{eval}は\code{cond}を用いた条件分岐として実装されています。
これの欠点は手続きがいくつかの判別可能な式の型のみを取り扱い、\code{eval}の
定義を編集すること無しに新しい式が定義できないことです。多くのLisp実装では
式の型に従う呼出はデータ主導スタイルにより行われています。これはユーザに
\code{eval}が判別可能な新しい式の型の追加を許可します。\code{eval}自身の定義の
変更は必要有りません。(\link{Exercise 4.3}参照)

\subsubsection*{Apply}


\code{apply}は2つの引数、手続きと手続きが適用されるべき引数のリストを取ります。
\code{apply}は手続きを2つ種類に分類します。プリミティブの適用には
\code{apply\-/primitive\-/procedure}を呼びます。複合手続きの適用には手続きのボディを
作る式を連続して評価することにより行います。複合手続きのボディの評価のための
環境は手続きにより運ばれた基礎環境を拡張することで構築し、手続きのパラメタを手続きが
適用される引数に束縛するフレームを含めます。以下が\code{apply}の定義です。

\begin{scheme}
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type: APPLY" procedure))))
\end{scheme}

\subsubsection*{手続きの引数}



\code{eval}が手続き適用を処理する時、\code{list\-/of\-/values}を用いて手続きが適用される引数の
リストを生成します。\code{list\-/of\-/values}は引数として組み合わせのオペランドを取ります。
各オペランドを評価し対応する値のリストを返します。\footnote{\code{eval}の
\code{application?}節は明示的に\code{list\-/of\-/values}手続きを書くのではなく、\code{map}を
用いることで(そして\code{operands}がリストを返すよう規定することで)より単純にすることが
できました。ここでは\code{map}を用いないことを選択することで高階手続きを用いなくとも、
例え評価機がサポートする言語が高階手続きをサポートすることになっても、評価機が
実装できることを強調しました。(従って高階手続きを持たない言語で評価機を書くことも可能です)。}

\begin{scheme}
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
\end{scheme}

\subsubsection*{条件文}


\code{eval\-/if}は与えられた環境において\code{if}式の述語部分を評価します。
もし結果が真なら\code{eval\-/if}はconsequent(結果)を評価し、そうでなければ
alternative(代替)を評価します。

\begin{scheme}
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
\end{scheme}

\noindent
\code{eval\-/if}内での\code{true?}の使用は実装言語と被実装言語の間の接続の問題を強調します。
\code{if\-/predicate}は被実装言語にて評価されるのでその言語の値を生じます。
インタプリタの述語\code{true?}はその値を実装言語の\code{if}でテストできる値に翻訳します。
真実性のメタ循環表現は根底をなすSchemeのそれとは同じではないかもしれません。\footnote{今回は
実装言語と被実装言語は同じです。ここでの\code{true?}の意味に対する熟考は本質を誤解
することなく理解の発展を促します。}

\subsubsection*{列}



\code{eval\-/sequence}は\code{apply}により用いられ手続きのボディの中にある連続した式を
評価します。また\code{eval}でも使用され\code{begin}式の中の一連の式を評価します。
引数として一連の式と環境を取り、式が現われる順で評価します。返り値は最後の
式の値です。

\begin{scheme}
(define (eval-sequence exps env)
  (cond ((last-exp? exps)
         (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))
\end{scheme}

\subsubsection*{代入と定義}


以下の手続きは変数への代入を扱います。\code{eval}を呼び代入される値を見つけ
値と結果となる変数を\code{set\-/variable\-/value!}へ転送することで指定された
環境へ設定されるようにします。

\begin{scheme}
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)
\end{scheme}

\noindent
変数の定義は同様の方法で扱われます。\footnote{この\code{define}の実装は内部定義の
扱いの微妙な問題を無視します。しかし多くの場合では正しく動きます。問題が何か、
どのようにして解決するかについては\link{Section 4.1.6}で学びます。}

\begin{scheme}
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)
\end{scheme}

\noindent
ここで代入、または定義の値としてシンボル\code{ok}を返すことを選択しました。\footnote{\code{define}と
\code{set!}を導入した時に述べたように、これらの値はSchemeの実装依存です---つまり、
実装者がどんな値を返すのか選択できます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.1}Exercise 4.1:} 
メタ循環評価機がオペランドを左から右へ評価するのか、右から左へなのか
判断が付かないことに注意せよ。評価順は下位に横たわるLispから継承する。もし
\code{list\-/of\-/values}内の\code{cons}の引数が左から右へ評価されるのなら、
\code{list\-/of\-/values}はオペランドを左から右へと評価する。もし\code{cons}の引数が
右から左へ評価されるなら、\code{list\-/of\-/values}は右から左へ評価する。



オペランドを左から右へと下位に横たわるLispの評価順に係らず評価する\code{list\-/of\-/values}の
版を書け。またオペランドを右から左へ評価する\code{list\-/of\-/values}の版も書け。
\end{quote}

\subsection{式の表現}
\label{Sec. 4.1.2}
\label{Section 4.1.2}



評価機は\link{Section 2.3.2}で議論された記号微分プログラムを思い出させます。
双方のプログラムが記号式を操作します。両方のプログラムにおいて、複合式上の操作の
結果は式の断片を再帰的に操作し、式の型に依存した方法で結合することにより決定します。
両方のプログラムにおいて、私達はデータ抽象化を用いて式がどのように表現されるかの
詳細から命令の一般的なルールを分離します。微分プログラムではこのことが、同じ微分手続きが
接頭辞形式、接中辞形式、またはいくつかの他の形式の代数式を扱えることを意味しました。
評価機にとっては、これは評価される言語の文法がもっぱら式を分類し、断片を抽出する
手続きにより決定されることを意味します。


以下に私達の言語の構文の仕様を示します。

\begin{itemize}

\item
自己評価アイテムは数値と文字列のみです。

\begin{scheme}
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
\end{scheme}

\item
変数はシンボルにより表現されます。

\begin{scheme}
(define (variable? exp) (symbol? exp))
\end{scheme}

\item
引用は\code{(quote <\var{text\-/of\-/quotation}>)}の形式を持ちます。\footnote{\link{Section 2.3.1}で
述べたとおり、評価機は引用(quote)された式を\code{quote}で始まるリストだと見ます。
例え式がクォーテーションマークで入力されていてもです。例えば式\code{'a}は
この評価機では\code{(quote a)}と見られます。\link{Exercise 2.55}を参照して下さい。}

\begin{scheme}
(define (quoted? exp) (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))
\end{scheme}


\code{quoted?}は手続き\code{tagged\-/list?}を用いて定義されます。これはリストが指定された
シンボルで開始するかを判断します。

\begin{scheme}
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
\end{scheme}

\item
代入は\code{(set! <\var{var}> <\var{value}>)}の形式を取ります。

\begin{scheme}
(define (assignment? exp) (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
\end{scheme}

\item
定義は以下の形式を取ります。

\begin{scheme}
(define ~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark value}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
または以下の形式になります。

\begin{scheme}
(define (~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark parameter_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark parameter_n \)~~\( \dark \rangle \)~)
  ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}


後者の形式(標準手続き定義)は以下に対する構文糖です。

\begin{scheme}
(define ~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~
  (lambda (~\( \dark \langle \)~~\( \dark parameter_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark parameter_n \)~~\( \dark \rangle \)~)
    ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~))
\end{scheme}



対応する構文手続きは以下となります。

\begin{scheme}
(define (definition? exp) (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)     ~\textrm{; formal parameters}~
                   (cddr exp))))   ~\textrm{; body}~
\end{scheme}

\item
\code{lambda}式はシンボル\code{lambda}で始まるリストです。

\begin{scheme}
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
\end{scheme}


また\code{lambda}式に対するコンストラクタも提供します。これは
上記の\code{definition\-/value}で使用されます。

\begin{scheme}
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
\end{scheme}

\item
条件式は\code{if}で始まり述語、結果式を持ち、(任意で)代替式を持ちます。もし式が代替式
の部分を持たないのであれば代替式として\code{false}を与えます。\footnote{述語がfalseになり
代替式が存在しない場合の\code{if}式の値はSchemeでは未定義です。ここでは私達はfalseにする
ことを選択しました。私達は変数\code{true}と\code{false}の式内での利用をサポートし、グローバル
環境でのそれらの束縛により評価されるようにします。\link{Section 4.1.4}参照。}

\begin{scheme}
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
\end{scheme}



また\code{if}式に対するコンストラクタも提供します。これは\code{cond\-/>if}により
\code{cond}式を\code{if}式に変換するのに用いられます。

\begin{scheme}
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
\end{scheme}

\item
\code{begin}は一連の式を1つの式へとまとめます。\code{begin}式から実際の列を取り出す命令と同時に、
列の最初の式とその残りの式を返すセレクタも含まれます。\footnote{式のリストに対する
これらのセレクタ---それに対応するオペランドのリスト向けのものも含めて---はデータ抽象化を
意図するものではありません。それらは基本的なリスト命令のためのmnemonic(ニーモニック)名として
\link{Section 5.4}にて明示的コントロール評価機を理解することを易しくするために導入されます。}

\begin{scheme}
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
\end{scheme}


また\code{cond\-/>if}で用いるコンストラクタ\code{sequence\-/>exp}も含めます。これは
列を単一の式に、必要ならば\code{begin}を用いて、変換します。

\begin{scheme}
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))
\end{scheme}

\item
手続きの適用は上記の式の型ではない任意の複合式です。その式の\code{car}は演算子であり、
\code{cdr}はオペランドのリストです。

\begin{scheme}
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
\end{scheme}

\end{itemize}

\subsubsection*{派生式}


いくつかの私達の言語内での特殊形式は直接実装されるのでなく、他の特殊形式を含む式を用いて定義できます。
例の1つは\code{cond}です。これは入れ子の\code{if}式として実装できます。例えば以下の式の評価上の
問題を、

\begin{scheme}
(cond ((> x 0) x)
      ((= x 0) (display 'zero) 0)
      (else (- x)))
\end{scheme}

\noindent
次の\code{if}と\code{begin}の式を含む式の評価問題へと簡約することができます。

\begin{scheme}
(if (> x 0)
    x
    (if (= x 0)
        (begin (display 'zero) 0)
        (- x)))
\end{scheme}

\noindent
\code{cond}の評価をこのように実装することは評価機を簡略化します。評価過程が明示的に
指定されねばならない特殊形式の数を減らすことができるからです。



\code{cond}式の部分を抽出する構文手続きと\code{cond}式を\code{if}式に変形する式\code{cond->if}を
含めます。事例分析は\code{cond}で始まり述語-行動節のリストを持ちます。節はもし
その述語がシンボル\code{else}ならば\code{else}節です。\footnote{全ての述語がfalseで
\code{else}節が存在しない場合の\code{cond}式の値はSchemeでは未定義です。ここでは
それをfalseにしました。}


\begin{scheme}
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp) (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                        ~\textrm{; no \code{else} clause}~
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last: COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
\end{scheme}

\noindent
文法上の変形を実装することを選択した\code{cond}のような式は
\newterm{derived expressions}(\jnewterm{派生式})と呼ばれます。\code{let}式もまた派生式です。
(\link{Exercise 4.6}参照)\footnote{実用的なLispシステムはユーザに対し新しい派生式を
追加し、評価機の変更無しに文法上の変形としての実装を指定できる仕組みを提供します。
そのようなユーザ定義変形は\newterm{macro}(\jnewterm{マクロ})と呼ばれます。マクロ定義の初歩的な仕組みを
追加することは簡単なのですが、結果的にその言語は微妙な名前衝突の問題を持ちます。
これらの困難をもたらさないマクロ定義の仕組みに関する多くの研究が存在します。
例えば\link{Kohlbecker 1986}, \link{Clinger and Rees 1991}, \link{Hanson 1991}を
参照して下さい。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.2}Exercise 4.2:} 
Louis Reasonerは\code{eval}の\code{cond}の順を変えて手続き適用の節が代入のための節の前に
なるようにする計画を立てた。彼はこうすることでインタプリタをより効率良くできると
主張した。プログラムは通常代入、定義等より適用を含んでいるためだ、と。
彼の変更した\code{eval}は元の\code{eval}よりも通常より少ない節を式の型が判明する前に
チェックするだろうという主張だ

\begin{enumerate}[a]

\item
Louisの計画の何が間違っているか? (ヒント：Louisの評価機は式\code{(define x 3)}に
対し何を行うか?)

\item
Louisは彼の計画がうまく行かないことに激昂した。彼は他の多くの型の式をチェックする
前に彼の評価機をいくらでも長くして手続き適用を認識させようとしている。評価される
言語を変更し手続き適用が\code{call}で始まるようにすることで彼の手助けをせよ。
例えば\code{(factorial 3)}の代わりに変更後は\code{(call factorial 3)}と書かねばならず、
\code{(+ 1 2)}は\code{(call + 1 2)}と書かねばならない。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.3}Exercise 4.3:} 
\code{eval}を書き直し呼出がデータ主導スタイルにて行われるようにせよ。これを
\link{Exercise 2.73}のデータ主導型微分手続きと比較せよ。この節で実装された文法
に適切であるとおり、(複合式の\code{car}を式の型として用いてよい。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.4}Exercise 4.4:} 
\link{Chapter 1}の特殊形式\code{and}と\code{or}の定義を思い出せ。

\begin{itemize}

\item
\code{and}: 式は左から右へと評価される。もし任意の式がfalseと評価されるならfalseが返される。
残りの式全ては評価されない。もし全ての式がtrueの値に評価されるなら最後の式の評価値が
返される。もし式が全く存在しないならtrueが返される。

\item
\code{or}: 式は左から右へと評価される。もし任意の式がtrueと評価されるのならその値が
返される。残りの式全ては評価されない。もし全ての式がfalseと評価されるのなら、または
もし式が全く存在しないなら、falseが返される。

\end{itemize}
\code{and}と\code{or}を評価機に対する新しい特殊形式として適切な構文手続きと
評価手続き\code{eval\-/and}と\code{eval\-/or}を定義することで導入せよ。
代替法として、\code{and}と\code{or}を派生式として実装する方法を示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.5}Exercise 4.5:} 
Schemeは\code{cond}の節に追加の文法、\code{(<\var{test}> => <\var{recipient}>)}を認めている。
もし\( \langle \)\var{test}\( \kern0.08em\rangle \)がtrueとして評価されるなら、
\( \langle \)\var{recipient}\( \kern0.08em\rangle \)が評価される。その値は1引数の手続きでなければならない。
そしてこの手続きが\( \langle \)\var{test}\( \kern0.08em\rangle \)の値で起動され、その結果が\code{cond}式の値と
して返される。例えば、

\begin{scheme}
(cond ((assoc 'b '((a 1) (b 2))) => cadr)
      (else false))
\end{scheme}

\noindent
は2を返す。\code{cond}を変更してこの拡張文法をサポートするようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.6}Exercise 4.6:} 
\code{let}式は派生式である。なぜなら、

\begin{scheme}
(let ((~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~) ~\( \dots \)~ (~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~))
  ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
は以下と等価である。

\begin{scheme}
((lambda (~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~)
   ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
 ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~
 ~\( \dots \)~
 ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~)
\end{scheme}

文法上の変形\code{let\-/>combination}を実装せよ。これは\code{let}式の評価を上記で示された
型の組み合わせの評価へと簡約する。そして\code{let}式を扱うために\code{eval}に適切な節を
追加する。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.7}Exercise 4.7:}
\code{let*}は\code{let}に似ているが、\code{let*}の変数の束縛が左から右へと続けて実行され、
全ての先行する束縛が可視となるよう各束縛が環境へ追加されていく。例えば、

\begin{scheme}
(let* ((x 3)  (y (+ x 2))  (z (+ x y 5)))
  (* x z))
\end{scheme}

\noindent
は39を返す。\code{let*}式が入れ子の\code{let}式の集合としてどのように書き直すことができるか
説明せよ。そしてこの変形を実行する手続き\code{let*\-/>nested\-/lets}を書け。
もし私達が既に\code{let}を実装していて(\link{Exercise 4.6})、評価機を拡張し\code{let*}を
扱いたいとしたら、以下の処理を行う節を\code{eval}に追加することは十分であろうか?

\begin{scheme}
(eval (let*->nested-lets exp) env)
\end{scheme}

\noindent
または私達は明示的に\code{let*}を非派生式を用いて拡張するべきであろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.8}Exercise 4.8:} 
``名前付き\code{let}''は\code{let}の変種であり以下の形式を持つ。

\begin{scheme}
(let ~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark bindings}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}


\( \langle \)\var{bindings}\( \kern0.08em\rangle \)と\( \langle \)\var{body}\( \kern0.08em\rangle \)は
通常の\code{let}と同様である。しかし\( \langle \)\var{var}\( \kern0.08em\rangle \)が
\( \langle \)\var{body}\( \kern0.08em\rangle \)内部で束縛される手続きであり、
ボディが\( \langle \)\var{body}\( \kern0.08em\rangle \)であり、
かつパラメタが\( \langle \)\var{bindings}\( \kern0.08em\rangle \)の変数である点が異なる。
従って\( \langle \)\var{var}\( \kern0.08em\rangle \)で名付けられた手続きを呼び出すことで
繰り返し\( \langle \)\var{body}\( \kern0.08em\rangle \)を実行することができる。例えば、
反復フィボナッチ手続き(\link{Section 1.2.2})は名前付き\code{let}を用いて以下のように書き直すことができる。
\begin{scheme}
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
\end{scheme}


\link{Exercise 4.6}の\code{let\-/>combination}を変更して名前付き\code{let}もサポートするようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.9}Exercise 4.9:} 
多くの言語が\code{do}, \code{for}, \code{while}, \code{until}のような多様な反復構造をサポートする。
Schemeでは反復処理が通常の手続き呼出を用いて表現できるため特別な反復構造が演算能力に対し
本質的な利益を与えることはない。一方でそのような構造は時折便利でもある。いくつかの
反復構造を設計せよ。それらの使用の例を与えどのように派生式として実装するかについて示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.10}Exercise 4.10:}
データ抽象化を用いることで、評価されるべき言語の特定の文法から独立した\code{eval}手続きを
書くことができる。これを説明するために\code{eval}と\code{apply}を変更すること
なくこの節の手続きを変更することでSchemeの新しい文法を設計し、実装せよ。
\end{quote}

\subsection{評価機のデータ構造}
\label{Sec. 4.1.3}
\label{Section 4.1.3}

式の外側の文法を定義するのに加えて、評価機の実装は評価機が内部的に操作するデータ構造も
プログラムの実行の一部として、手続きと環境の表現やtrueとfalseの表現を定義しなければなりません。

\subsubsection*{述語のテスト}


条件節に対しては真になるものは全て受け入れます。真とは明示的な\code{false}オブジェクトでは無いものです。

\begin{scheme}
(define (true? x)  (not (eq? x false)))
(define (false? x) (eq? x false))
\end{scheme}

\subsubsection*{手続きの表現}


プリミティブを扱うために、以下の手続きが利用可能であると仮定します。

\begin{itemize}

\item
\code{(apply\-/primitive\-/procedure <\var{proc}> <\var{args}>)}

\noindent
与えられたプリミティブな手続きをリスト\( \langle \)\var{args}\( \kern0.08em\rangle \)中の
引数の値に適用し、適用の結果を返します。

\item
\code{(primitive\-/procedure? <\var{proc}>)}

\noindent
\( \langle \)\var{proc}\( \kern0.08em\rangle \)がプリミティブな手続きであるか確認します。

\end{itemize}

\noindent
プリミティブを扱うこれらの仕組みは\link{Section 4.1.4}でさらに説明されます。


複合手続きはパラメタ、手続きのボディ、環境からコンストラクタ\code{make\-/procedure}を用いて
構築されます。

\begin{scheme}
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
\end{scheme}

\subsubsection*{環境上の命令}


評価機は環境を操作する命令を必要とします。\link{Section 3.2}で説明された通り、環境は
連続するフレームであり、各フレームは変数をその対応する値に関連付ける束縛のテーブルです。
以下の命令を用いて環境を操作します。

\begin{itemize}

\item
\code{(lookup\-/variable\-/value <\var{var}> <\var{env}>)}


環境\( \langle \)\var{env}\( \kern0.08em\rangle \)内でシンボル\( \langle \)\var{var}\( \kern0.08em\rangle \)に
束縛された値を返します。または変数が束縛されていない場合エラーを発します。

\item
\code{(extend\-/environment <\var{variables}> <\var{values}> <\var{base\-/env}>)}

新しいフレームから成る環境を返します。フレームの中ではリスト\( \langle \)\var{variables}\( \kern0.08em\rangle \)中の
シンボルがリスト中\( \langle \)\var{values}\( \kern0.08em\rangle \)の対応する要素に束縛されます。
取り囲む環境は環境\( \langle \)\var{base\-/env}\( \kern0.08em\rangle \)です。
\item
\code{(define\-/variable! <\var{var}> <\var{value}> <\var{env}>)}


環境\( \langle \)\var{env}\( \kern0.08em\rangle \)の最初のフレームに
変数\( \langle \)\var{var}\( \kern0.08em\rangle \)を
値\( \langle \)\var{value}\( \kern0.08em\rangle \)に関連付ける新しい束縛を追加します。
\item
\code{(set\-/variable\-/value! <\var{var}> <\var{value}> <\var{env}>)}


環境\( \langle \)\var{env}\( \kern0.08em\rangle \)中の変数\( \langle \)\var{var}\( \kern0.08em\rangle \)の束縛を変更し、
その変数が新しく値\( \langle \)\var{value}\( \kern0.08em\rangle \)に束縛されるようにします。
またはもし変数が束縛されていない場合にはエラーを発します。
\end{itemize}

\noindent
これらの命令を実装するためには環境をフレームのリストとして表現します。
環境を内包する環境はリストの\code{cdr}です。空の環境は単純に空リストです。

\begin{scheme}
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
\end{scheme}

\noindent
環境の各フレームはリストのペアとして表現されます。フレームに束縛される変数のリストと
対応する値のリストです。\footnote{フレームは実際には以下のコードにおいてデータ抽象化されていません。
\code{Set\-/variable\-/value!}と\code{define\-/variable!}は\code{set\-/car!}を用いて直接フレームの値を変更しています。
フレーム手続きの目的は環境操作手続きを読み易くすることです。}

\begin{scheme}
(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
\end{scheme}

\noindent
環境を変数を値に関連付ける新しいフレームにより拡張するために、変数のリストと値のリストから
成るフレームを作成します。そしてその環境に隣接させます。もし変数の数が値の数に合わない場合には
エラーを発します。

\begin{scheme}
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))
\end{scheme}

\noindent
環境内の変数を探すためには、最初のフレームの変数のリストを走査します。
希望の変数を見つければ対応する値リスト内の要素を返します。
もし現在のフレーム内にその変数が見つからなければ内包する環境を探します。以下、繰り返しです。
もし空環境まで辿り着いたならば``束縛されていない変数''のエラーを発します。

\begin{scheme}
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
\end{scheme}

\noindent
変数に新しい値を指定された環境にて設定するには、\code{lookup\-/variable\-/value}と同様に変数を走査し、
対応する見つかった場合には対応する値を変更します。

\begin{scheme}
(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable: SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
\end{scheme}

\noindent
変数を定義するには、最初にその変数の束縛を最初のフレームにて探します。
束縛が存在すれば変更を行います。(\code{set\-/variable\-/value!}と同様です)。
そのような束縛がなければ最初のフレームに追加します。

\begin{scheme}
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame) (frame-values frame))))
\end{scheme}

\noindent
ここで記述された手法は環境を表現する多くのもっともな方法の1つでしかありません。
データ抽象化を用いて評価機の他の部分を表現の詳細な選択から分離したので、もし
望めば環境の表現を変更することが可能です。(\link{Exercise 4.11}参照)。
実運用品質のLispシステムでは評価機の環境向け命令のスピードが---特に変数探索の物が---システムの
パフォーマンスに主に影響を与えます。ここで説明された表現は概念上シンプルではありますが、
効率的ではなく通常は実運用システムでは用いられません。\footnote{この
表現の欠点は(\link{Exercise 4.11}の亜種も同様に)評価機が与えられた変数を見つけるために
数多くのフレームを探索しなければならないかもしれない点です。(このような取り組み方は
\newterm{deep binding}(\jnewterm{深い束縛})と参照されます)。この非効率性を防ぐ1つの方法は
\newterm{lexical addressing}(\jnewterm{レキシカルアドレッシング})と呼ばれ\link{Section 5.5.6}にて
議論されます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.11}Exercise 4.11:} 
フレームをリストのペアと表現する代わりに、フレームを束縛のリストとして表現可能である。
この場合、各束縛は名前と値のペアだ。環境の命令を書き換えこの代替表現を用いるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.12}Exercise 4.12:}
手続き\code{set\-/variable\-/value!}, \code{define\-/variable!}, \code{lookup\-/variable\-/value}は
環境の構造を縦断するためのより抽象的な手続きを用いて表現することができる。
共通なパターンを捕える抽象化を定義し、3つの手続きをこられの抽象化を用いて再定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.13}Exercise 4.13:} 
Schemeは\code{define}を用いて新しい束縛を作成することができる。しかし束縛を
取り除く手段は提供しない。評価機に特殊形式\code{make\-/unbound!}を実装せよ。
これは\code{make\-/unbound!}が評価された環境から与えられたシンボルの束縛を
削除する。この問題は完全には指示されていない。例えば環境の最初のフレームの
束縛のみを削除するべきだろうか? 仕様を完成させあなたが行った選択について
理由を述べよ。
\end{quote}

\subsection{評価機をプログラムとして実行する}
\label{Section 4.1.4}


評価機を与えられたことで、Lisp式が評価されるプロセスの(Lispで表現された)記述を
手中にしました。評価機をプログラムとして表現することの利点の1つはプログラムを
実行できることです。これによりLispの中で実行することでLisp自身がどのように式を
評価するのかについての実行モデルを得ることができました。これは評価ルールを検証する
フレームワークの役割を果たします。実際にこの章の後の方で行います。


評価機プログラムは式を究極的にはプリミティブな手続きの適用まで簡約します。
従って評価機を実行するのに必要なもの全ては基盤を無すLispシステムを呼び出す
仕組みを作成することでプリミティブ手続きの適用をモデル化することです。


各プリミティブな手続きの名前の束縛が存在しなければなりません。そのため\code{eval}が
プリミティブの適用の命令を評価する時、\code{apply}に渡すオブジェクトを見つけます。
従って私達は評価しようとする式の中に現れることが可能なプリミティブな手続きの名前と
独自のオブジェクトを関連付けするグローバル環境を設定します。グローバル環境は
またシンボル\code{true}と\code{false}のための束縛も含めます。そうすることで
それらが評価される式の中で変数として利用することができます。

\begin{scheme}
(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
(define the-global-environment (setup-environment))
\end{scheme}

\noindent
どのようにプリミティブ手続きオブジェクトを評価するかは、\code{apply}がそれらを手続き
\code{primitive\-/procedure?}と\code{apply\-/primitive\-/procedure}を用いて判別できる限り問題ではありません。
私達はプリミティブな手続きをシンボル\code{primitive}で始まり、そのプリミティブを実装する低層のLispの手続きを
含むリストとして表現することを選択しました。

\begin{scheme}
(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
\end{scheme}

\noindent
\code{setup\-/environment}はプリミティブの名前と実装手続きをリストから得ます。\footnote{低層のLispで
定義される任意の手続きはメタ循環評価機のプリミティブとして使用できます。評価機にインストールされる
プリミティブの名前は低層のLispにおける実装の名前と同じである必要はありません。
ここで名前が同じなのはメタ循環評価機がSchemeそれ自身を実装するためです。従って例えば
\code{(list 'first car)}や\code{(list 'square (lambda (x) (* x x)))}を
\code{primitive\-/procedures}に入れることもできたでしょう。}

\begin{scheme}
(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ~\( \dark \langle \)~~\var{\dark more primitives}~~\( \dark \rangle \)~ ))
(define (primitive-procedure-names)
  (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))
\end{scheme}

\noindent
プリミティブ手続きを適用するためには単純に実装手続きを引数に対して低層のLispシステムを
用いて適用します。\footnote{
\code{apply\-/in\-/underlying\-/scheme}は前の章で使用した
\code{apply}手続きです。メタ循環評価機の\code{apply}手続き(\link{Section 4.1.1})はこのプリミティブの
動き方をモデルにしています。2つの異なる\code{apply}と呼ばれる物を持つことはメタ循環
評価機を実行するにおいて問題へと導きます。メタ循環評価機の\code{apply}を定義することが
プリミティブの定義を隠してしまうためです。これを回避する1つの方法はメタ循環の
\code{apply}をリネームすることでプリミティブ手続きの名前との衝突を避けることです。
私達はその代わりに下層の\code{apply}への参照をメタ循環の\code{apply}を定義する前に
以下のようにすることで保存しました。

\begin{smallscheme}
(define apply-in-underlying-scheme apply)
\end{smallscheme}

\noindent
これで元の版の\code{apply}に異なる名前でアクセスできるようになりました。}

\begin{scheme}
(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))
\end{scheme}

\noindent
メタ循環評価機実行時の利便性のために、低層のLispシステムのread-eval-print loop (REPL:レプル)を
モデルにした\newterm{driver loop}(\jnewterm{ドライバループ})を提供します。これは\newterm{prompt}(\jnewterm{プロンプト})を表示し、
入力式を読み込み、この式をグローバル環境の中で評価し、結果を表示します。
私達は各表示された結果の前に\newterm{output prompt}(\jnewterm{出力プロンプト})を置きます。そうすることで
式の値を他の表示されるかもしれない出力から判別するためです。\footnote{プリミティブな手続き
\code{read}はユーザからの入力を待ち、次の入力された完全な式を返します。例えばもしユーザが
\code{(+ 23 x)}と入力した場合、\code{read}は3つの要素、シンボル\code{+}、数値23、シンボル\code{x}を
含むリストを返します。もしユーザが\code{'x}と入力したなら\code{read}は2つの要素、
シンボル\code{quote}とシンボル\code{x}を含むリストを返します。}

\begin{scheme}
(define input-prompt  ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))
(define (announce-output string)
  (newline) (display string) (newline))
\end{scheme}

\noindent
私達は特別なプリント手続き、\code{user\-/print}を使用します。これは複合手続きの環境部分を
表示するのを防ぐためです。これはとても長いリストに成り得ます。(またはさらにループを
含んでいるかもしれません。)

\begin{scheme}
(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))
\end{scheme}

\noindent
これで評価機を実行するのに必要なことはグローバル環境の初期化と
ドライバーループの開始のみです。以下がサンプルの応答です。

\begin{scheme}
(define the-global-environment (setup-environment))
(driver-loop)
~\textit{;;; M-Eval input:}~
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
~\textit{;;; M-Eval value:}~
~\textit{ok}~
~\textit{;;; M-Eval input:}~
(append '(a b c) '(d e f))
~\textit{;;; M-Eval value:}~
~\textit{(a b c d e f)}~
\end{scheme}

% \vspace{1em}
\begin{quote}
\heading{\phantomsection\label{Exercise 4.14}Exercise 4.14:}
Eva Lu AtorとLouis Reasonerはそれぞれ評価機を検証している。Evaは\code{map}の定義を
入力しいくつかそれを用いるテストプログラム実行している。それらはうまく動いた。
Louisは逆に\code{map}のシステム版をメタ循環評価機のプリミティブとして導入した。
彼がそれを確かめた時、全くうまく動かなかった。なぜEvaはうまく行ったのに
Louisの\code{map}は失敗するのか。説明せよ。
\end{quote}

\subsection{プログラムとしてのデータ}


Lisp式を評価するLispプログラムについて考えることにおいて、例えはとても良い
手助けになるでしょう。プログラムの意味についての命令上の視点の1つに、プログラムは
(恐らく無限に大きな)抽象機械の記述であるという物があります。
例えば階乗を計算する親しみのあるプログラムについて考えてみましょう。

\begin{scheme}
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
\end{scheme}

\noindent
私達はこのプログラムを減算、乗算、等価試験の部品と一緒に2つの位置を持つスイッチと
他の階乗機械を含める機械の説明であると見做すことができるでしょう。(階乗機械は
無限です。他の階乗機械をその中に含んでいるためです)。\link{Figure 4.2}は
階乗機械の流れ図でありその部品がどのようにお互いに接続されているかを示しています。


同様な方法で、評価機を入力として機械の説明書を取るとても特殊な機械だと見做すことができます。
この入力を与えられると、評価機はそれ自身を記述された機械を真似るように設定します。
例えばもし評価機に\link{Figure 4.3}で示される\code{factorial}の記述を与えれば、
評価機は階乗の計算ができるようになります。

\begin{figure}[tb]
\phantomsection\label{Figure 4.2}
\centering
\begin{comment}
\heading{Figure 4.2:} The factorial program, viewed as an abstract machine.

\begin{example}
    +-----------------------------------+
    | factorial                   |1    |
    |              |1             V     |
    |              |           +-----+  |
    |              V           | #   |  |
    |           +-----+        |     |  |
6 --------*-----|  =  |------->|   #-+-----> 720
    |     |     +-----+        |  /  |  |
    |     |                    | #   |  |
    |     |                    +-----+  |
    |     |                       ^     |
    |     |                       |     |
    |     |                    +--+--+  |
    |     *------------------->|  *  |  |
    |     |                    +-----+  |
    |     V                       ^     |
    |  +-----+    +-----------+   |     |
    |  |  -  +--->| factorial +---+     |
    |  +-----+    +-----------+         |
    |     ^                             |
    |     |1                            |
    +-----------------------------------+
\end{example}
\end{comment}
\includegraphics[width=84mm]{fig/chap4/Fig4.2.pdf}
\par\bigskip
\noindent
\heading{Figure 4.2:} 抽象機械として見た階乗プログラム
\end{figure}

この視点からは、私達の評価機は\newterm{universal machine}(\jnewterm{万能機械})であると見えます。
他の機械がLispにて説明される時、それを真似します。\footnote{機械がLispで記述されるという
ことは本質ではありません。もし私達の評価機にC言語の様な他の言語のための評価機として
振る舞うLispプログラムを与えた場合、Lisp評価機はC評価機の真似をします。
それは順に、C言語で記述された任意の機械の真似が可能です。同様にCで書かれたLisp評価機は
任意のLispプログラムを実行できるCのプログラムを生成します。ここでの深い意図は評価機は
任意の他の物を真似できることです。従って``原理上、何が計算できるのか''という概念(必要な
時間とメモリの実現性は無視)は言語や計算機に非依存です。その代わりに根底を成す概念である
\newterm{computability}(\jnewterm{計算可能性})を反映します。これは最初にAlan M. Turing (1912-1954)に
より明確に証明されました。彼の1936年の論文は計算機科学理論の基礎を導きました。この論文で
チューリングは簡素な計算モデル---今日、\newterm{Turing machine}(\jnewterm{チューリングマシン})として
知られる---を公開し、任意の``実効的な処理''はそのような機械のプログラムとして定式化できると
主張しました。(この論拠は\newterm{Church-Turing thesis}(\jnewterm{チャーチ・チューリングのテーゼ}、
または提唱)として知られます)。チューリングは次に万能機械、即ちチューリングマシン向けプログラムの
評価機として振る舞うチューリングマシンを実装しました。彼はこのフレームワークを用いて
チューリングマシンでは計算できない上手く設定された問題が存在することを証明しました。
(\link{Exercise 4.15}参照)。そのため暗に``実効的な処理''として定式化
できない問題の存在も示したのです。チューリングは実用的な計算機科学への基礎的な貢献の
行いも続けました。例えば彼は汎用目的サブルーチンを用いて構造化プログラミングの考えを
発明しました。チューリングの経歴については\link{Hodges 1983}を参照して下さい。}これは
特筆すべきことです。電子回路向けの同等な評価機について想像することを試してみて下さい。
入力としてフィルタのようなある他の回路の計画を符号化した信号を取る回路になるでしょう。
この入力を与えられて、回路評価機はそこで記述と同じフィルタのように振る舞うでしょう。
そのような万能電子回路はほとんど想像不可能なほど複雑です。プログラム評価機がとても
簡単なプログラムであることは特筆に値します。\footnote{ある人々は比較的単純な手続きにより
実装された評価機が評価機それ自身より複雑なプログラムの真似ができることが直感的でないと
感じました。万能評価機械の存在は深く、そして素晴しい演算処理の特性です。\newterm{Recursion
theory}(\jnewterm{再帰理論})は数理論理学の1部門であり、演算処理の論理上の制約に関係します。
Douglas Hofstadter(ダグラス ホフスタッター)の美しい本
\textit{G\"odel, Escher, Bach}(邦題:ゲーデル エッシャー バッハ)は
これらの考えのいくつかについて探求します。(\link{Hofstadter 1979})}

\begin{figure}[tb]
\phantomsection\label{Figure 4.3}
\centering
\begin{comment}
\heading{Figure 4.3:} The evaluator emulating a factorial machine.

\begin{example}
                   +--------+
            6 ---->|  eval  |----> 720
                   +--------+
                       /
             . . .    /  . . .
       . . .       ../. .      .
     .                           ..
    .   (define (factorial n)      . . .
   .      (if (= n 1)                   . .
    .         1                            .
    .         (* (factorial (- n 1)) n)))   .
      . .                       . .        .
          . .  . .      . . . .     . . . .
                   . ..
\end{example}
\end{comment}
\includegraphics[width=69mm]{fig/chap4/Fig4.3.pdf}
\par\bigskip
\noindent
\heading{Figure 4.3:} 階乗マシンを真似する評価機
\end{figure}

もう1つの特筆すべき評価機の側面はそれがプログラミング言語により操作されるデータオブジェクトと
プログラミング言語それ自身との間のブリッジ(橋)として働くことです。(Lispで実装された)
評価機プログラムが実行中であり、ユーザが式をその評価機に入力し結果を観察していると
想像してみて下さい。ユーザの視点からは\code{(* x x)}の様な入力式はプログラミング言語に
よる式であり、評価機が実行すべき物です。しかし、評価機の視点からは式は単純なリスト
(この場合ではシンボル\code{*}, \code{x}, \code{x}のリスト)であり、これは明確なルール集合に
従って操作されねばならぬ物です。

ユーザのプログラムが評価機のデータだということは混乱の元となる必要はありません。
実際に、時々はこの区別は無視したほうが便利です。そしてユーザに対し明示的にデータ
オブジェクトをLispの式として評価する能力を\code{eval}手続きをプログラム中で使用できる
ようにすることで与えることもまた便利なことです。多くのLisp方言は引数として
式と環境を取り、その環境に関連してその式を評価するプリミティブな\code{eval}手続きを
与えます。\footnote{警告：この\code{eval}プリミティブは私達が\link{Section 4.1.1}で
実装した\code{eval}手続きとは異なります。それは私達が\link{Section 4.1.3}で構築した
サンプルの環境構造ではなく、実際のScheme環境を用いるためです。これらの実際の環境は
ユーザにより通常のリストとして操作することはできません。それらは\code{eval}により
アクセスされるか、他の特別な命令を用います。同様に以前に見た\code{apply}プリミティブ
もメタ循環\code{apply}とは異なります。それが私達が\link{Section 4.1.3}と\link{Section 4.1.4}で
構築した手続きオブジェクトではなく、実際のScheme手続きを用いるからです。}従って、

\begin{scheme}
(eval '(* 5 5) user-initial-environment)
\end{scheme}

\noindent
と

\begin{scheme}
(eval (cons '* (list 5 5)) user-initial-environment)
\end{scheme}

\noindent
の両方は25を返します。\footnote{Schemeの\acronym{MIT}実装は\code{eval}と同様に
ユーザの入力式が評価される初期環境に束縛されるシンボル\code{user\-/initial\-/environment}も
含みます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.15}Exercise 4.15:}
1引数手続き\code{p}とオブジェクト\code{a}を与えられた時、式\code{(p a)}が(エラーメッセージや
無限に停止しない場合とは対照的に)値を返す場合に、\code{p}は\code{a}に対して``halt''(停止)
すると呼ばれる。\code{p}が\code{a}に対し停止するかどうかを任意の手続き\code{p}と任意のオブジェクト\code{a}に
対して正確に決定する手続き\code{halts?}を書くことは不可能であることを示せ。以下の推測を
用いろ：もしそのような手続き\code{halts?}が存在するなら以下のプログラムを実装できるだろう。

\begin{scheme}
(define (run-forever) (run-forever))
(define (try p)
  (if (halts? p p) (run-forever) 'halted))
\end{scheme}


ここで式\code{(try try)}の評価について考え、どんな可能な結末(停止するか、無限に実行するか)も
\code{halts?}の意図した振舞に違反することを示せ。\footnote{\code{halts?}が手続きオブジェクトを
与えらえたと規定したが、この推測が例え\code{halts?}が手続きのテキストとその環境への
アクセスを得ることが出来るとしても依然として適用できることに注意せよ。
これはチューリングの著名な\newterm{Halting Theorem}(\jnewterm{停止性問題})であり、
\newterm{non\-/computable}(\jnewterm{計算不可能})な問題の最初の明確な例を与える。
言い換えれば、計算手続きとして実行不可能なうまく設定された課題である。}
\end{quote}

\subsection{内部定義}
\label{Section 4.1.6}


私達の評価の環境モデルとメタ循環評価機は定義を順に実行し、環境のフレームを1度に
1定義づつ拡張します。これはインタラクティブなプログラム開発に対しては特に便利です。
その場合にはプログラマは自由に手続きの適用を新しい手続きの定義に混ぜる必要があります。
しかし、(\link{Section 1.1.8}で紹介された)ブロック構造を実装するために用いられた内部定義に
ついて注意深く考えてみれば、環境の名前毎の拡張はローカル変数の定義に最良の方法
ではないのではと気付くのではないでしょうか。


内部定義を伴なう以下のような手続きについて考えてみます。

\begin{scheme}
(define (f x)
  (define (even? n) (if (= n 0) true  (odd?  (- n 1))))
  (define (odd? n)  (if (= n 0) false (even? (- n 1))))
  ~\( \dark \langle \)~~\var{\dark rest of body of \code{f}}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
ここでの意図は手続き\code{even?}のボディ内の名前\code{odd?}は\code{even?}の後に定義された
手続き\code{odd?}を参照しなければなりません。名前\code{odd?}のスコープは\code{f}の
ボディ全体であり、\code{odd?}の定義が起こった箇所から始まる\code{f}のボディの
一部分ではありません。実際に\code{odd?}がそれ自身\code{even?}を用いて定義されて
いることについて考えると---\code{even?}と\code{odd?}は相互再帰手続きであり---2つの
\code{define}を満足させる解釈はそれらを名前\code{even?}と\code{odd?}が環境に同時に
追加されたと見做すことのみだとわかります。より一般的には、ブロック構造において、
ローカルな名前のスコープは\code{define}が評価された手続きのボディ全体だという
ことです。

偶然にも私達のインタプリタは\code{f}の呼出を正確に評価します。しかし``予想外''の
理由のためです。内部手続きの定義が最初に来るため、これらの手続きへの呼出はそれらの
全てが定義されるまで起こりません。従って\code{odd?}は\code{even?}が実行された時に
定義されるのです。
内部定義がボディの最初に来て定義された変数の値の式の評価が実際にはどの定義された
変数も用いない任意の手続きに対し直接、同時定義を実装する仕組みと、私達の逐次的な
評価システムの仕組みは実際に同じ結果を与えます。
(これらの制限に従わず、その結果逐次定義が同時定義と等価でない手続きの例に対しては
\link{Exercise 4.19}を参照して下さい)。\footnote{プログラムにこの評価の仕組みに依存
して欲しくないというのが\link{Chapter 1}の\link{Footnote 28}での見解、``管理は責任を
取れない''に対する理由です。これを主張することで内部定義は最初に来て、定義中で
お互いを定義が評価されている間に使用はしません。Schemeの\acronym{IEEE}標準は
実装者にこれらの定義の評価に用いられる仕組みについて幾つかの選択を残します。
別のルールではなくある評価ルールを選択することはここでは``悪い形式''のプログラムの
解釈のみに影響する小さな問題に見えるかもしれません。しかし\link{Section 5.5.6}では同時に
内部定義を行うモデルへの移行が、そうしなければコンパイラの実装にて起こり得る意地の悪い
問題を防ぐことを学びます。}


しかし内部定義の名前が真に同時にスコープを持つようになる簡単な定義の扱い方が存在します。
単に現在の環境に入ることになる全てのローカル変数をどの値の式が評価されるよりも早く
作成することです。これを行う1つの方法は\code{lambda}式上の構文変形によります。
\code{lambda}式のボディを評価する前に、ボディの中の全ての内部定義を走査し、削除します。
内部で定義された変数は\code{let}を用いて作成され、次に代入を用いてそれらの値に設定されます。
例えば、以下の手続きは、

\begin{scheme}
(lambda ~\( \dark \langle \)~~\var{\dark vars}~~\( \dark \rangle \)~
  (define u ~\( \dark \langle \)~~\var{\dark e1}~~\( \dark \rangle \)~)
  (define v ~\( \dark \langle \)~~\var{\dark e2}~~\( \dark \rangle \)~)
  ~\( \dark \langle \)~~\var{\dark e3}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
以下の形式に変形されます。

\begin{scheme}
(lambda ~\( \dark \langle \)~~\var{\dark vars}~~\( \dark \rangle \)~
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u ~\( \dark \langle \)~~\var{\dark e1}~~\( \dark \rangle \)~)
    (set! v ~\( \dark \langle \)~~\var{\dark e2}~~\( \dark \rangle \)~)
    ~\( \dark \langle \)~~\var{\dark e3}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
ここで\code{*unassigned*}は特別なシンボルであり、変数が調べられた時にもしまだ値が
割り当てられていない変数を使用しようとしたならばエラーを発せさせます。

内部定義を全て走査する方法の代替となる戦略は\link{Exercise 4.18}にて示されます。
上で示された変形とは異なり、これは定義された変数の値がその変数のどんな値も
用いずに評価できるという制約を強制します。\footnote{Schemeの\acronym{IEEE}標準は
この制約を強制する実装にまかせるのではなく、プログラマに対してこの制約に従うかを
まかせると指定することで、異なる実装戦略を許しています。\acronym{MIT} Schemeを含む
いくつかのScheme実装は上で示された変形を用いています。従ってこの制約に従わない
プログラムは実際にはそのような実装の下では動作します。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.16}Exercise 4.16:}
この課題では内部定義を逐次実行するためについ先程説明された手法を実装する。
評価機は\code{let}をサポートすると仮定する。(\link{Exercise 4.6}参照)

\begin{enumerate}[a]

\item
\code{lookup\-/variable\-/value} (\link{Section 4.1.3})を変更してもし見つけた値が
シンボル\code{*unassigned*}ならエラーを発するようにする。

\item
手続きのボディを取り内部手続きを持たない同等な手続きを返す手続き\code{scan\-/out\-/defines}を
上で説明された変形を作成することにより、書け。

\item
\code{scan\-/out\-/defines}をインタプリタの\code{make\-/procedure}または
\code{procedure\-/body} (see \link{Section 4.1.3})の中に導入せよ。
どちらの場所が良いか? それは何故か?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.17}Exercise 4.17:}
この本の手続きの式\( \langle \)\var{e3}\( \kern0.1em\rangle \)の評価を実施している時の
環境図を書くことで、定義が逐次的に翻訳された時にどのように構築されるかと、定義が
説明されたように走査された場合にどのように構築されるかとの違いを比較せよ。
変形されたプログラムにはなぜ余分なフレームが存在するのか? 環境構造内のこの違いが
正しいプログラムの振舞に違いを起こさないのか説明せよ。インタプリタに内部定義の
``同時''スコープのルールを余分なフレームの構築成しに実装させる方法を設計せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.18}Exercise 4.18:}
テキストの例を以下の様に変形する定義の走査に対する代替となる戦略を考えよ。

\begin{scheme}
(lambda ~\( \dark \langle \)~~\var{\dark vars}~~\( \dark \rangle \)~
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (let ((a ~\( \dark \langle \)~~\var{\dark e1}~~\( \dark \rangle \)~) (b ~\( \dark \langle \)~~\var{\dark e2}~~\( \dark \rangle \)~))
      (set! u a)
      (set! v b))
    ~\( \dark \langle \)~~\var{\dark e3}~~\( \dark \rangle \)~))
\end{scheme}

ここで\code{a}と\code{b}は新しい変数の名前を表現することを意味し、インタプリタにより作成され、ユーザの
プログラムには現れない。\link{Section 3.5.4}の\code{solve}手続きについて考える。

\begin{scheme}
(define (solve f y0 dt)
  (define  y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
\end{scheme}

この手続きはこの課題に示されたように内部定義が走査された場合にうまく動くだろうか?
テキストに示されたように走査された場合には動くだろうか? 説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.19}Exercise 4.19:}
Ben Bitdiddle, Alyssa P. Hacker, Eva Lu Atorの3人は以下の式を評価した場合の
望まれた結果について議論している。

\begin{scheme}
(let ((a 1))
  (define (f x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (f 10))
\end{scheme}

Benは結果は\code{define}に対する逐次的実行のルールを用いて得られるべきだと主張した。
\code{b}は11に定義され、\code{a}は5に定義される。従って結果は16である。Alyssaは相互再帰は
同時スコープのルールが内部手続き定義に要求されるとして異議を唱えた。手続きの名前を
他の名前から異なって扱うのは不合理だ。従って彼女は\link{Exercise 4.16}で実装された
仕組みに賛成した。これは\code{a}が\code{b}の値が計算される時点では割り当てられていない
という結論に導くだろう。従ってAlyssaの視点では手続きはエラーを生じなければならない。
Evaは3つ目の立ち位置を取る。彼女はもし\code{a}と\code{b}の定義が真に同時であることを意味
するのであれば、\code{a}に対する値5は\code{b}の評価にて用いられるべきであると述べた。
従ってEvaの視点では\code{a}は5でなければならず、\code{b}は15でなければならない。そして
結果は20にならなければならない。(もし同意するなら)3人の視点であなたはどれを支持するのか?
あなたはEvaが好んだように振る舞う内部定義を実装する方法を考案できるか?\footnote{\acronym{MIT} Schemeの
実装者達は次の根拠に従ってAlyssaを支持する。Evaは原理上は正しい。定義は同時だと見做される
べきだ。しかしEvaが要求することを行う一般的でかつ効率的な仕組みを実装することは難しく
見える。そのような仕組みが不足している状況では、同時定義の難しい場合についてはエラーを
生成するほうが(Alyssaの意見)、正しくない答を生成するよりも(Benの様に)、より良いだろう。}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.20}Exercise 4.20:}
内部定義は逐次的に見えるが実際には同時であるため、いくらかの人々はこれを完全に
回避するほうを好むだろう。そして特殊形式\code{letrec}を代わりに用いる。
\code{letrec}は\code{let}に似ているため、それが束縛する変数が同時に束縛されお互いに
同じスコープを持つことは不思議ではないだろう。上記のサンプル手続き\code{f}は内部手続きを
用いずに、しかし全く同じ意味を持つように書くことができる。

\begin{scheme}
(define (f x)
  (letrec
    ((even? (lambda (n)
              (if (= n 0) true  (odd?  (- n 1)))))
     (odd?  (lambda (n)
              (if (= n 0) false (even? (- n 1))))))
    ~\( \dark \langle \)~~\var{\dark rest of body of \code{f}}~~\( \dark \rangle \)~))
\end{scheme}

\code{letrec}式は以下の形式を持つ。

\begin{scheme}
(letrec ((~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~) ~\( \dots \)~ (~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~))
  ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
\code{letrec}式は\code{let}の亜種であり、変数\( \langle \)\( var_k \)\( \kern0.08em\rangle \)に
初期値を与える式\( \langle \)\( exp_k \)\( \kern0.08em\rangle \)は、全ての\code{letrec}の束縛を
含む環境にて評価される。これは上の例においての\code{even?}と\code{odd?}の相互再帰のような束縛の中での再帰を許す。
または以下の様な10の階乗の評価も可能である。

\begin{scheme}
(letrec
  ((fact (lambda (n)
           (if (= n 1) 1 (* n (fact (- n 1)))))))
  (fact 10))
\end{scheme}

\begin{enumerate}[a]

\item
\code{letrec}を派生式として実装せよ。\code{letrec}式を\code{let}を上で示したように、
または\link{Exercise 4.18}の様に変形することで行え。
即ち、\code{letrec}の変数は\code{let}を用いて作成しなければならず、そして次に
それらの値を\code{set!}で代入すること。

\item
Louis Reasonerは内部定義に関するこの全ての空騒ぎにより混乱してしまった。
彼の見解は、もし手続きの中での\code{define}の使用を好まないのであれば、単に
\code{let}を使えるのではないかである。彼のreasoning(推測)の何が緩いのかを、この課題と同様に
定義された\code{f}を用いて、式\code{(f 5)}の評価の間に
\( \langle \)\var{rest of body of \code{f}}\( \kern0.08em\rangle \)が評価された
環境を示す環境図を書くことによって説明せよ。
同じ環境の、ただし\code{f}の定義中の\code{letrec}の場所に\code{let}を用いた場合の環境図を書け。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.21}Exercise 4.21:}
驚くべきことに、\link{Exercise 4.20}におけるLouisの直感は正しい。\code{letrec}を(または
\code{define}すらも)用いずに再帰手続きを指定することは本当に可能である。しかしこれを
達成する手法はLouisが存在したよりもずっと繊細である。以下の式は10の階乗を再帰
階乗手続きを適用することで求めている。\footnote{この例は再帰手続きを\code{define}を用いずに
定式化するためのプログラミング上の技を説明しています。最も一般的なこの種の技は
\( Y \) \newterm{operator}(\jnewterm{Yコンビネータ}、不動点演算子)です。これは
``pure \( \lambda \)-calculus''(純粋ラムダ計算)による再帰の実装を与えます。(\( \lambda \)計算の
詳細については\link{Stoy 1977}を参照して下さい。またSchemeによる\( Y \)コンビネータの
解説については\link{Gabriel 1988}を参照して下さい。}

\begin{scheme}
((lambda (n)
   ((lambda (fact) (fact fact n))
    (lambda (ft k)
      (if (= k 1) 1 (* k (ft ft (- k 1)))))))
 10)
\end{scheme}

\begin{enumerate}[a]

\item
(式を評価することで)これが実際に階乗を計算することを確認せよ。
フィボナッチ数を計算する同様な式を工夫せよ。

\item
以下の手続きについて考える。これは相互再帰内部定義を含む。

\begin{scheme}
(define (f x)
  (define (even? n)
    (if (= n 0) true  (odd?  (- n 1))))
  (define (odd? n)
    (if (= n 0) false (even? (- n 1))))
  (even? x))
\end{scheme}

\code{f}の代替的な定義を完成するために欠けている式を埋めよ。これは内部定義も
\code{letrec}も使用してはいない。

\begin{scheme}
(define (f x)
  ((lambda (even? odd?) (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0) true (od? ~\( \dark \langle \)~??~\( \dark \rangle \)~ ~\( \dark \langle \)~??~\( \dark \rangle \)~ ~\( \dark \langle \)~??~\( \dark \rangle \)~)))
   (lambda (ev? od? n)
     (if (= n 0) false (ev? ~\( \dark \langle \)~??~\( \dark \rangle \)~ ~\( \dark \langle \)~??~\( \dark \rangle \)~ ~\( \dark \langle \)~??~\( \dark \rangle \)~)))))
\end{scheme}
\end{enumerate}
\end{quote}

\subsection{構文分析を実行から分離する}
\label{Section 4.1.7}

上で実装された評価機は簡単ですが、非効率です。式の構文上の分析がその実行と相互
配置されているためです。従ってもしプログラムが何度も実行された場合、その構文は
何度も分析されます。例えば次の\code{factorial}を用いて\code{(factorial 4)}を評価する
ことを考えてみて下さい。

\begin{scheme}
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
\end{scheme}

\noindent
\code{factorial}が呼ばれる度に、評価機はボディが\code{if}式であることを判断せねばならず、
それから述語を取り出します。その後にのみ述語を評価しその値により振り分けが行えます。
式\code{(* (factorial (- n 1)) n)}、または部分式
\code{(factorial (- n 1))}と\code{(- n 1)}を評価する度に、評価機は\code{eval}にて状況分析を
行い式が適用であるかを判断せねばならず、また演算子とオペランドの抽出をせねばなりません。
この分析はコストが高いのです。これを繰り返し実行することは無駄が多いでしょう。

評価機を変形し構文上の分析をたった1度のみ実行されるように準備することで
著しく効率良くすることができます。\footnote{この技はコンパイル過程に
不可欠な要素であり、\link{Chapter 5}で議論します。Jonathan Reesは1982年頃に
このようなSchemeインタプリタをTプロジェクトのために書きました(\link{Rees and Adams 1982})。
Marc \link{Feeley (1986)} (\link{Feeley and Lapalme 1987}も参照)は彼の修士論文にて
独力でこの技を発明しました。}私達は式と環境を取る\code{eval}を2つに分けます。
手続き\code{analyze}は式のみを取ります。構文上の分析を行い新しい手続き
\newterm{execution procedure}(\jnewterm{実行手続き})を返します。この手続きは分析された式を
実行するにおいて行われた結果をカプセル化します。実行手続きは環境を引数として
取り評価を完了します。これは実行手続きが何度も呼ばれるのに対し、\code{analyze}が式に
対して1度しか呼ばれないため作業量を減らせます。


分析と実行への分離に伴ない、\code{eval}は以下の様になります。

\begin{scheme}
(define (eval exp env) ((analyze exp) env))
\end{scheme}

\noindent
\code{analyze}の呼出の結果は環境に適用される実行手続きです。\code{analyze}手続きは\link{Section 4.1.1}の
元の\code{eval}により実行されたのと同じ状況分析です。ただし私達が呼び出す手続きは完全な
評価ではなく分析のみを実行します。

\begin{scheme}
(define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp)
         (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else
         (error "Unknown expression type: ANALYZE" exp))))
\end{scheme}

\noindent
以下に最も簡単な構文分析手続きがあります。これは自己評価式です。環境引数を無視し、
ただ式を返す実行手続きを返します。

\begin{scheme}
(define (analyze-self-evaluating exp)
  (lambda (env) exp))
\end{scheme}

\noindent
クォートされた式に対してはそのテキストの取り出しを実行フェーズでなく、分析フェーズで
1度だけ行うことでほんの少し効率良くすることができます。

\begin{scheme}
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))
\end{scheme}

\noindent
変数の値の探索は依然として実行フェーズで行わねばなりません。これは環境を知ることに
依存するためです。\footnote{しかし、構文上の分析の部分にて終わらせられる変数探索の
重要な部分があります。\link{Section 5.5.6}にて示されるように、環境構造の中でどこで変数の値が
見つかるか、その位置を決定することが可能です。従って変数にマッチするエントリのために
環境を走査する必要を防ぐことができます。}

\begin{scheme}
(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
\end{scheme}

\noindent
\code{analyze\-/assignment}もまた実際の変数の設定を環境の供給が完了する実行時まで
遅らせなければなりません。しかし\code{assignment\-/value}式が分析の間に
(再帰的に)分析されることができることは効率を大きく向上します。\code{assignment\-/value}式は
今はただ1度しか分析されないためです。同じことが定義に対しても言えます。

\begin{scheme}
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))
\end{scheme}

\noindent
\code{if}式に対しては分析時に述語、結果、代替を取り出し分析します。

\begin{scheme}
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env) (if (true? (pproc env))
                      (cproc env)
                      (aproc env)))))
\end{scheme}

\noindent
\code{lambda}式の分析もまた効率が大きく向上します。\code{lambda}のボディは1度しか
分析しません。例え\code{lambda}の評価の結果としての手続きが何度適用されてもです。

\begin{scheme}
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))
\end{scheme}

\noindent
(\code{begin}や\code{lambda}式のボディの中としての)式の列の評価の分析は
より必要とされます。\footnote{列の処理に関する実態については\link{Exercise 4.23}を
参照して下さい。}列の各式は分析され実行手続きを生じます。これらの実行手続きは
環境を引数として取り順番に各個別の実行手続きを引数としての環境と共に呼び出す
実行手続きを生成するために組み合わせれます。

\begin{scheme}
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs) (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))
\end{scheme}

\noindent
適用を分析するためには、演算子とオペランドを分析し、演算子の実行手続きを(実際に適用される
手続きを得るために)呼び出し、オペランドの実行手続きを(実際の引数を得るために)呼び出す
実行手続きを構築します。次にこれらを\code{execute\-/application}に渡します。これは
\link{Section 4.1.1}の\code{apply}の類似品です。\code{execute\-/application}は\code{apply}とは
複合手続きのための手続きのボディが既に分析されている点が異なります。そのためさらなる
分析の必要性がありません。その代わりに、ただ拡張された環境上のボディに対して
手続き実行を呼び出します。

\begin{scheme}
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application
       (fproc env) 
       (map (lambda (aproc) (aproc env))
            aprocs)))))
(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (procedure-parameters proc)
           args
           (procedure-environment proc))))
        (else
         (error "Unknown procedure type:
                 EXECUTE-APPLICATION"
                proc))))
\end{scheme}

\noindent
私達の新しい評価機は節\link{Section 4.1.2}, \link{Section 4.1.3}, \link{Section 4.1.4}に
あるように、同じデータ構造、構文手続き、実行時サポート手続きを用います。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.22}Exercise 4.22:}
この節の評価機を特殊形式\code{let}をサポートするように拡張せよ。(\link{Exercise 4.6}参照)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.23}Exercise 4.23:}
Alyssa P. Hackerはなぜ\code{analyze\-/sequence}がそんなに複雑になるのか理解できなかった。
他の分析手続き全ては\link{Section 4.1.1}の対応する評価手続き(または\code{eval}節)の簡単な変形である。
彼女は\code{analyze\-/sequence}は以下のようになるのではと予想した。

\begin{scheme}
(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs))
           ((car procs) env))
          (else
           ((car procs) env)
           (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence: ANALYZE"))
    (lambda (env) (execute-sequence procs env))))
\end{scheme}


Eva Lu AtorはAlyssaに対し、テキストの版は分析時に列を評価する仕事よりもより多くの
ことを行っていると説明した。Alyssaの逐次実行手続きは個別の組み込みの実行手続きに
対する呼出を行うのではなく、複数の手続きを通してそれらを呼び出すためにループする。
実際に列内の個別の式は分析されるが、列それ自身は分析されない。


2つの版の\code{analyze\-/sequence}を比較せよ。例として、列がただ1つの式を持つ場合に
おいて(手続きのボディ特有の)共通な場合について考えよ。Alyssaのプログラムにより生成された
実行手続きはどのような行いをするか? 上のテキスト内のプログラムで生成された実行手続きに
ついてはどうか? 2つの版は2つの式を持つ列に対してはどのように比較されるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.24}Exercise 4.24:}
元のメタ循環評価機とこの節の版のスピードを比較するためのいくつかの実験を設計し
実行せよ。あなたの結果を用いて種々の手続きに対して分析と実行で消費された時間を
概算せよ。
\end{quote}

\section{Scheme上でのバリエーション --- 遅延評価}
\label{Sec. 4.2}
\label{Section 4.2}

今や私達はLispプログラムとして表現された評価機を得ました。これで言語設計上の代替となる
選択を単純に評価機を変更することで試験することができます。実際に新しい言語は良く、
最初に既存の高級言語の中に新しい言語を埋め込む評価機を書くことで開発されます。
例えばもしわたしたちがLispに対する変更の提案のある側面についてLispコミュニティの他の
メンバと議論したい時に、変更を組み込んだ評価機を与えることができます。受け手はすると
新しい評価機を持ちいて実験を行いさらなる変更としてのコメントを返すことができます。
高レベルな実装ベースが評価機のテストとデバッグをより簡単にするだけではありません。
加えて組込むことは設計者に対し下層の言語から機能をsnarfする\footnote{Snarf: ``つかみ
取ること、特に巨大な文書やファイルを持ち主の許可を得ても得なくても使う目的のため''
Snarf Down: ``snarfすること、稀に吸収する、処理する、または理解するの含意を持つ''
(これらの定義は\link{Steele et al. 1983}からsnarfした。\link{Raymond 1993}も参照すること)}
ことを可能にします。これは
私達の組込Lisp評価機が下層のLispからプリミティブやコントロール構造を使用するのと同じです。
設計者は(もし必要があれば)後で低レベル言語やハードウェアにて完全な実装を構築するだけです。
この節と次ではSchemeの、優位な追加の表現力を提供するいくつかのバリエーションについて探求します。



\subsection{正規順と適用順}
\label{Section 4.2.1}

\link{Section 1.1}では評価のモデルについての議論を始めましたが、Schemeは\newterm{applicative-order}(\jnewterm{適用順序})
言語であると記しました。即ち、Schemeの手続きへの全ての引数は手続きが適用される時に評価される、と。
逆に、\newterm{normal-order}(\jnewterm{正規順序})言語は手続き引数の評価を実際に引数の値が必要とされるまで
遅らせます。手続き引数の評価を可能な限り最後の瞬間まで(例えばプリミティブ命令により必要とされるまで)
遅らせることは\newterm{lazy evaluation}(\jnewterm{遅延評価})と呼ばれます。\footnote{専門用語
``lazy''と``normal-order''の間の違いはいささか曖昧(fuzzy)です。一般的に``lazy''は特定の
評価機の仕組みを参照しますが、一方で``normal-order''は言語の意味を参照し、どんな特定の評価戦術からも
独立しています。しかしこれは確かな区別ではありません。そして2つの専門用語は良く同義的に
用いられています。} 以下の手続きについて考えてみましょう。

\begin{scheme}
(define (try a b) (if (= a 0) 1 b))
\end{scheme}

\noindent
\code{(try 0 (/ 1 0))}の評価はSchemeではエラーを生成します。遅延評価ではエラーは現れません。
その式の評価は1になります。なぜなら絶対に引数は評価されないためです。


遅延評価を利用した例で、手続き\code{unless}の定義です。

\begin{scheme}
(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))
\end{scheme}

\noindent
これは以下のような式で使用できます。

\begin{scheme}
(unless (= b 0)
        (/ a b)
        (begin (display "exception: returning 0") 0))
\end{scheme}

\noindent
これは適用順序の言語では動きません。通常値と例外値の両方が\code{unless}が呼ばれる前に
評価されるためです。(\link{Exercise 1.6}と比較してみて下さい)。遅延評価の利点は
\code{unless}のような手続きは例えそれらの引数の幾つかの評価がエラーを発したり、
停止しなかったとしても役立つ計算ができます。

引数の評価が完了する前に手続きのボディに入ることを、手続きがその引数において
\newterm{non\-/strict}(\jnewterm{非厳密})であると呼びます。もし引数が手続きのボディに入る前に
評価されたなら手続きはその引数に対し\newterm{strict}(\jnewterm{厳密})であると言います。\footnote{``厳密''対
``非厳密''の技術用語は本質的には``適用順序''対``正規順序''と同じことを言っています。
しかし個別の手続きと引数を言及しており、言語全体を言及してはいません。
プログラミング言語のカンファレンスでは誰かがこのようなことを言うのを聞くかもしれません。
``正規順序言語のHassleはいくつか厳密なプリミティブを持っている。他の手続きはそれらの引数を
遅延評価で取る。''}純粋適用順序言語では全ての手続きが全ての引数に対し厳密です。そして
プリミティブな手続きは厳密にも非厳密にも成り得ます。またプログラマに彼等が定義する手続きの
厳密さに細かなコントロールを提供する言語もあります。(\link{Exercise 4.31}参照)

実用性のため非厳密にすることができる手続きの印象的な例には\code{cons}(または一般的に、
ほとんど全てのデータ構造のコンストラクタが)あります。
例えもし要素の値がわからなくても、データ構造を形成するよう要素を組み立て、
結果のデータ構造上で操作する実用的な計算を行えます。例えばリストの長さを
リスト内の個々の要素の値を知ること無しに計算することは完璧に意味があります。
私達はこの考えを\link{Section 4.2.3}で非厳密な\code{cons}ペアにより形成されたリストとして
\link{Chapter 3}のストリームを実装するために利用します。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.25}Exercise 4.25:}
(通常の適用順Schemeにおいて)\code{unless}を上で示されたように定義し、
次に\code{unless}を用いて以下のように\code{factorial}を定義する。

\begin{scheme}
(define (factorial n)
  (unless (= n 1)
          (* n (factorial (- n 1)))
          1))
\end{scheme}


もし\code{(factorial 5)}を評価したら何が起こるか? この定義は正規順序言語では
動くか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.26}Exercise 4.26:}
Ben BitdiddleとAlyssa P. Hackerは\code{unless}のような物を実装するための
遅延評価の重要性について意見が分かれた。Benは\code{unless}を適用順序でも特殊形式として
実装可能である点を指摘した。Alyssaはもしそれを行えば\code{unless}はただ単に構文であり
高階手続きと連動して使用できる手続きではないと反論した。議論の両サイド上の詳細を埋めよ。
\code{unless}をどのようにして派生手続きとして(\code{cond}や\code{let}のように)実装するかを示せ。
そして特殊形式ではなく手続きとして存在する\code{unless}を持つことが有効である状況の
例を与えよ。
\end{quote}

\subsection{遅延評価を持つインタプリタ}
\label{Section 4.2.2}


この節ではSchemeと同じですが、複合手続きが全ての引数に対して非厳密であることが異なる
正規順言語を実装します。プリミティブな手続きは依然として厳密です。\link{Section 4.1.1}の
評価機を、それが解釈する言語がこのように振る舞うように変更するのは難しくありません。
ほとんど全ての必要な変更は手続き適用が中心となります。


基本的な考えは、手続きを適用する時、インタプリタはどの引数が評価されるべきかと、
どの引数が遅延されるべきかを決定しなければなりません。遅延化された引数は評価されません。
その代わりにそれらは\newterm{thunks}(\jnewterm{サンク})と呼ばれるオブジェクトに変形されます。\footnote{\newterm{thunk}という
単語は非公式な作業部会により考案されました。彼等はAlgol 60にてcall\-/by\-/nameの
実装について議論していたのです。彼等は式のほとんどの分析は(``式についての考えは'')
コンパイル時に行えることに気付きました。従って実行時には式は既に(\link{Ingerman et al. 1960})に
係わる``サンク''を持っていました。}サンクは引数の値を生成するために必要な情報を必要な時に
含んでなければなりません。それはまるで適用時に評価されたかのようにです。従って、
サンクは引数の式と手続き適用がその中で評価される環境を持たなければなりません。


サンク中の式の評価プロセスは\newterm{forcing}(\jnewterm{強制})と呼ばれます。\footnote{これは
\link{Chapter 3}でストリームを表現するのに導入された遅延化オブジェクト上で\code{force}を
用いることに類似しています。ここで行っていることと、\link{Chapter 3}で行ったことの
重大な違いは、ここでは遅延化と強制を評価機の中に構築していることです。従って
これを言語を通して同一化し、自動化しています。}
一般的にはサンクはその値が必要になった時のみ強制されます。サンクの値を使用する
プリミティブな手続きに渡された時です。また演算子の値であり手続きとして適用される時です。
設計上の1つの選択として可能なこととして、\link{Section 3.5.1}にて遅延化オブジェクトに我々がしたように、
サンクを\newterm{memoize}(\jnewterm{メモ化})するか否かがあります。メモ化を用いれば、サンクが初めて
強制された時、計算された値が格納されます。続く強制は単純に演算を繰り返すことなく単純に
格納された値を返します。私達はインタプリタをメモ化します。これはとても多くのアプリケーションに
対して効率的だからです。しかし、これには用心しなければならない考慮点が存在します。\footnote{メモ化と
組み合わされた遅延評価は時々、\newterm{call-by-need}(\jnewterm{必要時呼出})引数渡しと呼ばれます。
\newterm{call-by-name}(\jnewterm{名前呼出})引数渡しと対照的です。(call-by-nameはAlgol 60で導入されましたが、
メモ化を行わない遅延評価と同類です)。言語設計者として、私達は評価機をメモ化することも、しないことも、
プログラマに任せることも可能です(\link{Exercise 4.31})。\link{Chapter 3}からおわかりかと思いますが、
これらの選択は微妙で、かつ混乱を招く問題を代入の存在において提起します。(\link{Exercise 4.27}と
\link{Exercise 4.29}を参照)。\link{Clinger (1982)}による素晴しい論文がここで提起される混乱の
複数の特徴を明らかにしようと試みています。}

\subsubsection*{評価機を変更する}

遅延評価と\link{Section 4.1}の評価との主な違いは\code{eval}と\code{apply}における手続き適用の取扱に存在します。


\code{eval}の\code{application?}節は以下になります。

\begin{scheme}
((application? exp)
 (apply (actual-value (operator exp) env)
        (operands exp)
        env))
\end{scheme}

\noindent
これは\link{Section 4.1.1}の\code{eval}の\code{application?}節とほとんど同じです。
遅延評価のためにはしかし、\code{apply}をオペランド式と共に呼びます。それらを評価することで
生成された引数と共にではありません。もし引数が遅延化されるのであれば環境にサンクを
構築させる必要が出るので、これも渡さなければいけません。依然として演算子は評価します。
\code{apply}は実際の手続きが必要です。その型(プリミティブであるか複合であるか)に従って
呼出と適用を行うためです。


式の実際の値が必要になる度に、\code{eval}するだけの代わりに以下を用います。

\begin{scheme}
(define (actual-value exp env)
  (force-it (eval exp env)))
\end{scheme}

\noindent
これでもし式の値がサンクであれば強制されます。


また新しい版の\code{apply}もほとんど\link{Section 4.1.1}の版と同じです。
違いは\code{eval}が未評価のオペランド式を通り直ぎたことです。(厳密である)プリミティブな手続きに対しては
プリミティブを適用する前に全ての引数を評価します。(非厳密である)複合手続きに対しては
全ての引数を手続きに適用する前に遅延化します。

\begin{scheme}
(define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env)))   ;~\textrm{changed}~
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)  ;~\textrm{changed}~
           (procedure-environment procedure))))
        (else (error "Unknown procedure type: APPLY"
                     procedure))))
\end{scheme}

\noindent
引数を処理する手続きは\link{Section 4.1.1}の\code{list\-/of\-/values}そっくりです。しかし
\code{list\-/of\-/delayed\-/args}が引数を評価するのではなく遅延化することと、
\code{list\-/of\-/arg\-/values}が\code{eval}の代わりに\code{actual\-/value}を用いることが違います。

\begin{scheme}
(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps)
                          env)
            (list-of-arg-values (rest-operands exps)
                                env))))
(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps)
                      env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))
\end{scheme}

\noindent
評価機で変更しなければいけない他の場所は\code{if}の取扱の中にあります。
そこでは\code{eval}の代わりに\code{actual\-/value}を使用して述語が真であるか偽で
あるかテストする前に、述語式の値を取らねばなりません。

\begin{scheme}
(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
\end{scheme}

\noindent
最後に、\link{Section 4.1.4}の\code{driver\-/loop}手続きを変更して、\code{eval}の代わりに
\code{actual\-/value}を使用せねばなりあせん。そうすることでもし遅延化された値が
REPLに伝播して返った場合に、表示される前に強制されます。またプロンプトも
変更してこれが遅延評価であることを示します。

\begin{scheme}
(define input-prompt  ";;; L-Eval input:")
(define output-prompt ";;; L-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output
           (actual-value
            input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
\end{scheme}

\noindent
これらの変更を行うことで、評価機を開始しテストすることができます。
\link{Section 4.2.1}で議論された\code{try}式の評価の成功はインタプリタが遅延評価を
実行していることを示しています。

\begin{scheme}
(define the-global-environment (setup-environment))
(driver-loop)
~\textit{;;; L-Eval input:}~
(define (try a b) (if (= a 0) 1 b))
~\textit{;;; L-Eval value:}~
~\textit{ok}~
~\textit{;;; L-Eval input:}~
(try 0 (/ 1 0))
~\textit{;;; L-Eval value:}~
~\textit{1}~
\end{scheme}

\subsubsection*{サンクの表現}


私達の評価機は手続きが引数に適用される時にサンクを作成することと、これらのサンクを
後で強制することの準備をせねばなりません。サンクは式を環境と一緒にまとめなければ
なりません。そうすることで引数が後から生成されることができます。
サンクを強制するためには単純に式と環境をサンクから取り出しその環境の中で式を評価します。
\code{eval}ではなく\code{actual\-/value}を用いることで式の値それ自身がサンクである場合にその
強制をサンクでない物に辿り着くまで繰り返します。

\begin{scheme}
(define (force-it obj)
  (if (thunk? obj)
      (actual-value (thunk-exp obj) (thunk-env obj))
      obj))
\end{scheme}

\noindent
式と環境をまとめる1つの簡単な方法はその式と環境を含むリストを作成することです。
従ってサンクを以下のように作成します。

\begin{scheme}
(define (delay-it exp env)
  (list 'thunk exp env))
(define (thunk? obj)
  (tagged-list? obj 'thunk))
(define (thunk-exp thunk) (cadr  thunk))
(define (thunk-env thunk) (caddr thunk))
\end{scheme}

\noindent
実際に私達のインタプリタに欲っしたものはこれではなく、メモ化されたサンクです。
サンクが強制された時に格納された式とその値に置き換え、
\code{thunk}タグを変更することでサンクをサンクが評価された物に変更することで、
既に評価されたと認識させることができます。\footnote{
一度式の値が計算されれば
サンクから\code{env}もまた消去します。これによりインタプリタにより返される値に違いは
生じません。しかしこれはスペースを本当に節約します。サンクから\code{env}への参照を
必要が無くなったら直ぐに削除することで、この構造が
\newterm{garbage-collected}(\jnewterm{ガベージコレクション}、GC、ゴミ集め)され、そのスペースは
\link{Section 5.3}で議論されるようにリサイクルされます。


同様に、\link{Section 3.5.1}のメモ化、遅延化されたオブジェクトの中の不必要な環境をGCされるように
許可することも、\code{memo\-/proc}に\code{(set! proc '())}の様な何かを行わせて
(\code{delay}が中で評価される環境を含む)手続き\code{proc}をその値を格納した後に捨てることでできました。}

\begin{scheme}
(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk) 
  (cadr evaluated-thunk))
(define (force-it obj)
  (cond ((thunk? obj)
         (let ((result (actual-value (thunk-exp obj)
                                     (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) 
                     result)     ;~\textrm{\code{exp}をその値で置き換える}~
           (set-cdr! (cdr obj) 
                     '())        ;~\textrm{不必要な\code{env}を忘れる}~
           result))
        ((evaluated-thunk? obj) (thunk-value obj))
        (else obj)))
\end{scheme}

\noindent
同じ\code{delay\-/it}手続きがメモ化有りでも無しでも動作することに注意して下さい。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.27}Exercise 4.27:}
以下の定義を遅延評価機に入力したとする。

\begin{scheme}
(define count 0)
(define (id x) (set! count (+ count 1)) x)
\end{scheme}


以下の一連の応答の欠けた値を与えよ。そして貴方の回答について説明せよ。\footnote{この
課題は遅延評価と副作用の間の応答が大きな混乱の原因となりえることを実演している。
これこそが\link{Chapter 3}の議論からあなたが予期するかもしれないことである。}

\begin{scheme}
(define w (id (id 10)))
~\textit{;;; L-Eval input:}~
count
~\textit{;;; L-Eval value:}~
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
~\textit{;;; L-Eval input:}~
w
~\textit{;;; L-Eval value:}~
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
~\textit{;;; L-Eval input:}~
count
~\textit{;;; L-Eval value:}~
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.28}Exercise 4.28:}
\code{eval}は\code{eval}でなく\code{actual\-/value}を用いて\code{apply}に渡す前に
演算子を評価する。演算子の値を強制するためである。この強制の必要性を実演する
例を与えよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.29}Exercise 4.29:}
メモ化しない場合に、メモ化した場合よりも非常に遅く実行されると予測するプログラムを
示せ。また以下の応答について考えよ。\code{id}手続きは\link{Exercise 4.27}と同じに定義され
\code{count}は0から始める。

\begin{scheme}
(define (square x) (* x x))
~\textit{;;; L-Eval input:}~
(square (id 10))
~\textit{;;; L-Eval value:}~
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
~\textit{;;; L-Eval input:}~
count
~\textit{;;; L-Eval value:}~
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
\end{scheme}


評価機がメモ化された場合とメモ化されない場合の両方について応答を与えよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.30}Exercise 4.30:}
Cy D. Fectは元C言語プログラマである。彼はいくつかのside effects(副作用)が起こらない
のではないかと心配している。遅延評価が列内の式に強制を行わないためである。
最後の1つ以外の列内の式の値は使用されないため(式は変数への代入や表示等の作用のため
だけに存在している)、この値の強制を引き起こす後の使用は存在しない(例えばプリミティブな手続きの
引数として)。Cyは従って列を評価する時には列内の最後の1つを除いた全ての式を評価せねば
ならないと考えた。彼は\link{Section 4.1.1}の\code{eval\-/sequence}を変更し\code{eval}でなく
\code{actual\-/value}を使用することを提案した。

\begin{scheme}
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (actual-value (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
\end{scheme}

\begin{enumerate}[a]

\item
Ben BitdiddleはCyが間違っていると考えた。彼はCyに\link{Exercise 2.23}で説明された
\code{for\-/each}手続きを見せた。これは副作用を伴う列の重要な例を与える。 

\begin{scheme}
(define (for-each proc items)
  (if (null? items)
      'done
      (begin (proc (car items))
             (for-each proc (cdr items)))))
\end{scheme}

彼はテキストの評価機(オリジナルの\code{eval\-/sequence}を持つ物)は
これを正しく取り扱うと主張した。

\begin{scheme}
~\textit{;;; L-Eval input:}~
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
~\textit{57}~
~\textit{321}~
~\textit{88}~
~\textit{;;; L-Eval value:}~
~\textit{done}~
\end{scheme}

なぜBenが\code{for\-/each}の振舞について正しいのか説明せよ。

\item
CyはBenが\code{for\-/each}について正しいのは同意した。しかし彼が\code{eval\-/sequence}に対する
変更を提案した時、彼が考えていたのはこの種のプログラムではないと言った。
彼は以下の2つの遅延評価の手続きを定義した。

\begin{scheme}
(define (p1 x)
  (set! x (cons x '(2)))
  x)
(define (p2 x)
  (define (p e)
    e
    x)
  (p (set! x (cons x '(2)))))
\end{scheme}

オリジナルの\code{eval\-/sequence}を用いた時、\code{(p1 1)}と\code{(p2 1)}の値はいくらか?
Cyが提案した\code{eval\-/sequence}への変更を用いた時には値はどうなるか?

\item
Cyは彼が提案した通りの\code{eval\-/sequence}への変更はaの例の振舞に影響を与えないと
指摘した。なぜこれが正しいのか説明せよ。

\item
遅延評価では列はどのように扱われるべきと考えるか? あなたはCyのアプローチ、テキストの
アプローチ、または他のアプローチのどれを好むか?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.31}Exercise 4.31:}
この節で取り上げられた取り組み方は少々、不愉快である。Schemeに対して互換性のない
変更を行うためだ。遅延評価を\newterm{upward-compatible extension}(\jnewterm{上位互換性のある拡張})として
実装するほうがより良いだろう。それは通常のSchemeプログラムが依然と同じように
働くということである。これをユーザに引数が遅延されるか、されないかを
コントロールさせるように手続き定義の構文を拡張することで可能である。それを行う間、
ユーザに遅延をメモ化させるか、させないかの選択も同様に与えることができるだろう。
例えば、以下の定義は

\begin{scheme}
(define (f a (b lazy) c (d lazy-memo))
  ~\( \dots \)~)
\end{scheme}

\noindent
\code{f}は4つの引数の手続きであり、最初と3番目の引数は手続きが呼ばれた時に評価され、
2番目は遅延化され、4番目は遅延化とメモ化が行われる。従って通常の手続き定義は
通常のSchemeと同じ振舞を行うが、\code{lazy\-/memo}宣言を各複合手続きの各パラメタに
追加することでこの節で定義された遅延評価の振舞を行う。この変更の設計と実装は
Schemeに対しそのような拡張の生成を必要とする。あなたは\code{define}に対する新しい構文を
取り扱う新しい構文手続きを実装しなければならない。また引数がいつ遅延化されるか、そして
いつ強制するか、またはそれに応じて引数を遅延化するか決定するために\code{eval}や
\code{apply}に対して準備もしなければならない。同時に強制に対してメモ化するか、しないかも
適切に準備すること。
\end{quote}

\subsection{遅延化リストとしてのストリーム}
\label{Section 4.2.3}


\link{Section 3.5.1}ではどのようにストリームを遅延化されたリストとして実装するかについて示しました。
特殊形式\code{delay}と\code{cons\-/stream}導入しました。このことは私達にストリームの\code{cdr}を
求める``promise''(プロミス、約束)を、実際には後になるまではプロミスを実行すること
無しに構築することを可能にしました。

遅延評価ではストリームとリストは同一にできます。そのため特殊形式やリストとストリームの
命令を分ける必要はありません。私達が行わなければならないこと全ては\code{cons}が非厳密になる
よう問題を準備することです。これを達成する1つの方法は遅延評価を拡張しプリミティブにも
非厳密を許し\code{cons}をこれらの内の1つとすることです。より簡単な方法は(\link{Section 2.1.3})の
\code{cons}をプリミティブとして実装する必要性は本質的には全く無いということを思い出すことです。
その代わりに、ペアは手続きとして表現可能です。\footnote{これが\link{Exercise 2.4}で説明された
手続き表現です。本質的にはどんな手続き表現(例えばメッセージパッシングによる実装)も同じことが行え
るでしょう。これらの定義を遅延評価に単純にドライバーループにて型を付けることのみでインストール
できることに注意して下さい。もし私達が元々\code{cons}, \code{car}, \code{cdr}をグローバル環境の
プリミティブとして含めていたのならば、それらは再定義されるでしょう。(\link{Exercise 4.33}と
\link{Exercise 4.34}も参照して下さい。}

\begin{scheme}
(define (cons x y) (lambda (m) (m x y)))
(define (car z) (z (lambda (p q) p)))
(define (cdr z) (z (lambda (p q) q)))
\end{scheme}

\noindent
これらの基本的な命令において、リスト命令の標準定義は無限リスト(ストリーム)と同様に
有限な物としても働きます。そしてストリーム命令はリスト命令として実装可能です。
以下にいくつかの例を示します。

\begin{scheme}
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items)) (map proc (cdr items)))))
(define (scale-list items factor)
  (map (lambda (x) (* x factor)) items))
(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else (cons (+ (car list1) (car list2))
                    (add-lists (cdr list1) (cdr list2))))))
(define ones (cons 1 ones))
(define integers (cons 1 (add-lists ones integers)))
~\textit{;;; L-Eval input:}~
(list-ref integers 17)
~\textit{;;; L-Eval value:}~
~\textit{18}~
\end{scheme}

\noindent
これらの遅延リストは\link{Chapter 3}のストリームよりもさらに遅延化されています。
リストの\code{car}も\code{cdr}と同様に遅延化されます。\footnote{このことはより一般的な
種類の、ただの列ではない、リスト構造の遅延化版を作ることを可能にします。
\link{Hughes 1990}は``遅延化木''のいくつかのアプリケーションについて議論しています。}実際に、
遅延化ペアの\code{car}や\code{cdr}に対するアクセスさえもリスト要素の値を強制する必要がありません。
その値はそれが本当に必要になった場合---例えばプリミティブの引数としてや回答として
表示される場合に---強制されることになります。

遅延化ペアはまた\link{Section 3.5.4}でストリームに対して提起された問題に対する手助けにも
なります。その時はループを伴なうシステムのストリームモデルを定式化することは
明示的な\code{delay}命令を\code{cons\-/stream}で提供されるものを越えてプログラムの中に
撒き散らすことを必要としました。遅延評価では全ての手続きの引数は遅延化に統一されています。
例えばリストと統合する手続きを実装し微分方程式を\link{Section 3.5.4}で元々意図したように実装する
ことが可能です。

\begin{scheme}
(define (integral integrand initial-value dt)
  (define int
    (cons initial-value
          (add-lists (scale-list integrand dt) int)))
  int)
(define (solve f y0 dt)
  (define  y (integral dy y0 dt))
  (define dy (map f y))
  y)
~\textit{;;; L-Eval input:}~
(list-ref (solve (lambda (x) x) 1 0.001) 1000)
~\textit{;;; L-Eval value:}~
~\textit{2.716924}~
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.32}Exercise 4.32:}
\link{Chapter 3}のストリームとこの節で説明された``より遅延化された''遅延化リストの間
の違いを説明する例をいくつか上げよ。この拡張された遅延性の利点をどのように活用するか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.33}Exercise 4.33:}
Ben Bitdiddleは上で与えられた遅延リスト実装を式\code{(car '(a b c))}を評価することで
テストした。

\begin{scheme}
(car '(a b c))
\end{scheme}

驚いたことにこれはエラーを生じる。幾らか考えた後に、彼はクォートされた
式を読み込むことで得られた``リスト''が\code{cons}, \code{car}, \code{cdr}の新しい定義で
操作されたリストから異なることに気が付いた。評価機のクォートされた式の扱いを
修正しドライバループで型付けされたクォートされたリストが正しい遅延リストを
生成するようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.34}Exercise 4.34:}
評価機のドライバループを変更し遅延化したペアとリストが何らかの妥当な方法で
表示を行うようにせよ。(無限リストに対しては何を行うか?)。遅延化ペアの表現も
変更が必要になるだろう。評価機がそれらを表示するためにそれらを判別することが
できるようにするためである。
\end{quote}

\section{Scheme上でのバリエーション --- 非決定性演算}
\label{Section 4.3}


この節では\newterm{nondeterministic computing}(\jnewterm{非決定性演算})と呼ばれる
プログラミングパラダイムをサポートするよう、評価機の中に自動的な探索をサポートするための
機能を構築することで、Scheme評価機を拡張します。これは\link{Section 4.2}での
遅延評価の導入に比べ、とても深い言語への変更です。


非決定性演算はストリーム処理のように、``生成してテストする''アプリケーションに対して
便利です。正の整数の2つのリストを用いて開始する、整数のペアを見つけるタスクについて考えます
1つは最初のリストから、もう1つは別のリストから取得し、その和は素数となります。
私達はこの問題をどのように扱うかについて、\link{Section 2.2.3}では有限列の命令を用いて、
\link{Section 3.5.3}では無限ストリームを用いる方法について学びました。私達の取り組み方は
全ての可能なペアを生成し、これらから和が素数になるペアを選択するという方法でした。
実際にペアの列全体を最初に生成する\link{Chapter 2}や、生成とフィルタリングを相互配置する
\link{Chapter 3}に係わらず演算がどのように体系化されるかの本質的なイメージに対しては
重要ではありませんでした。


非決定性の取り組み方は異なるイメージを喚起します。単純に(何らかの方法で)最初のリストから
数値を選択し、別の数値を2つ目のリストから選択し、(何らかの仕組みで)それらの和が素数である
ことを要求とすると想像してみてください。これは以下の手続きにより表現されます。

\begin{scheme}
(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))
\end{scheme}

\noindent
この手続きはただ単に問題を言い直したに過ぎなく、解法を指定したようには見えないかも
しれません。それにもかかわらず、これは正規の非決定性プログラムです。\footnote{以前に
数値が素数であるかをテストする手続き\code{prime?}を定義しました。例え\code{prime?}が
定義されていたとしても、\code{prime\-/sum\-/pair}手続きは、\link{Section 1.1.7}の最初で説明した
助けにならない``擬似Lisp''による平方根関数の定義の試みのように疑わしく見えるかも
しれません。現実に、あれらの行に沿った平方根手続きが実際に非決定性プログラムとして
定式化することができます。評価機に探索の仕組みを合併することで、どのようにして回答を
計算するかについての純粋な宣言型の記述と命令型の仕様の間の区別を侵食していきます。
私達は\link{Section 4.4}にてこの方向へとさらに進みます。}

ここでの鍵となる考えは、非決定性言語における式は1つ以上の可能な値を持つことが
できるということです。例えば\code{an\-/element\-/of}は与えられたリストのどの要素でも
返すことが有り得ます。私達の非決定性プログラム評価機は自動的に可能な値を選択し
その選択を追跡することで働きます。もし続く要件に合わなければ、評価機は異なる
選択を試します。そして評価が成功するまで、または選択肢が無くなるまで、新しい選択を試し続けます。
遅延評価がプログラマを値がどのように遅延化され強制されるかの詳細から解放されたのと
同様に、非決定性プログラムの評価機はプログラマを選択がどのように行われるかの詳細から
解放します。

非決定性評価とストリーム処理により起こった時間の異なるイメージの対比は
示唆的です。ストリーム処理は遅延評価を可能な答のストリームが組まれた時間を
実際のストリーム要素が生成された時間から分離します。評価機は全ての可能な
回答が私達の前に永遠の列の中に横たわっているというイリュージョンを支えます。
非決定性評価機では式は可能な世界の集合の調査を表現します。それぞれは選択の
集合により判断されます。可能なせかい のいくつかは行き止まりへと導き、一方、
他は役立つ値へと導きます。非決定性プログラム評価機は時間の分岐と私達のプログラムが
異なる可能な実行履歴を持つというイリュージョンを支えます。行き止まりに辿り着いた
時には直前の選択地点に戻り、異なる分岐に従って進むことが可能です。

以下で実装される非決定性プログラム評価機は\code{amb}評価機と呼ばれます。
それが\code{amb}と呼ばれる新しい特殊形式に基づくためです。上記の\code{prime\-/sum\-/pair}の
定義を\code{amb}評価機ドライバループにて(\code{prime?}, \code{an\-/element\-/of}, \code{require}と
一緒に)型を付け、以下のように手続きを実行することができます。

\begin{scheme}
~\textit{;;; Amb-Eval input:}~
(prime-sum-pair '(1 3 5 8) '(20 35 110))
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{(3 20)}~
\end{scheme}

\noindent
返り値は評価機が条件に合う選択が行われるまで繰り返し各リストから要素を選択した
後に取得されました。


\link{Section 4.3.1}は\code{amb}を紹介しそれがどのように非決定性を評価機の自動探索の仕組みを
通してサポートするかについて説明します。\link{Section 4.3.2}は非決定性プログラムの例を与え、
\link{Section 4.3.3}は\code{amb}の実装方法の詳細を通常のScheme評価機を変更することで与えます。



\subsection{ambと検索}
\label{Section 4.3.1}

Schemeに非決定性を対応するよう拡張するために、\code{amb}と呼ばれる新しい特殊形式を
導入します。\footnote{非決定性プログラミングのための\code{amb}の考えは1961年に
最初にJohn McCarthyにより説明されました。(\link{McCarthy 1963}参照)。}

\begin{scheme}
(amb ~\( \dark \langle \)~~\( \dark e_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark e_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark e_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上の式は\( n \)個の式\( \langle \)\( e_i \)\( \kern0.08em\rangle \)の内1つの値を``ambiguously''(曖昧に)
返します。例えば以下の式は

\begin{scheme}
(list (amb 1 2 3) (amb 'a 'b))
\end{scheme}

\noindent
以下の6つの値の可能性があります。

\begin{scheme}
~\code{(1 a)}~ ~\code{(1 b)}~ ~\code{(2 a)}~ ~\code{(2 b)}~ ~\code{(3 a)}~ ~\code{(3 b)}~
\end{scheme}

\noindent
単一の選択を行う\code{amb}は通常の(単一の)値を生成します。

\noindent
選択を行わない\code{amb}---式\code{(amb)}---は受け入れられる値の無い式です。操作上、
\code{(amb)}を評価された時に演算に対し``fail''(失敗)を起こさせると考えることができます。
演算は異常終了し、何の値も生成されません。この考えを用いて、ある特定の述語式\code{p}が
真でなければならないことを以下のように表現可能です。

\begin{scheme}
(define (require p) (if (not p) (amb)))
\end{scheme}

\noindent
\code{amb}と\code{require}を用いて上で使用された\code{an\-/element\-/of}を実装可能です。

\begin{scheme}
(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
\end{scheme}

\noindent
\code{an\-/element\-/of}はリストが空である場合には失敗します。そうでなければリストの
最初の要素か、リストの残りの要素から選択された要素を曖昧に返します。

無限の範囲の選択も表現可能です。以下の手続きは可能性としてある与えられた\( n \)に
等しいか大きな任意の整数を返します。

\begin{scheme}
(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))
\end{scheme}

\noindent
これはまるで\link{Section 3.5.2}で説明されたストリーム手続き\code{integers\-/starting\-/from}の様です。
しかし重要な違いがあります。ストリーム処理は\( n \)で始まる全ての整数の列を表す
オブジェクトを返します。一方、\code{amb}手続きは単一の整数を返します。\footnote{本当は
非決定的に単一の選択を返すことと全ての選択を返すことの違いは私達の視点に
幾分、依存します。値を使用するコードの視点からは非決定性による選択は単一の値を返します。
コードを設計するプログラマの視点からは非決定性による選択は潜在的に全ての可能な値を
返します。そして各値が個別に調査されるように演算は分岐するのです。}

抽象的に、\code{amb}式を評価することが時間に対して分岐を起こさせ、演算は各分岐上にて
式の可能な値の1つに上で続行するのだと想像することができます。\code{amb}が
\newterm{nondeterministic choice point}(\jnewterm{非決定性選択点})を表現すると言えます。
もし私達が動的に獲得できる十分な数のプロセッサを持つ計算機を持っているならば、
探索を簡単な方法で実装できるでしょう。実行は\code{amb}式に遭遇するまでは逐次的に
行われます。遭遇した時点では多くのプロセッサが獲得され選択により暗示された
全ての並列実行を続けるために初期化されます。各プロセッサは選択がそれしか無かった
かのように逐次的に続行します。その処理は失敗に遭遇して停止するか、さらなる分岐が
起こるか、完了するまで続けられます。\footnote{これは絶望的に非効率だと異議を唱える
人がいるかもしれません。この方法では簡単に規定された問題を解くのに数百万の
プロセッサを必要とするかもしれません。そしてそれらの多くのプロセッサはほとんどの
時間をアイドル状態(遊休状態)になるでしょう。この異議は歴史の文脈で捕えられるべきです。
メモリはとても高価な消費財だと考えられてきました。1964年にはメガバイトのRAMは\$400,000
の費用が掛かりました。現在では全てのPCが多数のメガバイトのRAMを積んでいます。そして
ほとんどの時間でほとんどのメモリは利用されていません。大量生産された電子製品の
コストを過小評価することは難しいことです。}

一方で、もし私達が1つのプロセス(またはいくつかの並行プロセス)しか実行できない計算機を持っている場合には
逐次的に動作する代替法を考えねばなりません。1つの方法としては評価機を選択点に辿り着いた時に
無作為に分岐を選択するよう変更することが考えられるでしょう。しかし無作為な選択は簡単に
失敗する値へと導きます。評価機を何度も何度も実行し無作為な選択を行い失敗しない値を見つけることを
期待するかもしれません。しかし全ての可能な実行パス(実行経路)を
\newterm{systematically search}(\jnewterm{体系的探索})をしたほうがより良いです。私達がこの節で開発し
働きかける\code{amb}評価機は体系的探索を次のように実装します。評価機が\code{amb}の適用に遭遇した
場合に初期値として最初の選択肢を選択します。この選択それ自身がさらなる選択へと導きます。
評価機は常に初期値として最初の選択肢を各選択点にて選択します。もし選択の結果が失敗となれば
評価機はautomagically\footnote{automagically: ``自動的に、しかし幾つかの理由で(典型的には
複雑過ぎて、または酷すぎて、または恐らくさらにどうでも良すぎて)話者が説明する気にならない''
(\link{Steele et al. 1983}, \link{Raymond 1993})\label{Footnote 4.47}}に最も最近の選択に
\newterm{backtracks}(\jnewterm{バックトラック}、引き返す)し、次の選択肢を試行します。もしどこかの
選択点において、全ての選択肢を使用してしまえば、評価機は以前の選択点へと戻りそこから
再開します。この処理は\newterm{depth-first search}(\jnewterm{深さ優先探索})または\newterm{chronological
backtracking}(クロノロジカルバックトラック、\jnewterm{年代順バックトラック})として知られる
探索戦略へと導きます。\footnote{自動的な探索戦略の
プログラミング言語への統合は長く功罪相半ばする歴史があります。非決定性アルゴリズムが美しく
プログラミング言語へと探索と自動的バックトラックと共に組込まれただろう最初の提案は
Robert \link{Floyd (1967)}により行われました。Carl \link{Hewitt (1969)}はPlannerと呼ばれる
プログラミング言語を発明しましたが、これは明示的に自動的なクロノロジカルバックトラックを
サポートし、組込の深さ優先探索戦略を提供していました。\link{Sussman et al. (1971)}はこの言語の
部分集合であるMicroPlannerを実装しました。これは問題解決とロボット計画の仕事の支持に使用され
ました。同様なアイデアが論理と定理証明から提起され、エディンバラとマルセイユにて洗練された
言語Prologの起源へと導きました。(\link{Section 4.4}にて議論します)。自動探索に対する多くの不満の後に
\link{McDermott and Sussman (1972)}はConniverと呼ばれる言語を開発しました。これはプログラマの
コントロール下に探索戦略を置くための仕組みを含みました。しかしこれは扱い難く、
\link{Sussman and Stallman 1975}はもっと御しやすい取り組み方を電子回路向け記号分析の手法の
研究の間に発見しました。彼等は事実を繋げる論理的依存性の追跡を基にした非クロノロジカルな
バックトラック計画を開発しました。これは
\newterm{dependency-directed backtracking}(\jnewterm{依存型バックトラック})として知られるようになった
技術です。彼等の手法は複雑でしたが、合理的な効率の良いプログラムを生成しました。冗長な
探索をほとんどしなかったためです。\link{Doyle (1979)}と\link{McAllester (1978; 1980)}は
StallmanとSussmanの手法を一般化し、明確にしました。そして探索を定式化するための
新しいパラダイムを開発しました。これは今では\newterm{truth maintenance}(\jnewterm{真理維持})と呼ばれています。
現代の問題解決システムは全て真理維持システムの何らかの形式を素地として使用しています。
真理維持システムと真理維持を用いたアプリケーションを構築するための洗練された方法の
議論については\link{Forbus and deKleer 1993}を参照して下さい。
\link{Zabih et al. 1987}はSchemeに対する\code{amb}を基にした非決定性拡張を説明しています。
これはこの節で説明されるインタプリタと同様です。しかしより高度な物です。それが
クロノロジカルバックトラックではなく依存型バックトラックを使用しているためです。
\link{Winston 1992}は両方の種類のバックトラックに対する入門を提供しています。}

\subsubsection*{ドライバループ}

\code{amb}評価機のドライバループはいくつかの普通ではない性質を持っています。
これは式を読み最初の失敗ではない実行の値を上で示された\code{prime\-/sum\-/pair}の例のように
表示します。もし次の成功する実行の値を見たいのであれば、インタプリタにバックトラックして
二番目の失敗ではない実行を生成する試行を命令します。これはシンボル\code{try\-/again}を入力
することで伝えられます。もし\code{try\-/again}ではない任意の式が与えられたなら、
インタプリタは新しい問題を開始し、直前の問題の調査されていない選択肢を捨てます。
以下にサンプルの応答を示します。

\begin{scheme}
~\textit{;;; Amb-Eval input:}~
(prime-sum-pair '(1 3 5 8) '(20 35 110))
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{(3 20)}~

~\textit{;;; Amb-Eval input:}~
try-again
~\textit{;;; Amb-Eval value:}~
~\textit{(3 110)}~

~\textit{;;; Amb-Eval input:}~
try-again
~\textit{;;; Amb-Eval value:}~
~\textit{(8 35)}~

~\textit{;;; Amb-Eval input:}~
try-again
~\textit{;;; There are no more values of}~
~\textit{(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))}~

~\textit{;;; Amb-Eval input:}~
(prime-sum-pair '(19 27 30) '(11 36 58))
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{(30 11)}~
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.35}Exercise 4.35:}
2つの与えられた境界値の間の整数を返す手続き\code{an\-/integer\-/between}を書け。
これはピタゴラスの3つ組を求める手続きを実装するのに使用できる。例えば与えられた範囲の間の
整数の三つ組\( (i, j, k) \)で\( i \le j \) and \( i^2 + j^2 = k^2 \)の場合は以下の様になる。

\begin{scheme}
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.36}Exercise 4.36:}
\link{Exercise 3.69}ではどのように``全ての''ピタゴラスの三つ組のストリームを探索対象の整数の
サイズに上限無しで生成するかについて議論した。なぜ単純に\code{an\-/inte\-/ger\-/between}を
\link{Exercise 4.35}の手続き内の\code{an\-/integer\-/starting\-/from}で置き換えることは、
自由裁量なピタゴラスの三つ組を生成するのに適切でないのか、説明せよ。
これを実際に達成する手続きを書け。
(すなわち、原理上は\code{try\-/again}を繰り返し入力することで全てピタゴラスの三つ組を生成する手続きを書け)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.37}Exercise 4.37:}
Ben Bitdiddleは以下のピタゴラスの3つ組を生成する手法は\link{Exercise 4.35}の手法に比べ
より効率的であると主張した。彼は正しいだろうか? (ヒント：探索しなければならない可能性の
数を考えよ)

\begin{scheme}
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (>= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
\end{scheme}
\end{quote}

\subsection{非決定性プログラムの例}
\label{Section 4.3.2}
\link{Section 4.3.3}は\code{amb}評価機の実装を説明します。しかし最初にそれがどのように使用できるかに
ついて、いくつかの例を与えます。非決定性プログラミングの利点は探索がどのように実行されるのか
についての詳細を隠すことができることです。従って抽象の高いレベルにてプログラムを表現できます。

\subsubsection*{論理パズル}


以下のパズル(\link{Dinesman 1968}から拝借しました)は典型的な大きなクラスの簡単な
論理パズルです。

\begin{quote}
Baker, Cooper, Fletcher, Miller, それにSmithは同じ5階しかないアパートの異なる階に
住んでいます。Bakerは最上階には住んでいません。Cooperは最下階には住んでいません。
Fletcherは最上階にも最下階にも住んでいません。MillerはCooperよりも高い階に住んでいます。
SmithはFletcherのすぐ隣の階には住んでいません。FletcherはCooperのすぐ隣の階には住んでいません。
皆はどの階に住んでいるでしょうか?
\end{quote}

\noindent
誰がどの階に住んでいるかを、全ての可能性を列挙し与えられた制約を与える簡単な方法で
決定することができます。\footnote{
私達のプログラムは以下の手続きをリストの要素が識別可能
であるか判断するために使用しています。

\begin{smallscheme}
(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
\end{smallscheme}

\noindent
\code{member}は\code{memq}と同様ですがこれは\code{eq?}の代わりに\code{equal?}を
等価性のテストに用いています。}

\begin{scheme}
(define (multiple-dwelling)
  (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
        (smith    (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)       (list 'cooper cooper)
          (list 'fletcher fletcher) (list 'miller miller)
          (list 'smith smith))))
\end{scheme}

\noindent
式\code{(multiple\-/dwelling)}を評価すると結果を生成します。

\begin{scheme}
((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
\end{scheme}

\noindent
この簡単な手続きはうまく行きますが、とても遅いです。\link{Exercise 4.39}と
\link{Exercise 4.40}はいくらかの可能な改善法について議論します。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.38}Exercise 4.38:}
multiple-dwelling手続きを変更し、SmithとFletcherが隣接する階に住んでいないという
要件を取り除く。この変更したパズルにはいくつの解が存在するか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.39}Exercise 4.39:}
multiple-dwelling手続き内の制約の順は解に影響するだろうか? 回答を見つけるのにかかる
時間には影響を与えるだろうか? もしそれが重要であると考えるのなら、制約の順を変える
ことで与えられる物から得られるより速いプログラムを実演せよ。
もしそれが問題ではないと考えるのなら、あなたの考えを論ぜよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.40}Exercise 4.40:}
複数の住居の問題において、人を階へと割り当てる方法は、requirementの前と後で階の割り当てが
区別可能な方法でいくつあるか? 全ての人から階への可能な割り当てを生成してからその次に
それらを排除するためにbacktrackにまかせることは非常に非効率である。
例えば制約のほとんどは一つか二つの人と階の変数を持ち、従って全ての人に対して階が
選択される前に制約を与えることができる。この問題を先の制約により既に排除されたもの
以外の可能性のみを生成することに基づいて解くずっと効率の良い非決定性手続きを書き、実演せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.41}Exercise 4.41:}
複数住居パズルを解く通常のSchemeプログラムを書け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.42}Exercise 4.42:}
次の``嘘つき''パズル(\link{Phillips 1934}から)を解け

5人の女生徒が試験のために座っている。彼女達は、彼女等の両親が
結果に過大な興味を見せていると考えている。従って彼女達は次のことを合意した。
それぞれの少女が1つの正しい文と嘘の文を作り、各家庭に試験についての手紙を書く。
以下は彼女らの手紙の該当する一節である。

\begin{itemize}

\item
Betty: ``Kittyが試験では二位だった。私だけが3位だった。''

\item
Ethel: ``喜んで、私がトップ。Joanが2位だった。''

\item
Joan: ``私が3番。可哀想なEthelは最下位だった。''

\item
Kitty: ``私が2番。Maryが単独で4位。''

\item
Mary: ``私が4位。トップはBettyが取ったわ。''

\end{itemize}

実際にはどの順に5人の女の子は並べられるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.43}Exercise 4.43:}
\code{amb}評価機を用いて以下のパズルを解け\footnote{これは1960年代にLitton Industriesにより出版された
``問題の多いレクリエーション''と呼ばれる小冊子から引用しました。
\textit{Kansas State Engineer}著。}

Mary Ann Mooreの父はヨットを持っており、彼の4人の友達、
Downing大佐, Hallさん, Barnacle Hood卿, Dr. Parkerもそれぞれが持っていました。
5人のそれぞれに一人の娘がおり、それぞれが各自のヨットに他人の娘の名を取って付けていました。
Barnacle卿のヨットはGabrielleで、MooreさんのはLornaです。HallさんのはRosalindです。
Downing大佐のMelissaはBarnacle卿の娘の名を取って付けました。
Gabrielleの父のヨットはDr. Parkerの娘からです。Lornaの父は誰でしょう?

効率良く実行されるプログラムを書くように努めること(\link{Exercise 4.40}参照)。
また、もしMary Annの家族名がMooreであることを伝えなければ、いくつの解が存在するだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.44}Exercise 4.44:}
\link{Exercise 2.42}はチェス盤に8つのクイーンをどの2つもお互いに攻撃することが無いように
置く``8クイーンパズル''について説明した。このパズルを解く非決定性プログラムを書け。
\end{quote}

\subsubsection*{自然言語の構文解析}

自然言語を入力として受け入れるよう設計されたプログラムは通常、その入力を
\newterm{parse}(\jnewterm{パース}、\jnewterm{構文解析})することから始めます。つまり入力を
ある文法構造に対して合わせることです。例えば冠詞と続く名詞、続く動詞から成る
簡単な文、''The cat eats.``(猫は食べる)のような物を認識しようとしていると
します。そのような分析を達成するためには個別の単語の品詞を判別できなければ
なりません。多種の単語を判別できるいくつかのリストから始めることが
できるでしょう。\footnote{ここでは各リストの最初の要素はリストの残りの単語の
品詞を示すという仕様を用いています。}

\begin{scheme}
(define nouns '(noun student professor cat class))
(define verbs '(verb studies lectures eats sleeps))
(define articles '(article the a))
\end{scheme}

\noindent
また\newterm{grammar}(\jnewterm{文法})も必要です。つまり、文法上の要素がどのようにより簡単な要素から
組み立てられるのかを説明するルールの集合です。とても簡単な文法は文は常に2つの要素---名詞句と
それに続く動詞---により成ると規定することができるかもしれません。そして名詞句は定冠詞と
それに続く名詞から成り立ちます。この文法を用いて、文``The cat eats.''は以下のように
パースされます。

\begin{scheme}
(sentence (noun-phrase (article the) (noun cat))
          (verb eats))
\end{scheme}

\noindent
そのようなパースを、手続きを各文法上のルールに分割する簡単なプログラムを用いて生成することができます。
文をパースするためには、それを構成する2つの要素を判別し、これらの2つの要素のリストを
シンボル\code{sentence}のタグを付けて返します。


\begin{scheme}
(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-word verbs)))
\end{scheme}

\noindent
名詞句も同様に定冠詞とそれに続く名詞を見つけることでパースされます。

\begin{scheme}
(define (parse-noun-phrase)
  (list 'noun-phrase
        (parse-word articles)
        (parse-word nouns)))
\end{scheme}

\noindent
最も低いレベルでは、パースとは繰り返し次のパースされていない単語が必要とされる品詞の
ための単語のリストのメンバであるかをチェックすることだとまとめられます。
これを実装するために、私達はグローバル変数\code{*unparsed*}を持ちます。これは
まだパースされていない入力です。単語をチェックする各時点で\code{*unparsed*}が空では
ないことを要求し、また指定されたリストの単語で始まることを要求します。もしそうで
あるならその単語を\code{*unparsed*}から削除し、その単語をその品詞(これはリストの先頭に
見つかります)と共に返します。\footnote{\code{parse\-/word}がparseされていない入力リストの
変更するのに\code{set!}を用いているおおに注意して下さい。これをうまく行うためには、
\code{amb}評価機は\code{set!}命令の効果をバックトラックする時に取り消しできなければいけません。}

\begin{scheme}
(define (parse-word word-list)
  (require (not (null? *unparsed*)))
  (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
\end{scheme}

\noindent
パースを始めるために行わなければいけないこと全ては\code{*unparsed*}に入力全体を設定し、
文のパースを試み、何も残っていないことをチェックすることです。

\begin{scheme}
(define *unparsed* '())
(define (parse input)
  (set! *unparsed* input)
  (let ((sent (parse-sentence)))
    (require (null? *unparsed*)) sent))
\end{scheme}

\noindent
これでパーザ(parser、パースを行うプログラム)を試し、簡単なテスト文に対してうまく働くこと
を確認することができます。

\begin{scheme}
~\textit{;;; Amb-Eval input:}~
(parse '(the cat eats))
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
\end{scheme}
\begin{smallscheme}
~\textit{(sentence (noun-phrase (article the) (noun cat)) (verb eats))}~
\end{smallscheme}

\noindent
\code{amb}評価機はここでとても役立ちます。\code{require}の助けを用いてパースする上での
制約を表現するのにとても便利なためです。しかし、自動的な探索とバックトラックが
本当に効果を生むのはより複雑な文法について考えた時に、1つの単位の分解方法に
多数の選択肢が存在する場合です。


私達の文法に前置詞を追加してみましょう。

\begin{scheme}
(define prepositions '(prep for to in by with))
\end{scheme}

\noindent
そして前置詞句(例えば``for the cat''(猫のために))を名詞句の前の前置詞として定義します。

\begin{scheme}
(define (parse-prepositional-phrase)
  (list 'prep-phrase
        (parse-word prepositions)
        (parse-noun-phrase)))
\end{scheme}

\noindent
これで文は名詞句に動詞句が続くと定義でき、動詞句は動詞か、または前置詞句で拡張された動詞句
となります。\footnote{この定義が再帰的であることに注意して下さい。動詞には任意の数の
前置詞句が続けられます。}

\begin{scheme}
(define (parse-sentence)
  (list 'sentence (parse-noun-phrase) (parse-verb-phrase)))
(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend
          (list 'verb-phrase
                verb-phrase
                (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
\end{scheme}

\noindent
ここまでを行っている間に、名詞句の定義に``a cat in the class''(クラスの猫)のような
物を認めるよう詳細を詰めることができます。今まで名詞句と呼んできた物はこれからは
シンプルな名詞句と呼びます。そして名詞句はこれからシンプルな名詞句か前置詞句で
拡張した名詞句となります。

\begin{scheme}
(define (parse-simple-noun-phrase)
  (list 'simple-noun-phrase
        (parse-word articles)
        (parse-word nouns)))
(define (parse-noun-phrase)
  (define (maybe-extend noun-phrase)
    (amb noun-phrase
         (maybe-extend
          (list 'noun-phrase
                noun-phrase
                (parse-prepositional-phrase)))))
  (maybe-extend (parse-simple-noun-phrase)))
\end{scheme}

\noindent
私達の新しい文法はより複雑な文をパースできます。例えば、

\begin{scheme}
(parse '(the student with the cat sleeps in the class))
\end{scheme}

\noindent
(猫と一緒にその生徒はクラスで寝ている)は以下を生成します。

\begin{scheme}
(sentence
 (noun-phrase
  (simple-noun-phrase (article the) (noun student))
  (prep-phrase
   (prep with)
   (simple-noun-phrase (article the) (noun cat))))
 (verb-phrase
  (verb sleeps)
  (prep-phrase
   (prep in)
   (simple-noun-phrase (article the) (noun class)))))
\end{scheme}

\noindent
与えられた入力が二つ以上の有効な分析結果を持つかもしれないことを確認して下さい。
文``The professor lectures to the student with the cat''はprofessor(教授)が猫と一緒に
講義をしている場合と、学生が猫を持っている場合が有り得ます。
私達の非決定性プログラムは両方の可能性を見つけます。

\begin{scheme}
(parse '(the professor lectures to the student with the cat))
\end{scheme}

\noindent
は以下を生成します。

\begin{scheme}
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase
   (verb lectures)
   (prep-phrase
    (prep to)
    (simple-noun-phrase (article the) (noun student))))
  (prep-phrase
   (prep with)
   (simple-noun-phrase (article the) (noun cat)))))
\end{scheme}

\noindent
評価機にもう一度試行を命ずると以下を生じます。

\begin{scheme}
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase
   (prep to)
   (noun-phrase
    (simple-noun-phrase (article the) (noun student))
    (prep-phrase
     (prep with)
     (simple-noun-phrase (article the) (noun cat)))))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.45}Exercise 4.45:}
上で与えられた文法を用いて次の文は5通りにパースできる。 ``The professor
lectures to the student in the class with the cat''。5通りの結果を与えて
それらの間の様々な意味の違いを説明せよ。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.46}Exercise 4.46:} 
\link{Section 4.1}と\link{Section 4.2}は評価機はどの順でオペランドが評価されるかを決定しない。
我々は\code{amb}評価機がそれらを左から右へと評価するのを見るだろう。
なぜ我々のパーザはオペランドが何らかの他の順で評価されたならうまく働かないのか
説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.47}Exercise 4.47:}
Louis Reasonerは動詞句は動詞か前置詞句が続く動詞句であるのだから、
手続き\code{parse\-/verb\-/phrase}を以下のように(そして同様に名詞句に対しても)
定義すればずっと簡単になるのではないかと提案した。

\begin{scheme}
(define (parse-verb-phrase)
  (amb (parse-word verbs)
       (list 'verb-phrase
             (parse-verb-phrase)
             (parse-prepositional-phrase))))
\end{scheme}

これはうまく行くだろうか? このプログラムの振舞はもし\code{amb}内の式の順を置き換えたら
変わるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.48}Exercise 4.48:}
上で与えられた文法をより複雑な文を取り扱うように拡張せよ。例えば、名詞句と動詞句を
拡張し形容詞と福祉を含める、または複合文を取り扱えるようできるだろう。\footnote{この種の
文法は任意の複雑さに成り得ます。しかし現実の言語の理解を考える限りはただの玩具に
過ぎません。現実の自然言語のコンピュータによる理解は構文解析と意味解釈の念入りな
混合が要求されます。一方で、例えおもちゃのパーザでもプログラムのための柔軟な命令言語、
例えば情報取得システム等をサポートするには実用的です。\link{Winston 1992}は
計算機による自然言語理解への取り組みと共に簡単な文法の命令言語のアプリケーションについても
議論しています。}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.49}Exercise 4.49:}
Alyssa P. Hackerはパースするよりも面白い文を生成することにより興味を持っている。
彼女は手続き\code{parse\-/word}を簡単に変更してそれが``入力文''を無視し、その代わりに
常に成功して適切な単語を生成するようにすれば、このパースのために構築したプログラムを
用いて代わりに生成を行えるのではないかと推測した。Alyssaの考えを実装せよ。そして
生成された文の最初の半ダースかそこらを示せ。\footnote{Alyssaのアイデアはちゃんと
うまく働きますが(そして驚くほど簡単ですが)、それが生成する文は少しつまらないです。
それらはこの言語の可能な文からとても面白い様には抽出はしません。実際に文法は
多くの場所で高度に再帰し、Alyssaの技術はこれらの再帰の1つに``falls into''(陥り)、
抜け出せなくなります。これに対処する方法は\link{Exercise 4.50}を参照して下さい。}
\end{quote}

\subsection{\code{Amb}評価機の実装}
\label{Section 4.3.3}


通常のScheme式の評価機は値を返すか、永遠に停止しないか、またはエラーを発します。
非決定性Schemeでは式の評価はそれに加えて探索が行き止まりに帰結します。
その場合には評価機は依然の選択点へバックトラックしなければなりません。
非決定性Schemeの解釈はこの特別な場合により複雑になります。


私達は非決定性Schemeのための\code{amb}評価機を、\link{Section 4.1.7}の分析評価機を変更することで
構築します。\footnote{私達は\link{Section 4.2}の遅延評価機を\link{Section 4.1.1}の通常のメタ循環評価機に
対する変更として実装することを選択しました。対照的に、\link{Section 4.1.7}の分析評価機を
\code{amb}評価機の基にします。その評価機内の実行手続きがバックトラックを実装するのに
便利なフレームワークを提供するためです。}分析評価機のように、式の評価は式の分析により
生成される実行手続きを呼ぶことにより達成されます。通常のSchemeの解釈と非決定性Schemeの
解釈との違いは完全に実行手続きの中に存在します。

\subsubsection*{手続きと継続の実行}

通常の評価機の実行手続きが1つの引数、実行の環境を取ることを思い出して下さい。
対照的に、\code{amb}評価機の実行手続きは3つの引数を取ります。環境と
\newterm{continuation procedures}(\jnewterm{継続手続き})と呼ばれる2つの手続きです。
式の評価はこれらの2つの継続の1つを呼ぶことで完了します。もし評価の結果が
値に帰結するならば、\newterm{success continuation}(\jnewterm{成功継続})がその値と共に
呼ばれます。もし評価が行き止まりの発見に帰結したのであれば、
\newterm{failure continuation}(\jnewterm{失敗継続})が呼ばれます。適切な継続の構築と呼出が
非決定性評価機のバックトラックが実装される仕組みです。

値を受け取り計算を続行することが成功継続の仕事です。その値と共に、成功継続は別の
失敗継続も渡されます。これはその後にもしその値の使用が行き止まりに導いたなら
呼び出されます。


非決定性処理の他の分岐を試すのは失敗継続の仕事です。非決定性言語の本質は
式が選択肢の間の選択を表現するだろうという事実の中に存在します。
そのような式の評価は例え前もってどの選択肢受け入れ可能な結果に導くか知らなくても
指示された代替となる選択の一つを用いて続行しなければなりません。これを処理するため
には、評価機は選択肢から1つを取り出しこの値を成功継続に渡します。この値と共に、
評価機は後で異なる選択肢を選択するために呼び出し可能な失敗継続を構築し、一緒に渡します。


失敗は評価の間に引き起こされます。(言い換えれば失敗継続が呼ばれます)。それはユーザプログラムが
明示的に現在の一連の取り組みを拒絶した場合に起こります。(例えば、\code{require}の呼出は結果として
\code{(amb)}が実行される場合があります。これは常に失敗する式です。---\link{Section 4.3.1}参照)。
その時点で手中にある失敗継続が最も最近の選択点に他の選択肢を選択させます。
もしもうその選択点にて考えられる他の選択肢が無い場合には、直前の選択点の失敗が引き起こされます。
以下その繰り返しです。失敗継続はまた式の別の値を見つけるためのドライバループによる\code{try\-/again}要求への
応答としても起動されます。


加えて、もし副作用命令(変数への代入等)がある選択の結果としての分岐処理上で起こったならば、
処理が行き止まりを見つけた時に、新しい選択を行う前にその副作用を取り消しする必要が
あるかもしれません。これは副作用命令に副作用を取り消し失敗を伝播させる失敗継続を
生成させることで達成されます。


まとめとして、失敗継続は以下により構築されます。

\begin{itemize}

\item
\code{amb}式---\code{amb}式により行われた現在の選択が行き止まりに導いた場合に別の選択を行う
仕組みを提供します

\item
トップレベルドライバ---選択肢が枯渇した時に失敗を報告する仕組みを提供します

\item
代入---失敗に割り込み、バックトラックの間に代入を取り消します

\end{itemize}

\noindent
失敗は行き止まりに遭遇したその時のみ起動されます。これは以下の場合に起こります。

\begin{itemize}

\item
ユーザプログラムが\code{(amb)}を実行した

\item
ユーザがトップレベルドライバにて\code{try\-/again}を入力した

\end{itemize}

\noindent
失敗継続はまた失敗処理の間にも呼ばれます。

\begin{itemize}

\item
代入が副作用の取消を完了させることで失敗継続が作成された時に、それは割り込んだ
失敗継続を、失敗を伝播させこの代入に導いた選択点に戻すために、またはトップレベルに戻すために
呼びます。

\item
\code{amb}に対する失敗継続が選択肢を使い切った時、、
失敗を直前の選択点かトップレベルに伝播させるために、\code{amb}に対して元々与えられた失敗継続を呼び出します。

\end{itemize}

\subsubsection*{評価機の構造}


\code{amb}評価機に対する文法とデータの表現手続き、また基本的な\code{analyze}手続きは、
\link{Section 4.1.7}の評価機のそれらに等しい物です。しかし私達が追加の構文手続きを\code{amb}の
特殊形式を認識するために必要とすることが異なります。\footnote{評価機は\code{let}を
サポートすると想定しています。(\link{Exercise 4.22}参照)。私達はこれを非決定性
プログラム内にて利用してきました。}

\begin{scheme}
(define (amb? exp)
  (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
\end{scheme}

\noindent
\code{analyze}内にこの特殊形式を認識し、適切な実行手続きを生成する呼出を追加しなければなりません。

\begin{scheme}
((amb? exp) (analyze-amb exp))
\end{scheme}

\noindent
トップレベル手続き\code{ambeval}(\link{Section 4.1.7}で与えられた\code{eval}の版に似た物)は
与えられた式を分析し、実行手続きを与えられた環境に対し、2つの与えられた継続と一緒に
適用しなければなりません。

\begin{scheme}
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
\end{scheme}

\noindent
成功継続は2引数の手続きです。2引数は得られたばかりの値とその値がその後に失敗へと導いたなら
使用される別の失敗継続です。失敗継続は引数無しの手続きです。そのため実行手続きの
一般的な形は以下のようになります。

\begin{scheme}
(lambda (env succeed fail)
  ~\textrm{;; \code{succeed} is \code{(lambda (value fail) \( \dots \))}}~
  ~\textrm{;; \code{fail} is \code{(lambda () \( \dots \))}}~
  ~\( \dots \)~)
\end{scheme}

\noindent
例えば、以下を実行すると、

\begin{scheme}
(ambeval ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
\end{scheme}

\noindent
与えられた式を評価し、式の値(評価が成功した場合)かシンボル\code{failed}(評価が失敗
した場合)を返します。以下で示されるドライバループ内での\code{ambeval}の呼出はより
多くの複雑な継続手続きを使用します。これらはループを継続し\code{try\-/again}要求を
サポートします。

\code{amb}の複雑さの多くは実行手続きがお互いを呼ぶに従い、継続をたらい回しにすることから来ています。
以下のコードを通して読むに当って、それぞれの実行手続きを\link{Section 4.1.7}で与えられた通常の評価機のための
対応する手続きと比べて下さい。

\subsubsection*{単純な式}

最も単純な種類の式に対する実行手続きは本質的に通常の評価機に対するものと同じです。
ただし、継続を管理する必要があることが異なります。これらの実行手続きは式の値と共に単純に
成功し、渡された失敗継続をそのまま手渡します。

\begin{scheme}
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
\end{scheme}

\noindent
変数の検索が常に`成功'することに注意して下さい。もし\code{lookup\-/variable\-/value}が
変数を見つけるのに失敗した場合、それはいつも通りにエラーを発します。
そのような``失敗''はプログラムのバグ---未束縛な変数への参照---を示します。
これは現在試行中の物の代わりに別の非決定性選択を試すことを示してはいません。

\subsubsection*{条件文と列}


条件文もまた通常の評価機と同様に取り扱われます。\code{analyze\-/if}により生成される
実行手続きは述語実行手続き\code{pproc}を成功継続と共に起動します。成功継続は
述語の値が真であるかチェックし、結果部(consequent)か代替部(alternative)を実行します。
もし\code{pproc}の実行が失敗したなら\code{if}式に対する元の失敗継続が呼ばれます。

\begin{scheme}
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             ~\textrm{;; 述語を評価するための成功継続を置く}~
             ~\textrm{;; \code{pred\-/value}を得るため}~
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             ~\textrm{;; 述語を評価するための失敗継続}~
             fail))))
\end{scheme}

\noindent
列もまた以前の評価機と同様に取り扱われます。ただし継続を渡すために必要とされる
内部手続き\code{sequentially}内の企みが異なります。具体的には\code{a}を実行し、次に\code{b}と順に
行うために、\code{a}を成功継続と共に呼び、成功継続が\code{b}を呼びます。

\begin{scheme}
(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         ~\textrm{;; \code{a}を呼ぶための成功継続}~
         (lambda (a-value fail2)
           (b env succeed fail2))
         ~\textrm{;; \code{a}を呼ぶための失敗継続}~
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc
                            (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))
\end{scheme}

\subsubsection*{定義と代入}

定義は継続を管理するために手間をかけなければいけない一例です。定義の値(definition-value)の式を
実際に新しい値を定義する前に評価する必要があるためです。これを達成するためには
定義値実行手続き\code{vproc}が環境、成功継続、失敗継続と共に呼ばれます。
もし\code{vproc}の実行が成功したなら定義値のための値\code{val}を取得し、変数が定義され
成功が伝播されます。

\begin{scheme}
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
\end{scheme}

\noindent
代入はもっと面白いです。これは継続をたらい回しにするのではなく、本当に継続を使用する最初の場所です。
代入のための実行手続きは定義のためのものと同様に開始します。最初に変数に代入される新しい値を取得しようと
試みます。もしこの\code{vproc}の評価が失敗したら代入は失敗します。


しかし\code{vproc}が成功し代入を行なおうとした場合には、この計算の分岐が後に失敗する
可能性について考えねばなりません。この場合には代入から外れてバックトラックする必要があります。
従ってこの代入をバックトラック処理の一部分として取消する準備をしなければなりません。\footnote{定義の
取消については心配しません。内部定義は走査されたことが想定可能なためです。(\link{Section 4.1.6})}


これは\code{vproc}に(下でコメント``*1*''が記された)成功継続を与えることで達成されます。
この成功継続は新しい値を代入し、結果として存在する前に、変数の古い値を保存します。
代入値と共に渡された(下でコメント``*2*''が記された)失敗継続は失敗を続ける前に変数の古い値を再格納します。
つまり、代入の成功は後の失敗に割り込む失敗継続を提供します。そうでなければ\code{fail2}を呼んでいたはずのどんな失敗も
この手続きを代わりに呼ぶことで、実際に\code{fail2}を呼ぶ前に代入を取り消します。

\begin{scheme}
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))

    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        ~\textrm{; *1*}~
               (let ((old-value
                      (lookup-variable-value var env)))
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    ~\textrm{; *2*}~
                            (set-variable-value!
                             var old-value env)
                            (fail2)))))
             fail))))
\end{scheme}

\subsubsection*{手続きの適用}


適用のための実行手続きは新しいアイデアを含んではいません。ただし継続を管理する
技術的な複雑さが異なります。この複雑さは\code{analyze\-/application}の中で
オペランドを評価するに従い成功と失敗の継続を追跡する必要があるために、浮上します。
私達は通常の評価機の中の様に単純に\code{map}を使うのでなく、手続き\code{get\-/args}を用いてオペランドの
リストを評価しています。

\begin{scheme}
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
\end{scheme}

\noindent
\code{get\-/args}の中では、どのようにして\code{aproc}実行手続きのリストを\code{cdr}で下り、そして
結果の\code{args}のリストを全て\code{cons}するかについて注意して下さい。
これはリスト中の全ての\code{aproc}を、
再帰的に\code{get\-/args}を呼ぶ成功継続と共に呼ぶことにより達成されます。
これらの\code{get\-/args}に対する全ての再帰的呼出は、蓄積された引数のリストの上に
新しく取得された引数を\code{cons}した値を返す成功継続を持っています。

\begin{scheme}
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs)
       env
       ;;~\textrm{この\code{aproc}のための成功継続}~
       (lambda (arg fail2)
         (get-args
          (cdr aprocs)
          env
          ;;~\textrm{\code{get\-/args}の再帰呼出のための}~
          ;;~\textrm{成功継続}~
          (lambda (args fail3)
            (succeed (cons arg args) fail3))
          fail2))
       fail)))
\end{scheme}

\noindent
\code{exe@\-/cute\-/application}により実行される実際の手続き適用は通常の評価機に対する物と
同じ方法にて達成されます。ただし継続の管理の必要が異なります。

\begin{scheme}
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (procedure-parameters proc)
           args
           (procedure-environment proc))
          succeed
          fail))
        (else (error "Unknown procedure type:
                      EXECUTE-APPLICATION"
                     proc))))
\end{scheme}

\subsubsection*{\code{amb}式の評価}

\code{amb}の特殊形式は非決定性言語の鍵となる要素です。ここでは逐次翻訳処理の本質と
継続を追跡する理由について学びます。\code{amb}に対する実行手続きはループ\code{try\-/next}を
定義します。これは全ての\code{amb}式の可能な値のために、全実行手続きを通して実行します。
各実行手続きは次の実行手続きを試す失敗継続と共に呼ばれます。試行する選択肢が無くなった
時には、\code{amb}式全体が失敗します。

\begin{scheme}
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices)
             env
             succeed
             (lambda () (try-next (cdr choices))))))
      (try-next cprocs))))
\end{scheme}

\subsubsection*{ドライバループ}

\code{amb}評価機のドライバループは複雑です。ユーザに式の評価を再試行(try-again)
することを可能にする仕組みのためです。ドライバは\code{internal\-/loop}と呼ばれる
手続きを使用します。これは引数として手続き\code{try\-/again}を取ります。これの意図は
\code{try\-/again}の呼出は次のまだ試行されていない非決定性評価における選択肢へ
続けなければならないことです。\code{internal\-/loop}はユーザのドライバループでの
\code{try\-/again}の入力への応答として\code{try\-/again}を呼ぶか、またはそうでなければ
\code{ambeval}を呼ぶことにより新しい評価を開始します。

\code{ambeval}へのこの呼出のための失敗継続はユーザにもう値は残っていないと伝え、
ドライバループを再起動する。

\code{ambeval}への呼出のための成功継続はより微妙です。獲得した値を表示し、次に内部ループを
再び起動します。起動には次の選択肢を試行可能な\code{try\-/again}手続きを伴ないます。
この\code{next\-/alternative}手続きは成功継続に二番目の引数として渡されます。通常はこの二番目の
引数はもし現在の評価分岐が後に失敗場合に利用される失敗継続として考えます。
今回の場合はしかし、評価を成功裏に完了しました。そのため``失敗''の代替分岐を追加の成功する
評価を探すために起動することができます。

\begin{scheme}
(define input-prompt  ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")
(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Starting a new problem ")
            (ambeval
             input
             the-global-environment
             ;; ~\textrm{\code{ambeval} success}~
             (lambda (val next-alternative)
               (announce-output output-prompt)
               (user-print val)
               (internal-loop next-alternative))
             ;; ~\textrm{\code{ambeval} failure}~
             (lambda ()
               (announce-output
                ";;; There are no more values of")
               (user-print input)
               (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; There is no current problem")
     (driver-loop))))
\end{scheme}

\noindent
\code{internal\-/loop}の最初の呼出では現在、問題が無いと不服を述べ、ドライバループを再開します。
これはユーザが\code{try\-/again}を入力し評価に進展が無い場合に起こる振舞です。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.50}Exercise 4.50:}
\code{amb}と似ているが、次の選択肢を左から右へでなくランダムな順で探索する新しい特殊形式\code{ramb}を実装せよ。
\link{Exercise 4.49}におけるAlyssaの問題をどのように助けるか示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.51}Exercise 4.51:}
失敗時に取り消されない\code{permanent\-/set!}と呼ばれる新しい種類の代入を実装せよ。
例えば、以下の様に2つの区別可能な要素をリストから選択し、成功した選択に必要とした試行の数を
カウントする。

\begin{scheme}
(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{(a b 2)}~
~\textit{;;; Amb-Eval input:}~
try-again
~\textit{;;; Amb-Eval value:}~
~\textit{(a c 3)}~
\end{scheme}


ここで\code{permanent\-/set!}の代わりに\code{set!}を使ったらどんな値が表示されるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.52}Exercise 4.52:}
ユーザに式の失敗を捕獲させることを可能にする新しいコンストラクタ\code{if\-/fail}を実装せよ。
\code{if\-/fail}は2つの式を取る。最初の式を通常通りに評価し評価が成功したら普通に戻る。
しかし、もし評価が失敗したら2つ目の式の値が以下の例の様に返される。

\begin{scheme}
~\textit{;;; Amb-Eval input:}~
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{all-odd}~

~\textit{;;; Amb-Eval input:}~
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{8}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.53}Exercise 4.53:}
\link{Exercise 4.51}で説明した\code{permanent\-/set!}と\link{Exercise 4.52}の
\code{if\-/fail}を用いて以下を評価した時どのような結果になるか。

\begin{scheme}
(let ((pairs '()))
  (if-fail 
   (let ((p (prime-sum-pair '(1 3 5 8)
                            '(20 35 110))))
     (permanent-set! pairs (cons p pairs))
     (amb))
   pairs))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.54}Exercise 4.54:}
もし\code{require}が\code{amb}を用いた通常の手続きとして実装できることに気付かなかった場合、
ユーザにより非決定性プログラムの一部として定義されるために、それを特殊形式として
実装する必要があったはずである。これは以下の構文手続きを必要としたであろう。

\begin{scheme}
(define (require? exp)
  (tagged-list? exp 'require))
(define (require-predicate exp) 
  (cadr exp))
\end{scheme}

\noindent
そして\code{analyze}内の呼出に新しい節が必要となった。

\begin{scheme}
((require? exp) (analyze-require exp))
\end{scheme}

\noindent
また\code{require}式を取り扱う手続き\code{analyze\-/require}も必要となった。
以下の\code{analyze\-/require}の定義を完成させよ。

\begin{scheme}
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
                   ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
                   (succeed 'ok fail2)))
             fail))))

\end{scheme}
\end{quote}


\section{論理プログラミング}
\label{Section 4.4}

\link{Chapter 1}では計算機科学は命令型(どうするか)の知識を扱い、一方、数学は宣言型(何であるか)の
知識を扱うと強調しました。実際に、プログラミング言語はプログラマが特定の問題を解くために、
段階的な手法を示す形式により、知識を表現することを要求します。
一方、高級言語は言語の実装の一部としてユーザを、指定された演算がどのように進められるかについての詳細から
解放する、十分な量の方法論的知識を提供します。

Lispを含む多くのプログラミング言語は数学上の関数の値の演算の周りに体系化されています。
式指向の言語(例えばLisp、Fortran、Algol)は関数の値を記述する式がその値を求める
手段としても解釈されるという``多義性''を十分に活用しています。このため、多くの
プログラミング言語は単向性演算(明確な入力と出力を持つ演算)に向けて強く偏っています。
しかし、この偏りを緩和する完全に異なるプログラミング言語も存在します。そのような言語の
例を\link{Section 3.3.5}で見ました。そこでは計算オブジェクトは数値的な制約でした。制約システムでは
演算の向きと順はあまり明らかには指定されません。従って、演算の実行においてシステムはより
詳細な``行い方''の知識を、通常の数値演算による場合よりも多く提供しなければなりません。
しかし、これはユーザが命令型の知識を提供する責任から完全に解放されることは意味しません。
同じ制約の集合を実装する制約ネットワークは数多く存在し、ユーザは数学的に等価なネットワークの中から
特定の演算を指定するのに適切なネットワークを選択せねばなりません。

\link{Section 4.3}の非決定性プログラム評価機もまたプログラミングとは一方向性関数のための
アルゴリズムを構築することであるという視点から離れています。非決定性言語においては、
式は2つ以上の値を持つことができ、結果として演算とは単一の値の関数ではなく関係性を
取り扱う物になります。論理プログラミングはプログラミングの関係性の視点と
\newterm{unification}(\jnewterm{ユニフィケーション}、単一化)と呼ばれる強力な種類の記号パターン
マッチングとを組み合わせることでこの考えを拡張します。\footnote{論理プログラミングは
自動定理証明の研究の長い歴史から成長しました。早期の定理証明プログラムはあまり目的を
達成することができませんでした。可能な証明空間を網羅的に探索するためです。受け入れ可能な
探索を行える打開策の主な物は1960年代早期の\newterm{unification algorithm}(\jnewterm{ユニフィケーションアルゴリズム})と
\newterm{resolution principle}(\jnewterm{導出原理})(\link{Robinson 1965})の発見でした。
例えば導出は\link{Green and Raphael (1968)}により(\link{Green 1969}も参照)
演繹的質問応答システムの基盤として使用されました。この時期の多くの間、研究者達は
証明が存在するのであれば見つけられることが保証されたアルゴリズムについて集中していました。
そのようなアルゴリズムはコントロールして証明に向かわせることが難しいものでした。
\link{Hewitt (1969)}はプログラミング言語のコントロール構造と論理操作システムとの
結合の可能性を認識し、\link{Section 4.3.1}(\link{Footnote 4.47})で述べられた自動探索の成果へと
導きました。同時期に、マルセイユのColmerauerは自然言語を扱うルールベースシステム
(\link{Colmerauer et al. 1973})により同じ事を達成しました。彼はPrologと呼ばれる
プログラミング言語を開発しそれらのルールを表現しました。\link{Kowalski (1973; 1979)}は
エディンバラにて、Prologプログラムの実行は(線形ホーン節導出と呼ばれる
証明のテクニックを用いて)定理証明として解釈できることを認めました。
最後の2つの糸を縒り合わせることが論理プログラミング運動へと導きました。従って
論理プログラミングの開発に対して功績を与えることにおいて、フランス人はマルセイユ大学
でのPrologの起源を指摘することができ、一方、イギリス人はエディンバラ大学の成果を
強調することができます。\acronym{MIT}の人々に言わせれば、論理プログラミングはこれらの
グループにより、Hewittがその才能ある、しかし頑迷な博士論文にて何を伝えていたかを
解き明かす試みにより開発されました。論理プログラミングの歴史については
\link{Robinson 1983}を参照して下さい。}

この取り組み方は、うまく行く場合には、プログラムを書くのにとても強力な方法となります。
その力の一部は単一の``何であるか''という事実が、異なる``行い方''の要素を持つかもしれない
いくつかの異なる問題を解決するのに使用できるという事実から来ています。
例として、\code{append}命令について考えましょう。これは2つのリストを引数として取り、それらの
要素を結合して単一のリストを形成します。Lispのような手続き型言語では\code{append}を
基本的なリストコンストラクタ\code{cons}を用いて、\link{Section 2.2.1}で行ったように定義することができました。

\begin{scheme}

(define (append x y)
  (if (null? x) y (cons (car x) (append (cdr x) y))))
\end{scheme}

\noindent
この手続きは以下の2つのルールによりLispへと翻訳したと捕えることができます。
最初のルールは1つ目のリストが空である場合を扱い、2つ目のルールは空でないリスト、
つまり2つの部分による\code{cons}の場合を扱います。

\begin{itemize}

\item
任意のリスト\code{y}に対し、空リストと\code{y}の\code{append}は\code{y}を形成する。

\item
任意の\code{u}, \code{v}, \code{y}, \code{z}に対し、\code{(cons u v)}と\code{y}の\code{append}は
もし\code{v}と\code{y}の\code{append}が\code{z}を形成するならば\code{(cons u z)}を形成する。\footnote{ルールと
手続きの間の対応を見るためには、手続きにおける\code{x}(\code{x}が空でない場合)を
ルールの\code{(cons u v)}に対応させます。次にルールの\code{z}は\code{(cdr x)}と\code{y}の
\code{append}に対応します。}

\end{itemize}

\noindent
\code{append}手続きを用いることで、私達は次のような質問に答えることができます。

\begin{quote}
\code{(a b)}と\code{(c d)}の\code{append}を求めよ。
\end{quote}

\noindent
しかし同じ2つのルールがまた以下のような種類の質問に答えるためにも十分です。
これらは手続きでは答えられません。

\begin{quote}
\code{(a b)}と\code{append}すると\code{(a b c d)}を生成するリスト\code{y}を求めよ。


\code{append}すると\code{(a b c d)}を生成する全ての\code{x}と\code{y}を求めよ。
\end{quote}

\noindent
論理プログラミング言語ではプログラマは\code{append}``手続き''を上で与えられた\code{append}に関する
2つのルールを提示することにより記述します。``行い方''の知識は自動的にインタプリタにより
提供されこの単一ペアのルールが3つ全てのタイプの\code{append}に関する質問に対して答えることを
可能にします。\footnote{これは確かにユーザをどのように回答を求めるかという問題全体からは
解放しません。\code{append}の関係を形式化するための数学的に等価なルールは数多く存在します。
それらのいくつかのみが任意の方向の演算に対する効果的な手段と成り得ます。
付け加えて、時々、``何であるか''という情報は``どのように''回答を求めるかについて
何の手掛かりも与えない場合があります。例えば\( y^2 = x \)となる\( y \)を求める
問題について考えてみて下さい。}


現代の論理プログラミング言語(ここで私達が実装しているものを含めて)にはかなりの量の
不足がそれらの一般的な``行い方''の手法について存在します。このことが偽の無限ループを
引き起したり、他の望ましくない振舞へと導いてしまします。論理プログラミングは計算機
科学において活発な研究領域です。\footnote{論理プログラミングへの興味は80年代早期に
日本政府が論理プログラミング言語を実行するのに最適化されたとても速い計算機を構築する
ことを狙った大望あるプロジェクトを開始した時にピークを迎えました。そのような計算機の
スピードは通常のFLOPS(FLoating-point Operations Per Second)でなく
LIPS(Logical Inferences Per Second)で計られます。プロジェクトはハードウェアとソフトウェアの
開発において元々の計画通りに成功しましたが、国際的なコンピュータ業界は異なる方向へと
向かいました。日本のプロジェクトの評価の概観については\link{Feigenbaum and Shrobe 1993}を
参照して下さい。論理プログラミングコミュニティもまた、\link{Section 3.3.5}の制約伝播システムで
説明されたような数値値上の制約を取り扱う能力の様な単純なパターンマッチングではない
技術を基盤にしたリレーショナルプログラミングへと移行しました。}


この章の最初では私達はインタプリタの実装技術を探求しLispの様な言語のための
インタプリタに対して(実際に、任意の従来の言語に対して)本質である要素を説明しました。
今から私達はこれらの考えを応用し論理プログラミング言語のためのインタプリタについて議論します。
この言語を\newterm{query language}(\jnewterm{クエリ言語})と呼ぶことにします。言語で内で表現される、
\newterm{queries}(\jnewterm{クエリ})、つまり質問を定式化することによりデータベースから情報を
取得することに対してとても便利なためです。
クエリ言語はLispと全く違うであるにも係らず、私達がここまで利用してきた同じ一般的なフレームワークを
用いてこの言語を説明することがとても都合が良いことを理解するでしょう。
このフレームワークはプリミティブな要素の集合として、簡単な要素を組み合わせることでより複雑な要素を作ることを
可能にする組み合わせの手段と、複雑な要素を単純な概念の単位として見做すことを可能にする
抽象化の手段とを一緒に用いました。
論理プログラミング言語向けインタプリタはLispのような言語のインタプリタよりも大幅に複雑です。
それでも、私達のクエリ言語インタプリタが\link{Section 4.1}のインタプリタ内にて見つけた多くの同じ
要素を含むことを学ぶでしょう。
具体的には式を方に従って分類する``eval''のパートが存在し、そして言語の抽象化の仕組み(Lispの
場合では手続きであり、論理プログラミングの場合ではルール)を実装する``apply''のパートが存在します。
また、中心的な役割はフレームデータ構造により実装の中で演じられます。このフレームデータ構造は
シンボルとそれらに関連する値の間の対応を決定します。クエリ言語の実装の追加の面白い側面の1つは、
\link{Chapter 3}で紹介したストリームを大量に使用することです。



\subsection{演繹的情報検索}
\label{Section 4.4.1}

論理プログラミングは情報取得のためのデータベースに対するインターフェイスの提供に
おいて秀でています。私達がこの章で実装するクエリ言語はこのように使用されるよう
設計されています。


クエリシステムが何を行うかを説明するために、ボストン区域に存在する成長中の
ハイテク企業、Microshaftの社員情報のデータベースを管理するために、クエリシステムが
どのように利用できるかについて示します。この言語はパターンにより示される社員情報への
アクセスを提供し、また論理的演繹法を行うための一般的なルールの利点をも得ることができます。

\subsubsection*{サンプルデータベース}

Microshaftの社員情報データベースは会社の全社員に関する\newterm{assertions}(\jnewterm{アサーション}、表明)を
保持します。以下に常駐のコンピュータウィザード、Ben Bitdiddleに関する情報を挙げます。

\begin{scheme}
(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))
(job (Bitdiddle Ben) (computer wizard))
(salary (Bitdiddle Ben) 60000)
\end{scheme}

\noindent
各アサーションはリスト(この場合3つ組)で、その要素はそれ自体がリストに成り得ます。


常駐のウィザードとして、Benは会社のコンピュータ部門を管理し、二人のプログラマと一人の
技術者を監督します。以下に部下に関する情報を挙げます。

\begin{scheme}
(address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))
(job (Hacker Alyssa P) (computer programmer))
(salary (Hacker Alyssa P) 40000)
(supervisor (Hacker Alyssa P) (Bitdiddle Ben))

(address (Fect Cy D) (Cambridge (Ames Street) 3))
(job (Fect Cy D) (computer programmer))
(salary (Fect Cy D) 35000)
(supervisor (Fect Cy D) (Bitdiddle Ben))

(address (Tweakit Lem E) (Boston (Bay State Road) 22))
(job (Tweakit Lem E) (computer technician))
(salary (Tweakit Lem E) 25000)
(supervisor (Tweakit Lem E) (Bitdiddle Ben))
\end{scheme}

\noindent
Alyssaに監督されているプログラマ見習いもいます。

\begin{scheme}
(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
(job (Reasoner Louis) (computer programmer trainee))
(salary (Reasoner Louis) 30000)
(supervisor (Reasoner Louis) (Hacker Alyssa P))
\end{scheme}

\noindent
これらの人々全てはコンピュータ部門に属し、彼等の職位(job)記述の最初の項目である
単語\code{computer}により示されています。


Benは高位の従業員です。彼の監督者は会社の有力者である彼自身です。

\begin{scheme}
(supervisor (Bitdiddle Ben) (Warbucks Oliver))
(address (Warbucks Oliver) (Swellesley (Top Heap Road)))
(job (Warbucks Oliver) (administration big wheel))
(salary (Warbucks Oliver) 150000)
\end{scheme}

\noindent
コンピュータ部門がBenに監督されているのに加えて、会社には会計士長とそのアシスタントから
成る経理部門があります。

\begin{scheme}
(address (Scrooge Eben) (Weston (Shady Lane) 10))
(job (Scrooge Eben) (accounting chief accountant))
(salary (Scrooge Eben) 75000)
(supervisor (Scrooge Eben) (Warbucks Oliver))

(address (Cratchet Robert) (Allston (N Harvard Street) 16))
(job (Cratchet Robert) (accounting scrivener))
(salary (Cratchet Robert) 18000)
(supervisor (Cratchet Robert) (Scrooge Eben))
\end{scheme}

\noindent
また重役のための秘書もいます。

\begin{scheme}
(address (Aull DeWitt) (Slumerville (Onion Square) 5))
(job (Aull DeWitt) (administration secretary))
(salary (Aull DeWitt) 25000)
(supervisor (Aull DeWitt) (Warbucks Oliver))
\end{scheme}

\noindent
データベースはまたどの職種が他の職種を持つ人々により行われることができるかに関する
アサーションも含みます。例えばコンピュータウィザードはコンピュータプログラマと
コンピュータ技術者の両方の職を行うことができます。

\begin{scheme}
(can-do-job (computer wizard) (computer programmer))
(can-do-job (computer wizard) (computer technician))
\end{scheme}

\noindent
コンピュータプログラマは見習いを埋めることができるでしょう。

\begin{scheme}
(can-do-job (computer programmer)
            (computer programmer trainee))
\end{scheme}

\noindent
また良く知られているように以下も言えます。

\begin{scheme}
(can-do-job (administration secretary)
            (administration big wheel))
\end{scheme}

\subsubsection*{単純なクエリ}


クエリ言語はユーザにシステムプロンプトに対する応答として
クエリを提示させることで、データベースから情報を取得することを許します。

\begin{scheme}
~\textit{;;; Query input:}~
(job ?x (computer programmer))
\end{scheme}

\noindent
システムは以下の項目を返します。

\begin{scheme}
~\textit{;;; Query results:}~
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
\end{scheme}

\noindent
入力クエリはある種のパターンにマッチするデータベース内のエントリを探すことを指示します。
この例では、パターンは3つの項目から成るエントリを指定しています。最初が文字シンボルの
\code{job}、2つ目は任意の値に成り得て、3番目は文字のリスト\code{(computer programmer)}です。
マッチングリスト内の2つ目の項目に成り得る``任意項''は\newterm{pattern variable}(\jnewterm{パターン変数})\code{?x}で
指定されます。パターン変数の一般的な形式はクエスチョンマークを前に置いた、変数の名前と
して取られるシンボルです。以下では、なぜこのことが単に\code{?}を``任意''を表すパターンに
置くのではなく、パターン変数のために名前を指定することが便利であるかを学びます。
システムは簡単なクエリに指定されたパターンにマッチするデータベース内の全てのエントリを
表示することで応答します。

パターンは複数の変数を持つことができます。例えば、以下のクエリ

\begin{scheme}
(address ?x ?y)
\end{scheme}

\noindent
は全ての従業員の住所を並べます。

パターンはクエリが単純にパターンがデータベース内のエントリであるかどうかを決定する
場合には変数を持つことができません。もしそうであれば1つの一致が存在します。
そうでなければ1つも一致は存在しません。

同じパターン変数が1つのクエリ内に複数存在することができ、同じ``任意項''が各位置に
現われなければいけないこと指定します。これがなぜ変数が名前を持つのかの理由です。
例えば、

\begin{scheme}
(supervisor ?x ?x)
\end{scheme}

\noindent
上のクエリは自分自身を監督する全ての人々を見つけます。(しかし私達のサンプル
データベース内のアサーションにはそのようなエントリがありません。)

以下のクエリは、

\begin{scheme}
(job ?x (computer ?type))
\end{scheme}

\noindent
3つ目の項目が二要素リストでありその1つ目の要素が\code{computer}である全ての職種エントリに
適合します。

\begin{scheme}
(job (Bitdiddle Ben) (computer wizard))
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
(job (Tweakit Lem E) (computer technician))
\end{scheme}

\noindent
この同じパターンが以下にはマッチ``しません''。

\begin{scheme}
(job (Reasoner Louis) (computer programmer trainee))
\end{scheme}

\noindent
なぜならエントリの3つ目の項目が3要素のリストであり、パターンの3つ目の項目がそこは
2要素でなければならないと指定しているためです。もし私達がパターンを変更し3つ目の
項目が\code{computer}で始まる任意のリストでも良いようにしたければ、以下のように
指定可能です。\footnote{これは\link{Exercise 2.20}で紹介されたドット付き末尾記述を
用いています。}

\begin{scheme}
(job ?x (computer . ?type))
\end{scheme}

\noindent
例えば、以下のクエリは、

\begin{scheme}
(computer . ?type)
\end{scheme}

\noindent
次のデータに適合します。

\begin{scheme}
(computer programmer trainee)
\end{scheme}

\noindent
この時\code{?type}はリスト\code{(programmer trainee)}になります。これはまた
次のデータにも適合します。

\begin{scheme}
(computer programmer)
\end{scheme}

\noindent
この時\code{?type}はリスト\code{(programmer)}になります。さらに以下のデータにも
適合します。

\begin{scheme}
(computer)
\end{scheme}

\noindent
この時\code{?type}は空リスト\code{()}です。


クエリ言語の簡単なクエリの処理は以下のように説明できます。

\begin{itemize}

\item
システムはクエリパターン内の変数に対する、パターンを満たす全ての割り当てを見つけます---つまり、
パターン変数が値によりインスタンス化されるような(例示されるような)、つまり値により置き換えられるような
変数に対する値の全ての集合です。結果はデータベース内に存在します。

\item
システムはクエリに対し、パターンを満たす変数割り当てと共に、クエリパターンの
全てのインスタンス(事例)を列挙することで応答します。

\end{itemize}

\noindent
もしパターンに変数が無い場合、クエリはそのパターンがデータベース内に存在するかどうか
の決定に簡約されることに注意して下さい。もしそうならば、変数に何の値も割り当てない
空割り当てがデータベースに対するそのパターンを満たします。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.55}Exercise 4.55:}
以下の情報をデータベースから取り出す簡単なクエリを与えよ。

\begin{enumerate}

\item
Ben Bitdiddleにより監督される(supervisor)全ての人

\item
経理部門に属す全ての人の名前(name)と職種(job)

\item
Slumervilleに済む全ての人の名前と住所(address)

\end{enumerate}
\end{quote}

\subsubsection*{複合クエリ}


単純なクエリはクエリ言語のプリミティブな命令を形成します。複雑な命令を形成する
ためには、クエリ言語は組み合わせの手段を提供します。クエリ言語を論理プログラミング言語と
成す物の1つに組み合わせの手段が論理式を形成するのに用いられる組み合わせの手段に酷似することが
あげられます。\code{and}, \code{or}, \code{not}です。(ここでは\code{and}, \code{or}, \code{not}は
Lispのプリミティブではありません。クエリ言語の組込命令です。)

\noindent
\code{and}を以下の様に用いて全てのコンピュータプログラマの住所を見つけることができます。

\begin{scheme}
(and (job ?person (computer programmer))
     (address ?person ?where))
\end{scheme}

\noindent
結果の出力は以下の通りです。

\begin{scheme}
(and (job (Hacker Alyssa P) (computer programmer))
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
(and (job (Fect Cy D) (computer programmer))
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))
\end{scheme}

\noindent
一般的に、

\begin{scheme}
(and ~\( \dark \langle \)~~\( \dark query_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark query_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark query_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上の式はパターン変数に対する全ての値の集合が同時に
\( \langle \)\( query_1 \)\( \rangle \) \( \dots \) \( \langle \)\( query_n \)\( \rangle \)を満す時に
満たされます。

\noindent
簡単にクエリに関しては、システムはクエリを満たすパターン変数への全ての割り当てを見つける
ことにより複合クエリを処理します。そしてそれらの値によるクエリのインスタンスを
表示します。

\noindent
複合クエリを構築する別の手段として\code{or}を通す方法があります。例えば、

\begin{scheme}
(or (supervisor ?x (Bitdiddle Ben))
    (supervisor ?x (Hacker Alyssa P)))
\end{scheme}

\noindent
上の式はBen Bitdiddle、またはAlyssa P.  Hackerに監督される従業員全てを見つけます。

\begin{scheme}
(or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
    (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))
(or (supervisor (Fect Cy D) (Bitdiddle Ben))
    (supervisor (Fect Cy D) (Hacker Alyssa P)))
(or (supervisor (Tweakit Lem E) (Bitdiddle Ben))
    (supervisor (Tweakit Lem E) (Hacker Alyssa P)))
(or (supervisor (Reasoner Louis) (Bitdiddle Ben))
    (supervisor (Reasoner Louis) (Hacker Alyssa P)))
\end{scheme}

\noindent
一般的に、

\begin{scheme}
(or ~\( \dark \langle \)~~\( \dark query_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark query_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark query_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上の式はパターン変数に対する全ての値の集合が、
\( \langle \)\( query_1 \)\( \rangle \) \( \dots \) \( \langle \)\( query_n \)\( \rangle \)の内、少くとも1つを
満たす場合に満たされます。

\noindent
複合クエリはまた\code{not}を用いても形成できます。例えば、

\begin{scheme}
(and (supervisor ?x (Bitdiddle Ben))
     (not (job ?x (computer programmer))))
\end{scheme}

\noindent
上の式はBen Bitdiddleに監督されるが、コンピュータプログラマではない全ての人を見つけます。
一般的に、

\begin{scheme}
(not ~\( \dark \langle \)~~\( \dark query_1 \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上の式はパターン変数に対する全ての割り当てが\( \langle \)\( query_1 \)\( \rangle \)を
満たさない場合に満たされます。\footnote{実際にはこの\code{not}の説明は簡単な場合に対してのみ有効です。
本当の\code{not}の振舞はより複雑です。\code{not}の奇妙な点については節\link{Section 4.4.2}と
\link{Section 4.4.3}にて調査します。}

最後の組み合わせ形式は\code{lisp\-/value}と呼ばれます。lisp-value
がパターンの最初の要素の時、
次の要素は(インスタンス化された)残りの要素を引数として適用されるLispの述語であることを意味します。
一般的に、

\begin{scheme}
(lisp-value ~\( \dark \langle \)~~\var{\dark predicate}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark arg_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark arg_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上の式は\( \langle \)\var{predicate}\( \rangle \)がパターン変数に対してインスタンス化された
\( \langle \)\( arg_1 \)\( \rangle \) \( \dots \) \( \langle \)\( arg_n \)\( \rangle \)に適用された
時の値がtrueになる場合の割り当てにより満たされます。

\begin{scheme}
(and (salary ?person ?amount) (lisp-value > ?amount 30000))
\end{scheme}


\begin{quote}
\heading{\phantomsection\label{Exercise 4.56}Exercise 4.56:}
以下の情報を取得する複合クエリを定式化せよ。

\begin{enumerate}[a]

\item
Ben Bitdiddleに監督される全ての人の名前と住所を共に

\item
Ben Bitdiddleよりも給料(salary)が安い全ての人をその給料とBen Bitdiddleの給料と共に

\item
コンピュータ部門ではない人に監督されている全ての人をその上司の名前と職種と共に

\end{enumerate}
\end{quote}

\subsubsection*{ルール}


プリミティブなクエリと複合クエリに加えて、クエリ言語はクエリを抽象化する手段を
提供します。これらは\newterm{rules}(\jnewterm{ルール})により提供されます。
以下のルールは、

\begin{scheme}
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
\end{scheme}

\noindent
二人の人が同じ街に住んでいるのなら、お互いに近くに住んでいると指定しています。
最後の\code{not}節はこのルールが全ての人がその人自身の近くに住んでいると言うことを
防ぎます。\code{same}リレーションはとても簡単なルールにより定義されます。\footnote{2つの
物が同じであるようにするためには\code{same}は必要ではないことに注意して下さい。
単に同じパターン変数をそれぞれに使用するだけです。実際に、最初から2つの物でなく
1つの物しか持ちません。例として\code{lives\-/near}ルールの\code{?town}や下記の\code{wheel}ルールの
\code{?middle\-/manager}を参照して下さい。\code{same}は2つの物が異なることを強制する場合に
便利です。例えば\code{lives\-/near}ルールの\code{?person\-/1}と\code{?person\-/2}です。
同じパターン変数をクエリの2つの部分に使うことは両方の場所に同じ値が現れることを
強制しますが、異なるパターン変数を用いることは異なる値が現れることを強制しません。
(異なるパターン変数に割り当てられた値は同じにも違う値にも成り得ます。)}

\begin{scheme}
(rule (same ?x ?x))
\end{scheme}

\noindent
以下のルールはある人が監督する人が同様に監督者である場合に組織内での``wheel''(重要人物)であると
宣言します。

\begin{scheme}
(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
\end{scheme}

\noindent
ルールの一般的な形式は以下となります。

\begin{scheme}
(rule ~\( \dark \langle \)~~\var{\dark conclusion}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
\( \langle \)\var{conclusion}\( \rangle \)がパターンであり\( \langle \)\var{body}\( \rangle \)が
任意のクエリです。\footnote{私達はsameの様にボディの無いルールも認めます。また
そのようなルールは、ルールの結論(conclusion)が任意の変数の値により満たされたことを意味する
と解釈します。}ルールは大きな(例え無限でも)アサーションの集合を表現するものとして考えることができます。
即ち、ルールのボディを満たす変数の割り当てを用いたルールの結果の全てのインスタンスです。
簡単なクエリ(パターン)を説明した時、変数への割り当ては、インスタンス化されたパターンがデータベース内に
存在する場合にパターンが満たされると説明しました。しかし、パターンは明示的にアサーションとして
データベース内に存在する必要はありません。ルールにより暗示される暗黙的なアサーションに成り得ます。
例えば、以下のクエリは、

\begin{scheme}
(lives-near ?x (Bitdiddle Ben))
\end{scheme}

\noindent
次の結果を生みます。

\begin{scheme}
(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
\end{scheme}

\noindent
Ben Bitdiddleの近くに住む全てのコンピュータプログラマを見つけるためには、
以下のように質問することができます。

\begin{scheme}
(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
\end{scheme}

\noindent
複合手続きの場合と同様に、ルールは他のルールの一部分として(上記の\code{lives\-/near}ルールで
見たように)使用可能です。または再帰的に定義することさえもできます。例として、
以下のルールは、

\begin{scheme}
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
\end{scheme}

\noindent
もしボスがスタッフの上司であるか、(再帰的に)スタッフの上司よりボスが上役(outranked)であるならば
ボスはスタッフより地位が上であると言えます。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.57}Exercise 4.57:}
人(person)その1が人その2を置き換えられるとは人その1が人その2と同じ仕事をしているか、
または第三者(someone)が人その1と同じ仕事をしつつ、かつ人その2の仕事も行え、そして
人その1と人その2が異なる人である場合であると述べるルールを定義せよ。
そのルールを用いて以下の条件を見つけるクエリを与えよ。

\begin{enumerate}[a]

\item
Cy D. Fectを置き換えられる全ての人

\item
自分より給料の高い誰かを置き換えられる全ての人を二人の給料と一緒に。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.58}Exercise 4.58:}
ある人が自分が働いている同じ部署に上司(監督者)がいない場合にその人を``big shot''(有力者)である
と述べるルールを定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.59}Exercise 4.59:}
Ben Bitdiddleはある会議を何度も欠席してしまった。彼の会議を忘れる癖は仕事を失う
恐れがある。Benは何かしなければならないと決心した。彼は会社の週次ミーティング全てを
Microshaftデータベースに以下のアサーションとして加えた。

\begin{scheme}
(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
\end{scheme}

各アサーションは部門の全体ミーティングのためのものだ。Benはまた全ての部門に渡る
全社会議のエントリを追加した。会社の全従業員がこの会議に参加する。

\begin{scheme}
(meeting whole-company (Wednesday 4pm))
\end{scheme}

\begin{enumerate}[a]

\item
金曜の朝に、Benはその日の全ての会議をデータベースからクエリしたいと思った。
彼のクエリはどのような物になるか?

\item
Alyssa P. Hackerは感心しなかった。彼女は自分の名前を指定することで彼女の会議を
尋ねることができればより便利になるだろうと考えた。そのため彼女はある人の会議は
全ての\code{whole\-/company}(全社)会議に加えてその人の部門会議を全て含むと言うルールを
設計した。Alyssaのルールのボディを埋めよ。

\begin{scheme}
(rule (meeting-time ?person ?day-and-time)
      ~\( \dark \langle \)~~\var{\dark rule-body}~~\( \dark \rangle \)~)
\end{scheme}

\item
Alyssaは水曜の朝に仕事場に到着し、その日に何の会議があるかについて考えた。
上記のルールを定義した上で、彼女のがこのことを見つけるためにはどのようなクエリを
行うべきか?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.60}Exercise 4.60:}
以下のクエリを与えることにより、

\begin{scheme}
(lives-near ?person (Hacker Alyssa P))
\end{scheme}

Alyssa P. Hackerは仕事場に相乗りできる、彼女の近所に住む人を見つけることができる。
一方で、お互いが近所に住んでいる全ての人々のペアを見つけたい場合には以下のクエリを
用いる。

\begin{scheme}
(lives-near ?person-1 ?person-2)
\end{scheme}

\noindent
彼女はお互いに近所に住んでいる人々の各ペアが二度づつ挙げられていることに気付いた。
例えば、

\begin{scheme}
(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
\end{scheme}

なぜこれが起こるのか?  お互いに近くに住んでいる人々のリストを各ペアが一度しか現れないように
見つける方法は存在するか? 説明せよ。
\end{quote}

\subsubsection*{プログラムとしての論理}


ルールを論理的意味合いの一種であると見做すことができます。\emph{もし}パターン変数に
対する値の割り当てがボディを満たす場合、\emph{それならば}結論を満たします。必然的に、
クエリ言語はルールを基にした\newterm{logical deductions}(\jnewterm{論理的推理})を実行する能力を
有すると見做すことができます。例として、\link{Section 4.4}の始めに説明した\code{append}命令について
考えてみましょう。既に述べたように、\code{append}は以下の2つのルールにて特徴づけられます。

\begin{itemize}

\item
任意のリスト\code{y}に対し、空リストと\code{y}の\code{append}は\code{y}を形成する。

\item
任意の\code{u}, \code{v}, \code{y}, \code{z}に対し、\code{(cons u v)}と\code{y}の\code{append}は
もし\code{v}と\code{y}\code{append}が\code{z}を形成する場合、\code{(cons u z)}を形成する。

\end{itemize}

\noindent
これを私達のクエリ言語で表現するために、以下の関係に対する2つのルールを定義します。

\begin{scheme}
(append-to-form x y z)
\end{scheme}

\noindent
上の関係は``\code{x}と\code{y}の\code{append}は\code{z}を形成する''ことを意味すると解釈できます。

\begin{scheme}
(rule (append-to-form () ?y ?y))
(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
\end{scheme}

\noindent
最初のルールにはボディがありません。これは結果部分が\code{?y}の任意の値を保持することを
意味します。2つ目のルールがどのようにドット付き末尾記述をリストの\code{car}と\code{cdr}に
名前を付けるために使用しているかについて注意して下さい。


これら2つのルールを与えられることで、2つのリストに対する\code{append}を求めるクエリを
定式化することができます。

\begin{scheme}
~\textit{;;; Query input:}~
(append-to-form (a b) (c d) ?z)
~\textit{;;; Query results:}~
(append-to-form (a b) (c d) (a b c d))
\end{scheme}

\noindent
より印象的なのは、同じルールを``\code{(a b)}に対し\code{append}したら\code{(a b c d)}になるリストは何''
という質問に使用できることです。これは以下のように行われます。

\begin{scheme}
~\textit{;;; Query input:}~
(append-to-form (a b) ?y (a b c d))
~\textit{;;; Query results:}~
(append-to-form (a b) (c d) (a b c d))
\end{scheme}

\noindent
\code{append}すると\code{(a b c d)}を形成する全てのリストのペアを尋ねることも可能です。

\begin{scheme}
~\textit{;;; Query input:}~
(append-to-form ?x ?y (a b c d))
~\textit{;;; Query results:}~
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
\end{scheme}

\noindent
上記のクエリに対する答を推論するルールを用いることにておいて、クエリシステムは
かなりの知性を示すように見えるかもしれません。実際には次の節で学ぶように、
システムはルールをときほぐす明確なアルゴリズムに従っているに過ぎません。
残念ながら、システムが\code{append}の場合では見事な程うまく行きますが、
一般的な手法はより複雑な場合に分解されるかもしれません。このことは\link{Section 4.4.3}で学びます。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.61}Exercise 4.61:}
以下のルールはリストの直前の要素を見つける関係\code{next\-/to}を実装する。

\begin{scheme}
(rule (?x next-to ?y in (?x ?y . ?u)))
(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
\end{scheme}


以下のクエリの結果を答えよ。

\begin{scheme}
(?x next-to ?y in (1 (2 3) 4))
(?x next-to  1 in (2 1 3 1))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.62}Exercise 4.62:}
\link{Exercise 2.17}の\code{last\-/pair}命令を実装するルールを定義せよ。
これは空ではないリストの最後の要素を含むリストを返す。あなたのルールを
\code{(last\-/pair (3) ?x)}, \code{(last\-/pair (1 2 3) ?x)}, \code{(last\-/pair (2 ?x) (3))}のような
クエリにて確認せよ。あなたのルールは\code{(last\-/pair ?x (3))}の様なクエリに対し
正しく動作するだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.63}Exercise 4.63:}
以下のデータベース(創世記第4章を参照せよ)はAdaの子孫の家系をCainを経由してAdamまで
戻りながら辿っている。

\begin{scheme}
(son Adam Cain)
(son Cain Enoch)
(son Enoch Irad)
(son Irad Mehujael)
(son Mehujael Methushael)
(son Methushael Lamech)
(wife Lamech Ada)
(son Ada Jabal)
(son Ada Jubal)
\end{scheme}

``もし\( S \)が\( f \)の息子であり、かつ、\( f \)が\( G \)の息子ならば、\( S \)は\( G \)
の孫である''と``もし\( W \)が\( M \)の妻であり、かつ、\( S \)が\( W \)の息子ならば、\( S \)は
\( M \)の息子である''(これは恐らく今日より聖書の時代にはより正確であっただろう)のルールを
定式化せよ。これらはクエリシステムに対しCainの孫、Lamechの息子、Methushaelの孫を見つけることを可能にする。
(より複雑な関係を推論するいくつかのルールについては\link{Exercise 4.69}を参照せよ。)

\end{quote}

\subsection{クエリシステムの働き方}
\label{Sec. 4.4.2}
\label{Section 4.4.2}

\link{Section 4.4.4}ではクエリインタプリタを手続きの集合として紹介します。この節では低レベルの
実装上の詳細からは独立したシステムの一般的な構造について説明する概観を与えます。
インタプリタの実装を説明した後に、私達はインタプリタのいくつかの限界と記号論理学の演算とは異なる
クエリ言語の論理演算のいくつかの微妙な行い方を理解できる位置に辿り着きます。

クエリ評価機がクエリをデータベース内の事実とルールに対してマッチさせるために
ある種の探索を実行せねばならないことは明らかでしょう。これを行う1つの方法はクエリシステムを
\link{Section 4.3}の\code{amb}評価機を用いて非決定性プログラムとして実装することになります(\link{Exercise 4.78}参照)。
別の可能性にはストリームの助けを用いて探索を管理する方法があります。私達の実装は
この2つ目のアプローチに従います。

クエリシステムは2つの中心となる演算、\newterm{pattern matching}(\jnewterm{パターンマッチング})と
\newterm{unification}(\jnewterm{ユニフィケーション}、単一化)の周りに体系化されます。
最初にパターンマッチングについて記述し、この演算がフレームのストリームを用いた情報体系と
共にどのように単純クエリと複合クエリの両方を実装可能にするのか説明します。
次に私達はユニフィケーション、つまりルールを実装ために必要なパターンマッチングの
一般化について議論します。最後に、
\link{Section 4.1}で説明されたインタプリタのために\code{eval}が式を分類する方法と同様の方法で、
式を分類する手続きを通してクエリインタプリタ全体がどのように組み合わされるかについて示します。

\subsubsection*{パターンマッチング}

\newterm{pattern matcher}(\jnewterm{パターンマッチャ})はあるデータが指定されたパターンに適合するかどうかを
試すプログラムです。例えばデータリスト\code{((a b) c (a b))}はパターン\code{(?x c ?x)}に対し
パターン変数\code{?x}が\code{(a b)}に束縛されることで適合します。
同じデータリストがパターン\code{(?x ?y ?z)}に対し\code{?x}と\code{?z}の両者が\code{(a b)}に束縛され、
\code{?y}が\code{c}に束縛されることで適合します。これはまたパターン\code{((?x ?y) c (?x ?y))}に
対しても\code{?x}が\code{a}に、\code{?y}が\code{b}に束縛されることで適合します。
しかし、これはパターン\code{(?x a ?y)}には適合しません。このパターンが2つ目の要素がシンボル\code{a}で
あるリストを指定しているためです。

パターンマッチャはクエリシステムにより使用されます。クエリシステムは入力として
パターン、データ、\newterm{frame}(\jnewterm{フレーム})を取ります。フレームはさまざまな
パターン変数に対する束縛を指定します。パターンマッチャはデータがフレームに既に
存在する束縛と一致する状態でパターンに適合するかどうかをチェックします。
もしそうであれば、その適合により決定された任意の束縛を増やしたフレームを返します。
そうでなければ、適合が失敗したことを示します。

例えば、パターン\code{(?x ?y ?x)}を用いて\code{(a b a)}に空のフレームを与えられた
場合に適合を行うと\code{?x}が\code{a}に、\code{?y}が\code{b}に束縛されることを指定する
フレームを返します。同じパターン、同じデータで\code{?y}が\code{a}に束縛されている
と指定するフレームを用いて適合を行うと失敗します。同じパターン、同じデータで
\code{?y}が\code{b}に束縛され\code{?x}が未束縛であるフレームを用いて適合を行えば
与えられたフレームに\code{?x}の\code{a}への束縛を増やした物が返されます。

パターンマッチャはルールを含まない単純なクエリを処理するのに必要な仕組みの全てです。
例えば、以下のクエリを処理する場合、

\begin{scheme}
(job ?x (computer programmer))
\end{scheme}

\noindent
データベース内の全てのアサーションを探索し、最初は空のフレームを考慮してパターンに
適合する物を選択します。探索を行った各適合に対して、適合により返されたフレームを
用いてパターンを\code{?x}の値と共にインスタンス化します。

\subsubsection*{フレームのストリーム}

フレームに対してパターンのテストを行うことはストリームの使用を通して体系化されています。
単一のフレームを与えられて、マッチング処理はデータベースのエントリを1つづつ通して実行します。
各データベースエントリに対して、マッチャは適合が失敗したことを示す特別なシンボルか、
フレームに対する拡張を生成します。全てのデータベースエントリに対する結果はストリーム内に
集められ、フィルタを通すことで失敗が取り除かれます。結果は与えられた
フレームを適合を通すことでデータベース内のあるアサーションに拡張した全てのフレームの
ストリームです。\footnote{マッチングは一般的にとても重いので、完全なマッチャをデータベース
の全ての要素に対して適用することは防ぎたいと考えます。これは通常は高速で粗い適合と
最終適合の部品に分解することで準備します。粗い適合はデータベースをフィルタし、最終適合の
ための候補の小さな集合を生成します。手間をかけて、粗い適合のいくつかの成果がデータベースが
候補を選択したい時ではなく、構築された時に行えるようにデータベースを事前に
準備することができます。データベースの索引の仕組みの周りには莫大な技術が構築されています。
私達の実装は\link{Section 4.4.4}で説明されているように、そのような最適化のあまり賢くはない形態を
含んでいます。}

私達のシステムでは\link{Figure 4.4}で示されるように、クエリはフレームの入力ストリームを取り、
ストリーム内の各フレームに対して上記のマッチング処理を実行します。
言い替えれば、入力ストリーム内の各フレームに対して、クエリはデータベース内のアサーションに対する
適合による、全てのフレームの拡張から成る新しいストリームを生成します。
これらのストリームの全ては次に組み合わされて1つの大きなストリームを形成します。
これは入力ストリーム内の各フレームの全ての可能な拡張を含んでいます。
このストリームがクエリの出力です。

単純なクエリに答えるためにはクエリを単一の空フレームから成る入力ストリームと共に
用います。結果としての出力ストリームは空にフレームに対する全ての拡張を含んでいます(言い換えれば、
クエリに対する全ての答を含みます)。このフレームのストリームは次に、元々のクエリのパターンと
各フレーム内の値でインスタンス化された変数のコピーのストリームを生成するのに利用されます。
そしてこれが最終的に表示されるストリームです。

\begin{figure}[tb]
\phantomsection\label{Figure 4.4}
\centering
\begin{comment}
\heading{Figure 4.4:} A query processes a stream of frames.

\begin{example}
                                  output stream
  input stream   +-------------+  of frames,
  of frames      |    query    |  filtered and extended
---------------->|             +------------------------->
                 | (job ?x ?y) |
                 +-------------+
                        ^
                        |
               stream of assertions
                  from data base
\end{example}
\end{comment}
\includegraphics[width=102mm]{fig/chap4/Fig4.4.pdf}
\par\bigskip
\noindent
\heading{Figure 4.4:} フレームのストリームを処理するクエリ
\end{figure}

\subsubsection*{複合クエリ}


フレームのストリーム実装の真に優雅な点は複合クエリを扱う時に明白になります。
複合クエリの処理は適合の結果が指定されたフレームに一致するという私達の
マッチャが要求する能力を利用します。例えば、2つのクエリの\code{and}を取り扱う
以下のようなクエリでは

\begin{scheme}
(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
\end{scheme}

\noindent
(簡単に言えば、``コンピュータプログラマ見習いの職を行える全ての人を見つけろ'')
まず以下のパターンに適合する全てのエントリを見つけます。

\begin{scheme}
(can-do-job ?x (computer programmer trainee))
\end{scheme}

\noindent
これはフレームのストリームを生成します。各フレームは\code{?x}に対する束縛を含んでいます。
次にストリーム内の各フレームに対し、与えられた\code{?x}に対する束縛に一致する様に、
以下のパターンに適合する全てのエントリを探します。

\begin{scheme}
(job ?person ?x)
\end{scheme}

\noindent
そのような適合のそれぞれは\code{?x}と\code{?person}に対する束縛を含むフレームを生成します。
2つのクエリの\code{and}は\link{Figure 4.5}に示されるように、一連の2つのクエリのコンポーネントの
組み合わせであると見做すことができます。最初のクエリフィルタを通過するフレームは
フィルタをかけられ、2つ目のクエリにてさらに拡張されます。

\begin{figure}[tb]
\phantomsection\label{Figure 4.5}
\centering
\begin{comment}
\heading{Figure 4.5:} The \code{and} combination of two queries is produced 
by operating on the stream of frames in series.

\begin{example}
                +----------------------+
                |       (and A B)      |
  input stream  |                      |  output stream
  of frames     |   +---+       +---+  |  of frames
------------------->| A +------>| B +-------------------->
                |   +---+       +---+  |
                |     ^           ^    |
                |     |           |    |
                |     +-----*-----+    |
                +-----------|----------+
                            |
                        data base
\end{example}
\end{comment}
\includegraphics[width=93mm]{fig/chap4/Fig4.5.pdf}
\begin{quote}
\heading{Figure 4.5:} 2つのクエリの\code{and}の組合せはフレームのストリーム上での連続した操作により生成される
\end{quote}
\end{figure}

\begin{figure}[tb]
\phantomsection\label{Figure 4.6}
\centering
\begin{comment}
\heading{Figure 4.6:} The \code{or} combination of two queries is produced 
by operating on the stream of frames in parallel and merging the results.

\begin{example}
           +---------------------------+
           |          (or A B)         |
           |    +---+                  |
input      | +->| A |------------+     |  output
stream of  | |  +---+            V     |  stream of
frames     | |    ^          +-------+ |  frames
-------------*    |          | merge +--------------->
           | |    |          +-------+ |
           | |    |              ^     |
           | |    |   +---+      |     |
           | +------->| B +------+     |
           |      |   +---+            |
           |      |     ^              |
           |      |     |              |
           |      +--*--+              |
           +---------|-----------------+
                     |
                 data base
\end{example}
\end{comment}
\includegraphics[width=107mm]{fig/chap4/Fig4.6.pdf}
\begin{quote}
\heading{Figure 4.6:} 2つのクエリのcode{or}の組合せはフレームのストリームを並列に操作しその結果をマージする
ことで生成される
\end{quote}
\end{figure}

\link{Figure 4.6}は2つのクエリの\code{or}を2つのクエリコンポーネント
の並列な組み合わせとして求めるための類似の手法を示しています。
フレームの入力ストリームは各クエリにより別々に拡張されます。2つの結果ストリームは
次にマージされ最終の出力ストリームを生成します。

この高いレベルの記述からでも複合クエリの処理が遅くなることがはっきりとわかります。
例えば、クエリは各入力フレームに対して複数の出力ストリームを生成するかもしれません。
そして各クエリも同様です。最悪の場合にはクエリ数の指数関数となる多数のマッチングを
実行しなければなりません(\link{Exercise 4.76}参照)。\footnote{しかし、この種の
指数関数爆発は\code{and}クエリでは一般的ではありません。追加された条件が生成されるフレームの
数を増やすのでなく、減らす傾向があるためです。}単純なクエリのみを扱うシステムのほうが
とても実用的ではありますが、複合クエリを扱うことは極めて難しいのです。\footnote{複合
クエリをどのように効果的に扱うかに関連するデータベース管理システムの多数の文献が
存在します。}

フレームのストリームの視点から、あるクエリの\code{not}はクエリが満たされる
全てのフレームを取り除くフィルタとして働きます。例えば、以下のパターンを与えらえると、

\begin{scheme}
(not (job ?x (computer programmer)))
\end{scheme}

\noindent
入力ストリームの各フレームに対して\code{(job ?x (computer programmer))}を満たす
拡張フレームの生成を試みます。入力ストリームからそのような拡張が存在する
全てのフレームを削除します。結果はフレーム中の\code{?x}の束縛が
\code{(job ?x (computer programmer))}を満たさないフレームのみから成るストリームと
なります。例えば以下のクエリの処理においては、

\begin{scheme}
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
\end{scheme}

\noindent
最初の節は\code{?x}と\code{?y}に対する束縛を持つフレームを生成します。次に
\code{not}節はこれらから\code{?x}に対する束縛が\code{?x}がコンピュータプログラマである
という制約を満たす全てのフレームを削除することでフィルタリングします。\footnote{この
\code{not}のフィルタ実装と、記号論理学における通常の意味での\code{not}の間には
微妙な違いが存在します。\link{Section 4.4.3}を参照して下さい。}


\code{lisp\-/value}特殊形式はフレームのストリーム上の同様なフィルタとして実装されます。
ストリーム内の各フレームをパターン内の任意の変数をインスタンス化するために用い、
そしてLisp手続きを適用します。入力ストリームから述語が失敗する全てのフレームを削除します。

\subsubsection*{ユニフィケーション}


クエリ言語内のルールを扱うために、ルールの結果が与えられたクエリパターンに適合する
ルールを見付けられねばなりません。ルールの結果はアサーションに似ていますが、変数を
含められる所が異なります。そのためパターンマッチングの
一般化---\newterm{unification}(\jnewterm{ユニフィケーション})と呼ばれます---を必要とし、
その中で``パターン''と``データ''の両方が変数を持ち得ます。

ユニファイアは2つの定数と変数を含むパターンを取り、2つのパターンを等しくする
変数への値の割り当てが可能であるかどうかを決定します。もしそうであれば、
これらの束縛を含むフレームを返します。例えば\code{(?x a ?y)}と\code{(?y ?z a)}の
ユニフィケーションは\code{?x}, \code{?y}, \code{?z}が全て\code{a}に束縛されなければならない
フレームを指示します。一方で、\code{(?x ?y a)}と\code{(?x b ?y)}のユニフィケーションは
失敗します。2つのパターンを等しくできる\code{?y}の値が存在しないためです。(両方のパターンの
2つ目の要素が等しくなるためには\code{?y}は\code{b}にならなければなりません。
しかし、3番目の要素が等しくなるためには\code{?y}が\code{a}になるしかありません)。
クエリシステムで用いられるユニファイアはパターンマッチャの様に、フレームを入力として取り
このフレームと一致するユニフィケーションを実行します。

ユニフィケーションアルゴリズムはクエリシステムで最も技術的に難しい部分です。
複雑なパターンを共なうため、ユニフィケーションの実行は演繹を必要とするように見えるかもしれません。
例えば、\code{(?x ?x)}と\code{((a ?y c) (a b ?z))}をユニフィケーションするためには
アルゴリズムは\code{?x}は\code{(a b c)}に、\code{?y}は\code{b}に、\code{?z}は\code{c}にならなければ
いけないことを推論しなければなりません。この処理はパターンコンポーネント間の
等式の集合を解くこととして考えることができます。一般的には、これらは連立方程式であり、
これを解くためには大量の操作が必要となるでしょう。\footnote{一方向のパターンマッチングでは、
全てのパターン変数を含む等式は明白で未知数(パターン変数)について既に解かれています。}
例えば、\code{(?x ?x)}と\code{((a ?y c) (a b ?z))}のユニフィケーションは以下の連立方程式を
指定することだと考えられるでしょう。

\begin{scheme}
?x  =  (a ?y c)
?x  =  (a b ?z)
\end{scheme}

\noindent
これらの方程式は以下を暗示します。

\begin{scheme}
(a ?y c)  =  (a b ?z)
\end{scheme}

\noindent
これは順に次を暗示します。

\begin{scheme}
 a  =  a, 
?y  =  b, 
 c  =  ?z,
\end{scheme}

\noindent
従って以下の通りです。

\begin{scheme}
?x  =  (a b c)
\end{scheme}

\noindent
パターンマッチが成功する場合、全てのパターン変数は束縛され、それらに束縛される
値は定数のみを持ちます。これはまたここまで見てきた全てのユニフィケーションの例に
対しても真です。しかし一般的に、ユニフィケーションが成功する場合には変数の値が
完全には決定されるとは限りません。いくつかの変数は未束縛のままで、他は変数を
含む値に束縛されます。

\code{(?x a)}と\code{((b ?y) ?z)}のユニフィケーションについて考えます。
\code{?x = (b ?y)}であり\code{a = ?z}であると推論できます。しかしそれ以上\code{?x}と\code{?y}に
ついて解くことはできません。このユニフィケーションは失敗はしません。確かに
2つのパターンを\code{?x}と\code{?y}に値を割り当てることで等しくすることは可能なためです。
この適合が\code{?y}の取り得る値を全く限定しないため、結果フレームに\code{?y}の束縛は
全く入りません。しかしこの適合は\code{?x}の値は限定します。\code{?y}がどのような値を
取っても、\code{?x}は必ず\code{(b ?y)}になります。従って\code{?x}の\code{(b ?y)}への束縛は
フレームへ入れられます。もし\code{?y}の値が(パターンマッチ、またはこのフレームに
一致する必要のあるユニフィケーションにより)後に決定されフレームに追加されたなら、
その前に束縛された\code{?x}はこの値を参照することになります。\footnote{ユニフィケーションについて
考えるもう1つの方法は、二つの入力パターンの特殊化である最も一般的なパターンを生成するということです。
言い換えれば、\code{(?x a)}と\code{((b ?y) ?z)}のユニフィケーションは\code{((b ?y) a)}であり、
上で議論した \code{(?x a ?y)}と\code{(?y ?z a)}のユニフィケーションは\code{(a a a)}です。
私達の実装に対しては、ユニフィケーションの結果をパターンではなく、フレームとして
考えたほうがより便利です。}

\subsubsection*{ルールの適用}


ユニフィケーションはルールから推論を行わせるクエリシステムのコンポーネントに対する
鍵です。これがどのように達成されるかについて学ぶためには、ルールの適用を含むクエリの
処理について考えてみましょう。例えば、以下について考えます。

\begin{scheme}
(lives-near ?x (Hacker Alyssa P))
\end{scheme}

\noindent
このクエリを処理するためには、最初に通常の上で説明されたパターンマッチ手続きを用いて
このパターンに適合するアサーションがデータベース内に存在するかどうかを見ます。(この場合には
存在しません。私達のデータベースには誰が誰の近くに住んでいるかについての直接の
アサーションが全く含まれていないためです)。次のステップはクエリパターンと各ルールの結果との
ユニフィケーションを試みることです。このパターンは以下のルールの結果とユニフィケーションする
と、

\begin{scheme}
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
\end{scheme}

\noindent
結果としてフレームに\code{?person\-/2}が\code{(Hacker Alyssa P)}に束縛され、
\code{?x}が(同じ値として)\code{?person\-/1}に束縛されなければならないことの指定が
入ることを発見します。これで、このフレームに関連して、このルールのボディにより
与えられた複合クエリを評価します。適合が成功すればこのフレームは\code{?person\-/1}に
対する束縛を与えることで拡張され、その結果として\code{?x}の値も決定し、元々のクエリ
パターンをインスタンス化するのに利用することができます。


一般的に、クエリ評価機は以下の手法を用いて、パターン変数に対する束縛を指定する
フレーム内のクエリパターンを定めようとする時に、ルールを適用します。

\begin{itemize}

\item
クエリをルールの結論とユニフィケーションすることで(成功すれば)元のフレームの
拡張を形成する

\item
拡張されたフレームを参照しながら、ルールのボディにより形成されたクエリを評価する

\end{itemize}

\noindent
これがどれほどLispの\code{eval}/\code{apply}評価機内での手続き適用のための手法に似ているか
について注意して下さい。

\begin{itemize}

\item
手続きのパラメタをその引数に束縛することで元々の手続き環境を拡張するフレームを形成する

\item
拡張された環境を参照しながら、手続きのボディにより形成された式を評価する

\end{itemize}

\noindent
2つの評価機の間の類似度は驚くべきことではありません手続き定義がLispにおける抽象化の
手段であるように、ルール定義はクエリ言語の抽象化の手段です。それぞれの場合において、
適切な束縛を作成し、ルール、または手続きのボディをこれらの束縛を参照することで
抽象化を巻き戻します。

\subsubsection*{単純なクエリ}


私達はこの節の始めにルールを欠いた単純なクエリをどのように評価するかについて学びました。
今ではルールの適用の仕方も学んだため、単純なクエリをルールとアサーションの両方を用いて
どのように評価するかについても説明することができます。


クエリパターンとフレームのストリームを与えられた時、入力ストリーム内の各フレームに対して
2つのストリームを生成します。

\begin{itemize}

\item
(パターンマッチャを用いて)データベース内の全てのアサーションに対してパターンの適合を行うことにより
得られた拡張フレームのストリーム

\item
(ユニファイアを用いて)全ての可能なルールを適用することにより得られた
拡張フレームのストリーム\footnote{ユニフィケーションはマッチングの一般化であるため、
ユニファイアを用いて両方のストリームを生成することによりシステムを簡略化することが
できました。しかし、簡単な場合を単純なマッチャで取り扱うことはマッチング(適合)が
どのように(本格的なユニフィケーションとは逆に)それ自身の正しさにおいて便利であることを
説明します。}

\end{itemize}

\noindent
これらの2つのストリームをアペンドすることにより、与えられたパターンを元のフレームに
一致して満たすことができる全ての方法により成り立つストリームを生成します。
これらのストリーム(入力ストリームの各フレームに対して1つ)はこれで全てが1つの
巨大なストリームに接続されます。従ってこの巨大ストリームは元の入力ストリーム内の
任意のフレームを与えられたパターンへの適合を生成するために拡張した全ての方法から
成り立っています。

\subsubsection*{クエリ評価機とドライバループ}

潜在的なマッチング操作の複雑さに係らず、システムは任意の言語のための評価機と
そっくりに体系化されます。マッチング操作を統合する手続きは\code{qeval}と呼ばれ、
Lispの\code{eval}手続きの役割と同様な役割を演じます。\code{qeval}は入力としてクエリと
フレームのストリームを取ります。その出力はフレームのストリームであり、クエリパターンへの
成功したマッチングに相応します。これは\link{Figure 4.4}で示されるよう入力ストリームの
いくつかを拡張しています。\code{eval}と同様に、\code{qeval}は異なる型の式(クエリ)を分類し、
それぞれに対する適切な手続きを呼び出します。各特殊形式(\code{and}, \code{or}, \code{not}, \code{lisp\-/value})に
手続きが存在し、また単純なクエリにも手続きが存在します。

この章の他の評価機のための\code{driver\-/loop}手続きと同様のドライバループが端末から
クエリを読み出します。各クエリに対して、ドライバループは\code{qeval}をそのクエリと
1つの空フレームと共に呼び出します。これにより全ての可能な適合(全ての可能な空フレームに
対する拡張)のストリームが生成されます。結果としてのストリームの各フレームに対して、
ドライバループは元のクエリをフレーム内で見つかった変数の値を用いてインスタンス化します。
次にこのインスタンス化されたクエリのストリームは表示されます。\footnote{私達が
フレームの(リストではなく)ストリームを使う理由は、ルールの再帰的適用は
クエリを満たす無限の数の値を生成することができるからです。ストリームに組込まれた
遅延化された評価がここでは重要です。システムは応答を1つづつそれらが生成された順に、
有限か無限の数の応答があるかに係らずに表示します。}

ドライバはまた特別なコマンド\code{assert!}をチェックします。これは入力がクエリではなく
データベースに追加するアサーション、またはルールでることを示します。例えば、

\begin{scheme}
(assert! (job (Bitdiddle Ben)
              (computer wizard)))
(assert! (rule (wheel ?person)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
\end{scheme}


\subsection{論理プログラミングは記号論理学なのか?}
\label{Sec. 4.4.3}
\label{Section 4.4.3}

クエリ言語内で使用される組み合わせの手段は最初は記号論理学の\code{and}, \code{or}, \code{not}命令と
同じに見えるかもしれません。実際にクエリ言語のルールの適用は、推論という、まともな手段を通して
達成されます。\footnote{推論の特定の手段がまともであるということは自明な主張ではありません。
もし真となる前提で開始したのであれば、真となる結論のみが導き出されることを証明しな
ければなりません。ルール適用で表現された推論の手法は\newterm{modus ponens}(\jnewterm{肯定式})という
親しみある推論の手法であり、もし\( A \)が真でありかつ\emph{A implies B}(AならばB)が真である
ならば、\( B \)は真であると結論づけることができます。}
しかし、このクエリ言語の記号論理学を用いた同定は実際には有効ではありません。クエリ言語が
論理的な命題を手続き的に解釈する\newterm{control structure}(\jnewterm{制御構造})を提供するためです。
私達は頻繁にこの制御構造を活用することができます。例えばプログラマの監督者全てを見るけるためには
以下の2つの論理的に等価な形式のどちらかをクエリとして策定することができます。

\begin{scheme}
(and (job ?x (computer programmer)) (supervisor ?x ?y))
\end{scheme}

\noindent
または

\begin{scheme}
(and (supervisor ?x ?y) (job ?x (computer programmer)))
\end{scheme}

\noindent
もし会社に(通常の場合として)プログラマより多くの監督者が存在するのであれば、
2つ目よりも最初の形式を用いたほうが良いです。なぜならデータベースは\code{and}の
最初の節により生成された中間結果(フレーム)全てに対して探索されねばならないためです。

論理プログラミングの目的はプログラマに演算問題を2つの分離された問題、``何''が求めらるべきかと
``どのように''これが求められるべきかに分解する技術を与えることです。
これは記号論理学の命題の部分集合を選択することで達成されます。これは人が演算したい
対象全てを記述するのに十分に強く、けれども制御可能な手続き的解釈を行うに十分に弱い
物です。一方で、ここでの意図は論理プログラミング言語で指示されたプログラムは
計算機により実行され得る実効的なプログラムでなければなりません。
制御(``どのように''演算するか)は言語の評価順の使用に影響を受けます。
私達は節の順と各節の中の下位目標の順とを操作し、演算が実効的、かつ効率的であると
考えれられる順で行われるようにせねばなりません。

私達のクエリ言語は単なるそのような手続き的に解釈可能な記号論理学の部分集合であると
見做すことができます。アサーションは単純な事実(アトミックな命題)を表現します。
ルールはルールのボディが持つ複数の場合に対する、ルールの結論が持つ推測の結果を表現します。
ルールは自然な手続き的解釈を持ちます。ルールの結論を成立させるためには、ルールのボディを
定めます。従って、ルールは演算を提示しています。しかし、ルールはまた記号論理学の命題であるとも
見做すことができるため、同じ結果が全体的に記号論理学の中で働くことにより得られることを
主張することで、論理プログラムにより遂行された任意の``推論''を正当化することができます。\footnote{私達は
この命題を以下に同意することで制限しなければなりません。``推論''が論理プログラムにより
正当化されるに言及するにおいて、私達は演算が停止することを前提としています。
残念なことに、例えこの制限された命題もクエリ言語の私達の実装においては正しくありません。
(そして同時にPrologのプログラムにとっても、そして他のほとんどの現在の論理プログラミング
言語においてもこれは正しくありません)。原因は私達の\code{not}と\code{lisp\-/value}の使用のためです。
この先で議論するように、クエリ言語で実装された\code{not}は常に記号論理学の\code{not}と一致
しません。そして\code{lisp\-/value}は複雑さを増します。私達は
単純に\code{not}と\code{lisp\-/value}を言語から削除し、プログラムを単純なクエリ, \code{and}, \code{or}のみを用いて
書くことに同意することで、記号論理学と一致する言語を実装することができます。
しかし、これは言語の表現力を大きく制限してしまいます。論理プログラミングにおける主要な
研究課題の1つは過度に表現力を犠牲にすることなく、記号論理学とより一致する方法を
見つけることです。}

\subsubsection*{無限ループ}


論理プログラムの手続き的な解釈の結果は絶望的に非効率なプログラムを一部の問題に
対して構築することが有り得ることです。極端に非効率な場合にはシステムは演繹を
行う無限ループに落ち込んでしまいます。簡単な例として、縁組のデータベースを
構築したと考えてみましょう。以下を含みます。

\begin{scheme}
(assert! (married Minnie Mickey))
\end{scheme}

\noindent
ここで以下を尋ねた場合、

\begin{scheme}
(married Mickey ?who)
\end{scheme}

\noindent
応答は有りません。なぜならシステムはもし\( A \)が\( B \)に結婚した場合、\( B \)が
\( A \)に結婚することになることを知らないためです。そのため以下のルールを
宣言します。

\begin{scheme}
(assert! (rule (married ?x ?y) (married ?y ?x)))
\end{scheme}

\noindent
そして再び質問します。

\begin{scheme}
(married Mickey ?who)
\end{scheme}

\noindent
残念ながら、これはシステムを無限ループに追いやります。以下のとおりです。

\begin{itemize}

\item
システムは\code{married}ルールが適用可能であることを見つけます。言い換えれば、
ルールの結論\code{(married ?x ?y)}は成功裏にクエリパターン\code{(married Mickey ?who)}と
単一化し、\code{?x}が\code{Mickey}に、\code{?y}が\code{?who}に束縛されるフレームを生成します。

\item
1つの答は直接データベース内のアサーションとして現れます: \code{(married
Minnie Mickey)}

\item
\code{married}ルールもまた適用可能です。そのためインタプリタは再度ルールのボディを
評価し、今回は\code{(married Mickey ?who)}に等しくなります。

\end{itemize}

\noindent
これでシステムは無限ループの中です。実際に、システムが簡単な答、\code{(married Minnie Mickey)}を
ループに入る前に見つけるかどうかは、システムがデータベース内のアイテムをチェックする順に
関連する実装上の詳細に依存します。これは起こり得るループのとても単純な種類の例です。
相互に関連するルールの蓄積は予想することがより難しいループへと導きます。そしてループの
出現は\code{and}内の節の順(\link{Exercise 4.64}参照)か、またはシステムがクエリを処理する順に
関連する低レベルの詳細に依存します。\footnote{これは論理の問題ではなく、私達のインタプリタにより
提供される手続き的な解釈の問題です。ここでループに陥らないインタプリタを書くこともできました。
例えばアサーションとルールから導きだせる全ての証明を深さ優先探索でなく、幅優先探索で
列挙することもできました。しかし、そのようなシステムは私達のプログラムの中における推論の
順序を活用することがより難しくなります。そのようなプログラムの中に洗練された制御を構築する
試みが\link{deKleer et al. 1977}に説明されています。そのような
深刻な制御上の問題に導かない別のテクニックとして、特定の種類のループの検知器のような
特別な知識を組込むことがあります(\link{Exercise 4.67})。しかし、推論の実行において
無限の小道を下ることから確実にシステムを防ぐ一般的な理論体系は有りません。
``\( P(x) \)が真であることを示すためには、\( P(f(x)) \)が真であることを示せ''という様式の
悪魔のルールをいくつかの適切に選択された関数\( f \)に対して想像してみて下さい。}

\subsubsection*{\code{not}の問題}


もう1つのクエリシステムの予測できない出来事は\code{not}に関連します。\link{Section 4.4.1}の
データベースを受け取った時、以下の2つのクエリについて考えてみます。

\begin{scheme}
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
\end{scheme}

\noindent
これらの2つのクエリは同じ結果を生成しません。最初のクエリはデータベース中の
\code{(supervisor ?x ?y)}に適合する全てのエントリを見つけ、次に結果のフレームから
\code{?x}の値が\code{(job ?x (computer programmer))}を満たす物を削除します。
2つ目のクエリは入力フレームから\code{(job ?x (computer programmer))}を満たす物を
消すフィルタから開始します。入力フレームだけでは空であるため、データベースから
\code{(job ?x (computer programmer))}を満たするパターンが存在するか確認します。
通常はこの形式のエントリが存在するので、\code{not}節は空のフレームを取り除き、
空のフレームのストリームを返します。結果として、複合クエリ全体が空ストリームを
返します。

問題は\code{not}の私達の実装は本当に変数の値上のフィルタとしての役目を果たす
ことを意図しています。もし\code{not}節がいくつかの束縛されていない変数を持つ
フレームと処理された場合(上記の例における\code{?x}が行うように)、システムは
予想外の結果を生成します。同様の問題が\code{lisp\-/value}の使用でも起こります。
Lispの述語はその引数のいくつかが未束縛な場合働くことができません。
\link{Exercise 4.77}を参照して下さい。

クエリ言語の\code{not}が記号論理学の\code{not}と異なるずっと深刻な部分があります。
論理学では命題``not \( P \)''を\( P \)は真ではないことを意味すると解釈します。
しかし、クエリシステムでは``not \( P \)''は\( P \)がデータベース内の知識から
推論不可能であることを意味しています。例えば、\link{Section 4.4.1}の社員情報データベース
を与えられた場合、システムは幸いにも全ての種類の\code{not}命令を推論することができるでしょう。
例えばBen Bitdiddleは野球のファンではない、外で雨は振っていない、2 + 2 は4ではないなどです。\footnote{クエリ
\code{(not (baseball\-/fan (Bitdiddle Ben)))}について考えてみましょう。システムは
データベースに\code{(baseball\-/fan (Bitdiddle Ben))}が無いことを知り、そのため空フレームは
パターンを満たさず初期値のフレームのストリームから取り除かれません。クエリの結果は
従って空フレームであり、これが入力クエリのインスタンス化に用いられ、
\code{(not (baseball\-/fan (Bitdiddle Ben)))}が生成されます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.64}Exercise 4.64:}
Louis Reasonerは誤って\code{outranked\-/by}ルール(\link{Section 4.4.1})をデータベースから削除して
しまった。彼はこのことに気付いた時、直ぐに再インストールした。残念なことに、
彼はルールにわずかな変更を行い、以下のように入力した。

\begin{scheme}
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person 
                           ?middle-manager))))
\end{scheme}


Louisがこの情報をシステムに入力して直ぐに、DeWitt AullがやってきてBen Bitdiddleの
上司は誰かを調べようとした。彼は以下のクエリを入力した。

\begin{scheme}
(outranked-by (Bitdiddle Ben) ?who)
\end{scheme}


回答を行った後、システムは無限ループへと陥った。何故であるか、説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.65}Exercise 4.65:}
組織内での昇進の日を待ち望んでいるCy D. Fectは全ての重役を探すクエリを入力
してみた(\link{Section 4.4.1}のルール\code{wheel}を用いた)。

\begin{scheme}
(wheel ?who)
\end{scheme}


驚いたことにシステムは以下の内容を応答した。

\begin{scheme}
~\textit{;;; Query results:}~
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
\end{scheme}

何故、Oliver Warbucksは4度表示されたのか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.66}Exercise 4.66:}
Benはクエリシステムを一般化し会社に関する統計を提供する。例えば、全ての
コンピュータプログラマの給料の合計を求めるためには、以下のように入力することが
できるだろう。

\begin{scheme}
(sum ?amount (and (job ?x (computer programmer))
                  (salary ?x ?amount)))
\end{scheme}


全般に、Benの新しいシステムは以下の形式の式を可能にする。

\begin{scheme}
(accumulation-function ~\( \dark \langle \)~~\var{\dark variable}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark query pattern}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
ここで\code{accumulation\-/function}は\code{sum}, \code{average}, または\code{maximum}のような物である。
Benはこれを実装するのは簡単なはずだと考えた。単純にクエリパターンを\code{qeval}に追加するだろう。
これはフレームのストリームを生成するだろう。すると彼はこのストリームをmap関数を通すことで
ストリーム内の各フレームから指定した変数の値を抽出し、結果の値のストリームをaccumulation(集積)
関数へと与えるだろう。Benが実装を完成し、丁度試験を行おうとした時にCyが依然として\link{Exercise 4.65}の
\code{wheel}クエリの結果に悩みながら歩いてきた。CyがBenにシステムの応答を見せた時、Benはうなってから
``なんてこった。私の簡単な集積の仕組みは動かない!''と述べた。


Benは何に気付いたのか? この状況を救い出すため用いられる手段の要点を述べよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.67}Exercise 4.67:}
クエリシステムにループ検知器をインストールし、テキストと\link{Exercise 4.64}で
説明されたような単純なループを防ぐための手段を工夫せよ。
一般的なアイデアは、システムに現在の推論の連鎖のある種の履歴を管理させ、既に取り組んでいる
クエリの処理を始めないようにすることである。どのような種類の情報(パターンとフレーム)が
この履歴に含まれるか、そしてどのように検査が行われるべきかについて説明せよ。(\link{Section 4.4.4}に
おけるクエリシステムの実装の詳細を学んだ後に、あなたはシステムを変更してループ検知器を
入れたいと思うだろう)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.68}Exercise 4.68:}
\link{Exercise 2.18}の\code{reverse}命令を実装するルールを定義せよ。これは与えられたリストの
逆順で同じ要素を含むリストを返す。(ヒント：\code{append\-/to\-/form}を使用せよ)。あなたの
ルールは\code{(reverse (1 2 3) ?x)}と\code{(reverse ?x (1 2 3))}の両方に回答することができるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.69}Exercise 4.69:}
\link{Exercise 4.63}で策定したデータベースとルールから始めて、孫の関係に``great''を
追加するためのルールを工夫せよ。これはシステムに対しIradがAdamのgreat-grandson(ひ孫)である
こと、またJabalとJubalがgreat-great-great-great-great-grandsons(ひひひひひ孫)であることを
推論することを可能にしなければならない。(ヒント：例えばIradに関する事実を
\code{((great grandson) Adam Irad)}として表現する。リストの終端が単語\code{grandson}であるかを
決定するルールを書け。これを用いて\code{?rel}が\code{grandson}で終わるリストである場合に、
関係\code{((great .  ?rel) ?x ?y)}を導き出すことが可能なルールを表現せよ)。
あなたのルールを\code{((great grandson) ?g ?ggs)}と\code{(?relationship Adam Irad)}のような
クエリを用いて確認せよ。
\end{quote}

\subsection{クエリシステムの実装}
\label{Sec. 4.4.4}
\label{Section 4.4.4}


\link{Section 4.4.2}はどのようにクエリシステムが働くかについて説明した。ここでは完全なシステムの実装
を公開することにより詳細を知らせる。



\subsubsection{ドライバループとインスタンス化}
\label{Section 4.4.4.1}


クエリシステムのためのドライバループは繰り返し入力式を読み込みます。もし式が追加されるべき
ルールかアサーションであるのならばその情報が追加されます。そうでなければ式はクエリであると
見做されます。ドライバはこのクエリを評価機\code{qeval}に単一の空のフレームから成る初期フレーム
ストリームと共に渡されます。評価の結果はクエリをデータベース内で見つかった変数の値で
満たすことにより生成されたフレームのストリームです。これらのフレームは、フレームのストリームに
より提供された値を用いて変数がインスタンス化された元のクエリのコピーから
成る新しいストリームを形成するのに用いられます。そしてこの最終的なストリームが
端末に表示されます。

\begin{scheme}
(define input-prompt  ";;; Query input:")
(define output-prompt ";;; Query results:")

(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Assertion added to data base.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate
                q
                frame
                (lambda (v f)
                  (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
\end{scheme}

\noindent
ここで、この章の他の評価機と同様に、クエリ言語の式に対して抽象構文を用います。
式の構文の実装は述語\code{assertion\-/to\-/be\-/added?}とセレクタ\code{add\-/assertion\-/body}を
含めて、\link{Section 4.4.4.7}にて与えられます。\code{add\-/rule\-/or\-/assertion!}は\link{Section 4.4.4.5}で
定義されます。


入力式のどんな処理を行う前にも、ドライバループは処理をより効率的にする形式へと
構文的に変換します。これはパターン変数の表現の変更を含みます。クエリが初期化される
時、未束縛である任意の変数は表示される前に入力時の表現に戻されます。これらの
変換は2つの手続き、\code{query\-/syntax\-/process}と\code{contract\-/question\-/mark}により実行されます(\link{Section 4.4.4.7})。


式をインスタンス化するためにはまずコピーを行い、式中の全ての変数を与えられたフレーム内の
それらの値にて置き換えます。値はそれら自身がインスタンス化されます。それらが変数を含む
可能性があるためです(例えば、式の中の\code{?x}がユニフィケーションの結果として\code{?y}に
束縛され、\code{?y}が同様に5に束縛されている場合)。変数がインスタンス化できない場合に取るべき
行動は手続き\code{instantiate}の引数に渡されます。

\begin{scheme}
(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
\end{scheme}

\noindent
束縛を操作する手続きは\link{Section 4.4.4.8}で定義されます。

\subsubsection{評価機}
\label{Section 4.4.4.2}


\code{query\-/driver\-/loop}により呼ばれる\code{qeval}手続きはクエリシステムの基本的な評価機です。
入力としてクエリとフレームのストリームを取り、拡張されたフレームのストリームを返します。
\link{Chapter 2}で総称的な命令を実装したのと同様に、
\code{get}と\code{put}を用いたデータ主導による呼出により特殊形式を判別します。
特殊形式とは判別されない任意のクエリは単純なクエリと見做され\code{simple\-/query}により処理されます。

\begin{scheme}
(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
\end{scheme}

\noindent
\code{type}と\code{contents}は\link{Section 4.4.4.7}で定義され、特殊形式の抽象構文を実装します。

\subsubsection*{単純なクエリ}


\code{simple\-/query}手続きは単純なクエリを扱います。引数として単純なクエリ(パターン)をフレームの
ストリームと共に取り、クエリのデータベースへの適合全てにより各フレームを拡張することにより
形成されたストリームを返します。

\begin{scheme}
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
\end{scheme}

\noindent
入力ストリーム中の各フレームに対し、\code{find\-/assertions}(\link{Section 4.4.4.3})を用いて
データベース内の全てのアサーションに対してパターンを適合し、拡張フレームの
ストリームを生成します。そして\code{apply\-/rules}(\link{Section 4.4.4.4})を用いて全ての
可能なルールを適用し、拡張フレームのもう1つのストリームを生成します。
これらの2つのストリームは(\code{stream\-/append\-/delayed}(\link{Section 4.4.4.6})を用いて)
接続され、与えられたパターンが元のフレームに一致して満たされることが可能な
全ての手段でストリームを作ります(\link{Exercise 4.71}参照)。個別の入力フレームに
対するストリームは\code{stream\-/flatmap} (\link{Section 4.4.4.6})を用いて接続され、
元の入力ストリーム内の任意のフレームが与えられたパターンを用いて
適合を生成するために拡張されることができる全ての手段により、1つの
巨大なストリームが形成されます。

\subsubsection*{複合クエリ}

\code{and}クエリは\link{Figure 4.5}にて説明されているように\code{conjoin}手続きにより
扱われます。\code{conjoin}は入力として結合(conjuncts)とフレームのストリームを
取り、拡張されたフレームのストリームを返します。最初に\code{conjoin}はフレームの
ストリームを処理し、結合内の最初のクエリを満たす全ての可能なフレームの拡張の
ストリームを探します。次に、これを新しいフレームのストリームとして用いて、
再帰的にクエリの残りに対して\code{conjoin}を適用します。

\begin{scheme}
(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))
\end{scheme}

\noindent
以下の式は

\begin{scheme}
(put 'and 'qeval conjoin)
\end{scheme}

\noindent
\code{qeval}に対し、\code{and}の型に遭遇した場合に\code{conjoin}を呼び出すように設定します。

\code{or}クエリも同様に、\link{Figure 4.6}に示されるように扱われます。
\code{or}の多様な選言肢に対する出力ストリームは別々に求められ、\link{Section 4.4.4.6}の
\code{interleave\-/delayed}手続きを用いて結合されます。(\link{Exercise 4.71}と\link{Exercise 4.72}を参照)

\begin{scheme}
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts)
              frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))
(put 'or 'qeval disjoin)
\end{scheme}

\noindent
論理積(conjuncts)と論理和(disjuncts)の構文のための述語とセレクタは\link{Section 4.4.4.7}で
提供されます。

\subsubsection*{フィルタ}


\code{not}は\link{Section 4.4.2}にて概説された手法により扱われます。入力ストリーム内の各フレームを
否定されたクエリを満たすように拡張することを試みます。そして拡張できない場合にのみ
出力ストリームに与えられたフレームを含めます。

\begin{scheme}
(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null?
          (qeval (negated-query operands)
                 (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'not 'qeval negate)
\end{scheme}

\noindent
\code{lisp\-/value}は\code{not}に似たフィルタです。ストリーム内の各フレームはパターン内の
変数をインスタンス化するために用いられ、指定された述語が適用され、述語が偽を返した
フレームは入力ストリームから取り除かれます。未束縛なパターン変数が存在する場合には
結果はエラーとなります。

\begin{scheme}
(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
           call
           frame
           (lambda (v f)
             (error "Unknown pat var: LISP-VALUE"
                    v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'lisp-value 'qeval lisp-value)
\end{scheme}

\noindent
\code{execute}は述語を引数に適用しますが、述語式を評価し適用する手続きを得なければなりません。
しかし引数は評価してはいけません。なぜならそれらは既に実際の引数であり、その(Lispにおける)
評価が引数を生成する式ではないためです。\code{execute}が基礎を成すLispシステムの
\code{eval}と\code{apply}を使用して実装されていることに注意して下さい。

\begin{scheme}
(define (execute exp)
  (apply (eval (predicate exp)
               user-initial-environment)
         (args exp)))
\end{scheme}

\noindent
特殊形式\code{always\-/true}はクエリに対し常に満たされた状態を与えます。これはその
中身(通常は空)を無視し、単純に入力ストリームの全てのフレームを通します。
\code{always\-/true}は\code{rule\-/body}セレクタ(\link{Section 4.4.4.7})により利用され、ボディ成しで
定義されたルールに対しボディを提供します。(言い換えれば、その結果部分が常に
満たされます。)

\begin{scheme}
(define (always-true ignore frame-stream) frame-stream)
(put 'always-true 'qeval always-true)
\end{scheme}

\noindent
\code{not}と\code{lisp\-/value}の構文を定義するセレクタは\link{Section 4.4.4.7}で提供されます。

\subsubsection{パターンマッチングによりアサーションを見つける}
\label{Sec. 4.4.4.3}
\label{Section 4.4.4.3}

\code{find\-/assertions}は\code{simple\-/query} (\link{Section 4.4.4.2})により呼ばれ、
入力としてパターンとフレームを取ります。フレームのストリームを返し、各フレームは
与えられた物を与えらえたパターンへのデータベースの適合により拡張されています。
\code{fetch\-/assertions} (\link{Section 4.4.4.5})を用いてデータベース内の全てのアサーションの
ストリームを得ます。これはパターンとフレームに対して適合するか確認されなければなりません。
ここで\code{fetch\-/assertions}する理由は、私達は良く簡単なテストをここで適用するためです。
このテストは適合を成功する候補のプールからデータベース内のエントリを数多く削減することが
できます。システムは例え\code{fetch\-/assertions}を削除して単純にデータベース内の全ての
アサーションのストリームを確認するだけでも動くでしょう。しかし演算は効率的ではなくなります。
より多くのマッチャに対する呼出を行わねばならなくなるためです。

\begin{scheme}
(define (find-assertions pattern frame)
  (stream-flatmap 
    (lambda (datum) 
      (check-an-assertion datum pattern frame))
    (fetch-assertions pattern frame)))
\end{scheme}

\noindent
\code{check\-/an\-/assertion}は引数としてパターン、データオブジェクト(アサーション)、フレームを取り、
拡張されたフレームを含む1要素のストリームか、適合を失敗した場合に\code{the\-/empty\-/stream}を返します。

\begin{scheme}
(define (check-an-assertion
         assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
\end{scheme}

\noindent
基本的なパターンマッチャはシンボル\code{failed}か、与えられたフレームの拡張を返します。
マッチャの基本的な考えはパターンをデータに対して要素毎に確認し、パターン変数に対する
束縛を集積します。もしパターンとデータオブジェクトが同じであるなら、適合は成功しそこまで
集積された束縛のフレームを返します。そうでなければ、もしパターンが変数ならば、変数を
データに対して束縛することで現在のフレームを拡張することをフレーム内に既に存在する
束縛に一致するまで行います。もしパターンとデータの両方がペアであるなら、(再帰的に)パターンの
\code{car}をデータの\code{car}に対して適合を行いフレームを生成します。次にこのフレームの中で
パターンの\code{cdr}をデータのに対して適合を行います。もしこれらの場合全てが当て嵌らない
場合、適合は失敗し、シンボル\code{failed}を返します。

\begin{scheme}
(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match 
          (cdr pat)
          (cdr dat)
          (pattern-match (car pat) (car dat) frame)))
        (else 'failed)))
\end{scheme}

\noindent
次が、フレーム内に既に存在している束縛に一致するなら、新しい束縛を追加することによりフレームを拡張する手続きです。

\begin{scheme}
(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match
         (binding-value binding) dat frame)
        (extend var dat frame))))
\end{scheme}

\noindent
もしフレーム内の変数に対する束縛が無い場合、単純に変数のデータに対する束縛を追加します。
そうでなければこのフレーム内で、データをフレーム内の変数の値に対して適合を行います。
もし格納されていた値が定数のみを持つならば、つまり\code{extend\-/if\-/consistent}により
パターンマッチングの間に格納されたのであれば、適合は単純に格納されていた値と新しい
値が同じであるかどうかを確認します。もしそうならば、フレームを変更せずに返します。
そうでないならば、失敗を示す印を返します。しかし格納されたいた値は、それがユニフィケーションの
間に格納されたのであればパターン変数を含む場合があります(\link{Section 4.4.4.4}参照)。
格納されたパターンの新しいデータに対する再帰的な適合はこのパターン内の変数に対する
束縛の追加、または確認を行います。例えば、\code{?x}が\code{(f ?y)}に束縛され\code{?y}が未束縛である
フレームを持っているとしましょう。そしてこのフレームを\code{?x}の\code{(f b)}への束縛で
拡大させたいとします。私達は\code{?x}を探し、それが\code{(f ?y)}に束縛されているのを見つけます。
このことがこの同じフレームの中で提案された新しい値\code{(f b)}に対して\code{(f ?y)}を適合させる
ことへと導きます。最終的に、この適合は\code{?y}から\code{b}への束縛を追加する
ことによりこのフレームを拡張します。\code{?x}は\code{(f ?y)}への束縛を維持します。
格納されていた束縛を変更することはありません。また与えられた変数に対して複数の
束縛を格納することもありません。


\code{extend\-/if\-/consistent}により使用される束縛を操作するための複数の手続きは\link{Section 4.4.4.8}で
定義されます。

\subsubsection*{末尾ドット付きパターン}
\label{Sec. 4.4.4.4}
\label{Section 4.4.4.4}

パターンがドットとそれに続くパターン変数を含む場合、そのパターン変数はデータリストの
(次の要素ではなく)残りに適合します。誰かが予想するように\link{Exercise 2.20}にて
説明されたドット付き末尾記述と同様です。私達が実装したばかりのパターンマッチャは
ドットを探しませんが、私達が望むとおりに振舞います。これは\code{query\-/driver\-/loop}で
用いられるLispの\code{read}プリミティブがクエリを読み込みリスト構造として表現する時に
ドットを特別な方法で扱うためです。

\code{read}がドットを見た時、次の項目をリストの次の要素にするのではなく
(\code{cons}の\code{car}のこと、\code{cdr}はリストの残り)、リスト構造の\code{cdr}を
次の項目にします。例えば、パターン\code{(computer ?type)}に対する\code{read}により
生成されるリスト構造は式\code{(cons 'computer (cons '?type '()))}を評価することにより
構築されます。またパターン\code{(computer . ?type)}に対する場合は式
\code{(cons 'computer '?type)}を評価することにより構築されます。

従って\code{pattern\-/match}が再帰的にデータリストとドットを持つパターンの\code{car}と\code{cdr}を
比較するにつれ、最終的にはドットの後ろの変数(パターンの\code{cdr})がデータリストの
部分リストに対して適合され、そのリストに対してその変数が束縛されます。例えば、
パターン\code{(computer . ?type)}を\code{(programmer trainee)}に適合することは
\code{?type}をリスト\code{(programmer trainee)}に適合させます。

\subsubsection{ルールとユニフィケーション}

\code{apply\-/rules}は\code{find\-/assertions}の類似のルールです(\link{Section 4.4.4.3})。
入力としてパターンとフレームを取り、データベースからルールを適用することにより
拡張フレームのストリームを形成します。\code{stream\-/flatmap}は\code{apply\-/a\-/rule}を
(\code{fetch\-/rules}により選択された(\link{Section 4.4.4.5}))恐らく適用可能な
ルールのストリームに対しmapし、結果のフレームのストリーム群を結合します。

\begin{scheme}
(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
\end{scheme}

\noindent
\code{apply\-/a\-/rule}は\link{Section 4.4.2}で概説された手法を用いてルールを適用します。
最初にルールの結論を与えられたフレーム内のパターンとユニフィケーションを行うことで
引数フレームを増大させます。これが成功したならこの新しいフレーム内でルールのボディを
評価します。

しかしこの全てが起こる前に、プログラムはルール内の全ての変数を個別の新しい名前に
変更します。この理由は異なるルールの適用に対する変数が御互いに混同されることを
防ぐためです。例えば、もし2つのルールの両方が\code{?x}と名付けられた変数を用いる場合、
それぞれが適用された時に\code{?x}に対する束縛をフレームに追加するかもしれません。
これら2つの\code{?x}は御互いに関係がありません。そして私達は2つの束縛が一致するはずだと
考えるように惑わされてはいけません。変数名を変えるのでなく、より賢い環境構造を
工夫することもできるでしょう。しかし、私達がここで選択した改名による取り組み方は
最も効率的ではないとしても、最も簡単です(\link{Exercise 4.79}参照)。
以下が\code{apply\-/a\-/rule}手続きです。

\begin{scheme}
(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result
           (unify-match query-pattern
                        (conclusion clean-rule)
                        query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
\end{scheme}

\noindent
セレクタ\code{rule\-/body}と\code{conclusion}はルールの部分を抜き出します。
これは\link{Section 4.4.4.7}で定義されます。

私達はユニークな(unique、独自の)識別子(例えば番号)を各ルールの適用に関連付けし、この識別子を元の
変数名に接続することで、ユニークな変数名を生成します。例えば、もしルール適用識別子が7なら、
ルール内の各\code{?x}を\code{?x\-/7}に、各\code{?y}を\code{?y\-/7}に変更するでしょう。
(\code{make\-/new\-/variable}と\code{new\-/rule\-/application\-/id}は\link{Section 4.4.4.7}の構文手続きに含まれます。)

\begin{scheme}
(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable
              exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
\end{scheme}

\noindent
ユニフィケーションアルゴリズムは手続きとして実装され、入力として2つのパターンとフレームを取り、
拡張されたフレームかシンボル\code{failed}を返します。ユニファイアはパターンマッチャに似ていますが、
対照的であることが異なります---つまり、変数が適合の両サイドに存在することが許されます。
\code{unify\-/match}は基本的には\code{pattern\-/match}と同じですが、(以下で``\code{***}''のマークを付けた)
拡張コードの存在が異なります。これは適合の右側のオブジェクトが変数である場合を扱います。

\begin{scheme}
(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame))  ~\textrm{; ***}~
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
\end{scheme}

\noindent
ユニフィケーションにおいては一方向マッチングのように、既存の束縛に一致する場合のみ
提案されたフレームの拡張を受け入れたいです。手続き\code{extend\-/if\-/possible}はユニフィケーションに
おいて使用され、パターンマッチにて利用される\code{extend\-/if\-/consistent}と同じですが、
下記のプログラムで``\code{***}''がマークされている、2つの特別なチェックが異なります。
最初のケースでは、もし適合を試す変数が未束縛であり、かつそれに対して適合させようと
している値それ自体が(異なる)変数である場合に、その値が束縛されているかを確認する
必要があります。そしてもしそうであれば、その値を適合する必要があります。
もし適合の両側が共に未束縛である場合、それぞれを御互いに束縛します。

2つ目のチェックは変数を、変数を含むパターンに対して束縛する試みを取り扱います。
そのような状況は変数が両方のパターン内で繰り返される場合に常に起こり得ます。
例えば2つのパターン、\code{(?x ?x)}と\code{(?y <\var{\code{?y}を含む式}>)}を、
\code{?x}と\code{?y}の両方が未束縛である場合のフレーム内にてユニフィケーションを
行う場合について考えてみて下さい。最初の\code{?x}は\code{?y}に対して適合し、\code{?x}から\code{?y}への
束縛を作成します。次に同じ\code{?x}が与えられた\code{?y}を含む式に対して適合されます。
\code{?x}は既に\code{?y}に対して束縛されているため、これは結果として\code{?y}をその式に対して
適合することになります。もし私達がユニファイアを2つのパターンを同じにするパターン変数に
対する値の集合を見つけるものとして考えているなら、これらのパターンは\code{?y}が\code{?y}を
含む式に等しいような\code{?y}を見付ける命令を暗示します。そのような方程式を解く一般的な
手法は存在しませんので、私達はそのような束縛を却下します。このような場合が述語\code{depends\-/on?}に
より認識されます。\footnote{
一般的に、\code{?y}を\code{?y}を含む式にユニフィケーションを行う場合には、
方程式\code{?y} = <\var{expression involving \code{?y}}>の不動点を見つけられなければなりません。
偶に解が存在する式を構文的に形成することが可能です。例えば、\code{?y} = \code{(f ?y)}は不動点
\code{(f (f (f \( \dots \) )))}を持つように見えます。これは式\code{(f ?y)}で始め、繰り返し\code{?y}を
\code{(f ?y)}で置き換えることで生成できます。残念ながら全てのそのような方程式が意味のある
不動点を持つわけではありません。ここで浮かび上がる問題は数学で無限級数を扱う場合の
問題と似ています。例えば、私達は2が方程式\( y = 1 + y / 2 \)の解であることを知っています。
式\( 1 + y / 2 \)で始めて、繰り返し\( y \)を\( 1 + y / 2 \)で置き換えていくと
以下の様になります。
\begin{comment}
\begin{example}
2 = y = 1 + y/2 = 1 + (1 + y/2)/2 = 1 + 1/2 + y/4 = ...
\end{example}
\end{comment}
\begin{displaymath}
 2 = y = 1 + {y \over 2} = 1 + {1\over2}\left(1 + {y \over 2}\right) = 
	1 + {1\over2} + {y \over 4} = \dots , 
\end{displaymath}
\noindent
これは以下の式へと導きます。
\begin{comment}

\begin{example}
2 = 1 + 1/2 + 1/4 + 1/8 + ...
\end{example}

\end{comment}
\begin{displaymath}
 2 = 1 + {1\over2} + {1\over4} + {1\over8} + \dots. 
\end{displaymath}
\noindent
しかし、もし同じ操作を式\( y = 1 + 2y \)の解が-1であるという結果から始めると、
\begin{comment}

\begin{example}
-1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = ...
\end{example}

\end{comment}
\begin{displaymath}
 -1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = \dots, 
\end{displaymath}
\noindent
これは以下の式へと導きます。
\begin{comment}

\begin{example}
-1 = 1 + 2 + 4 + 8 + ...
\end{example}

\end{comment}
\begin{displaymath}
 -1 = 1 + 2 + 4 + 8 + \dots. 
\end{displaymath}
\noindent
これらの2つの等式を導き出した形式的な操作は同一であるにも係らず、最初の結果は
無限級数に関して有効な正しい主張となりますが、2つ目はそうではありません。
同様に、私達のユニフィケーションの結果に対して無計画に構文に従い構築された
式はエラーへと繋るでしょう。
}


一方で、変数をそれ自体へ束縛する試みを拒否したくはありません。例として、
\code{(?x ?x)}と\code{(?y ?y)}のユニフィケーションについて考えてみましょう。
二度目の\code{?x}を\code{?y}へ束縛する試行は\code{?y}(\code{?x}の新しい値)に対する
\code{?y}(\code{?x}に格納された値)に適合します。これは\code{unify\-/match}の
\code{equal?}節により担当されます。

\begin{scheme}
(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                      ~\textrm{; ***}~
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)     ~\textrm{; ***}~
           'failed)
          (else (extend var val frame)))))
\end{scheme}

\noindent
\code{depends\-/on?}はパターン変数の値であると提案された式がその変数に依存するかを確認します。
これは現在のフレームと比較して行われなければなりません。式がテスト変数に依存する値を
既に持つ変数の存在を含むかもしれないためです。\code{depends\-/on?}の構造は簡単な再帰木の
探索であり、この中で必要な場合いつでも変数の値を置き換えます。

\begin{scheme}
(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
\end{scheme}

\subsubsection{データベースの保守}
\label{Sec. 4.4.4.5}
\label{Section 4.4.4.5}

論理プログラミング言語の設計における重要な問題の1つは、与えられたパターンの確認に
おいてできる限り少ないデータベースのエントリが検査されるように物事を準備することです。
私達のシステムでは、全てのアサーションを1つの大きなストリームに格納することに加えて、
\code{car}が静的なシンボルである全てのアサーションをそのシンボルで索引付けられたテーブル内の
分離されたストリームに格納します。パターンに適合するかもしれないアサーションを取り出すためには、
最初にパターンの\code{car}が静的なシンボルであるかを確認します。
もしそうならば、(マッチャを用いて確認するため)同じ\code{car}を持つ全ての格納された
アサーションを返します。もしパターンの\code{car}が静的なシンボルでない場合には、格納された
アサーションを全て返します。より賢い方法ではフレーム内の情報も活用するか、パターンの
\code{car}が静的なシンボルでない場合にも最適化を行うことに挑むことができるでしょう。
私達は検索作成の基準(\code{car}を用いる、静的シンボルの場合のみを扱う)をこのプログラムの中に
構築することを避けました。その代わりに私達の基準を具現する述語とセレクタを呼び出します。

\begin{scheme}
(define THE-ASSERTIONS the-empty-stream)
(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))
(define (get-all-assertions) THE-ASSERTIONS)
(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
\end{scheme}

\noindent
\code{get\-/stream}はテーブル内のストリームを探し、そこに何にも格納されていない場合には
空ストリームを返します。

\begin{scheme}
(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
\end{scheme}

\noindent
ルールも同様にルールの結論の\code{car}を用いて格納されます。しかしルールの結論は任意の
パターンであるため、変数を含められることがアサーションとは異なります。\code{car}が静的なシンボルである
パターンは結論が変数で始まるルールと、結論が同じ\code{car}を持つルールにも適合できます。
従って、\code{car}が静的なシンボルであるパターンに適合するかもしれないルールを取り出す場合、
結論が変数で始まる全てのルールと、結論がそのパターンと同じ\code{car}を持つルールを取り出します。
この目的のために、結論が変数で始まる全てのルールをテーブル内の分離されたストリームに、
シンボル\code{?}で索引付けして格納します。

\begin{scheme}
(define THE-RULES the-empty-stream)
(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))
(define (get-all-rules) THE-RULES)
(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
\end{scheme}

\noindent
\code{add\-/rule\-/or\-/assertion!}は\code{query\-/driver\-/loop}により使用されアサーションと
ルールとデータベースに追加します。各アイテムは適切であればインデックスに格納され、
データベース内の全てのアサーション、またはルールのストリームに格納されます。

\begin{scheme}
(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion old-assertions))
    'ok))
(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
\end{scheme}

\noindent
実際にアサーション、またはルールを格納するためには、索引を付けられるかを確認します。
もしそうであれば、適切なストリームに格納します。

\begin{scheme}
(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream
                assertion
                current-assertion-stream))))))
(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream rule
                              current-rule-stream)))))))
\end{scheme}

\noindent
以下の手続きはデータベースのインデックス(索引)がどのように使用されかについて定義します。
パターン(アサーション、またはルールの結論)が変数、または静的なシンボルで始まる場合に
テーブルに格納されます。

\begin{scheme}
(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
\end{scheme}

\noindent
パターンがその下に格納されるテーブル内のキーは(変数で始まる場合には)\code{?}、または
パターンの始めの静的なシンボルです。

\begin{scheme}
(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
\end{scheme}

\noindent
インデックスはパターンが静的なシンボルで始まる場合、パターンにマッチするかもしれない
アイテムを取得するために利用されます。

\begin{scheme}
(define (use-index? pat) (constant-symbol? (car pat)))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.70}Exercise 4.70:}
手続き\code{add\-/assertion!}と\code{add\-/rule!}内の\code{let}の束縛の目的は何か?
以下の\code{add\-/assertion!}の実装の誤りは何か? ヒント：\link{Section 3.5.2}における1の
無限ストリームの定義を思い出せ：\code{(define ones (cons\-/stream 1 ones))}

\begin{scheme}
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion THE-ASSERTIONS))
  'ok)
\end{scheme}
\end{quote}

\subsubsection{ストリーム命令}
\label{Section 4.4.4.6}

クエリシステムは\link{Chapter 3}には存在しなかったいくつかのストリーム命令を用います。


\code{stream\-/append\-/delayed}と\code{interleave\-/delayed}は\code{stream\-/append}と\\
\code{interleave}(\link{Section 3.5.3})と
同じですが、それらが(\link{Section 3.5.4}の\code{integral}の様に)遅延化された引数を取ることが異なります。
これはいくつかの場合においてループを先送りします。(\link{Exercise 4.71}参照)

\begin{scheme}
(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed
        (stream-cdr s1)
        delayed-s2))))
(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed
        (force delayed-s2)
        (delay (stream-cdr s1))))))
\end{scheme}

\noindent
\code{stream\-/flatmap}はクエリ評価機を通して使用され手続きをフレームのストリーム上に対してmapし、
結果としての複数のフレームのストリームを接続します。
\code{stream\-/flatmap}は\link{Section 2.2.3}にて通常のリストのために導入された\code{flatmap}手続きの
ストリーム向け類似品です。しかし通常の\code{flatmap}と異なり、単純にストリームをappendしていく
のではなく、相互配置処理により蓄積します。(\link{Exercise 4.72}と\link{Exercise 4.73}参照)
\begin{scheme}
(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))

(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
\end{scheme}

\noindent
評価機はまた以下の単純な手続きを用いて単一要素から成るストリームを生成します。

\begin{scheme}
(define (singleton-stream x)
  (cons-stream x the-empty-stream))
\end{scheme}

\subsubsection{クエリ構文手続き}
\label{Section 4.4.4.7}


\code{qeval}(\link{Section 4.4.4.2})により用いられる\code{type}と\code{contents}は、
特殊形式がその\code{car}に存在するシンボルにより判別されることを指示します。
これらは\link{Section 2.4.2}の\code{type\-/tag}と\code{contents}手続きと同じですが、エラーメッセージが
異なります。

\begin{scheme}
(define (type exp)
  (if (pair? exp)
      (car exp)
      (error "Unknown expression TYPE" exp)))
(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error "Unknown expression CONTENTS" exp)))
\end{scheme}

\noindent
以下の手続きは\link{Section 4.4.4.1}の\code{query\-/driver\-/loop}にて使用されます。これはルールと
アサーションがデータベースに\code{(assert! <\var{rule\-/or\-/assertion}>)}の形式の式により
追加されることを指示します。

\begin{scheme}
(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))
(define (add-assertion-body exp) (car (contents exp)))
\end{scheme}

\noindent
以下は特殊形式\code{and}, \code{or}, \code{not}, \code{lisp\-/value}のための構文定義です。(\link{Section 4.4.4.2})

\begin{scheme}
(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))
(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))
(define (negated-query exps) (car exps))
(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
\end{scheme}

\noindent
以下の3つの手続きはルールの構文を定義します。

\begin{scheme}
(define (rule? statement)
  (tagged-list? statement 'rule))
(define (conclusion rule) (cadr rule))
(define (rule-body rule)
  (if (null? (cddr rule)) '(always-true) (caddr rule)))
\end{scheme}

\noindent
\code{query\-/driver\-/loop}(\link{Section 4.4.4.1})は\code{query\-/syntax\-/process}を呼び、
\code{?symbol}の形態を持つ式のパターン変数を内部形式\code{(? symbol)}に変形します。
これは言ってみれば、\code{(job ?x ?y)}のようなパターンが実際には内部的にシステムにより
\code{(job (? x) (? y))}と表現されているということです。これによりクエリ処理の効率が
良くなります。システムが式がパターン変数であるかを確認するのにシンボルから文字を
抽出する必要が無しに、式の\code{car}がシンボル\code{?}であるかどうかを確認することにより
確認できることを意味するためです。構文変形は以下の手続きにより達成されます。\footnote{
多くの
Lispシステムは通常の\code{read}手続きを\newterm{reader macro characters}(\jnewterm{リーダ
マクロキャラクタ})を定義することにより変更し、そのような変形を実行させる能力を
ユーザにに与えています。クォートされた式は既にこのような取り扱われています。
リーダーは評価機が式を見る前に自動的に\code{'expression}を\code{(quote expression)}に
変形します。私達は同様に\code{?expression}が\code{(? expression)}に変形されるように
準備することも可能でした。しかし、明快さのために、私達はここに明示的に変形手続きを
含めました。

\code{expand\-/question\-/mark}と\code{contract\-/question\-/mark}は名前に\code{string}を持つ
いくつかの手続きを使用します。これらはSchemeのプリミティブです。}

\begin{scheme}
(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))
(define (map-over-symbols proc exp)
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))
(define (expand-question-mark symbol)
  (let ((chars (symbol->string symbol)))
    (if (string=? (substring chars 0 1) "?")
        (list '?
              (string->symbol
               (substring chars 1 (string-length chars))))
        symbol)))
\end{scheme}

\noindent
一旦、変数がこのように変形されれば、パターン内の変数は\code{?}で始まるリストであり、
静的なシンボル(データベースの索引付けのために必要、\link{Section 4.4.4.5})はただのシンボルです。

\begin{scheme}
(define (var? exp) (tagged-list? exp '?))
(define (constant-symbol? exp) (symbol? exp))
\end{scheme}

\noindent
他とは異なる変数がルールの適用の間に以下の手続きを用いて構築されます(\link{Section 4.4.4.4})。
ルール適用のための独自識別子は数値であり、ルールが適用される度にインクリメントされます。

\begin{scheme}
(define rule-counter 0)
(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)
(define (make-new-variable var rule-application-id)
  (cons '? (cons rule-application-id (cdr var))))
\end{scheme}

\noindent
\code{query\-/driver\-/loop}が回答を表示するためにクエリをインスタンス化する時、
全ての未束縛のパターン変数を表示に適した形式に以下を用いて戻します。

\begin{scheme}
(define (contract-question-mark variable)
  (string->symbol
   (string-append "?"
     (if (number? (cadr variable))
         (string-append (symbol->string (caddr variable))
                        "-"
                        (number->string (cadr variable)))
         (symbol->string (cadr variable))))))
\end{scheme}

\subsubsection{フレームと束縛}
\label{Section 4.4.4.8}


フレームは変数と値のペアである束縛のリストとして表現されます。

\begin{scheme}
(define (make-binding variable value)
  (cons variable value))
(define (binding-variable binding) (car binding))
(define (binding-value binding) (cdr binding))
(define (binding-in-frame variable frame)
  (assoc variable frame))
(define (extend variable value frame)
  (cons (make-binding variable value) frame))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.71}Exercise 4.71:}

Louis Reasonerはなぜ\code{simple\-/query}と\code{disjoin}の手続き(\link{Section 4.4.4.2})は
以下のような定義ではなく、明示的な\code{delay}命令を用いて実装されたのか不思議だった。

\begin{scheme}
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append
      (find-assertions query-pattern frame)
      (apply-rules query-pattern frame)))
   frame-stream))
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts)
              frame-stream)
       (disjoin (rest-disjuncts disjuncts)
                frame-stream))))
\end{scheme}

あなたはこれらのより簡単な定義を望まない振舞いへと導くクエリの例を与えることができるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.72}Exercise 4.72:}
なぜ\code{disjoin}と\code{stream\-/flatmap}は単純にそれらをappendせずに相互配置するのか?
なぜ相互配置のほうがより良く働くのかを説明する例を与えよ。(ヒント：なぜ私達は
\link{Section 3.5.3}において\code{interleave}を使用したのか?)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.73}Exercise 4.73:}
なぜ\code{flatten\-/stream}は明示的に\code{delay}を用いるのか?
以下のように定義した場合に何が間違っているのか?

\begin{scheme}
(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.74}Exercise 4.74:}
Alyssa P. Hackerはより簡単な版の\code{stream\-/flatmap}を\code{negate}, \code{lisp\-/value},
\code{find\-/assertions}の中で使用することを提案した。彼女はフレームのストリーム上に
mapされる手続きはこれらの場合において常に空ストリームか、単一要素のストリームを
生成する。そのためこれらのストリームを接続する場合、相互配置する必要が無いと
気付いた。

\begin{enumerate}[a]

\item
Alyssaのプログラムに欠けている式を埋めよ。

\begin{scheme}
(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))
(define (simple-flatten stream)
  (stream-map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
              (stream-filter ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ stream)))
\end{scheme}

\item
クエリシステムの振舞はこのように変更した場合に変化するだろうか?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.75}Exercise 4.75:}
クエリ言語に対して新しい特殊形式\code{unique}を実装せよ。\code{unique}は正確に
データベース内の1つの項目が指定されたクエリを満たす場合に成功しなければならない。
例えば、

\begin{scheme}
(unique (job ?x (computer wizard)))
\end{scheme}

\noindent
上の式は1つの項目のストリームを表示しなければならない。

\begin{scheme}
(unique (job (Bitdiddle Ben) (computer wizard)))
\end{scheme}

\noindent
Benはただ1人のコンピュータウィザードであるためである。
次に、

\begin{scheme}
(unique (job ?x (computer programmer)))
\end{scheme}

\noindent
上は空ストリームを表示しなければならない。複数のコンピュータプログラマが存在するためである。
さらに、

\begin{scheme}
(and (job ?x ?j) (unique (job ?anyone ?j)))
\end{scheme}

\noindent
上はただ1人により埋められた役職とその人達を全て表示しなければならない。


\code{unique}を実装するには2つの部分が存在する。1つ目はこの特殊形式を扱う手続きを
書くことであり、2つ目は\code{qeval}にその手続きを呼出させることである。2つ目の部分は
自明だ。\code{qeval}はその呼出をデータ主導の方法に従うためである。もしあなたの
手続きが\code{uniquely\-/asserted}という名前であるなら、やらなければいけないことは以下である。

\begin{scheme}
(put 'unique 'qeval uniquely-asserted)
\end{scheme}

\noindent
これで\code{qeval}は型(\code{car})がシンボル\code{unique}である全てのクエリに対して
この手続きを呼び出す。

真の問題は手続き\code{uniquely\-/asserted}を書くことである。これは入力として\code{unique}クエリの
\code{contents}(\code{cdr})をフレームのストリームと共に受け取る。ストリームの各フレームに対し、
\code{qeval}を用いて与えられたクエリを満たすフレームの全ての拡張のストリームを見つけなければ
ならない。正確に1つのアイテムのみを持たないストリームは全て取り除かれなければならない。
残ったストリームは\code{unique}クエリの結果である1つの巨大なストリームに蓄積するために
戻されなければならない。これは特殊形式\code{not}の実装に似ている。

あなたの実装を正確に1人だけを監督する全ての人々を並べるクエリを形成することによりテストせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.76}Exercise 4.76:}
一連のクエリの結合としての\code{and}の実装(\link{Figure 4.5})は洗練されているが非効率だ。
\code{and}の2つ目のクエリの処理において最初のクエリにより生成された各フレームに対して
データベースを走査しなければならないためである。もしデータベースが\( n \)個の要素を持ち、
典型的なクエリが\( n \)に比例した数(仮に\( n / k \)個)の出力フレームを生成する場合、
最初のクエリにより生成された各フレームに対するデータベースの走査は\( n^2\! / k \)の
パターンマッチャの呼出を必要とする。別の取り組み方としては\code{and}の2つの節を分離して処理し、
矛盾のない出力フレームの全てのペアを探すことになるだろう。もし各クエリが\( n / k \)個の
出力フレームを生成するなら、これは\( n^2\! / k^2 \)回の無矛盾テストを実行しなければ
ならないことを意味する。\( k \)の係数が現在の手法で必要な適合数よりもより少ない。


この戦略を用いる\code{and}の実装を工夫せよ。入力として2つのフレームを取り、
両フレームの中の束縛が無矛盾であることを確認しなければならない。もしそうであるなら
束縛の2つの集合をマージするフレームを生成する。この操作はユニフィケーションに似ている。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.77}Exercise 4.77:}
\link{Section 4.4.3}において\code{not}と\code{lisp\-/value}がクエリ言語に対し
もしこれらのフィルタリング命令が変数が束縛されていないフレームに適用された場合に
``間違った''回答を与えることがあることを学んだ。この欠陥を直す方法を工夫せよ。
1つの考えはフィルタリングを``遅延''の様式で実行することだ。フレームに``プロミス''を
追加することで十分な変数がその操作を可能にする場合にのみそれを果たすようにする。
フィルタリングの実行は全ての他の命令が実行を終えるまで待つことができる。しかし、
効率のために生成される中間フレームの数を削減できるようフィルタリングをできるだけ早く実行したい。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.78}Exercise 4.78:}
クエリ言語をストリーム処理ではなく非決定性プログラムとして、\link{Section 4.3}の評価機を用いて実装されるように
再設計せよ。この取り組み方においては、各クエリは(全ての回答のストリームではなく)単一の回答を生成し、
ユーザは\code{try\-/again}を入力することでより多くの回答を見ることができる。
この節で構築した仕組みの多くは非決定性探索とバックトラックにより組込まれていることに気付かなければ
ならない。しかし、新しいクエリ言語の振舞にここで実装されたものからわずかな違うことにも気付くだろう。
この違いを説明する例を見つけることができるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.79}Exercise 4.79:}
\link{Section 4.1}でLisp評価機を実装した時に、どのようにローカル環境を使用して
手続きのパラメタ間の名前衝突を防ぐかについて学んだ。例えば以下を評価する場合に
おいて、

\begin{scheme}
(define (square x) (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
\end{scheme}

\noindent
\code{square}の\code{x}と\code{sum\-/of\-/squares}の\code{x}の間に混乱は無い。なぜなら
各手続きのボディをローカル変数のための束縛を含めるために特別に構築した環境の
中で評価するからである。クエリシステムではルール適用における名前衝突を
避けるために異なる戦略を用いた。ルールを適用する度に変数名を唯一であることを
保証された新しい名前に変えている。Lisp評価機に対する同様の戦略はローカルな
環境を排除し、手続きを適用する度に手続きのボディの中の変数を改名することになるだろう。

クエリ言語に対して改名でなく、環境を用いるルール適用手法を実装せよ。
あなたの環境構造上に巨大システムを取り扱うために、クエリ言語内にブロック構造化された
手続きに同等なルールのような構成概念を作るために構築できるか確かめよ。
これの何かを文脈中での推論を行う問題に、問題解決の手段として関連付けることはできるだろうか?
(例えば``もし\( P \)が真であるとするならば、\( A \)と\( B \)を推論することができる'')。

(この問題には明確な回答やルールは存在しない。良い回答は恐らく博士号の価値があるだろう。)
\end{quote}

\chapter{レジスタマシンによる演算}
\label{Chapter 5}

\vspace{0.2em}

\begin{quote}
私の目的は天の機械は神からの授かり物や生き物ではなく、時計仕掛のような物であることを
示すことです。
(そして時計が魂を持つと信ずる人はその理由をその仕事に対するメーカーの栄光に帰するでしょう。)
それはほとんど全ての多様な運動が最も単純な物質の力により引き起こされるとする限りにおいて、
時計の全ての動作が1つの錘により引き起こされるのと全く同じように。

---Johannes Kepler (Herwart von Hohenburgへの手紙, 1605)
\end{quote}

\vspace{1.0em}

\noindent
私達はこの本をプロセスを学ぶことと、プロセスをLispで書かれた手続きを用いて説明することにより
始めました。これらの手続きの意味を説明するために、いくつかの評価モデルを用いました。
\link{Chapter 1}の置換モデル、\link{Chapter 3}の環境モデル、\link{Chapter 4}のメタ循環評価機です。
私達のメタ循環評価機の調査は特にLispのような言語がどのように解釈されるのかについての
謎の大部分を氷解させました。しかしメタ循環評価機ですらも重要な疑問を未知の状態に残します。
Lispシステム中の制御の仕組みは明らかにしないためです。例えば、この評価機は
部分式の評価がこの式の値を用いる式にどのようにその値を返すのかについて説明しません。
またこの評価機は、ある再帰関数が反復プロセス(つまり、定量的な記憶域で評価されるもの)を生成するのに
対し、一方で他の再帰関数が再帰プロセスを生成することもまた説明しません。
これらの疑問は未解決のままです。なぜならメタ循環評価機はそれ自身がLispプログラムであり、
それ故に根底に存在するLispシステムの制御構造を引き継ぐためです。より完全なLisp評価機の
制御構造の説明を与えるためには、Lispそれ自身よりもよりプリミティブなレベルについて
取り組まねばなりません。

この章ではプロセスを旧来の計算機の個々の操作を用いて説明します。そのような計算機、つまり
\newterm{register machine}(\jnewterm{レジスタマシン})は\newterm{registers}(\jnewterm{レジスタ})と呼ばれる
固定長の記憶要素の集合の中身を操作する\newterm{instructions}(\jnewterm{命令})を順に実行します。
典型的なレジスタマシンの命令はプリミティブな操作をいくつかのレジスタの中身に対して
適用し、その結果を他のレジスタに割り当てます。レジスタマシンにより実行される
プロセスの私達の説明は伝統的な計算機向けの``機械語''にとても良く似ているでしょう。
しかし、何らかの特定の計算機の機械語に注力する代わりに、私達はいくつかのLisp手続きを
調査し、各手続きを実行するための特定のレジスタマシンを設計します。従って私達はこの目的に
機械語のコンピュータプログラマではなく、ハードウェアアーキテクトの視点から取り組みます。
レジスタマシンの設計において、私達は再帰のような重要なプログラミング構造を実装するための
仕組みを開発します。またレジスタマシンの設計を記述するための言語も与えます。
\link{Section 5.2}ではこれらの記述を用いて設計したマシンをシミュレートするLispプログラムを
実装します。

私達のレジスタマシンのプリミティブな命令の多くはとても簡単です。例えばある命令は2つの
レジスタから取得した数値を足し、結果を生成して3つ目のレジスタに格納します。
そのような命令は簡単に記述されたハードウェアにより実行されることができます。
しかし、リスト構造を取り扱うためにはメモリ操作命令\code{car}, \code{cdr}, \code{cons}もまた
使用します。これは複雑なストレージ(記憶領域)獲得の仕組みを必要とします。
\link{Section 5.3}でより初歩的な命令を用いてのそれらの実装について学びます。

\link{Section 5.4}ではレジスタマシンによる簡単な手続きの形式化についての経験を貯めた後に、
\link{Section 4.1}のメタ循環評価機により説明されたアルゴリズムを実行するマシンを設計します。
これがSchemeがどのように解釈されるのかについての私達の理解のギャップを、評価機の
制御の仕組みに対する明確なモデルを与えることにより、埋めることでしょう。
\link{Section 5.5}ではSchemeプログラムを評価機のレジスタマシンのレジスタと命令を用いて直接実行可能な
一連の命令に変換する簡単なコンパイラについて学びます。



\section{レジスタマシンの設計}
\label{Section 5.1}

レジスタマシンを設計するためには、その\newterm{data paths}(\jnewterm{データパス})(レジスタと命令)と
これらの命令を順序付ける\newterm{controller}(\jnewterm{コントローラ})を設計する必要があります。
簡単なレジスタマシンの設計を説明するために、2つの整数の最大公約数(\acronym{GCD})を求めるために使用した
ユークリッドのアルゴリズムを検討しましょう。\link{Section 1.2.5}で学んだように、ユークリッドの
アルゴリズムは反復プロセスにて以下の手続きにて指定されるように実行されることができます。

\begin{scheme}
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
\end{scheme}

\noindent
このアルゴリズムを実行する機械は2つの数値、\( a \)と\( b \)を追跡しなければいけません。
そうすることでこれらの数値がそれらの名前と共に2つのレジスタに格納されることが推測できます。
必要とされる基本的な命令はレジスタ\code{b}の値が0であるかどうかを確認し、レジスタ\code{a}の中身を
レジスタ\code{b}の中身で割った余りを求めます。剰余の命令は複雑な処理ですが、当座は剰余を求める
プリミティブな手法が存在すると仮定します。\acronym{GCD}アルゴリズムの各サイクルにおいて、
レジスタ\code{a}の中身はレジスタ\code{b}の中身で置き換えられ、レジスタ\code{b}の中身は\code{a}の古い中身を
\code{b}の古い中身で割った場合の余りで置き換えられなければなりません。
もしこれらの置換が同時に行われれば便利でしょう。しかし私達のレジスタマシンのモデルでは
ただ1つのレジスタのみが各ステップで新しい値を割り当てられることができます。
置換を達成するためには、私達の機械は3つ目の``temporary''(一時的な)レジスタを使用します。
これを\code{t}と呼びます。(最初に剰余は\code{t}に置かれます。次に\code{b}の中身が\code{a}に置かれます。
最後に\code{t}に格納されている剰余が\code{b}に置かれます。)

この機械のレジスタと命令を\link{Figure 5.1}に示されるデータパス図を用いて説明することができます。
この図では、レジスタ(\code{a}, \code{b}, \code{t})は長方形で表現されます。値をレジスタに割り当てる方向は
\code{X}が頭の後ろにあり、データの元からレジスタを指す矢印により示されます。\code{X}は押された時に
元の値が指定されたレジスタに``flow''する(流れる)ボタンだと考えることができます。
各ボタンの横にあるラベルはそのボタンを参照するのに使われる名前です。この名前は
自由で、かつ記憶を助ける値を持つことを選択することができます。(例えば、\code{a<\-/b}は
ボタンを押すとレジスタ\code{b}の中身を\code{a}に割り当てることを意味します)。
レジスタに対するデータ元は別のレジスタであることも可能で(\code{a<\-/b}の代入のように)、また
(\code{t<\-/r}の代入のように)命令の結果や、定数(変更できない組込の値、データパス図では
定数を持つ三角形で表現される)にもなり得ます。

\begin{figure}[tb]
\phantomsection\label{Figure 5.1}
\centering
\begin{comment}
\heading{Figure 5.1:} Data paths for a \acronym{GCD} machine.

\begin{example}
                              ___
+-----+          +-----+     /   \
|  a  |<--(X)----|  b  +--->|  =  |
+--+--+   a<-b   +-+---+     \___/
   |               |  ^        ^
   +------+   +----+  |        |
          |   |      (X) b<-t  |
       .--+---+--.    |       / \
        \  rem  /     |      / O \
         \_____/      |     +-----+
            |         |
           (X) t<-r   |
            |         |
            V         |
         +-----+      |
         |  t  +------+
         +-----+
\end{example}
\end{comment}
\includegraphics[width=58mm]{fig/chap5/Fig5.1a.pdf}
\par\bigskip
\noindent
\heading{Figure 5.1:} \acronym{GCD}マシンのデータパス
\end{figure}

定数とレジスタの中身から値を求める命令はデータパス図では命令に対する名前を持つ
台形により表現されます。例えば\link{Figure 5.1}で\code{rem}と印された箱はそれに
取り付けられたレジスタ\code{a}と\code{b}の中身の剰余を求める命令を表します。
ボタンの無い矢印は入力レジスタと定数から箱へと指し、別の矢印は命令の出力値からレジスタへと
接続しています。テストはそのテストを表す名前を持つ円で表現されます。例えば、
私達の\acronym{GCD}マシンはレジスタ\code{b}の中身がゼロであるかをテストする命令を持ちます。
テストはまたその入力レジスタと定数からの矢印を持ちます。しかし出力の矢印を持ちません。
その値はデータパスでなくコントローラにより使用されます。全体としては、データパス図は
機械にとって必要とされるレジスタと命令と、それらがどのように接続されるべきかを示しています。
もし私達が矢印を配線に、\code{X}ボタンをスイッチだと見れば、データパス図は電子部品から
構築することができる機械の配線図にとても似ています。

データパスに対し実際に\acronym{GCD}を求めるためには、複数のボタンが正しい順序で
押される必要があります。私達はこの順序を\link{Figure 5.2}で図示されるコントローラ図を
用いて説明します。コントローラ図の要素はデータパスのコンポーネントがどのように
操作されるべきかであるかを示します。コントローラ図の長方形の箱は押されるべきデータパスの
ボタンを判別します。そして矢印はあるステップから次への順を示します。図の中のひし形は
選択を表現します。ひし形内で確認されたデータパスのテストの値に依存し、2つの順路矢印の1つに
従います。私達はコントローラを物質的なアナロジーを用いて解釈することができます。この図を
ビー玉が転がっている迷路だと考えるのです。ビー玉が箱に転がり込んだ時に、箱により名付けら
れたデータパスボタンを押します。ビー玉が(\code{b} = 0のテストのような)決断点に転がり込んだ
時には、示されたテストの結果により決定された道に乗りその点を去ります。
これらをもとに、データパスとコントローラは完全に\acronym{GCD}を求めるための機械を説明します。
私達はコントローラ(転がるビー玉)を\code{start}と印された地点から、レジスタ\code{a}と\code{b}に
数値を置いてから開始します。コントローラが\code{done}に辿り着いた時、\acronym{GCD}の値は
レジスタ\code{a}の中に見つかります。

\begin{figure}[tb]
\phantomsection\label{Figure 5.2}
\centering
\begin{comment}
\heading{Figure 5.2:} Controller for a \acronym{GCD} machine.

\begin{example}
     start
       |
       V
      / \ yes
+--->< = >-----> done
|     \ /
|      | no
|      V
|  +------+
|  | t<-r |
|  +---+--+
|      |
|      V
|  +------+
|  | a<-b |
|  +---+--+
|      |
|      V
|  +------+
+--+ b<-t |
   +------+
\end{example}
\end{comment}
\includegraphics[width=41mm]{fig/chap5/Fig5.2.pdf}
\par\bigskip
\noindent
\heading{Figure 5.2:} \acronym{GCD}マシンのコントローラ
\end{figure}


\begin{quote}
\heading{\phantomsection\label{Exercise 5.1}Exercise 5.1:}
以下の手続きで指定される反復アルゴリズムを用いて階乗を求めるレジスタマシンを設計せよ。
このマシンに対するデータパスとコントローラの図を描け。

\begin{scheme}
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
\end{scheme}
\end{quote}



\subsection{レジスタマシンを記述するための言語}
\label{Section 5.1.1}


データパスとコントローラの図は\acronym{GCD}の様な簡単な機械を表現するには適切です。
しかしそれらはLispインタプリタのような大きな機械を記述するには扱いにくい物です。
複雑な機械を扱うことを可能にするために、私達はテキスト形式でデータパスとコントローラの図
により与えられる全ての情報を表現する言語を作成することにします。まずは直接図を写し取る
表記法から始めます。

機械のデータパスをレジスタと命令を記述することにより定義します。レジスタを記述するために、
それに名前を与え、それに対する代入をコントロールするボタンを指定します。
これらのボタン全てに名前を与え、ボタンのコントロールの下にレジスタに入れられる
データの代入元を指定します。(代入元はレジスタ、定数、または命令です)。命令を
記述するために、それに名前を与え、その入力(レジスタ、または定数)を指定します。

機械のコントローラを\newterm{instructions}(\jnewterm{命令})の列として、その列の
\newterm{entry points}(\jnewterm{エントリポイント}、入口)を特定する\newterm{labels}(\jnewterm{ラベル})と共に
定義します。

\begin{itemize}

\item
レジスタに値を割り当てるために押すデータパスボタンの名前。(これはコントローラ図の
箱に対応する)

\item
\code{test}(テスト)命令、特定のテストを実行する。

\item
直前のテストの結果に基づくコントローララベルにより示された地点への条件分岐(\code{branch}命令)。
(テストと分岐は共にコントローラ図のひし形に対応する)。もしテストが偽であれば、
コントローラは命令列の次の命令へと続ける。そうでなければ、コントローラはラベルの
次の命令から続ける。

\item
無条件分岐(\code{goto}命令)は実行を続ける地点にコントローララベルを名付ける

\end{itemize}

\noindent
機械はコントローラの命令列の初めから開始し、列の終わりに辿り付いた時に実行を停止する。
ただし分岐が制御の流れを変更した場合、命令はそれが並べられた順に向かい実行される。

\begin{quote}
\heading{\phantomsection\label{Figure 5.3}Figure 5.3:} \( \downarrow \) A specification of the \acronym{GCD}
machine.

\begin{scheme}
(data-paths
 (registers
  ((name a)
   (buttons ((name a<-b) (source (register b)))))
  ((name b)
   (buttons ((name b<-t) (source (register t)))))
  ((name t)
   (buttons ((name t<-r) (source (operation rem))))))
 (operations
  ((name rem) (inputs (register a) (register b)))
  ((name =) (inputs (register b) (constant 0)))))
(controller
 test-b                           ~\textrm{; label}~
   (test =)                       ~\textrm{; test}~
   (branch (label gcd-done))      ~\textrm{; conditional branch}~
   (t<-r)                         ~\textrm{; button push}~
   (a<-b)                         ~\textrm{; button push}~
   (b<-t)                         ~\textrm{; button push}~
   (goto (label test-b))          ~\textrm{; unconditional branch}~
 gcd-done)                        ~\textrm{; label}~
\end{scheme}

\end{quote}

\noindent
\link{Figure 5.3}はこの方法で記述された\acronym{GCD}マシンを示します。この例はこれらの
記述の一般性を暗示しているに過ぎません。\acronym{GCD}マシンはとても単純な場合であるからです。
各レジスタはたった1つのボタンしか持たず、各ボタンとテストはコントローラにより
ただ1度しか利用されていません。

残念なことに、このような記述を読むことは難しいことです。コントローラの命令を理解する
ためには、常にボタンの名前と命令の名前の定義に戻らねばならず、またボタンが何をするのか
理解するためには命令の名前の定義を参照する必要があるでしょう。従って私達はこの表記法を
変形し、データパスとコントローラの記述からの情報を組み合わせることで全てを一緒に
見られるようにします。

記述のこの形式を得るために、自由裁量なボタンと命令の名前をそれらの振舞の定義により
置き換えます。つまり、(コントローラの中で)``ボタン\code{t<\-/r}を押せ''と言い、別に
(データパスの中で)``ボタン\code{t<\-/r}は\code{rem}命令の値をレジスタ\code{t}に代入''と
``\code{rem}命令の入力はレジスタ\code{a}と\code{b}の中身''と言う代わりに、これからは
(コントローラの中で)``レジスタ\code{a}と\code{b}の中身上での\code{rem}命令の値をレジスタ\code{t}に
代入するボタンを押せ''と言うことにします。同様に、(コントローラの中で)``\code{=}テストを
実行せよ''と言い、別に(データパスの中で)``\code{=}テストはレジスタ\code{b}の中身と定数0の上で
動作する''と言う代わりに、これからは``\code{=}テストをレジスタ\code{b}の中と定数0の上で実行せよ''と
言います。データパスの記述は省略し、コントローラの命令列のみを残します。従って、
\acronym{GCD}マシンは以下のように記述されます。

\begin{scheme}
(controller
 test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
 gcd-done)
\end{scheme}

\noindent
この記述の形式は\link{Figure 5.3}で説明されたものよりも読み易いでしょう。
しかし同時に欠点も持ちます。

\begin{itemize}

\item
大きな機械に対してはより冗長である。データパス要素の複雑な記述がその要素が
コントローラ命令列内で触れられる度に繰り返されるため。(これは\acronym{GCD}の例では
問題にならない。命令とボタンのそれぞれがただ1度しか使用されないため)。さらに、
データパス記述の繰り返しが実際の機械のデータパス構造を分かりにくくする。
大きな機械にとっていくつのレジスタ、命令、ボタンが存在し、それらがどのように相互接続されて
いるのかは自明では無い。

\item
機械の定義内のコントローラの命令はLisp式の様に見えるため、それらが自由裁量なLisp式
ではないことを簡単に忘れてしまう。それらは正式な機械の命令のみを記述できる。
例えば、命令は直接には定数とレジスタの中身のみに対して操作ができる。他の命令の
結果に対してはできない。

\end{itemize}

\noindent
これらの欠点にも係らず、私達はこのレジスタマシンの言語をこの章を通して使用します。
データパスの要素と接続を理解することよりもコントローラを理解することにより関係
していくためです。しかし、私達はデータパスの設計は実際の機械の設計において、とても
重要であることを肝に命じておかねばなりません。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.2}Exercise 5.2:}
レジスタマシン言語を用いて\link{Exercise 5.1}の反復階乗機械を記述せよ。

\end{quote}

\subsubsection*{アクション}


\acronym{GCD}マシンを変更して、\acronym{GCD}が欲しい数値を入力し、端末に答が表示される
ようにしてみましょう。私達は読み込みや表示ができる機械をどのように作るかについては
議論しません。しかし(私達がSchemeにて\code{read}と\code{display}を使う時に行うように)
それらがプリミティブな命令として既に存在すると仮定します。\footnote{この仮定は
多量の複雑さを言い繕っています。通常、Lispシステムの実装の大きな部分が読み込みと
表示を可能にすることに関してささげられています。}

\begin{figure}[tb]
\phantomsection\label{Figure 5.4}
\centering
\begin{comment}
\heading{Figure 5.4:} A \acronym{GCD} machine that reads inputs and prints results.

\begin{example}
                   .--------.
                    \ read /
                     \____/
                       |
               +-------*------+
               |              |
        a<-rd (X)            (X) b<-rd
               |              |
               V              V           ___
            +-----+        +-----+       /   \
            |  a  |<--(X)--+  b  +----->|  =  |
            +-+-+-+  a<-b  +-+---+       \___/
              | |            |  ^          ^
           +--+ +----+    +--+  |          |
           |         |    |    (X) b<-t   / \
           V         V    V     |        / O \
      .---------.  .---------.  |       /_____\
--(X)->\ print /    \  rem  /   |
   P    \_____/      \_____/    |
                        |       |
                       (X) t<-r |
                        |       |
                        V       |
                     +-----+    |
                     |  t  +----+
                     +-----+
\end{example}

\begin{scheme}
 (controller
  gcd-loop
    (assign a (op read))
    (assign b (op read))
  test-b
    (test (op =) (reg b) (const 0))
    (branch (label gcd-done))
    (assign t (op rem) (reg a) (reg b))
    (assign a (reg b))
    (assign b (reg t))
    (goto (label test-b))
  gcd-done
    (perform (op print) (reg a))
    (goto (label gcd-loop)))
\end{scheme}

\end{comment}
\includegraphics[width=107mm]{fig/chap5/Fig5.4b.pdf}
\par\bigskip
\noindent
\heading{Figure 5.4:} 入力を読み込み結果を表示する\acronym{GCD}マシン
\end{figure}

\code{read}は私達が使用してきた、その中でレジスタに格納することができる値を生成する
命令のような物です。しかし\code{read}は入力をどのレジスタからも取得しません。その値は
私達が設計している機械の外側の部品で起こる何かに依存しています。私達は私達の機械の
命令にそのようは振舞を持つことを許します。従って\code{read}の使用を描き、記述することを
他の任意の値を求める命令と全く同様に行います。

一方で、\code{print}は私達が使用してきた命令とは基本的な意味において異なります。これは
レジスタに格納できる出力の値を生成しません。この種の命令は\newterm{action}(\jnewterm{アクション})として
参照することにします。データパス図ではアクションは値を求める命令と同じように、アクションの
名前を含む台形として表現します。矢印は任意の入力(レジスタ、または定数)からアクションの箱へと
指します。またボタンをアクションと関連付けることもします。ボタンを押すとアクションが起こります。
コントローラにアクションボタンを押させるために、\code{perform}(パフォーム、実行)と呼ばれる
新しい種類の命令を用います。従ってレジスタ\code{a}の中身を表示するアクションはコントローラの
命令列の中でその命令により表現されます。

\begin{scheme}
(perform (op print) (reg a))
\end{scheme}

\noindent
\link{Figure 5.4}は新しい\acronym{GCD}マシンのデータパスとコントローラを示しています。
回答を表示した後にマシンをストップさせる代わりに、再開させています。そのため数値の
ペアを読み込み、それらの\acronym{GCD}を計算し、結果を表示することを繰り返します。
この構造は\link{Chapter 4}のインタプリタにて使用したドライバループに似ています。

\subsection{機械設計における抽象化}
\label{Section 5.1.2}

私達はこれから頻繁に、実際には複雑な``プリミティブな''命令を含む機械を定義します。例えば
\link{Section 5.4}と\link{Section 5.5}ではSchemeの環境の操作をプリミティブとして扱います。
そのような抽象化はそれにより機械の部品の詳細を無視することを可能にし、設計の他の
側面に集中することを可能にするため有益です。しかし、私達が数多くの複雑さを敷物の下に
隠してしまった事実は機械設計が非現実的であることを意味しません。
私達は常に複雑な``プリミティブ''をより簡単なプリミティブな命令で置き換えることができます。

\acronym{GCD}マシンについて考えます。マシンはレジスタ\code{a}と\code{b}の中身の剰余を
求める、結果をレジスタ\code{t}に割り当てる命令を持ちます。もし\acronym{GCD}マシンを
プリミティブな剰余命令を使用すること無しに構築したい場合、より単純な命令、例えば
引き算を用いてどのように剰余を求めるのかを指定しなければなりません。実際に、この
方法で剰余を見つけるSchemeの手続きを描くことができます。

\begin{scheme}
(define (remainder n d)
  (if (< n d) n (remainder (- n d) d)))
\end{scheme}

従って\acronym{GCD}マシンのデータパス内の剰余命令を引き算命令と比較テストで置き換える
ことができます。\link{Figure 5.5}は緻密化されたマシンのデータパスとコントローラを
示します。\acronym{GCD}コントローラ定義内の以下の命令は、

\begin{scheme}
(assign t (op rem) (reg a) (reg b))
\end{scheme}

\noindent
\link{Figure 5.6}に示されるように、ループを含む一連の命令により置き換えることができます。

\begin{figure}[tp]
\phantomsection\label{Figure 5.5}
\centering
\begin{comment}
\heading{Figure 5.5:} Data paths and controller for the elaborated \acronym{GCD} machine.

\begin{example}
                                    ___
+-----+         +-----+            /   \
|  a  |<--(X)---+  b  +-------*-->|  =  |
+--+--+   a<-b  +-+---+       |    \___/
   |              |  ^        |
  (X) t<-a        |  |        |
   |              | (X) b<-t  |
   V              |  |       _V_
+-----+           |  |      /   \
|  t  +-------*---|--*-----|  <  |
+-----+       |   |         \___/
   ^          V   V
   |        ---------
  (X) t<-d   \  -  /
   |          --+--
   |            |
   +------------+


   start
     |
     V
    / \ yes            +-------+
+->< = >----> done     | t<-d  |<--+
|   \ /                +---+---+   |
|    | no                  |       |
|    |                     V       |
|    |   +------+         / \ no   |
|    +-->| t<-a +------->< < >-----+
|        +------+         \ /
|                          | yes
|      +-------------------+
|      V
|  +-------+
|  | a<-b  |
|  +---+---+
|      |
|      V
|  +-------+
+--+ b<-t  |
   +-------+
\end{example}
\end{comment}
\includegraphics[width=67mm]{fig/chap5/Fig5.5a.pdf}
\begin{quote}
\heading{Figure 5.5:} 精緻な\acronym{GCD}マシンのデータパスとコントローラ
\end{quote}
\end{figure}


\noindent
\heading{\phantomsection\label{Figure 5.6}\mbox{Figure 5.6:}} \( \downarrow \) \link{Figure 5.5}の\acronym{GCD}マシンのコントローラの命令列

\begin{quote}
\begin{scheme}
(controller test-b
              (test (op =) (reg b) (const 0))
              (branch (label gcd-done))
              (assign t (reg a))
            rem-loop
              (test (op <) (reg t) (reg b))
              (branch (label rem-done))
              (assign t (op -) (reg t) (reg b))
              (goto (label rem-loop))
            rem-done
              (assign a (reg b))
              (assign b (reg t))
              (goto (label test-b))
            gcd-done)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.3}Exercise 5.3:}
平方根を求める機械を\link{Section 1.1.7}で説明されたようにニュートン法を用いて設計せよ。

\begin{scheme}
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
\end{scheme}


\code{good\-/enough?}と\code{improve}命令はプリミティブとして存在するとして始めよ。
次にこれらを算術演算子を用いてどのように展開するか示せ。\code{sqrt}マシン設計の各版を
データパス図を描き、レジスタマシンのコントローラ定義を記述することで説明せよ。
\end{quote}

\subsection{サブルーチン}
\label{Section 5.1.3}

演算を実行する機械を設計する時、私達は良くコンポーネントを複製するのではなく、
演算の異なる部品により共有されるコンポーネントを準備することを好みます。
2つの\acronym{GCD}演算を含む機械についえ考えてみましょう。1つはレジスタ\code{a}と\code{b}の
中身の\acronym{GCD}を求め、もう1つはレジスタ\code{c}と\code{d}の\acronym{GCD}を求めます。
私達はまずプリミティブな\code{gcd}命令を持つと仮定することから始め、次に2つの\code{gcd}の
インスタンスをよりプリミティブな命令を用いて展開するでしょう。\link{Figure 5.7}は
結果としての機械のデータパスの\acronym{GCD}の部分を、それらが機械の残りの部分にどのように
接続されていかを除いて示しています。この図はまた機械のコントローラシーケンス(命令列)の
対応する部分も示しています。

\begin{figure}[tb]
\phantomsection\label{Figure 5.7}
\centering
\begin{comment}
\heading{Figure 5.7:} Portions of the data paths and controller sequence for a machine with two \acronym{GCD} computations.

\begin{example}
                            ___                                 ___  
+-----+        +-----+     /   \    +-----+        +-----+     /   \ 
|  a  |<-(X)---+  b  |--->|  =  |   |  c  |<-(X)---+  d  |--->|  =  |
+--+--+  a<-b  ++----+     \___/    +--+--+  c<-d  ++----+     \___/ 
   |            |  ^         ^         |            |  ^         ^   
   `----.   .---'  |         |         `----.   .---'  |         |   
        V   V     (X) b<-t   |              V   V     (X) d<-t   |   
       -------     |        / \            -------     |        / \  
       \ rem /     |       /_0_\           \ rem /     |       /_0_\ 
        --+--      |                        --+--      |             
          |        |                          |        |             
         (X) t<-r  |                         (X) s<-r  |             
          |        |                          |        |             
          V        |                          V        |             
       +-----+     |                       +-----+     |             
       |  t  +-----'                       |  s  +-----'             
       +-----+                             +-----+                   
\end{example}

\begin{scheme}
gcd-1
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-1))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-1))
after-gcd-1
   ~\( \dots \)~
gcd-2
 (test (op =) (reg d) (const 0))
 (branch (label after-gcd-2))
 (assign s (op rem) (reg c) (reg d))
 (assign c (reg d))
 (assign d (reg s))
 (goto (label gcd-2))
after-gcd-2
\end{scheme}

\end{comment}
\includegraphics[width=105mm]{fig/chap5/Fig5.7b.pdf}
\begin{quote}
\heading{Figure 5.7:} 2つの\acronym{GCD}演算を持つ機械のデータパスとコントローラシーケンスの一部
\end{quote}
\end{figure}

この機械は2つの剰余命令の箱と2つの等値テストの箱を持っています。もし複製された
コンポーネントが剰余の箱のように複雑なら、これは機械を構築するのに経済的な方法では
ありません。私達はより大きな機械の演算に影響を与えないように与えられた場合に、
同じコンポーネントを両方の\acronym{GCD}演算に用いることでデータパスコンポーネントの
複製を防ぎます。もしレジスタ\code{a}と\code{b}の値がコントローラが\code{gcd\-/2}に取り掛かって
いる時に必要無いのであれば(またはもしこれらの値が安全のために他のレジスタに移動して
おくことができるのならば)、機械を変更し、レジスタ\code{c}と\code{d}でなく、レジスタ\code{a}と
\code{b}を2つ目の\acronym{GCD}を1つ目と同じに求めるおおができます。もしこれを行うなら、
\link{Figure 5.8}に示されるコントローラシーケンスを得ます。
\newpage

\begin{quote}
\heading{\phantomsection\label{Figure 5.8}Figure 5.8:} \( \downarrow \) 2つの異なる\acronym{GCD}演算に対して同じデータパスコンポーネントを使用する機械のコントローラシーケンスの一部
\begin{scheme}
gcd-1
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-1))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-1))
after-gcd-1
  ~\( \dots \)~
gcd-2
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-2))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-2))
after-gcd-2
\end{scheme}
\end{quote}

\noindent
私達はデータパスコンポーネントの複製を削除しました。(そうすることでデータパスは
\link{Figure 5.1}の状態に戻りました)。しかしコントローラは今ではそれらのエントリポイントの
ラベルのみが異なる2つの\acronym{GCD}シーケンスを持ちます。これら2つのシーケンスを
1つのシーケンス---\code{gcd} \newterm{subroutine}(\jnewterm{サブルーチン})---への分岐により置き換えた
ほうが良くなるでしょう。サブルーチンの終わりにメインの命令列の正しい場所へと戻ります。
これを次のように達成することができます。\code{gcd}に分岐する前に、(0か1のような)識別するための値を
特別なレジスタ、\code{continue}に置きます。\link{Figure 5.9}は結果としてのコントローラシーケンスの
関連する部分を示しています。これはただ1つの\code{gcd}命令列のコピーを含みます。

\begin{quote}
\heading{\phantomsection\label{Figure 5.9}Figure 5.9:} \( \downarrow \) \link{Figure 5.8}でコントローラシーケンスの重複を防ぐため\code{continue}レジスタを用いる
\begin{scheme}
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (test (op =) (reg continue) (const 0))
 (branch (label after-gcd-1))
 (goto (label after-gcd-2))
  ~\( \dots \)~
 ~\textrm{;; \code{gcd}を必要とする場所からその場所へと分岐する前に}~
 ~\textrm{;; レジスタ\code{continue}に0を置く}~
 (assign continue (const 0))
 (goto (label gcd))
after-gcd-1
  ~\( \dots \)~

 ~\textrm{;; \code{gcd}の二度目の使用の前にはレジスタ\code{continue}に1を置く}~
 (assign continue (const 1))
 (goto (label gcd))
after-gcd-2
\end{scheme}
\end{quote}

\noindent
これは小さな問題に対応するのに妥当な取り組み方です。しかしもし数多くの\acronym{GCD}演算が
コントローラシーケンスの中にある場合には困ったことになりそうです。
\acronym{gcd}サブルーチンの後に実行をどこで続けるかを決定するために、データパス内のテストと
コントローラ内に分岐命令が\acronym{gcd}を置く全ての場所に対して必要となるでしょう。
サブルーチンを実装するためのより強力な手法は、\code{continue}レジスタにサブルーチンが終了した時に
実行が続行しなければならない場所のコントローラシーケンス内のエントリポイントのラベルを持たせることです。
この戦略の実装にはレジスタマシンのデータパスとコントローラの間に新しい種類のコネクションが必要です。
ラベルの値をレジスタから取得し指定されたエントリポイントから実行を再開するのに使用できるような方法のため、
レジスタにコントローラシーケンス内のラベルを代入するための方法が必要です。

この能力を反映するために、レジスタマシン言語の\code{assign}命令を拡張し、レジスタに値として
ラベルをコントローラシーケンスから(特別な種類の中身として)代入することを許可する拡張を行います。
また\code{goto}命令にも静的ラベルにより記述されたエントリポイントのみでなく、レジスタの中により
表されたエントリポイントから実行を続行することを許可する拡張を行います。
これらの新しい構造物を用いることで、\code{continue}レジスタ内に格納された
場所に分岐することにより、\code{gcd}サブルーチンを停止することができます。
これは\link{Figure 5.10}に示されたコントローラシーケンスへと導きます。

\begin{quote}
\heading{\phantomsection\label{Figure 5.10}Figure 5.10:} \( \downarrow \) Assigning labels to the
\code{continue} register simplifies and generalizes the strategy shown in
\link{Figure 5.9}.
\begin{scheme}
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
   ~\( \dots \)~
 ~\textrm{;; \code{gcd}を呼ぶ前に、\code{continue}に\code{gcd}が戻るべきラベルを代入します}~
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
   ~\( \dots \)~
 ~\textrm{;; 異なる継続を持つ2つ目の\code{gcd}呼出}~
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
\end{scheme}
\end{quote}

\noindent
複数のサブルーチンを持つマシンは複数の継続レジスタ(例えば\code{gcd\-/continue}, \code{factorial\-/continue})を
用いるか、または全てのサブルーチンが単一の\code{continue}レジスタを共有することができるでしょう。
共有はより経済的ですが、別のサブルーチン(\code{sub2})を呼び出すサブルーチン(\code{sub1})を持っていないか
注意しなければなりません。\code{sub1}が\code{continue}の中身を何か他のレジスタに、\code{continue}を
\code{sub2}の呼出のために設定する前に保存しなければ、 \code{sub1}は完了した時点で
どこに行けば良いのか知ることができません。次の節で開発される再帰を扱う仕組みは
この入れ子のサブルーチン呼出の問題にもより良い解法を提供します。

\subsection{再帰実装にスタックを使用する}
\label{Section 5.1.4}

ここまでに説明されたアイデアを用いて、そのプロセスの各状態変数に
対応するレジスタを持つレジスタマシンを指定することにより、任意の反復プロセスを
実装することができます。この機械はレジスタの中身を変更しながら、繰り返しコントローラの
ループを、ある停止条件が満たされるまで実行します。コントローラシーケンスの各地点に
おいて、(反復プロセスの状態を表現する)機械の状態はレジスタの状態(状態変数の値)により
完全に決定されます。

しかし、再帰プロセスを実装する場合には追加の仕組みを必要とします。
以下の階乗を求めるための再帰手法について考えましょう。これは\link{Section 1.2.1}で
最初に調査しました。

\begin{scheme}
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
\end{scheme}

\noindent
この手続きから見てとれるように、\( n! \)の演算は\( (n - 1)! \)の演算を必要とします。
私達の\acronym{GCD}は以下の手続きからモデル化されていますが、

\begin{scheme}
(define (gcd a b)
  (if (= b 0) a (gcd b (remainder a b))))
\end{scheme}

\noindent
同様に別の\acronym{GCD}を求める必要があります。しかし、元の演算から新しい{GCD}演算へと
簡約する{GCD}手続きと、部分問題として別の階乗を求める必要がある\code{factorial}の間には
重要な違いがあります。\acronym{GCD}においては新しい\acronym{GCD}演算に対する答は
元の問題の答です。次の\acronym{GCD}を求めるためには、単純に新しい引数を\acronym{GCD}マシンの
入力レジスタに置き、機械のデータパスを同じコントローラシーケンスを実行することにより
再利用します。機械が最後の\acronym{GCD}問題を解くことを完了した時には、演算全体を
完了したことになります。

階乗の場合(または任意の再帰プロセス)においては新しい階乗の部分問題の回答は元の問題の
回答ではありません。\( (n - 1)! \)に対して得られた値は最終回答を得るために\( n \)で
乗算しなければなりません。もし\acronym{GCD}の設計を真似し、階乗の部分問題をレジスタ\code{n}を
デクリメント(1引く)し、階乗マシンに戻るこのより解決したいとしても、その結果に乗算を
行う有効な古い\code{n}の値は既に存在しません。従って部分問題上で働くための2つ目の
階乗マシンが必要です。この2つ目の階乗の演算はそれ自身が階乗の部分問題を持ち、それは
3つ目の階乗マシンを必要とし、以下繰り返されます。各階乗マシンがその中に別の階乗マシンを
持つため、総計の機械は同様な機械の無限の入れ子を含み、従って固定長の有限数な部品から
構築することはできません。

\begin{figure}[tp]
\phantomsection\label{Figure 5.11}
\centering
\begin{comment}
\heading{Figure 5.11:} A recursive factorial machine.

\begin{example}
                             ___
                            /   \
    +----------*-----------|  =  |
    |          |            \___/
   (X)         |              ^
    |          |              |
    V          |          +---+---+   sn    +-------+
+-------+      |          |       +---(X)-->|       |
|  val  |<-(X)-|----------+   n   |         | stack |
+-----+-+      |          |       |<--(X)---+       |
  ^   |        |          +-------+   rn    +-+-----+
  |   |        |            ^                 |   ^
 (X)  |        |            |                 |   |
  |   |   +----|--------*  (X)                |  (X) sc
  |   |   |    |        |   |             rc (X)  |
  |   |   |    *----.   |   |                 |   |
  |   V   V    |    V   V   |                 V   |
  |  -------   |   -------  |              +------+-+
  |  \  *  /   |   \  -  /  |              |continue+--> controller
  |   --+--    |    --+--   |              +--------+
  |     |      |      |     |               ^      ^
  +-----+      |      +-----+               |      |
               |                           (X)    (X)
               |                            |      |
              / \                   after- / \    / \  fact-
             /_1_\                  fact  /___\  /___\ done
\end{example}

\begin{smallscheme}
(controller
   (assign continue (label fact-done))     ~\textrm{; set up final return address}~
 fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   ~\textrm{;; Set up for the recursive call by saving \code{n} and \code{continue}.}~
   ~\textrm{;; Set up \code{continue} so that the computation will continue}~
   ~\textrm{;; at \code{after\-/fact} when the subroutine returns.}~
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
 after-fact
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val))   ~\textrm{; \code{val} now contains}~ ~\( n(n-1)! \)~
   (goto (reg continue))                   ~\textrm{; return to caller}~
 base-case
   (assign val (const 1))                  ~\textrm{; base case: }~1! = 1
   (goto (reg continue))                   ~\textrm{; return to caller}~
 fact-done)
\end{smallscheme}

\end{comment}
\includegraphics[width=106mm]{fig/chap5/Fig5.11a.pdf}
\par\bigskip
\noindent
\heading{Figure 5.11:} 再帰階乗マシン
\end{figure}

それにもかかわらず、もし機械の各入れ子のインスタンスが同じコンポーネントを使用するように
準備ができれば階乗プロセスをレジスタマシンとして実装できます。具体的に言えば、
\( n! \)を求める機械は\( (n - 1)! \)を求める部分問題、\( (n - 2)! \)の部分問題、以下
繰り返しの仕事に同じコンポーネントを使用せねばなりません。これはもっともらしく見えます。
例え階乗プロセスが同じ機械のコピーの未束縛の数値が演算を実行するのに必要だと指図したとしても、
これらのコピーのただ1つが一度に有効になる必要があるためです。この機械が再帰の部分問題に
遭遇した時に、メインの問題上の仕事を中断し、同じ物理部品を部分問題上の仕事に再利用し、
そして中断した演算を続けることが可能です。

部分問題の中では、レジスタの中身はメインの問題の中の物と異なります。(この場合には
レジスタ\code{n}はデクリメントされます)。中断された演算を続けることを可能にするために、
機械は部分問題が解決した後に必要となる全てのレジスタの中身を保存しなければなりません。
そうすることで、中断した演算を続ける時にこれらの値が再格納されることができます。
階乗の場合には、デクリメントされたレジスタ\code{n}の階乗の演算が完了した時に再格納されるように
\code{n}の古い値を保存します。\footnote{古い\code{n}を保存する必要は無いと主張する人が
いるかもしれません。デクリメントし、部分問題を解決した後に、単純に古い値を回復するために
インクリメントすることができると思われるでしょう。例えこの戦略が階乗に対しては
働いたとしても、それは一般的にはうまく行きません。レジスタの古い値が常に
新しい値から求められるとは限らないためです。}

予測可能な限界が入れ子の再帰呼出の深さには存在しないため、任意の数のレジスタ値を
保存する必要があるでしょう。これらの値は保存された順の逆順に再格納されねばなりません。
入れ子の再帰では突入する最後の部分問題が最初に完了するためです。このことが
\newterm{stack}(\jnewterm{スタック})、つまり``last in, first out''(LIFO, 後入れ先出し)データ構造を
レジスタ値の保存への使用することを指示しています。レジスタマシン言語を拡張し、
2つの種類の命令を追加することでスタックを含めることができます。値はスタックに
\code{save}命令を用いて置かれて、\code{restore}命令を用いてスタックから再格納されます。
スタック上に一連の値が\code{save}された後に、連続した\code{restore}がこれらの値を逆順に
取り出します。\footnote{\link{Section 5.3}において,よりプリミティブな命令を用いてどのように
スタックを実装するかについて学びます。}

スタックの助けを借りることで階乗マシンの各階乗部分問題のために、データパスの
単一のコピーを再利用することができます。同様なデータパスを操作するコントローラシーケンスの
再利用についても同様の設計上の問題が存在します。階乗演算を再実行するためには,
コントローラは単純には最初に反復プロセスのようにループバックすることはできません。
\( (n - 1)! \)を解いた後には機械は依然としてその結果と\( n \)を掛ける必要があるためです。
コントローラは\( n! \)の演算を中断し、部分問題\( (n - 1)! \)を解き、そして\( n! \)の演算を
続けなければなりません。階乗演算のこの見方は\link{Section 5.1.3}で説明されたサブルーチンの仕組みの
使用を推奨しており、これはコントローラにレジスタ\code{continue}を使用させて部分問題を解く
列の一部へと移動し、そしてメイン問題を中止した場所から続行します。このようにして
\code{continue}レジスタに格納されたエントリポイントに帰る階乗のサブルーチンを作ることができます。
各サブルーチン呼出の周りでは、\code{continue}を\code{n}レジスタに行うのと同じように保存し
再格納します。階乗演算の各``レベル''が同じ\code{continue}レジスタを利用するためです。
つまり、階乗サブルーチンはそれが自分自身を部分問題として呼び出す時に、新しい値を\code{continue}に
設定しなければいけません。しかし部分問題を解くために呼び出した場所に戻るために
古い値が必要となるのです。

\link{Figure 5.11}は再帰\code{factorial}手続きを実装する機械のためのデータパスとコントローラを
示しています。この機械はスタックと3つのレジスタ、\code{n}, \code{val}, \code{continue}を持ちます。
データパス図を単純化するために、レジスタ代入ボタンには名前を付けず、スタック命令ボタン
(レジスタを保存する\code{sc}と\code{sn}、レジスタに戻す\code{rc}と\code{rn})のみに付けています。
機械を運用するには、レジスタ\code{n}に階乗を求めたい数を入れ、それから機械を開始します。
機械が\code{fact\-/done}に辿り着いた時に演算は完了し、答はレジスタ\code{val}に見つかります。
コントローラシーケンスでは\code{n}と\code{continue}が各再帰呼出の前に保存され、その呼出から
戻る時に再格納されます。呼出からの復帰は\code{continue}に格納された場所に分岐することにより
達成されます。\code{continue}は機械が開始した時に最後の復帰が\code{fact\-/done}に向かうように
初期化されます。階乗演算の結果を持つ\code{val}レジスタは再帰呼出の前に保存されません。
\code{val}の古い中身はサブルーチンから復帰後には役に立たないためです。部分問題により
生成された新しい値のみが必要とされます。

例え原理上は階乗演算が無限の機械を必要とするとしても、\link{Figure 5.11}の機械は
実際には限りが無いかもしれないスタックを除けば有限です。しかし、スタックのどんな特定の
物理実装も有限のサイズを持ち、このことが機械により扱うことが可能な再帰呼出の深さを
制限します。この階乗の実装は再帰アルゴリズムをスタックで容量が増加された通常のレジスタマシン
として実現するための一般的な戦略を説明します。再帰部分問題に遭遇した時には
その現在の値が部分問題が解決された後に必要とされるレジスタをスタック上に保存します。
次に再帰部分問題を解決し、保存されたレジスタを戻してメイン問題の実行を続行します。
\code{continue}レジスタは常に保存されなければなりません。保存する必要の有るレジスタが
他に存在するかどうかは機械に依存します。全ての再帰演算が部分問題の解決の間に変更される
レジスタの元の値を必要とはしないためです。(\link{Exercise 5.4}参照)。

\subsubsection*{二重再帰}


より複雑な再帰プロセス、\link{Section 1.2.2}で紹介したフィボナッチ数の木再帰演算について調査してみましょう。

\begin{scheme}
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
\end{scheme}

\noindent
階乗と同じ様に、再帰フィボナッチ演算をレジスタマシンとしてレジスタ\code{n}, \code{val}, \code{continue}と用いて
実装することができます。この機械は階乗のものよりも、より複雑です。コントローラシーケンスの中に
二箇所の再帰呼出の実行が必要な箇所が存在するためです。一度目は\( {\rm Fib}(n - 1) \)を求めるために、
二度目は\( {\rm Fib}(n - 2) \)を求めるためです。
これらの各呼出に準備するために、後にその値が必要となるレジスタを保存し、レジスタ\code{n}に
再帰的に求める(\( n - 1 \)または\( n - 2 \))必要のあるフィボナッチ数を設定します。
そして\code{continue}に戻り先のメインシーケンスのエントリポイント(それぞれ\code{afterfib\-/n\-/1}または\code{afterfib\-/n\-/2})を
割り当てます。そうしたら\code{fib\-/loop}へと飛びます。再帰呼出から帰る時には、回答は\code{val}の
中にあります。\link{Figure 5.12}はこの機械のためのコントローラシーケンスを示しています。

\begin{quote}
\heading{\phantomsection\label{Figure 5.12}Figure 5.12:} \( \downarrow \) Controller for a machine to compute
Fibonacci numbers.

\begin{scheme}
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   ~\textrm{;; Fib\( (n-1) \)を求める準備}~
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                 ~\textrm{; \code{n}の古い値を保存}~
   (assign n (op -) (reg n) (const 1)) ~\textrm{; \code{n}を\code{n\-/1}で上書き}~
   (goto (label fib-loop))  ~\textrm{; 再帰呼出の実行}~
 afterfib-n-1     ~\textrm{; リターン時に, \code{val}がFib\( (n-1) \)を持つ}~
   (restore n)
   (restore continue)
   ~\textrm{;; Fib\( (n - 2) \)を求める準備}~
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)               ~\textrm{; Fib\( (n-1) \)を保存}~
   (goto (label fib-loop))
 afterfib-n-2     ~\textrm{; リターン時に, \code{val}がFib\( (n-2) \)を持つ}~
   (assign n (reg val))     ~\textrm{; \code{n}がここでFib\( (n-2) \)を持つ}~
   (restore val)            ~\textrm{; \code{val}がここでFib\( (n-1) \)を持つ}~
   (restore continue)

   (assign val              ~\textrm{; Fib\( (n-1) \) + Fib\( (n-2) \)}~
           (op +) (reg val) (reg n))
   (goto (reg continue))    ~\textrm{; 呼び出しから戻る, 答は\code{val}の中にある}~
 immediate-answer
   (assign val (reg n))     ~\textrm{; 基底の場合: Fib\( (n) = n \)}~
   (goto (reg continue))
 fib-done)
\end{scheme}

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.4}Exercise 5.4:}
次の手続きのそれぞれを実装するレジスタマシンを指定せよ。各マシンに対して、
コントローラ命令列を書き、データパスを示す図を描け。

\begin{enumerate}[a]

\item
再帰指数計算

\begin{scheme}
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
\end{scheme}

\item
反復指数計算

\begin{scheme}
(define (expt b n)
  (define (expt-iter counter product)
    (if (= counter 0)
        product
        (expt-iter (- counter 1)
                   (* b product))))
  (expt-iter n 1))
\end{scheme}

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.5}Exercise 5.5:}
階乗とフィボナッチの機械をいくつかの非自明な入力を用いて手動でシミュレートせよ。
(少なくとも1回の再帰呼出を必要とする)。実行中の各重要な地点におけるスタックの中身を示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.6}Exercise 5.6:}
Ben Bitdiddleはフィボナッチマシンのコントローラシーケンスが余分な\code{save}と\code{restore}を持ち、
より速いマシンを作るために取り除くことができることに気付いた。これらの命令はどこにあるか?
\end{quote}

\subsection{命令の要約}
\label{Section 5.1.5}

私達のレジスタマシン言語のコントローラ命令は以下の形式の内1つを持ち、各\( \langle \)\( input_i \)\( \rangle \)は
\code{(reg<\var{register\-/name}>)}か\code{(const <\var{constant\-/value}>)}の何れかです。
これらの命令は\link{Section 5.1.1}で導入されました。

\begin{scheme}
(assign ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~ (reg ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~))
(assign ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~ (const ~\( \dark \langle \)~~\var{\dark constant-value}~~\( \dark \rangle \)~))
(assign ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~ 
        (op ~\( \dark \langle \)~~\var{\dark operation-name}~~\( \dark \rangle \)~) 
        ~\( \dark \langle \)~~\( \dark input_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark input_n \)~~\( \dark \rangle \)~)
(perform (op ~\( \dark \langle \)~~\var{\dark operation-name}~~\( \dark \rangle \)~) ~\( \dark \langle \)~~\( \dark input_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark input_n \)~~\( \dark \rangle \)~)
(test (op ~\( \dark \langle \)~~\var{\dark operation-name}~~\( \dark \rangle \)~) ~\( \dark \langle \)~~\( \dark input_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark input_n \)~~\( \dark \rangle \)~)
(branch (label ~\( \dark \langle \)~~\var{\dark label-name}~~\( \dark \rangle \)~))
(goto (label ~\( \dark \langle \)~~\var{\dark label-name}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
レジスタを用いてラベルを保存することは\link{Section 5.1.3}で導入されました。

\begin{scheme}
(assign ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~ (label ~\( \dark \langle \)~~\var{\dark label-name}~~\( \dark \rangle \)~))
(goto (reg ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
スタックを使用する命令は\link{Section 5.1.4}で導入されました。

\begin{scheme}
(save ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~)
(restore ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
ここまでで見た\( \langle \)\var{constant-value}\( \rangle \)の種類は数値のみです。しかし
後程、文字列、シンボル、それにリストを使用します。
\begin{scheme}
(const "abc") ~\textrm{は文字列}~ "abc",
(const abc) ~\textrm{はシンボル}~ abc,
(const (a b c)) ~\textrm{はリスト}~ (a b c),
(const ()) ~\textrm{は空リスト}~
\end{scheme}

\section{レジスタマシンシミュレータ}
\label{Section 5.2}

レジスタマシンの設計を良く理解するために、私達は設計した機械を期待通りに実行されるか
確認するためにテストをする必要があります。設計のテストを行う1つの方法として
\link{Exercise 5.5}と同様にコントローラの命令を手動でシミュレートする方法があります。
しかしこれは簡単な機械を除いてとんでもなく退屈な方法です。この節ではレジスタマシン言語で
記述された機械のためのシミュレータを構築します。このシミュレータは4つのインターフェイス
手続きを持つSchemeのプログラムです。1つ目はレジスタマシンの記述をマシンのモデルを構築する
ために利用します(データ構造の部品がシミュレートされるマシンの部品に対応します)。
残りの3つがモデルを操作することにより機械のシミュレーションを可能にします。

\begin{quote}

\begin{scheme}
(make-machine ~\( \dark \langle \)~~\var{\dark register-names}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark operations}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark controller}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
与えられたレジスタ、命令、コントローラを持つ機械のモデルを構築し、返します。

\begin{scheme}
(set-register-contents! ~\( \dark \langle\kern0.08em \)~~\var{\dark machine-model}~~\( \dark \rangle \)~ 
                        ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~ 
                        ~\( \dark \langle \)~~\var{\dark value}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
与えられた機械でシミュレートされるレジスタに値を格納します。

\begin{scheme}
(get-register-contents ~\( \dark \langle\kern0.08em \)~~\var{\dark machine-model}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
与えられた機械のシミュレートされるレジスタの中身を返す。

\begin{scheme}
(start ~\( \dark \langle\kern0.08em \)~~\var{\dark machine-model}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
与えられた機械の実行をシミュレートする。コントローラシーケンスの最初から開始し、
シーケンスの最後に辿り着いた時に停止する。
\end{quote}

\noindent
これらの手続きがどのように利用されるかの例として、\link{Section 5.1.1}の\acronym{GCD}マシンの
モデルとなる\code{gcd\-/machine}を以下のように定義します。

\begin{scheme}
(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b (test (op =) (reg b) (const 0))
            (branch (label gcd-done))
            (assign t (op rem) (reg a) (reg b))
            (assign a (reg b))
            (assign b (reg t))
            (goto (label test-b))
            gcd-done)))
\end{scheme}

\noindent
\code{make\-/machine}に対する最初の引数はレジスタ名のリストです。次の引数は各命令名と
その命令を実装するScheme手続き(つまり、同じ入力値を与えられて同じ出力値を生成します)を
ペアにするテーブル(2要素リストのリスト)です。最後の引数は\link{Section 5.1}にあるように
ラベルと機械の命令(機械語)のリストとしてのコントローラを指定します。


この機械を用いて\acronym{GCD}を求めるために、入力レジスタを設定し、機械を開始し、
シミュレーションが停止した時に結果を検査します。

\begin{scheme}
(set-register-contents! gcd-machine 'a 206)
~\textit{done}~
(set-register-contents! gcd-machine 'b 40)
~\textit{done}~
(start gcd-machine)
~\textit{done}~
(get-register-contents gcd-machine 'a)
~\textit{2}~
\end{scheme}

\noindent
この演算はSchemeで書かれた\code{gcd}手続きよりもとても遅く実行します。なぜなら
\code{assign}のような低レベルの機械語をより複雑な命令によりシミュレートするためです。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.7}Exercise 5.7:}
シミュレータを用いて\link{Exercise 5.4}で自分で設計した機械をテストせよ。
\end{quote}



\subsection{マシンモデル}
\label{Section 5.2.1}

\code{make\-/machine}にて生成された機械のモデルは\link{Chapter 3}で開発された
メッセージパッシングの技術を用いた局所状態を持つ手続きとして表現されています。
このモデルを構築するために、\code{make\-/machine}は手続き\code{make\-/new\-/machine}を呼び
全てのレジスタマシンに対して共通なマシンモデルの部品を構築することから始めます。
\code{make\-/new\-/machine}により構築されるこの基本的な機械のモデルは本質的には
いくつかのレジスタとスタックと、コントローラ命令を1つずつ処理する実行の
仕組みを一緒にしたコンテナです。

\code{make\-/machine}は次にこの基本的なモデルを(それに対してメッセージを送ることで)
拡張し、レジスタ、命令、定義される特定の機械のコントローラを含めます。
最初に新しい機械の中に与えられた各レジスタ名に対するレジスタを獲得し、指定された
命令をその機械にインストール(導入)します。次に\newterm{assembler}(\jnewterm{アセンブラ})(下記の
\link{Section 5.2.2}で説明されます)を用いてコントローラリストを新しい機械に対する命令に変換し、
これらを機械の命令列としてインストールします。\code{make\-/machine}はその値として変更された
機械のモデルを返します。

\begin{scheme}
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each
     (lambda (register-name)
       ((machine 'allocate-register) register-name))
     register-names)
    ((machine 'install-operations) ops)
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
\end{scheme}

\subsubsection*{レジスタ}

レジスタは\link{Chapter 3}の様に局所状態を持つ手続きとして表現されます。手続き\code{make\-/register}は
アクセスと変更が可能な値を持つレジスタを作成します。

\begin{scheme}
(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            (else
             (error "Unknown request: REGISTER" message))))
    dispatch))
\end{scheme}

\noindent
以下の手続きはレジスタにアクセスするために使用されます。

\begin{scheme}
(define (get-contents register) (register 'get))
(define (set-contents! register value)
  ((register 'set) value))
\end{scheme}

\subsubsection*{スタック}


スタックもまた局所状態を持つ手続きとして表現されます。手続き\code{make\-/stack}は
局所状態がスタック上のアイテム(項目)のリストから成るスタックを作成します。
スタックはスタック上にアイテムを\code{push}とスタックから最上位の
アイテムを取り去りそれを返す\code{pop}、スタックを空に初期化する\code{initialize}の
リクエストを受け付けます。

\begin{scheme}
(define (make-stack)
  (let ((s '()))
    (define (push x) (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error "Unknown request: STACK"
                         message))))
    dispatch))
\end{scheme}

\noindent
以下の手続きはスタックへのアクセスに使用されます。

\begin{scheme}
(define (pop stack) (stack 'pop))
(define (push stack value) ((stack 'push) value))
\end{scheme}

\subsubsection*{基本的な機械}

\link{Figure 5.13}に示す\code{make\-/new\-/machine}手続きは局所状態がスタック、初期値が空の
命令列、初期値がスタックを初期化する命令を持つ命令のリスト、初期値として2つのレジスタ
\code{flag}(フラグ)と\code{pc}(``program counter''、プログラムカウンタ)を持つ
\newterm{register table}(\jnewterm{レジスタテーブル})から成り立ちます。内部手続き\code{lookup\-/register}は
テーブル内のレジスタを探します。

\code{flag}レジスタはシミュレートされる機械にて分岐をコントロールするために使用されます。
\code{test}命令は\code{flag}の中身にテストの結果(真、または、偽)を設定します。\code{branch}命令は
分岐するかしないかを\code{flag}の中身を調査して決定します。

\code{pc}レジスタは機械が実行する命令の順序付けを決定します。この順序付けは内部手続き\code{execute}により
実装されています。シミュレーションモデルでは各機械命令は
\newterm{instruction execution procedure}(\jnewterm{命令実行手続き})と呼ばれる引数無しの
手続きを含むデータ構造であり、この手続きを呼ぶことにより命令の実行をシミュレートします。
シミュレーションが実行されるにつれ、\code{pc}は次に実行される命令から始まる命令列の地点を
指します。\code{execute}はその命令を得て、それを命令実行手続きを呼ぶことにより実行し、
このサイクルを実行する命令が無くなるまで(すなわち、\code{pc}が命令列の最後を
指すまで)繰り返します。

\newpage
\noindent
\heading{\phantomsection\label{Figure 5.13}Figure 5.13:}
\( \downarrow \) 基本の機械モデルを実装する\code{make\-/new\-/machine}手続き

\begin{scheme}
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq)
                 (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) 
               allocate-register)
              ((eq? message 'get-register)
               lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops)
                 (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error "Unknown request: MACHINE"
                           message))))
      dispatch)))
\end{scheme}

\noindent
工程の一部として、各命令の実行手続きは\code{pc}を変更し次に実行される命令を指すようにします。
\code{branch}と\code{goto}命令は\code{pc}を変更し新しい行き先を指すようにします。
全ての他の命令は単純に\code{pc}を進めて列の次の命令を指すようにします。
各\code{execute}の呼出が\code{execute}を再び呼び出すことに中止して下さい。
これはしかし無限ループにはなりません。命令実行手続きの実行は\code{pc}の中身を
変更するためです。

\code{make\-/new\-/machine}は\code{dispatch}手続きを返します。これは内部の状態にアクセスする
メッセージパッシングを実装します。機械の開始は\code{pc}に命令列の最初を設定し、
\code{execute}を呼ぶことにより達成されることに注意して下さい。

利便性のために、機械の\code{start}命令の代替となる手続きのインターフェイスを提供します。
同様に、レジスタの中身の設定、試験の手続きも\link{Section 5.2}の最初にて指示されたように
提供します。

\begin{scheme}
(define (start machine) (machine 'start))
(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name)
                 value)
  'done)
\end{scheme}

\noindent
これらの手続き(と\link{Section 5.2.2}と\link{Section 5.2.3}の多くの手続き)は以下を用いて与えられた機械と
レジスタ名のレジスタを探します。

\begin{scheme}
(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
\end{scheme}

\subsection{アセンブラ}
\label{Section 5.2.2}

アセンブラはコントローラの機械のための式の列を対応する機械の命令のリストへと変形します。
各命令はその実行手続きを持ちます。概して、アセンブラは\link{Chapter 4}で学習した評価機に
とても似ています。入力言語が存在し(この場合にはレジスタマシン言語)、言語の式の各型に
対して適切なアクションを実行しなければなりません。

各命令のための実行手続きを生成する技術は\link{Section 4.1.7}で実行時に実行から分析を分離する
ことで高速化するために用いたのものと同じです。\link{Chapter 4}で学んだように、
Schemeの式の多くの実用的な分析は変数の実際の値を知らなくとも実行することができました。
ここでも同様に、レジスタマシン言語の式の多くの実用的な分析が実際の機械のレジスタの
値を知ることなしに実行することができます。例えばレジスタへの参照をレジスタオブジェクトへの
ポインタにより置き換えたり、ラベルをラベルが指定する命令列内の地点へのポインタで
置き換えることができます。

アセンブラが命令実行手続きを生成する前に、全てのテーブルが何を参照するのか知っておく
必要がります。そのためコントローラテキストを走査し命令からラベルを分離することから
始めます。アセンブラがテキストを走査するにつれ、命令のリストと各ラベルをそのリスト内部を指すポインタと
関連付けるテーブルの両方を構築します。そうしたらアセンブラは命令リストを各命令に
対する実行手続きを挿入することで増補します。

\code{assemble}手続きはアセンブラに対する主な入口です。コントローラテキストとマシンモデルを引数として
取り、モデルに格納するべき命令列を返します。\code{assemble}は\code{extract\-/labels}を呼び初期命令リストと
与えられたコントローラテキストからラベルテーブルを構築します。\code{extract\-/labels}の2つ目の引数は
これらの結果を処理するために呼ばれるべきものです。この手続きは\code{update\-/insts!}を用いて命令実行
手続きを再生し、それらを命令リストの中に挿入し、変更されたリストを返します。

\begin{scheme}
(define (assemble controller-text machine)
  (extract-labels
   controller-text
   (lambda (insts labels)
     (update-insts! insts labels machine)
     insts)))
\end{scheme}

\noindent
\code{extract\-/labels}は引数としてリスト\code{text}(コントローラ命令式の列)と
\code{receive}手続きを取ります。\code{receive}は2つの値と共に呼び出されます。
(1) 命令データ構造のリスト\code{insts}はそれぞれが\code{text}からの命令を含みます。
(2) テーブル\code{labels}は\code{text}からの各ラベルとそのラベルが指定するリスト\code{insts}内の
位置とを関連付けします。

\begin{scheme}
(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels
       (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts
                        (cons (make-label-entry next-inst
                                                insts)
                              labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
\end{scheme}

\noindent
\code{extract\-/labels}は連続して\code{text}の要素を走査し、\code{insts}と\code{labels}を集積する
ことで働きます。もし要素がシンボル(従ってラベル)なら適切なエントリが\code{labels}テーブルに
追加されます。そうでなければその要素は\code{insts}リスト上に集積されます。\footnote{
\code{receive}手続きをここで使用するのは\code{extract\-/labels}を得て、効率的に2つの値、\code{labels}と
\code{insts}をそれを保持する複合データ構造を明示的に作ること無しに返すための方法です。
代替となる、明示的に値のペアを返す実装は以下の通りです。

\begin{smallscheme}
(define (extract-labels text)
  (if (null? text)
      (cons '() '())
      (let ((result (extract-labels (cdr text))))
        (let ((insts (car result)) (labels (cdr result)))
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (cons insts
                      (cons (make-label-entry next-inst insts) 
                            labels))
                (cons (cons (make-instruction next-inst) insts)
                      labels)))))))
\end{smallscheme}

\noindent
これは\code{assemble}により以下のように呼び出されます。

\begin{smallscheme}
(define (assemble controller-text machine)
  (let ((result (extract-labels controller-text)))
    (let ((insts (car result)) (labels (cdr result)))
      (update-insts! insts labels machine)
      insts)))
\end{smallscheme}

\noindent
\code{receive}の使用は複数の値を返す洗練された手法の実演、または単純にプログラミング上のトリックを
見せ付けるための言い訳として考えることができます。\code{receive}のような次に実行されるべき手続き引数は
``継続''と呼ばれます。\link{Section 4.3.3}で私達が継続を\code{amb}評価機のバックトラック制御構造の実装に
用いたのを思い出して下さい。
}


\code{update\-/insts!}は命令リストを変更します。これは初期値としては命令のテキストのみを
含みますが、対応する実行手続きを含むようになります。

\begin{scheme}
(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc!
        inst
        (make-execution-procedure
         (instruction-text inst)
         labels machine pc flag stack ops)))
     insts)))
\end{scheme}

\noindent
マシン語データ構造は単純に命令テキストと対応する実行手続きのペアを作ります。
実行手続きは\code{extract\-/labels}が命令を構築した時にはまだ存在せず、
後に\code{update\-/insts!}により挿入されます。

\begin{scheme}
(define (make-instruction text) (cons text '()))
(define (instruction-text inst) (car inst))
(define (instruction-execution-proc inst) (cdr inst))
(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
\end{scheme}

\noindent
命令テキストはシミュレータでは使用されません。しかし、デバッグのために
手元に置いておくと便利です。(\link{Exercise 5.16}参照)


ラベルテーブルの要素はペアです。

\begin{scheme}
(define (make-label-entry label-name insts)
  (cons label-name insts))
\end{scheme}

\noindent
テーブル内の要素は以下により検索されます。

\begin{scheme}
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Undefined label: ASSEMBLE"
               label-name))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.8}Exercise 5.8:}
以下のレジスタマシンのコードは曖昧である。ラベル\code{here}が複数回、定義されているためである。

\begin{scheme}
start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
\end{scheme}


シミュレータが書かれているままの状態で、レジスタ\code{a}の中身はコントローラが
\code{there}に辿り着いた時に何になるか? 手続き\code{extract\-/labels}を変更し、同じラベル名が
2つの異なる地点を指し示すのに使用された場合にエラーを発するようにせよ。
\end{quote}

\subsection{各命令に対する実行手続きの生成}
\label{Section 5.2.3}

アセンブラは命令の実行手続きを生成するために\code{make\-/execution\-/procedure}を呼びます。
\link{Section 4.1.7}の評価機の\code{analyze}手続きと同様に、これは適切な実行手続きを生成するために
命令の型に従い呼出を行います。

\begin{scheme}
(define (make-execution-procedure 
         inst labels machine pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else
         (error "Unknown instruction type: ASSEMBLE"
                inst))))
\end{scheme}

\noindent
レジスタマシンの言語の命令の各型に対し、適切な実行手続きを構築する生成器が存在します。
これらの手続きの詳細がレジスタマシン言語の構文と個別の命令の意味の両方を決定します。
データ抽象化を用いることで全体的な実行の仕組みからレジスタマシンの式の詳細な構文を
分離しています。これは\link{Section 4.1.2}で評価機に対して行ったのと同様で、構文手続きを用いて
命令の部分を抽出し、分類することによります。

\subsubsection*{\code{assign}命令}


\code{make\-/assign}手続きは\code{assign}命令を扱います。

\begin{scheme}
(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()   ~\textrm{; \code{assign}に対する実行手続き}~
        (set-contents! target (value-proc))
        (advance-pc pc)))))
\end{scheme}

\noindent
\code{make\-/assign}はターゲットとなるレジスタ名(命令の2つ目の要素)と値の式(命令を
構成するリストの残りの部分)を\code{assign}命令からセレクタを用いて抽出します。

\begin{scheme}
(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))
(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
\end{scheme}

\noindent
レジスタ名が\code{get\-/register}を用いて検索され目的のレジスタオブジェクトを生成します。
値の式はもし値が命令の結果であるのなら\code{make\-/operation\-/exp}に渡され、そうでなければ
\code{make\-/primitive\-/exp}に渡されます。これらの手続き(以下に示されます)は値の式を構文解析し
その値に対する実行手続きを生成します。これは引数無しの手続きで\code{value\-/proc}と呼ばれ、
シミュレーションの間にレジスタに代入される実際の値を生成するために評価されます。
レジスタ名の検索と値の式の構文解析の仕事はただ一度、アセンブリ時(アセンブラ実行時)に実行されることに注意して下さい。
その命令がシミュレートされる度に毎回ではありません。この仕事量の削減こそが私達が
実行手続きを使用する理由です。そしてこれが直接\link{Section 4.1.7}の評価機において、実行から
プログラム分析を分離することにより仕事量の削減を得たことに対応します。

\code{make\-/assign}により返される結果は\code{assign}命令のための実行手続きです。
この手続きが(マシンモデルの\code{execute}手続きにより)呼ばれた時に、\code{value\-/proc}手続きを
実行することにより得られた結果を目的のレジスタの中身に設定します。その次に\code{pc}を
以下の手続きを実行することにより次の命令へと進めます。

\begin{scheme}
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
\end{scheme}

\noindent
\code{advance\-/pc}は\code{branch}と\code{goto}を除く全ての命令に対する通常の終わりです。

\subsubsection*{\code{Test}, \code{branch}, \code{goto}命令}

\code{make\-/test}は\code{test}命令を同様な方法で扱います。これはテストされる条件を指定する
式を抽出し、それに対する実行手続きを生成します。シミュレーション時に、条件のための
手続きが呼ばれ、その結果が\code{flag}レジスタに割り当てられ、\code{pc}が進められます。

\begin{scheme}

(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Bad TEST instruction: ASSEMBLE" inst))))
(define (test-condition test-instruction)
  (cdr test-instruction))
\end{scheme}

\noindent
\code{branch}命令のための実行手続きは\code{flag}レジスタの中身をチェックし、\code{pc}の中身に
分岐の目的地を設定するか(分岐が選択された場合)、または単に\code{pc}を進めます
(分岐が選択されなかった場合)。\code{branch}命令内で指定された目的値はラベルでなければ
ならず、\code{make\-/branch}手続きがこのことを強制することに注意して下さい。またラベルは
アセンブリ時に検索され、\code{branch}命令がシミュレートされる時に毎回検索される
訳ではないことにも注意して下さい。

\begin{scheme}
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label
                labels 
                (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction: ASSEMBLE" inst))))
(define (branch-dest branch-instruction)
  (cadr branch-instruction))
\end{scheme}

\noindent
\code{goto}命令は\code{branch}に似ていますが、目的地がラベルか、またはレジスタにより指定される
ことが異なります。また条件分岐ではありません。\code{pc}は常に新しい目的地に設定されます。

\begin{scheme}
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts (lookup-label
                         labels
                         (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg (get-register
                       machine
                       (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction: ASSEMBLE"
                       inst)))))
(define (goto-dest goto-instruction)
  (cadr goto-instruction))
\end{scheme}

\subsubsection*{他の命令}

スタック命令の\code{save}と\code{restore}は単純にスタックを指定したレジスタと共に
用いて、\code{pc}を進めます。

\begin{scheme}
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))
(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc))))
(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
\end{scheme}

\noindent
\code{make\-/perform}で扱われる最後の命令型は実行されるべきアクションのための実行手続きを
生成します。シミュレーション時にこのアクション手続きが実行され\code{pc}は進められます。

\begin{scheme}
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda () (action-proc) (advance-pc pc)))
        (error "Bad PERFORM instruction: ASSEMBLE" inst))))
(define (perform-action inst) (cdr inst))
\end{scheme}

\subsubsection*{部分式の実行手続き}

\code{reg}, \code{label}, または\code{const}式の値はレジスタへの代入(\code{make\-/assign})のため、
または演算命令の入力(下記の\code{make\-/operation\-/exp})のために必要になるかもしれません。
以下の手続きはこれらの式のための値をシミュレーションの間に生成するための実行手続きを
生成します。

\begin{scheme}
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts (lookup-label
                       labels
                       (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type: ASSEMBLE" exp))))
\end{scheme}

\noindent
\code{reg}, \code{label}, \code{const}式の構文は以下により決定されます。

\begin{scheme}
(define (register-exp? exp) (tagged-list? exp 'reg))
(define (register-exp-reg exp) (cadr exp))
(define (constant-exp? exp) (tagged-list? exp 'const))
(define (constant-exp-value exp) (cadr exp))
(define (label-exp? exp) (tagged-list? exp 'label))
(define (label-exp-label exp) (cadr exp))
\end{scheme}

\noindent
\code{assign}, \code{perform}, \code{test}命令は(\code{op}式により指定される)機械の演算命令の
(\code{reg}と\code{const}式により指定される)いくつかのオペランドへの適用を含むかも
しれません。以下の手続きは``演算命令式''---命令からの演算命令とオペランドの式を
含むリスト---に対する実行手続きを生成します。

\begin{scheme}
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp)
                         operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
\end{scheme}

\noindent
演算命令式の構文は以下により決定されます。

\begin{scheme}
(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))
(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))
(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
\end{scheme}

\noindent
演算命令式の処理が\link{Section 4.1.7}の評価機において各オペランドに対して実行手続きを生成したことにおいて
\code{analyze\-/application}手続きによる手続きの適用の処理にとても似ていることに注意して下さい。
シミュレーション時に、オペランド手続きを呼び、結果となる値に対して演算をシミュレートする
Scheme手続きを適用します。シミュレーション手続きは演算命令の名前を機械の演算命令テーブルから
検索することで見つかります。

\begin{scheme}
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation: ASSEMBLE"
               symbol))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.9}Exercise 5.9:}
上記の機械の演算命令の取扱はそれらにラベル、定数、レジスタの中身上での演算を可能にする。
式を処理する手続きを変更し、演算命令がレジスタと定数のみに対して使用できるような条件を
強制するようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.10}Exercise 5.10:}
レジスタマシンの命令に新しい構文を設計し、シミュレータを変更してその新しい構文を使用せよ。
シミュレータの内、この節の構文手続き以外を変更せずにあなたの新しい構文を実装することができるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.11}Exercise 5.11:}
\link{Section 5.1.4}で\code{save}と\code{restore}を導入した時、以下の順の様に最後に保存した物ではない
レジスタに戻した場合に何が起こるのかは指定しなかった。

\begin{scheme}
(save y)  (save x)  (restore y)
\end{scheme}


\code{restore}の意味に対してはいくつかの妥当な可能性が存在する。

\begin{enumerate}[a]

\item
\code{(restore y)}はスタック上に最後に保存された値を、どのレジスタからその値が来たのか
関係無しに\code{y}に入れる。これが私達のシミュレータの振舞である。この振舞の利点の
活用法を示すため、\link{Section 5.1.4}のフィボナッチマシンから1つ命令を削減して見せよ。(\link{Figure 5.12})

\item
\code{(restore y)}はスタック上に最後に保存された値を\code{y}に入れる。しかしその
値が\code{y}から保存された場合のみである。そうでなければエラーを発する。
シミュレータを変更してこのように振る舞うようにせよ。\code{save}を変更して
スタック上に値と共にレジスタ名を保存しなければならない。

\item
\code{(restore y)}は\code{y}の後に他のどのレジスタが保存され、取り出されていなくても
最後に\code{y}から保存した値を\code{y}に入れる。シミュレータをこのように振る舞うように変更せよ。
分離されたスタックを各レジスタに関連付けする必要がある。また\code{initialize\-/stack}命令に
全てのレジスタのスタックを初期化させなければならない。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.12}Exercise 5.12:}
シミュレータは与えられたコントローラと共に機械を実装するために必要とされるデータパスを
決定することを手助けするために利用することが可能である。アセンブラを拡張し以下の情報を
マシンモデルに格納せよ。

\begin{itemize}

\item
全ての命令のリストを重複を削除し、命令の型でソートする(\code{assign}, \code{goto}等)

\item
エントリポイントを持つのに使用されたレジスタの(重複の無い)リスト。(これらは
\code{goto}命令で参照されたレジスタである)

\item
\code{save}または\code{restore}されたレジスタの(重複の無い)リスト

\item
各レジスタに対し、代入元の(重複の無い)リスト。(例えば\link{Figure 5.11}の階乗マシンの
レジスタ\code{val}の入力元は\code{(const 1)}と\code{((op *) (reg n) (reg val))}).

\end{itemize}


メッセージパッシングの機械へのインターフェイスを拡張し、この新しい情報へのアクセスを提供せよ。
あなたの分析器をテストするために\link{Figure 5.12}のフィボナッチマシンを定義し、
構築されたリストを試験せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.13}Exercise 5.13:}
シミュレータを変更することで、\code{make\-/machine}に対する引数としてレジスタのリストを
要求するのではなく、コントローラシーケンスを使用して機械がどんなレジスタを持つのか
決定するようにせよ。\code{make\-/machine}の中でレジスタを事前に獲得しておく代わりに、
命令のアセンブリ時の間に初めて現れた時に1つづつレジスタを獲得するようにせよ。
\end{quote}

\subsection{機械のパフォーマンスの監視}
\label{Section 5.2.4}

シミュレーションは提案された機械設計の正しさを確認するためだけではなく、
機械のパフォーマンスを計るためにも便利です。例えば、私達のシミュレータに演算中に
使用されるスタック命令の数を計る``メーター''を導入することができます。これを行うためには、
シミュレーションを行うスタックを変更しスタック上にレジスタが保存された回数とスタックが
到達した最大の深さを追跡するにし、スタックのインターフェイスにメッセージを追加し
以下のように統計を表示するようにします。また\code{make\-/new\-/machine}内の\code{the\-/ops}を以下の様に
初期化することで、基本的なマシンモデルにスタックの統計を表示する命令を追加します。

\begin{scheme}
(list (list 'initialize-stack
            (lambda () (stack 'initialize)))
      (list 'print-stack-statistics
            (lambda () (stack 'print-statistics))))
\end{scheme}

\noindent
以下が新しい版の\code{make\-/stack}です。

\begin{scheme}
(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else
             (error "Unknown request: STACK" message))))
    dispatch))
\end{scheme}

\noindent
\link{Exercise 5.15}から\link{Exercise 5.19}はレジスタマシンシミュレータに追加できる
他の便利な監視とデバッグの機能を説明します。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.14}Exercise 5.14:}
\link{Figure 5.11}で示された階乗マシンを用いて様々な小さな値\( n \)に対する\( n! \)の
演算に必要とされるpushの数とスタックの最大深さを計れ。データから任意\( n > 1 \)に
対する\( n! \)を求めるのに使用されたpush命令の総数とスタックの最大深度に対する
\( n \)を用いた方程式を決定せよ。それぞれが\( n \)の線形関数であり、従って2つの
定数により決定されることに注意せよ。統計が表示されるために、階乗マシンをスタックを初期化する
命令と統計を表示する命令を拡張しなければならない。また機械を変更することで\( n \)に対する
値を繰り返し読み込み、階乗を求め、結果を表示できるようにしたいと思うかもしれないだろう(我々が
\link{Figure 5.4})で丁度\acronym{GCD}マシンに対して行ったように)。そうすることで繰り返し
\code{get\-/register\-/contents},\code{set\-/register\-/contents!}, \code{start}を起動する必要が無くなる。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.15}Exercise 5.15:}
レジスタマシンのシミュレータに\newterm{instruction counting}(\jnewterm{命令数カウンタ})を
追加せよ。これはマシンモデルに対して実行された命令数を追跡させる。マシンモデルの
インターフェイスを拡張し、命令カウンタの値を表示する物とカウンタをゼロにリセットする
新しいメッセージを受け入れるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.16}Exercise 5.16:}
シミュレータを拡張し\newterm{instruction tracing}(\jnewterm{命令トレーサ})を追加せよ。
これは各命令が実行される前に、シミュレータが命令のテキストを表示する。
マシンモデルに対しトレーサをon/offする\code{trace\-/on}と\code{trace\-/off}メッセージを受け入れるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.17}Exercise 5.17:}
\link{Exercise 5.16}の命令トレーサを拡張し命令を表示する前にシミュレータが
コントローラシーケンス内でその命令の直前のラベル表示するにせよ。
命令数カウンタ(\link{Exercise 5.15})に干渉しない方法で行うように注意すること。
シミュレータに必要なラベル情報を維持するようにすることが必要だろう。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.18}Exercise 5.18:}
\link{Section 5.2.1}の\code{make\-/register}手続きを変更し、レジスタをトレース可能にせよ。
レジスタがトレースのon、offを行うメッセージを受け入れなければならない。
レジスタがトレースされている時、そのレジスタに対する代入はレジスタの名前、
レジスタの古い値、代入される新しい値が表示されること。マシンモデルへの
インターフェイスを拡張し指定された機械のレジスタに対するトレーサのon、offを
可能にせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.19}Exercise 5.19:}
Alyssa P. Hackerはシミュレータ内に\newterm{breakpoint}(\jnewterm{ブレイクポイント})の機能を
欲しいと思った。それにより彼女の機械設計を手助けするためである。あなたが彼女のために
この機能を導入するために雇用された。彼女はコントローラシーケンス内でシミュレータが
停止する場所を指定し、機械の状態を調査することができるようにして欲しかった。
あなたは以下の手続きを実装しようとしている。

\begin{scheme}
(set-breakpoint ~\( \dark \langle\kern0.08em \)~~\var{\dark machine}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark label}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark n}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
これは与えられたラベルの後ろの\( n \)番目の命令の直前にブレイクポイントを設定する。
例えば、

\begin{scheme}
(set-breakpoint gcd-machine 'test-b 4)
\end{scheme}

\noindent
上の式はブレイクポイントを\code{gcd\-/machine}のレジスタ\code{a}への代入の直前にブレイクポイントを
導入する。シミュレータがブレイクポイントに到達する時、ラベルとブレークポイントのオフセットを
表示し、命令の実行を停止しなければなりません。するとAlyssaは\code{get\-/register\-/contents}と
\code{set\-/register\-/contents!}を用いてシミュレートされている機械の状態を操作することが可能になる。
次に彼女は以下を入力することで実行を続行できなければならない。

\begin{scheme}
(proceed-machine ~\( \dark \langle\kern0.08em \)~~\var{\dark machine}~~\( \dark \rangle \)~)
\end{scheme}


また特定のブレイクポイントを以下を用いて削除できなければならない。

\begin{scheme}
(cancel-breakpoint ~\( \dark \langle\kern0.08em \)~~\var{\dark machine}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark label}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark n}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
または全てのブレイクポイントを削除するためには以下を用いる。

\begin{scheme}
(cancel-all-breakpoints ~\( \dark \langle\kern0.08em \)~~\var{\dark machine}~~\( \dark \rangle \)~)
\end{scheme}
\end{quote}

\section{記憶域の割当とガベージコレクション}
\label{Section 5.3}

\link{Section 5.4}ではレジスタマシンとしてのScheme評価機をどのように実装するかを示します。
議論を簡易化するために、私達のレジスタマシンは\newterm{list-structured memory}(\jnewterm{リスト構造メモリ})を
供えていると仮定します。この機械ではリスト構造のデータを操作する命令はプリミティブです。
そのようなメモリが存在するという仮定はSchemeインタプリタの制御の仕組みに集中する場合には
有用な抽象化です。しかしこれは現在のコンピュータの実際のプリミティブなデータ操作の
現実の光景を反映してはいません。Lispシステムがどのように動作するかのより完全な理解を得るためには、
リスト構造がどのように旧来のコンピュータのメモリに互換性のある方法で表現されるかについて
調査しなければなりません。

リスト構造の実装には2つの考慮点が存在します。1つは純粋に表現上の問題です。
Lispのペアによる``箱とポインタ''構造をストレージと典型的なコンピュータのメモリの
アドレス指定能力を用いてどのように表現するか。2つ目の問題は演算が進行するにつれての
メモリ管理に関係します。Lispシステムの動作は決定的に、継続して新しいデータオブジェクトを
作る能力に依存しています。これらは逐次実行されるLisp手続きにより明示的に作成されるオブジェクトと
同様に、インタプリタ自身により作成される環境や引数リストのような構造も含みます。
持続的な新しいデータオブジェクトの作成は無限の容量でかつ、高速にアドレス指定できるメモリを
持つコンピュータ上では問題を起こさないでしょうが、コンピュータのメモリは有限な量しか
ありません(残念なことに)。Lispシステムは従って無限のメモリという空想をサポートする
\newterm{automatic storage allocation}(\jnewterm{自動記憶域割当})の設備を提供します。
データオブジェクトが既に必要でなくなった時に、それに割り当てられたメモリは自動的に
リサイクルされ新しく構築されるデータオブジェクトに利用されます。そのような自動的な
記憶域割当を提供する多様な技術が存在します。この節で私達が議論する手法は
\newterm{garbage collection}(\jnewterm{ガベージコレクション}、ゴミ拾い)と呼ばれます。



\subsection{ベクタとしてのメモリ}
\label{Section 5.3.1}

伝統的なコンピュータのメモリは小さな部屋の配列だと考えることができます。
各部屋は情報の一片を入れることができます。各部屋は\newterm{address}(\jnewterm{アドレス})または
\newterm{location}(\jnewterm{位置})と呼ばれる個有の名前を持ちます。典型的なメモリシステムは
2つのプリミティブな命令を提供します。1つは指定された位置に格納されたデータを取り出し、
もう1つは指定された位置に新しいデータを割り当てます。メモリアドレスはある部屋の集合に
シーケンシャル(順)なアクセスをサポートするためにインクリメントすることができます。
より一般的には、多くの重要なデータの操作はメモリアドレスをデータして扱うことを要求します。
このデータはメモリ上の位置に格納でき、機械のレジスタ上で操作できなければいけません。
リスト構造の表現はそのような\newterm{address arithmetic}(\jnewterm{アドレス演算})の一つの応用です。

コンピュータメモリをモデル化するためには、\newterm{vector}(\jnewterm{ベクタ})と呼ばれる新しい
種類のデータ構造を用います。抽象的には、ベクタは複合データオブジェクトであり、その
個別の要素が整数の索引を用いて、索引から独立した時間量でアクセスすることができます。\footnote{メモリを
項目のリストとして表現することはできます。しかし、アクセス時間はその場合、索引から独立しません。
リストの\( n \)番目の要素へのアクセスが\( n - 1 \)回の\code{cdr}命令を必要とするためです。}
メモリ操作を説明するために、ベクタを扱うための2つのプリミティブなScheme手続きを使用します。

\begin{itemize}

\item
\code{(vector\-/ref <\var{vector}> <\var{n}>)}はベクタの\( n \)番目の要素を返す。

\item
\code{(vector\-/set! <\var{vector}> <\var{n}> <\var{value}>)}はベクタの\( n \)番目の要素に
指定された値を設定する。

\end{itemize}

\noindent
例えば、\code{v}がベクタであるならば、\code{(vector\-/ref v 5)}はベクタ\code{v}の5番目の項目を
取得し、\code{(vector\-/set! v 5 7)}はベクタ\code{v}の5番目の項目の値を7に変更します。\footnote{完全にするには、
ベクタを構築する\code{make\-/vector}命令を指定するべきです。しかし、現在のアプリケーションではベクタを
コンピュータメモリの固定区域をモデル化するためにのみ使用します。}コンピュータメモリに対して、
このアクセスはアドレス演算を用いて、メモリ内のベクタの開始位置を指定する
\newterm{base address}(\jnewterm{ベース(基底)アドレス})とベクタの特定の項目のオフセットを指定する
\newterm{index}(\jnewterm{インデックス}、索引)を組み合わせることで実装することができます。

\subsubsection*{Lispデータの表現}

ベクタを用いてリスト構造メモリに対する基本的なペア構造を実装することができます。
コンピュータメモリが2つのベクタに分割されている所を想像してみましょう。
\code{the\-/cars}と\code{the\-/cdrs}です。私達は次のようにリスト構造を表現します。
ペアに対するポイントは2つのベクタへの索引です。ペアの\code{car}は\code{the\-/cars}に
指定した索引を用いた項目です。そしてペアの\code{cdr}は指定された索引を用いた\code{the\-/cdrs}の
項目です。またペア以外のオブジェクト(例えば数値やシンボル)に対する表現とデータの種類をお互いに見分ける
ための手法も必要になります。これを達成する方法は多数存在しますが、しかしそれらは
全て\newterm{typed pointers}(\jnewterm{型付きポインタ})の使用へと帰します。これはつまり、
``ポインタ''の概念を拡張しデータの型の情報を含めることです。\footnote{これは正確に
\link{Chapter 2}で紹介したジェネリック(総称)な命令を扱うための``タグ付きデータ''と同じ考えです。
ここではしかし、データの型はリストの使用を通して構築されるのでなく、プリミティブな機械レベルにて
含まれます。}データの型はシステムにペアのポインタ(``ペア''データ型とメモリベクタを
指す索引から成り立つ)を他の種類のデータへのポインタ(何らかの他のデータ型とその型を
表現するために利用された何かにより成り立つ)を見分けることを可能にします。
2つのデータオブジェクトはそれらのポインタが全く同じである場合に同じ(\code{eq?})だと
判断されます。\footnote{型情報はLispシステムが実装される機械の詳細に依存して多様な
方法でエンコード(encode、符号化)されるでしょう。Lispプログラムの実行効率はこの選択
がどれだけ明確に行われたかに強く依存します。しかし良い選択のための一般的な設計ルールを
形式化することは難しいことです。型付きポインタを実装する最も簡単な方法は固定長の
ビット集合を各ポインタの中でデータ型をエンコードする\newterm{type field}(\jnewterm{型フィールド})とする様に
割り当てしておくことです。そのような表現を設計するにおいて解決すべき重要な問題は
次を含みます。いくつの型ビットが必要とされるか? ベクタの索引の長さはどれだけ必要か?
どれだけ効率良くプリミティブな機械語命令がポインタの型フィールドの操作に使用できるか?
型フィールドを効率良く扱うための特別なハードウェアを含む機械は\newterm{tagged
architectures}(\jnewterm{タグアーキテクチャ})を持つと言われます。}\link{Figure 5.14}はこの手法を
用いてリスト\code{((1 2) 3 4)}を表現する場合を図示しています。その箱とポインタ図もまた
示されています。私達は文字接頭辞をデータ型情報を示すために使用しています。従って、
ペアに対する索引5を伴なうポインタは\code{p5}と示されます。空リストはポインタ\code{e0}で示されます。
そして数値4へのポインタは\code{n4}として示されます。箱とポインタ図において各ペアの左隅に
ペアの\code{car}と\code{cdr}がどこに格納されるかを指定するベクタの索引を表示しました。

数値へのポインタ、例えば\code{n4}は数値データを示す型と実際の数値4の表現から成り立つでしょう。\footnote{この
数値の表現上の決断はポインタの等価性をテストする\code{eq?}が数値の等値性の試験に使用できるか
どうかを決定します。もしポインタが数値それ自身を含む場合、等しい数値は同じポインタを持ちます。
しかしもしポインタが数値が格納される位置の索引を持つ場合、私達が同じ数を複数の位置に
格納しないことに注意しない場合に限り等しい数値が同じポインタになることが保証されます。}
単一のポインタのために獲得された固定長のメモリの中で表現されるには大き過ぎる数値を扱うためには、
独特な\newterm{bignum}(\jnewterm{ビッグナンバー})データ型を使うことができるでしょう。このためのポインタは
格納される数値の部分が格納されるリストを指定します。\footnote{これは丁度数値を数字の列として
書くのに似ています。ただし各``桁''が0から単一のポインタに格納できる最大の数の間になることが
異なります。}

\begin{figure}[tb]
\phantomsection\label{Figure 5.14}
\centering
\begin{comment}
\heading{Figure 5.14:} Box-and-pointer and memory-vector representations of the list \code{((1 2) 3 4)}.

\begin{example}
               +---+---+               +---+---+    +---+---+
((1 2) 3 4) -->| * | *-+-------------->| * | *-+--->| * | / |
               +-|-+---+               +-|-+---+    +-|-+---+
              1  |                    2  |         4  |
                 V                       V            V
               +---+---+    +---+---+  +---+        +---+
               | * | *-+--->| * | / |  | 3 |        | 4 |
               +-|-+---+    +-|-+---+  +---+        +---+
              5  |         7  |
                 V            V
               +---+        +---+
               | 1 |        | 2 |
               +---+        +---+

   Index   0    1    2    3    4    5    6    7    8    ...
         +----+----+----+----+----+----+----+----+----+----
the-cars |    | p5 | n3 |    | n4 | n1 |    | n2 |    | ...
         +----+----+----+----+----+----+----+----+----+----
the-cdrs |    | p2 | p4 |    | e0 | p7 |    | e0 |    | ...
         +----+----+----+----+----+----+----+----+----+----
\end{example}
\end{comment}
\includegraphics[width=91mm]{fig/chap5/Fig5.14a.pdf}
\begin{quote}
\heading{Figure 5.14:} リスト\code{((1 2) 3 4)}の``箱とポインタ''とメモリベクタの表現
\end{quote}
\end{figure}

シンボルはその表示内容を形成する文字の列を指定する型付きポインタとして表現されることが
できるでしょう。この列はLispのreaderにより、最初に入力の中の文字列に出くわした時に
構築されます。2つのシンボルのインスタンスが\code{eq?}により``同じ''シンボルであると
認識されて欲しいことと、\code{eq?}にポインタの等価性のための簡単なテストになって欲しいこと
から、もしreaderが同じ文字列を2回見た場合、(同じ文字列に対する)同じポインタを両方の
出現に対して表現するために利用することを保証しなければなりません。これを達成するためには、
readerは伝統的に\newterm{obarray}(\jnewterm{オブジェクト配列})と呼ばれる出会った全てのシンボルの
表を管理します。readerが文字列に遭遇しシンボルを構築しようとする時、obarrayをチェックし
同じ文字列を以前に見ていないか確認します。もし初見であれば、文字列を用いて新しいシンボル
(新しい文字列に対する型付きポインタ)を構築し、このポインタをobarrayに挿入します。
もしreaderが既にその文字列を見ていれば、obarrayに格納されているシンボルのポインタを返します。
この文字列を一意なポインタで置き換える処理はシンボルの\newterm{interning}(\jnewterm{抑留})と呼ばれます。

\subsubsection*{プリミティブなリスト命令の実装}

上記の表現の構想を与えられた時に、レジスタマシンの各``プリミティブ''なリスト命令を
複数のプリミティブなベクタ命令で置き換えることができます。2つのレジスタ\code{the\-/cars}と
\code{the\-/cdrs}を用いてメモリベクタを特定し、\code{vector\-/ref}と\code{vector\-/set!}がプリミティブな
命令として有効であると仮定します。またポインタ上の演算命令(例えばポインタをインクリメントする、
ペアのポインタを用いてベクタを索引付けする、または2つの数値を足す)は型付きポインタの
索引部分しか利用しません。

\noindent
例えば、次の命令をサポートするレジスタマシンをその下の条件の下で作成することができます。

\begin{scheme}
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (op car) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (op cdr) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
\end{scheme}

\noindent
上の命令のそれぞれに対しこれらが実装されているとします。

\begin{scheme}
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (op vector-ref) (reg the-cars) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (op vector-ref) (reg the-cdrs) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
\end{scheme}

\noindent
以下の命令は、

\begin{scheme}
(perform (op set-car!) (reg ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
(perform (op set-cdr!) (reg ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
\end{scheme}

\noindent
次のように実装されます。

\begin{scheme}
(perform
 (op vector-set!) (reg the-cars) (reg ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
(perform
 (op vector-set!) (reg the-cdrs) (reg ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
\end{scheme}

\noindent
\code{cons}は未使用の索引を割り当て、\code{cons}の引数を\code{the\-/cars}と\code{the\-/cdrs}の中で
索引付けられたベクタの位置に格納します。私達は特別なレジスタ、\code{free}が存在し、
常に次に使用可能な索引を持つペアポインタを保つと仮定します。そしてそのポインタの
索引部分をインクリメントすることで次の空き位置を探すことができます。\footnote{空きの
記憶域を探す他の方法も存在します。例えば、全ての未使用のペアをリンクして
\newterm{free list}(\jnewterm{空きリスト})にすることもできたでしょう。私達の空き位置は連続的
(従ってポインタをインクリメントすることでアクセス可能であるため)です。なぜなら
私達が圧縮GCを用いているためです。また\link{Section 5.3.2}も参照して下さい。}例えば、以下の命令は

\begin{scheme}
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (op cons) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_3 \)~~\( \dark \rangle \)~))
\end{scheme}

\noindent
次の一連のベクタ命令として実装されます。\footnote{これは本質的に\link{Section 3.3.1}で説明した\code{set\-/car!}と
\code{set\-/cdr!}を用いた\code{cons}の実装です。その実装内で使用された命令\code{get\-/new\-/pair}は
ここでは\code{free}ポインタにより実現されています。}

\begin{scheme}
(perform
 (op vector-set!) (reg the-cars) (reg free) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg ~\( \dark \langle \)~~\( \dark reg_3 \)~~\( \dark \rangle \)~))
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (reg free))
(assign free (op +) (reg free) (const 1))
\end{scheme}

\noindent
以下の\code{eq?}命令は

\begin{scheme}
(op eq?) (reg ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
単純にレジスタ内の全ての項目の等価性をテストします。そして
\code{pair?}, \code{null?}, \code{symbol?}, \code{number?}等のような述語は型フィールドのみを
確認する必要があります。

\subsubsection*{スタックの実装}

私達のレジスタマシンはスタックを用いますが、ここでは特に特別なことを行う必要がありません。
スタックはリストを用いてモデル化することができるためです。スタックは保存した値のリストと
することができ、特別なレジスタ\code{the\-/stack}により指し示されます。従って\code{
(save <\var{reg}>)}は以下のように実装することができます。

\begin{scheme}
(assign the-stack (op cons) (reg ~\( \dark \langle \)~~\var{\dark reg}~~\( \dark \rangle \)~) (reg the-stack))
\end{scheme}

\noindent
同様に、\code{(restore <\var{reg}>)}は次のように実装することができます。

\begin{scheme}
(assign ~\( \dark \langle \)~~\var{\dark reg}~~\( \dark \rangle \)~ (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
\end{scheme}

\noindent
そして\code{(perform (op initialize\-/stack))}は以下のように実装することができます。

\begin{scheme}
(assign the-stack (const ()))
\end{scheme}

\noindent
これらの命令は上で与えられたベクタ命令を用いてさらに伸展されます。しかし、伝統的な計算機
アーキテクチャにおいてはスタックを別のベクタとして割り当てることは通常は好都合です。
そうすれば、スタックにpushやpopを行うことはベクタに対する索引をインクリメント、
デクリメントすることにより達成することができます。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.20}Exercise 5.20:}
以下の式から生成されるリスト構造の表現と(\link{Figure 5.14}にあるような)メモリ-ベクタ表現の
箱とポインタ図を描け。

\begin{scheme}
(define x (cons 1 2))
(define y (list x x))
\end{scheme}

\noindent
ただし、\code{free}ポインタの初期値は\code{p1}とする。\code{free}の最終的な値は何か?
どんなポインタが\code{x}と\code{y}の値を表現するか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.21}Exercise 5.21:}
以下の手続きのためのレジスタマシンを実装せよ。リスト構造のメモリ命令は機械のプリミティブと
して使用可能だと仮定せよ。

\begin{enumerate}[a]

\item
再帰\code{count\-/leaves}:

\begin{scheme}
(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
\end{scheme}

\item
明示的なカウンタを用いた再帰\code{count\-/leaves}

\begin{scheme}
(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else
           (count-iter (cdr tree)
                       (count-iter (car tree) 
                                   n)))))
  (count-iter tree 0))
\end{scheme}
\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.22}Exercise 5.22:}
\link{Section 3.3.1}の\link{Exercise 3.12}は2つのリストを接続し1つの新しいリストを形成する\code{append}手続きと、
2つのリストを一緒に繋ぎ合わせる\code{append!}手続きを紹介した。これらの手続きそれぞれを実装するレジスタ
マシンを設計せよ。リスト構造のメモリ命令はプリミティブな命令として使用可能と前提せよ。
\end{quote}

\subsection{無限のメモリの幻想を維持する}
\label{Section 5.3.2}

\link{Section 5.3.1}で概観した表現手法はリスト構造の実装上の問題を解決しましたが、無限の容量の
メモリを持っている場合という条件付きでした。実際のコンピュータではいつかは新しいペア
を構築するための空き容量を使い切ってしまいます。\footnote{これはいつかは正しくはなく
なるかもしれません。なぜならメモリが十分に大きくなればコンピュータの生存時間の間には
空きメモリを使い切ることは不可能になるかもしれないからです。例えば一年は
\( 3\cdot10^{13} \)マイクロ秒ですから、もし1マイクロ秒に1回\code{cons}を行うので
あれば、30年間はメモリを使い切ることのないコンピュータを構築するのには
約\( 10^{15} \)セルのメモリを必要とします。それだけのメモリは今日の標準では話にならない程大きく
見えますが、しかし物理的に不可能ではありません。一方で、プロセッサはより速くなりつつあり
未来のコンピュータは数多くのプロセッサを並列に単一のメモリ上で作動するかもしれません。
従って私達の前提よりもよい早くメモリを使い切ることが可能かもしれません。}しかし、
典型的な演算により生成されるペアの多くは中間結果を保つためだけに使用されます。これらの
結果がアクセスされた後には、それらのペアはもう必要ありません。それらは\newterm{garbage}(\jnewterm{ゴミ})です。
例えば、以下の演算は

\begin{scheme}
(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
\end{scheme}

\noindent
2つのリストを構築します。enumaration(列挙)と列挙をフィルタリングした結果です。
accumulation(集積)が完了した時に、これらのリストはもう必要ありません。そして
割り当てられたメモリは返還要求できます。もし全てのゴミを定期的に回収する準備を
行えるのであれば、そしてもしこれが新しいペアを構築するのと大体同じ比率でメモリを
リサイクルすることになれば、無限の容量のメモリが存在するという錯覚を維持することが
できます。

ペアをリサイクルするためには、どの割り当てられたペアが必要でないか(それらの中身が
その後将来の演算に影響しないという意味で)決定する方法を持たねばなりません。
これを達成するために調査する手法は\newterm{garbage collection}(\jnewterm{ガベージコレクション}、GC)として
知られています。ガベージコレクションはLispの逐次実行における任意の時点で、将来の
演算に影響を与えることができるオブジェクトは現状で機械のレジスタ内に存在する
ポインタにより辿り着くことができるオブジェクトのみであるという観察結果に基いています。\footnote{ここでは
スタックは\link{Section 5.3.1}で説明されたリストとして表現されていると仮定しています。そのため
スタック上の項目はスタックレジスタ内のポインタを通してアクセスすることができます。}
そのようにアクセスできないどのメモリセルもリサイクルして良いでしょう。

ガベージコレクションを実行する方法は数多く存在します。ここで調査する手法は
\newterm{stop-and-copy}と呼ばれます。基本的な考えはメモリを2つに割ります。
``ワーキングメモリ''と``空きメモリ''です。\code{cons}がペアを構築する時、ワーキングメモリに
割り当てます。ワーキングメモリに空きが無い時、ワーキングメモリ内の使い道のある全てのペアを探し出し、
これらをフリーメモリ内の連続した位置にコピーすることでガベージコレクションを実行します。
(使い道のあるペアは機械のレジスタから始めて、全ての\code{car}と\code{cdr}のポインタを
追跡することにより探し出します)。ゴミはコピーしないため、推定上、新しいペアを
割り当てるための利用できる追加の空きメモリが存在するはずです。加えて、ワーキング
メモリ内の全てが必要ありません。その中の使い道のあるペアはコピーされています。
従ってワーキングメモリと空きメモリの役割を交換すれば、処理を続けることができます。
新しいペアは新しいワーキングメモリ(空きメモリだった物)の中に割り当てられます。
これがいっぱいになったなら、使い道のあるペアを新しい空きメモリ(ワーキングメモリだったもの)の
中にコピーできます。\footnote{
この考えはMinsky(ミンスキー)により発明され、\acronym{MIT}研究所の
電子工学ラボのPDP-1に対するLispの実装の一部として実装されました。
\link{Fenichel and Yochelson (1969)}によりMultics時分割システムのLisp実装で使用するために、
さらに開発が進められました。後に、\link{Baker (1978)}はこの手法の``リアルタイム''版を開発しました。
これはガベージコレクションの間に演算を停止する必要がありません。Bakerの考えは
Hewitt, Lieberman, Moonにより拡張され(\link{Lieberman and Hewitt 1983}参照)、
ある構造はvolatile(揮発性)であり、別の構造はより永続的であるといった事実を
活用する様になりました。

一般に利用される代替的なガベージコレクションの技術は\newterm{mark-sweep}(\jnewterm{マーク アンド スイープ})の
手法です。これは回帰のレジスタからアクセス可能な全ての構造の追跡と辿り着く各ペアへのマーキングから
成り立ちます。次に全てのメモリを走査し、マークの無い全てのメモリはゴミとして``掃き出し''、
再使用可能とされます。マーク アンド スイープの十分な議論は\link{Allen 1978}の中に見つけられます。

Minsky-Fenichel-Yochelsonアルゴリズムは巨大なメモリシステムに対する使用における
支配的なアルゴリズムです。メモリの使い道のある部分のみを調査するためです。
これはスイープの段階で全てのメモリを確認しなければならないmark-and-sweepとは対照的です。
stop-and-copyの2つ目の強みは\newterm{compacting}(\jnewterm{圧縮})ガベージコレクタであることです。
つまり、ガベージコレクションの段階の終わりには使い道のあるデータは連続したメモリ位置に
移動され、全てのゴミペアは圧縮の仮定で外に出されます。このことが仮想メモリを使用する
機械におけるパフォーマンス上の考慮において非常に重要と成り得ます。仮想メモリを使用する
機械は広範囲に分離されたメモリアドレスへのアクセスに余計なページング処理が必要となるかも
しれません。
}

\subsubsection*{stop-and-copyガベージコレクタの実装}

今から私達はレジスタマシン言語を用いてstop-and-copyアルゴリズムをより詳細に
記述します。私達は\code{root}と呼ばれるレジスタが存在し、ある構造体へのポインタを
保持し、そのポインタから最終的には全てのアクセス可能なデータを指し示すことが
できるという前提を行います。これはガベージコレクションを行う直前に全てのレジスタの
中身を事前に割り当てられたリストに格納し、\code{root}により指し示させることで
準備が行えます。\footnote{このレジスタのリストは記憶域割当システムのレジスタ---\code{root},
\code{the\-/cars}, \code{the\-/cdrs}, それにこの節で紹介される他のレジスタは含みません。}
私達はまた現在のワーキングメモリに加えて、使い道のあるデータをコピーできる空きメモリが
存在すると前提します。現在のワーキングメモリはベースアドレスが\code{the\-/cars}と\code{the\-/cdrs}と
呼ばれるレジスタに格納されるベクタから成り立ち、そして空きメモリは同様に
\code{new\-/cars}と\code{new\-/cdrs}と呼ばれるレジスタに格納されます。

ガベージコレクションは現在のワーキングメモリ内の空きセルが枯渇した時に引き起こされます。
それはつまり、\code{cons}命令が\code{free}ポインタをメモリベクタの終端を越えてインクリメント
しようとした時です。ガベージコレクションの処理が完了した時、\code{root}ポインタは
新しいメモリの中を指し示し、\code{root}からアクセス可能な全てのオブジェクトは新しいメモリに
移動されています。そして\code{free}ポインタは新しいメモリ内の新しいペアを割り当てられる
次の位置を示します。加えて、ワーキングメモリと新しいメモリの役割が交換されます。
新しいペアは\code{free}により指し示される位置から始まる新しいメモリ内に構築され、
(以前の)ワーキングメモリは次のガベージコレクションに対する新しいメモリとして
使用可能となります。\link{Figure 5.15}はガベージコレクション直前、直後のメモリの
割り振りを示します。

\begin{figure}[tp]
\phantomsection\label{Figure 5.15}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 5.15:} Reconfiguration of memory by the garbage-collection process.

\begin{example}
             Just before garbage collection

         +------------------------------------+
the-cars |                                    | working
         | mixture of useful data and garbage | memory
the-cdrs |                                    |
         +------------------------------------+
                                            ^
                                            | free

         +------------------------------------+
new-cars |                                    | free   
         |            free memory             | memory
new-cdrs |                                    |
         +------------------------------------+

             Just after garbage collection

         +------------------------------------+
new-cars |                                    | new  
         |          discarded memory          | free  
new-cdrs |                                    | memory
         +------------------------------------+

         +------------------+-----------------+
the-cars |                  |                 | new
         |   useful data    |    free area    | working
the-cdrs |                  |                 | memory
         +------------------+-----------------+
                              ^
                              | free
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=91mm]{fig/chap5/Fig5.15a.pdf}
\begin{quote}
\heading{Figure 5.15:} ガベージコレクションプロセスによるメモリの再構成
\end{quote}
\end{figure}

ガベージコレクション処理の状態は2つのポインタを管理することによりコントロールされています。
\code{free}と\code{scan}です。これらは新しいメモリの開始位置を指し示すように初期化されます。
アルゴリズムは\code{root}により指し示されるペアの新しいメモリの開始位置への再配置から開始されます。
ペアはコピーされ、\code{root}ポインタは新しい位置を指すように調整されます。そして
\code{free}ポインタがインクリメントされます。併せて、ペアの古い位置はその中身が移動された
ことを示すマークが付けられます。このマーキングは次のように行われます。\code{car}の位置には
これが既に移動されたオブジェクトであることを示す特別なタグを置きます。(そのような
オブジェクトは伝統的に\newterm{broken heart}(失恋)と呼ばれます。)\footnote{\emph{broken heart}と
いう用語はDavid Cresseyにより作られました。彼は1970年代初期の間に\acronym{MIT}で開発された
Lispの方言、MDLのためにガベージコレクタを書きました。}\code{cdr}の位置には
\newterm{forwarding address}(\jnewterm{転送先})を置きます。これはオブジェクトの移動先の位置を指し示します。

\code{root}の再配置の後に、ガベージコレクタは基本となるサイクルに入ります。
アルゴリズムの各ステップにおいて、\code{scan}ポインタ(初期値として再配置後の\code{root}を指す)は、
新しいメモリに移動されたがその\code{car}と\code{cdr}のポインタが依然として古いメモリ内の
オブジェクトを参照しているペアを指します。これらのオブジェクトはそれぞれが再配置され、
\code{scan}ポインタはインクリメントされます。オブジェクト(例えば走査しているペアの\code{car}ポインタにより
指されたオブジェクト)を再配置するためにはそのオブジェクトが既に移動されていないかを
(そのオブジェクトの\code{car}の位置内にbroken-heartタグが存在するこにより示されていないか)確認します。
もしオブジェクトがまだ移動されていなければ、それを\code{free}により示される位置にコピーし、
\code{free}を更新し、オブジェクトの古い位置にbroken-heartを設定し、そのオブジェクトへの
ポインタを(この礼では、走査しているペアの\code{car}ポインタを)更新し、新しい位置を指すようにします。
もしオブジェクトが既に移動されている場合には、(broken heartの\code{cdr}の位置に見つかる)その移動先は
走査中のペアのポインタに置き換えられます。最終的には、\code{scan}
ポインタが\code{free}ポインタを追い越す時点まで、全てのアクセス可能なオブジェクトは移動され、
精査されます。そして処理は停止します。

stop-and-copyアルゴリズムをレジスタマシンの命令列として記述することができます。
オブジェクトの再配置の基本的なステップは\code{relocate\-/old\-/result\-/in\-/new}と呼ばれるサブルーチンにて
達成されます。このサブルーチンはその引数として再配置するオブジェクトのポインタを\code{old}という名の
レジスタから取得します。これは指定されたオブジェクトを再配置し、(処理の間に\code{free}をインクリメントし)、
再配置されたオブジェクトを指すポインタを\code{new}と呼ばれるレジスタに入れます。
そして\code{relocate\-/continue}レジスタに格納されたエントリポイントへ分岐することで帰ります。
ガベージコレクションを始めるために、このサブルーチンを起動して、\code{free}と\code{scan}を初期化した後に
\code{root}ポインタを再配置します。\code{root}の再配置が完了した時に、\code{new}ポインタを新しい\code{root}と
して導入し、ガベージコレクタのメインループに入ります。

\begin{scheme}
begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
\end{scheme}

\noindent
ガベージコレクタのメインループでは走査すべきオブジェクトが残っているのか決定しなければ
なりません。これを\code{scan}ポインタが\code{free}ポインタと一致するかどうかを試験することで
行います。もしポインタが等しければ、全てのアクセス可能なオブジェクトの再配置は完了し、
\code{gc\-/flip}へと分岐します。ここは後片付けを行い、割り込みが行われた演算を継続します。
もしまだ走査すべきペアが残っているのであれば、再配置(relocate)のサブルーチンを呼び出し
次のペアの\code{car}を(\code{old}内の\code{car}ポインタを配置することで)再配置します。
\code{relocate\-/continue}レジスタの設定によりサブルーチンは\code{car}ポインタを更新するために
帰ります。

\begin{scheme}
gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
\end{scheme}

\noindent
\code{update\-/car}にて、精査しているペアの\code{car}ポインタを変更します。次にペアの
\code{cdr}を再配置するために向かいます。再配置が完了すると\code{update\-/cdr}に帰ってきます。
再配置と\code{cdr}の更新の後に、そのペアの精査を完了しメインループを継続します。

\begin{scheme}
update-car
  (perform (op vector-set!)
           (reg new-cars)
           (reg scan)
           (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform (op vector-set!)
           (reg new-cdrs)
           (reg scan)
           (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
\end{scheme}

\noindent
サブルーチン\code{relocate\-/old\-/result\-/in\-/new}はオブジェクトを次のように再配置します。
もし(\code{old}により指し示される)再配置すべきオブジェクトがペアでないなら、そのオブジェクトへの
同じポインタを変更無しで(\code{new}の中で)返します。(例えば、\code{car}が数値の4であるペアを精査して
いるとします。もし\link{Section 5.3.1}にて説明されているように\code{n4}で\code{car}を表現するのなら、
``再配置された''\code{car}のポインタも依然として\code{n4}であって欲しいと願うはずです)。
そうでなければ、再配置を実行しなければなりません。もしペアの再配置すべき\code{car}の位置に
broken-heartタグを持つのならば、そのペアは実際には既に移動されています。従って
(broken-heartの\code{cdr}の位置から)移動先を取得し、これを\code{new}に入れて返します。
もし\code{old}内のポインタがまだ移動されていないペアを指す場合、そのペアを(\code{free}が指し示す)
新しいメモリの最初の空きセルに移動させ、broken-heartタグと移動先を元の位置に格納することで
broken-heartを設定します。\code{relocate\-/old\-/result\-/in\-/new}はレジスタ\code{oldcr}を用いて
\code{old}により指し示されるオブジェクトの\code{car}または\code{cdr}を保持します。\footnote{ガベージ
コレクタは低レベルの述語\code{pointer\-/to\-/pair?}をリスト構造\code{pair?}命令の代わりに使用します。
実際のシステムでは様々な物がガベージコレクションの目的のためにペアとして扱われるためです。
例えば、\acronym{IEEE}標準に準拠するSchemeシステムでは手続きオブジェクトは特別な種類の``ペア''
として実装されても良くこれは述語\code{pair?}は満たしません。シミュレーションの目的には、
\code{pointer\-/to\-/pair?}は\code{pair?}として実装できます。}

\begin{scheme}
relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) ~\textrm{; ペアの新しい位置}~
  ~\textrm{;; \code{free}ポインタを更新する}~
  (assign free (op +) (reg free) (const 1))
  ~\textrm{;; \code{car}と\code{cdr}を新しいメモリにコピーする.}~
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  ~\textrm{;; ブロークンハートの構築}~
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
\end{scheme}

\noindent
ガベージコレクション処理の最後に、メモリの新旧の役割をポインタを交換することにより
交代します。\code{the\-/cars}と\code{new\-/cars}、そして\code{the\-/cdrs}を\code{new\-/cdrs}を交換します。
これで次回メモリが枯渇した時にもう一度ガベージコレクションを行う準備ができます。

\begin{scheme}
gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
\end{scheme}

\section{明示的制御評価機}
\label{Section 5.4}
\link{Section 5.1}では簡単なSchemeプログラムをどのようにレジスタマシンの記述に変形するかについて学びました。
ここではこの変形をより複雑なプログラム上で実行します。\link{Section 4.1.1}--\link{Section 4.1.4}のメタ循環評価機です。
メタ循環評価機はSchemeインタプリタの振舞が手続き\code{eval}と\code{apply}と用いてどのように説明できるかを示しました。
この節で開発する\newterm{explicit-control evaluator}(\jnewterm{明示的制御評価機})は評価過程にて使用される
潜在的な手続き呼出と引数受け渡しの仕組みがレジスタとスタックの命令を用いてどのように説明できるかを
示します。付け加えて、明示的制御評価機はSchemeインタプリタの実装としての役割を果たすことができ、
従来の計算機の生来の機械語ととてもそっくりな言語で書かれています。この評価機は\link{Section 5.2}のレジスタ
マシンシミュレータにより実行することができます。あるいは、Scheme評価機の機械語実装を構築するための
開始点として使用することができます。またはSchemeの式を評価するための特殊用途の機械にすら使用できるでしょう。
\link{Figure 5.16}はそのようなハードウェア実装を示しています。Schemeの評価機として働くシリコンチップです。
このチップの設計者はこの節の中で説明される評価機に似たレジスタマシンに対するデータパスとコントローラの
仕様から開始しました。そしてIC(integrated-circuit、統合回路)を構築するための設計自動化プログラムを
使用しました。\footnote{このチップとその設計手法についてのより多くの情報については\link{Batali et al. 1982}を
参照して下さい。}

\begin{figure}[tb]
\phantomsection\label{Figure 5.16}
\centering
\begin{comment}
\heading{Figure 5.16:} A silicon-chip implementation of an evaluator for Scheme.

[A photograph of chip layout]

\end{comment}
\includegraphics[width=91mm]{fig/chap5/chip.jpg}
\par\bigskip
\noindent
\heading{Figure 5.16:} Scheme評価機のシリコンチップ実装
\end{figure}

\subsubsection*{レジスタと命令}

明示的制御評価機の設計では、私達のレジスタマシンで使用される命令を指定しなければなりません。
私達は\code{quoted?}や\code{make\-/procedure}のような手続きを用いることで抽象構文を用いたメタ循環評価機を
説明しました。レジスタマシンの実装においてはこれらの手続きを初歩的なリスト構造メモリの命令列に
展開することができました。そしてこれらの命令を私達のレジスタマシン上に実装しました。
しかし、これは私達の評価機の基本的な構造をその詳細によりわかりにくくしながら、とても長くして
しまいます。その表現を明快にするために、レジスタマシンのプリミティブな命令として
\link{Section 4.1.2}で与えられた構文手続きと環境を表現するための手続き、それに\link{Section 4.1.3}と\link{Section 4.1.4}で与えられた
実行時データを含めることにします。低レベルのマシン語でプログラミングできる、またはハードウェア
にて実装できる評価機の完全な仕様化を行うために、\link{Section 5.3}で説明したリスト構造の実装を用いて
これらの命令をより基本的な命令により置き換えることができるでしょう。

私達のScheme評価機レジスタマシンはスタックと7つのレジスタを含みます。
\code{exp}, \code{env}, \code{val}, \code{continue}, \code{proc}, \code{argl}, \code{unev}です。
\code{exp}は評価される式の保持に仕様され、\code{env}は評価がその中で実行される環境を
持ちます。評価の終わりには、\code{val}が指定された環境における式の評価により
得られた値を保持します。\code{continue}レジスタは\link{Section 5.1.4}で説明されたように
再帰の実装に用いられます。(評価機はそれ自身を再帰的に呼び出す必要があります。
式の評価はその部分式の評価を必要とするためです)。レジスタ\code{proc}, \code{argl}, \code{unev}は
組み合わせの評価に用いられます。

私達はデータパス図を評価機のレジスタと命令がどのように接続されているかを示すために
提供はしません。また機械の命令の完全なリストの提供も行ないません。これらは評価機の
コントローラに暗黙的に存在し、コントローラの詳細が与えられます。



\subsection{明示制御評価機の核}
\label{Section 5.4.1}

評価機の中心的な要素は\code{eval\-/dispatch}で始まる命令列です。これは\link{Section 4.1.1}で説明された
メタ循環評価機の\code{eval}手続きに対応します。コントローラが\code{eval\-/dispatch}から開始する時、
\code{exp}により指定された式を、\code{env}により指定された環境にて評価します。
評価が完了した時には、コントローラは\code{continue}に格納されたエントリポイントに飛びます。
その時、\code{val}レジスタが式の値を保持しています。メタ循環の\code{eval}と同様に、
\code{eval\-/dispatch}の構造は評価される式の構文型上の事例分析です。\footnote{私達のコントローラに
おいては、ディスパッチ(dispatch、割り振り)は\code{test}と\code{branch}の命令列として書かれています。
代替法として、データ主導スタイルで書くこともできるでしょう(そして実際のシステムは恐らくそうされて
いるでしょう)。連続したテストの実行の必要を防ぎ、新しい式の型の定義を用意にするためです。
Lispを実行するように設計された機械は恐らく\code{dispatch\-/on\-/type}命令を含むことでしょう。
これはそのようなデータに従った割り振りを効率的に実行します。}

\begin{scheme}
eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
\end{scheme}

\subsubsection*{単純な式の評価}

数値と文字列(これらは自己評価です)、変数、クォーテーション、そして\code{lambda}式は
評価するべき部分式がありません。これらのために、評価機は単純に正しい値を\code{val}レジスタに
配置し、\code{continue}により指定されたエントリポイントから実行を継続します。
単純な式の評価は以下のコントローラのコードにより実行されます。

\begin{scheme}
ev-self-eval
  (assign val (reg exp))
  (goto (reg continue))
ev-variable
  (assign 
    val (op lookup-variable-value) (reg exp) (reg env))
  (goto (reg continue))
ev-quoted
  (assign val (op text-of-quotation) (reg exp))
  (goto (reg continue))
ev-lambda
  (assign unev (op lambda-parameters) (reg exp))
  (assign exp (op lambda-body) (reg exp))
  (assign val (op make-procedure)
              (reg unev) (reg exp) (reg env))
  (goto (reg continue))
\end{scheme}

\noindent
\code{ev\-/lambda}がどのように\code{unev}と\code{exp}レジスタを用いてラムダ式のパラメタと
ボディを保持し、\code{env}の中の環境と共に\code{make\-/procedure}命令に引き渡されるのか観察して下さい。

\subsubsection*{手続き適用の評価}

手続きの適用は演算子とオペランドを含む組み合わせにより指定します。
演算子はその値が手続きとなる部分式であり、オペランドはその値が引数となる部分式で、
その引数に対して手続きが適用されねばなりません。メタ循環の\code{eval}は適用をそれ自身を
再帰的に呼び出すことで扱い、組み合わせの各要素を評価し、そして結果を\code{apply}に渡します。
これが実際の手続き適用を実行します。明示的制御評価機も同じことを行います。
これらの再帰呼出は\code{goto}命令と共に、スタックを使用して再帰呼出から戻った時に
再格納されるようにレジスタを保存することで実装されます。各呼出の前にどのレジスタが
保存されなければならないのかの確認に注意をしなければなりません。(なぜならこれらの値が
後で必要になるからです)。\footnote{これは重要ですが、アルゴリズムをLispの様な手続き型の言語から
レジスタマシンの言語へ翻訳する場合において微妙な点です。必要な物だけを保存することの
代替法として、各再帰呼出の前に全てのレジスタ(\code{val}を除く)を保存することもできます。
これは\newterm{framed-stack}(\jnewterm{スタックフレーム})の統制と呼ばれます。これはうまく行きますが
しかし必要以上のレジスタを保存します。このことはスタック命令が高価であるというシステム内の
懸念点に成り得ます。後に使用される必要のないレジスタの保存はまた使用価値の無いデータを
手放さないことにも成り得ます。これはそうでなければガベージコレクションされ、再使用される
ために領域が解法されたはずです。}

適用の評価は演算子を評価し手続きを生成することから開始します。手続きは後に評価された
オペランドに適用されます。演算子を評価するためには、それを\code{exp}レジスタに
移動させ、\code{eval\-/dispatch}へ飛びます。\code{env}レジスタ内の環境は既にその中で演算子を
評価するために適切な物になっていますが、それでも\code{env}を保存します。オペランドの評価にも
必要なためです。またオペランドを\code{unev}の中に展開し、スタック上にこれを保存します。
\code{continue}に対し\code{eval\-/dispatch}が演算子の評価が完了した後に\code{ev\-/appl\-/did\-/operator}にて
resume(再開)できるように設定します。しかし、最初に\code{continue}の古い値は保存します。
これがコントローラに対し適用後にどこから続行するのかを告げるためです。

\begin{scheme}
ev-application
  (save continue)
  (save env)
  (assign unev (op operands) (reg exp))
  (save unev)
  (assign exp (op operator) (reg exp))
  (assign continue (label ev-appl-did-operator))
  (goto (label eval-dispatch))
\end{scheme}

\noindent
演算子部分式の評価からの帰還すると、組み合わせのオペランドの評価と、
結果としての引数を\code{argl}に保持されるリストの中への蓄積へと進みます。
最初に未評価のオペランドと環境を戻します。\code{argl}を空リストに初期化します。
そして\code{proc}レジスタに演算子の評価により生成された手続きを割り当てます。
もしオペランドが無ければ、直接\code{apply\-/dispatch}へと進みます。そうでなければ、
\code{proc}をスタックに保存し引数評価ループを開始します。\footnote{
\link{Section 4.1.3}の評価機データ構造の手続きに以下の2つの手続きを引数リストの操作のために追加します。

\begin{smallscheme}
(define (empty-arglist) '())
(define (adjoin-arg arg arglist) (append arglist (list arg)))
\end{smallscheme}


また追加の構文手続きを使用して組み合わせの最後のオペランドであるかのテストを行います。

\begin{smallscheme}
(define (last-operand? ops) (null? (cdr ops)))
\end{smallscheme}
}

\begin{scheme}
ev-appl-did-operator
  (restore unev)                       ~\textrm{; the operands}~
  (restore env)
  (assign argl (op empty-arglist))
  (assign proc (reg val))              ~\textrm{; the operator}~
  (test (op no-operands?) (reg unev))
  (branch (label apply-dispatch))
  (save proc)
\end{scheme}

\noindent
引数評価ループの各サイクルは\code{unev}の中のリストからオペランドを評価し、その結果を\code{argl}の
中に蓄積します。オペランドを評価するために、それを\code{exp}レジスタの中に入れ、
実行が引数蓄積段階から再開できるよう\code{continueを}設定した後に\code{eval\-/dispatch}に飛びます。
しかし、最初に私達はそれまでに(\code{argl}に保持されている)蓄積された引数、環境(\code{env}に維持)、
評価されていない残りのオペランド(\code{unev}が保持)を保存します。最後のオペランドの評価は
特別な場合として扱われ\code{ev\-/appl\-/last\-/arg}により取り扱われます。

\begin{scheme}
ev-appl-operand-loop
  (save argl)
  (assign exp (op first-operand) (reg unev))
  (test (op last-operand?) (reg unev))
  (branch (label ev-appl-last-arg))
  (save env)
  (save unev)
  (assign continue (label ev-appl-accumulate-arg))
  (goto (label eval-dispatch))
\end{scheme}

\noindent
オペランドが評価された時に、その値は\code{argl}にて保持されるリストの中に蓄積されます。
そのオペランドはその後\code{unev}中の未評価オペランドのリストから消され、引数評価が
続行されます。

\begin{scheme}
ev-appl-accumulate-arg
  (restore unev)
  (restore env)
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (assign unev (op rest-operands) (reg unev))
  (goto (label ev-appl-operand-loop))
\end{scheme}

\noindent
最後の引数の評価は異なる扱いを受けます。環境や未評価のオペランドのリストを
\code{eval\-/dispatch}に飛ぶ前に保存する必要がありません。最後のオペランドが評価された後に
それらは必要が無いためです。従って評価から特別なエントリポイント\code{ev\-/appl\-/accum\-/last\-/arg}に
帰ります。これは引数リストを戻し、新しい引数を蓄積し、保存された手続きを戻し、適用
を実行するために飛びます。\footnote{最後のオペランドの処理の特別な最適化は
\newterm{evlis tail recursion}(\jnewterm{エブリス末尾再帰})として知られています(\link{Wand 1980}参照)。
最初のオペランドも特別な場合とすれば、私達は引数評価ループをいくらかより効率的良くできたでしょう。
これは\code{argl}の初期化を最初のオペランドの評価の後まで延期することができ、この場合に\code{argl}を
保存することを防げたでしょう。\link{Section 5.5}のコンパイラはこの最適化を実行します。
(\link{Section 5.5.3}の\code{construct\-/arglist}手続きと比較して下さい。)}

\begin{scheme}
ev-appl-last-arg
  (assign continue (label ev-appl-accum-last-arg))
  (goto (label eval-dispatch))
ev-appl-accum-last-arg
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (restore proc)
  (goto (label apply-dispatch))
\end{scheme}

\noindent
引数評価ループの詳細はインタプリタが組み合わせのオペランドを評価する順を決定します。(例えば、
左から右や右から左---\link{Exercise 3.8}参照)。この順はメタ循環評価機では決定されません。
メタ循環評価機はその制御構造をその基礎を成し実装を行うSchemeから継承します。\footnote{メタ循環評価機の
オペランドの評価順は\link{Section 4.1.1}の手続き\code{list\-/of\-/values}内の\code{cons}への引数の評価順により決定されます
(\link{Exercise 4.1}参照)。}(\code{ev\-/appl\-/operand\-/loop}内で一連のオペランドを\code{unev}から抽出するために使用された)
\code{first\-/operand}セレクタは\code{car}として実装され、\code{rest\-/operands}は\code{cdr}として実装され、
明示的制御評価機は組み合わせのオペランドを左から右への順で評価します。

\subsubsection*{手続き適用}

エントリポイント\code{apply\-/dispatch}はメタ循環評価機の\code{apply}手続きに対応します。
\code{apply\-/dispatch}に到達する時に、\code{proc}レジスタは適用するための手続きを持ち、
\code{argl}は適用するべき評価された引数のリストを持ちます。
(元々は\code{eval\-/dispatch}に渡され、\code{ev\-/application}で保存された)\code{continue}の保存された値は
手続き適用の結果と共に帰る場所を伝えますが、スタック上に存在します。適用が完了した時に、
コントローラは保存された\code{continue}により指示されたエントリポイントへ、\code{val}内の
適用の結果と共に移動します。メタ循環の\code{apply}と同様に、考慮すべき2つの場合が存在します。
適用すべき手続きはプリミティブであるか、または複合手続きであるかです。

\begin{scheme}
apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))
  (branch (label compound-apply))
  (goto (label unknown-procedure-type))
\end{scheme}

\noindent
各プリミティブは引数を\code{argl}から取得し、その結果を\code{val}内に置くように実装されていると
想定されます。機械がどのようにプリミティブを扱うかを指定するためには、それぞれのプリミティブを
実装するための一連のコントローラ命令を提供しなければならず、\code{proc}の中身により判別された
プリミティブのための命令への割り振りを行うように\code{primitive\-/apply}を準備しなければなりません。
私達はプリミティブの詳細ではなく、評価処理の構造に興味があるため、それらの代わりに
単に\code{apply\-/primitive\-/procedure}を使用します。これは\code{proc}内の手続きを\code{argl}内の引数に対して
適用します。\link{Section 5.2}のシミュレータを用いて評価機のシミュレーションを行う目的のために、
私達は手続き\code{apply\-/primitive\-/procedure}を使用します。これは根底にあるSchemeシステムを
適用を実行するために呼び出します。私達が\link{Section 4.1.4}のメタ循環評価機で行ったのと全く同じです。
プリミティブの適用の値を計算した後に、\code{continue}を戻して指定されたエントリポイントに飛びます。

\begin{scheme}
primitive-apply
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
  (restore continue)
  (goto (reg continue))
\end{scheme}

\noindent
複合手続きを適用するためには、メタ循環評価機と全く同様に進行します。
手続きのパラメタを引数に束縛するフレームを構築し、このフレームを用いて手続きにより
運ばれた環境を拡張し、この拡張環境の中で手続きのボディを形成する式の列を評価します。
\link{Section 5.4.2}で説明される\code{ev\-/sequence}は列の評価を取り扱います。

\begin{scheme}
compound-apply
  (assign unev (op procedure-parameters) (reg proc))
  (assign env (op procedure-environment) (reg proc))
  (assign env (op extend-environment)
              (reg unev) (reg argl) (reg env))
  (assign unev (op procedure-body) (reg proc))
  (goto (label ev-sequence))
\end{scheme}

\noindent
\code{compound\-/apply}は\code{env}レジスタが新しい値を割り当てられるインタプリタ内で唯一の場所です。
メタ循環評価機と同様に、新しい環境は手続きにより運ばれた環境から引数リストと対応する束縛される
変数のリストと共に構築されます。

\subsection{列の評価と末尾再帰}
\label{Section 5.4.2}

明示的制御評価機の\code{ev\-/sequence}の部分はメタ循環評価機の\code{eval\-/sequence}手続きと同等です。
手続きのボディ内の式、または明示的な\code{begin}式内の列を取り扱います。

明示的な\code{begin}式は\code{unev}内に評価されるべき式の列を配置し、\code{continue}をスタック上に保存し、
\code{ev\-/sequence}に飛ぶことで評価されます。

\begin{scheme}
ev-begin
  (assign unev (op begin-actions) (reg exp))
  (save continue)
  (goto (label ev-sequence))
\end{scheme}

\noindent
手続きのボディ内の暗黙的な列は\code{compound\-/apply}から\code{ev\-/sequence}へと飛ぶことで
扱われます。この時点で\code{continue}は既に\code{ev\-/application}で保存され、スタック上に存在します。

\code{ev\-/sequence}と\code{ev\-/sequence\-/continue}のエントリポイントはループを形成し、
連続して列内の各式を評価します。未評価の式のリストは\code{unev}に保持されています。
各式の評価の前に、列内にさらなる評価すべき式が存在しないかどうか確認します。
もしそうであれば、(\code{unev}に保持された)未評価の式の残りと、(\code{env}に保持された)
式の残りが評価される環境を保存し、その式を評価するために\code{eval\-/dispatch}を呼びます。
2つの保存されたレジスタはこの評価からの帰還時に\code{ev\-/sequence\-/continue}にて戻されます。

列内の最後の式は\code{ev\-/sequence\-/last\-/exp}にて異なる取扱を行います。
この後には評価すべき式は無いため、\code{unev}と\code{env}を\code{eval\-/dispatch}に行く前に
保存する必要はありません。列全体の値は最後の式の値であるため、最後の式の評価の後に
スタック上に現時点で保存されている(\code{ev\-/application}または\code{ev\-/begin}にて保存された)
エントリポイントから続行すること以外に必要なことはありません。
\code{continue}を設定して\code{eval\-/dispatch}からここに帰るように準備し、次にスタックから
\code{continue}の値を戻してそのエントリポイントから続行するのではなく、\code{eval\-/dispatch}へ
行く前にスタックから\code{continue}を戻します。そうすることで\code{eval\-/dispatch}は
式を評価した後にそのエントリポイントから続行します。

\begin{scheme}
ev-sequence
  (assign exp (op first-exp) (reg unev))
  (test (op last-exp?) (reg unev))
  (branch (label ev-sequence-last-exp))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-last-exp
  (restore continue)
  (goto (label eval-dispatch))
\end{scheme}

\subsubsection*{末尾再帰}


\link{Chapter 1}にて以下のような手続きにより記述されるプロセスは、

\begin{scheme}
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
\end{scheme}

\noindent
反復プロセスだと述べました。例えこの手続きが構文的に(それ自身の単語の定義において)再帰であっても、
論理的には評価機にとって、1つの\code{sqrt\-/iter}の呼出から次の呼出への横断において情報を保存する
必要がありません。\footnote{\link{Section 5.1}にてそのようなプロセスをどのようにスタックを持たない
レジスタマシンにて実装するのかを学びました。プロセスの状態は固定長のレジスタ集合に格納されます。}
\code{sqrt\-/iter}のような手続きを、手続きがそれ自身を呼び出すことを続けるに従い記憶域を増加させる
必要無しに実行することが可能な評価機は、\newterm{tail-recursive}(\jnewterm{末尾再帰})評価機と呼ばれます。
\link{Chapter 4}のメタ循環評価機の実装は評価機が末尾再帰であるかどうかを指定しませんでした。
その評価機が状態を保存するための仕組みをその基礎に横たわるSchemeから継承していたためです。
しかし明示的制御評価機と用いる場合、私達は評価の過程を追跡し、いつ手続き呼出が正味の情報集積を
スタック上に引き起すのかを確認することができます。

私達の評価機は末尾再帰です。なぜなら列の最後の式を評価するために、スタック上に
何の情報も保存すること無く\code{eval\-/dispatch}へと直接飛びます。従って、
列の最後の式---例えもしそれが手続き呼出であっても(\code{sqrt\-/iter}のように、手続きのボディの最後の
式が\code{if}式であっても、\code{sqrt\-/iter}への呼出へと簡約されます)---の評価がスタック上に
何の情報の蓄積も起こしません。\footnote{この\code{ev\-/sequence}における末尾再帰の実装は
多くのコンパイラで使用されている良く知られた最適化の技術の一種です。手続き呼出で
終了する手続きのコンパイルでは、呼出を呼び出された手続きのエントリポイントへのジャンプで
置き換えることができます。この節で行ったように、この戦略をインタプリタの中に構築することは
言語の至る所に均一に最適化を提供します。}

もしこの場合に情報を保存する必要が無いという事実を活用することを考えなかった場合、
列内の全ての式を同じように取り扱うように\code{eval\-/sequence}を実装していたことでしょう。
レジスタの保存、式の評価、レジスタを戻すために帰る、これらを全ての式が評価されるまで
繰り返したことでしょう。\footnote{We can
define \code{no\-/more\-/exps?} as follows:

\code{no\-/more\-/exps?}を以下のように定義することができます。

\begin{smallscheme}
(define (no-more-exps? seq) (null? seq))
\end{smallscheme}
}

\begin{scheme}
ev-sequence
  (test (op no-more-exps?) (reg unev))
  (branch (label ev-sequence-end))
  (assign exp (op first-exp) (reg unev))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-end
  (restore continue)
  (goto (reg continue))
\end{scheme}

\noindent
恐らくこれは列の評価のための以前のコードに対する軽微な変更のように見えるでしょう。
唯一の違いは保存と再格納のサイクルを他と同様に列の最後の式でも通すことです。
インタプリタは依然としてどの式に対しても同じ値を与えます。しかし、この変更は
末尾再帰の実装に対しては致命的です。なぜなら、これで私達は列の最後の式の評価の後にも
(使用価値の無い)レジスタの保存を戻すために帰らねばなりません。
これらの余分な保存は入れ子の手続きの呼出の間で蓄積されます。その結果として、\code{sqrt\-/iter}の
ようなプロセスは一定容量を必要とするのでなく、繰り返しの回数に比例する記憶域を必要と
します。この違いは重大事に成り得ます。例えば、末尾再帰を用いれば、無限ループは
手続き呼出の仕組みだけを用いて表現できます。

\begin{scheme}
(define (count n)
  (newline) (display n) (count (+ n 1)))
\end{scheme}

\noindent
末尾再帰が無ければ、そのような手続きはいつかはスタック領域を使いつくします。
そして真に反復を表現することは手続き呼出以外の何らかの制御の仕組みを必要とします。

\subsection{条件文、代入、定義}
\label{Section 5.4.3}

メタ循環評価機と同様に、特殊形式は選択的に式の部分部分を評価することで取り扱われます。
\code{if}式に対しては、述語を評価して、その値を元に、結果部(consequent)と代替部(alternative)の
どちらを評価するか決定します。

述語を評価する前に、\code{if}式自身を保存します。そうすることで後に結果部か代替部を抽出することが
できます。また後に結果部か代替部を評価するため必要となるので環境を保存します。
そして後に\code{if}の値を待っている式の評価に戻るために必要なため\code{continue}も保存します。

\begin{scheme}
ev-if
  (save exp)                    ~\textrm{; 後のため式を保存する}~
  (save env)
  (save continue)
  (assign continue (label ev-if-decide))
  (assign exp (op if-predicate) (reg exp))
  (goto (label eval-dispatch))  ~\textrm{; 述語を評価する}~
\end{scheme}

\noindent
述語の評価から戻る時、真か偽であるかをテストし、結果に依り\code{eval\-/dispatch}に飛ぶ前に
\code{exp}に結果部か代替部を配置します。\code{env}と\code{continue}をここで戻すことが
\code{eval\-/dispatch}に正しい環境を持たせ、正しい場所から継続し\code{if}式の値を受けとるように
設定していることに注意して下さい。

\begin{scheme}
ev-if-decide
  (restore continue)
  (restore env)
  (restore exp)
  (test (op true?) (reg val))
  (branch (label ev-if-consequent))
ev-if-alternative
  (assign exp (op if-alternative) (reg exp))
  (goto (label eval-dispatch))
ev-if-consequent
  (assign exp (op if-consequent) (reg exp))
  (goto (label eval-dispatch))
\end{scheme}

\subsubsection*{代入と定義}

代入と定義は\code{ev\-/assignment}により扱われます。ここには\code{eval\-/dispatch}から代入式が\code{exp}の
中にある状態で到達します。\code{ev\-/assignment}の最初のコードは式の部分の値を評価し、次に
新しい値を環境に導入します。\code{Set\-/variable\-/value!}が機械語命令として必要可能であると
前提します。

\begin{scheme}
ev-assignment
  (assign unev (op assignment-variable) (reg exp))
  (save unev)                   ~\textrm{; 後のため変数を保存}~
  (assign exp (op assignment-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-assignment-1))
  (goto (label eval-dispatch))  ~\textrm{; 代入値を評価する}~
ev-assignment-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op set-variable-value!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
\end{scheme}

\noindent
定義も同様に扱われます。

\begin{scheme}
ev-definition
  (assign unev (op definition-variable) (reg exp))
  (save unev)                   ~\textrm{; 変数を後のため保存}~
  (assign exp (op definition-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-definition-1))
  (goto (label eval-dispatch))  ~\textrm{; 定義値を評価する}~
ev-definition-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op define-variable!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.23}Exercise 5.23:}
評価機を拡張し、\code{cond}, \code{let}, 等の派生式を取り扱うようにせよ(\link{Section 4.1.2})。
\code{cond\-/>if}の様な構文変換器が機械語命令として使用可能と前提して``インチキ''しても良い。\footnote{これは
本当はインチキではありません。実際のゼロからの実装においても、Schemeを解釈する明示的制御評価機を用いて
\code{cond\-/>if}のようなソースレベル変換を実行前の構文フェーズにて実行するでしょう。}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.24}Exercise 5.24:}
\code{cond}を新しい基本的な特殊形式として\code{if}に簡約すること無しに実装せよ。
連続する\code{cond}節の述語を真になるものを見つけるまでテストするループを構築する必要がある。
次に\code{ev\-/sequence}を使用してその節のアクションを評価する。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.25}Exercise 5.25:}
評価機を変更し、\link{Section 4.2}の遅延評価機を基にした正規順評価を使用するようにせよ。
\end{quote}

\subsection{評価機を実行する}
\label{Section 5.4.4}

明示的制御評価機の実装と共に、私達は\link{Chapter 1}から始まった開発の終わりにやってきました。
ここまで私達は引き続きより的確な評価過程のモデルを探求してきました。比較的、略式な
置換モデルから開始し、次にこれを\link{Chapter 3}で環境モデルに拡張しました。これは
状態と変更を扱うことを可能にしました。\link{Chapter 4}のメタ循環評価機ではScheme自身を
式の評価の間に構築される、より明確な環境構造のための言語として使用しました。
ここでは、レジスタマシンを用いてメモリ管理、引数渡し、制御のための評価機の仕組みについて
つぶさに見てきました。それぞれの新しいレベルの説明にて、直前の、明確さで劣る評価処理の
見ることはできない曖昧さに関して問題を提起し、解決する必要がありました。
明示的制御評価機の振舞を理解するために、そのシミュレーションを行い、パフォーマンスを
監視することができます。

私達の評価機にドライバループを導入します。これは\link{Section 4.1.4}の\code{driver\-/loop}手続きの
役割を果たします。この評価機は繰り返しプロンプトを表示し、式を読み込み、\code{eval\-/dispatch}へ
飛ぶことで式を評価し、結果を表示します。以下の命令は明示的制御評価機のコントローラシーケンスの
開始を形づくります。\footnote{
ここでは\code{read}と多様な表示命令がプリミティブな機械語命令として
使用可能であると前提します。このことは私達のシミュレーションには便利ですが、実際には完全に
非現実的です。これらは本当はかなり複雑な命令です。実際には、それらは単一の文字を端末との間で
双方向に転送するような低レベルの入出力命令を用いて実装されるでしょう。


\code{get\-/global\-/environment}命令をサポートするためには以下を定義します。

\begin{smallscheme}
(define the-global-environment (setup-environment))
(define (get-global-environment) the-global-environment)
\end{smallscheme}
}

\begin{scheme}
read-eval-print-loop
  (perform (op initialize-stack))
  (perform
   (op prompt-for-input) (const ";;EC-Eval input:"))
  (assign exp (op read))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (label eval-dispatch))
print-result
  (perform (op announce-output) (const ";;EC-Eval value:"))
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
\end{scheme}

\noindent
手続きの中で(\code{apply\-/dispatch}で指摘される``未知の手続き型エラー''の様な)エラーに遭遇した時、
エラーメッセージを表示し、ドライバループへと戻ります。\footnote{インタプリタに取り扱って
欲しいと願うかもしれない他のエラーも存在します。しかしこれらはあまり単純ではありません。
\link{Exercise 5.30}を参照して下さい。}

\begin{scheme}
unknown-expression-type
  (assign val (const unknown-expression-type-error))
  (goto (label signal-error))
unknown-procedure-type
  (restore continue)    ~\textrm{; clean up stack (from \code{apply\-/dispatch})}~
  (assign val (const unknown-procedure-type-error))
  (goto (label signal-error))
signal-error
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
\end{scheme}

\noindent
シミュレーションの目的のために、ドライバループを通る度にスタックを初期化します。
(未定義変数の様な)エラーが評価を割り込みした後には空でない可能性があるためです。\footnote{スタックの
初期化をエラーの後にのみ行うことも可能でしょう。しかしドライバループの中で行うことは
評価機のパフォーマンスを監視するために便利です。この先で説明されます。}

\link{Section 5.4.1}から\link{Section 5.4.4}の間のコードの断片を組合せれば、\link{Section 5.2}のレジスタマシン
シミュレータを用いて実行することができる評価機の機械モデルを作ることができます。

\begin{scheme}
(define eceval
  (make-machine
   '(exp env val proc argl continue unev)
   eceval-operations
   '(read-eval-print-loop
     ~\( \dark \langle \)~~\emph{entire machine controller as given above}~~\( \dark \rangle \)~ )))
\end{scheme}

\noindent
評価機によりプリミティブとして使用される命令をシミュレートするためのScheme手続きを定義しなければなりません。
これらは\link{Section 4.1}でメタ循環評価機のために使用したものと同じ手続きと、\link{Section 5.4}の至る所の脚注にて
定義されたいくつかの追加の物があります。

\begin{scheme}
(define eceval-operations
  (list (list 'self-evaluating? self-evaluating)
        ~\( \dark \langle \)~~\emph{complete list of operations for eceval machine}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
最後に、グローバル環境を初期化し、評価機を実行します。

\begin{scheme}
(define the-global-environment (setup-environment))
(start eceval)
~\textit{;;; EC-Eval input:}~
(define (append x y)
  (if (null? x) y (cons (car x) (append (cdr x) y))))
~\textit{;;; EC-Eval value:}~
~\textit{ok}~
~\textit{;;; EC-Eval input:}~
(append '(a b c) '(d e f))
~\textit{;;; EC-Eval value:}~
~\textit{(a b c d e f)}~
\end{scheme}

\noindent
もちろん、この方法の式の評価はSchemeに直接入力した場合よりもずっと長くかかります。
複数レベルのシミュレーションが関与するためです。式は明示的制御評価器の機械により評価されます。
これはSchemeプログラムによりシミュレートされ、Schemeプログラム自身はSchemeインタプリタにより
評価されています。

\subsubsection*{評価機のパフォーマンスの監視}

シミュレーションは評価器の実装を案内するのに強力なツールです。
シミュレーションはレジスタマシンの設計の多様性を探求することだけでなく、シミュレートされた
評価器のパフォーマンスを観察することも簡単にします。例えば、パフォーマンスにおける
1つの重要な要因はどれだけ効率良く評価機がスタックを使用するかがあります。
スタック利用上の統計を集めるシミュレータの版を用いて評価機のレジスタマシンを設計することと、
評価機の\code{print\-/result}エントリポイントに統計を表示する命令を追加することでにより、
様々な式を評価するのに必要とされるスタック命令の数を観察することができます(\link{Section 5.2.4})。

\begin{scheme}
print-result
  (perform (op print-stack-statistics))   ~\textrm{; 追加された命令}~
  (perform
   (op announce-output) (const ";;; EC-Eval value:"))
  ~\( \dots \)~ ~\textrm{; 以前と同じ}~
\end{scheme}

\noindent
評価機との応答はこれで以下のように見えます。

\begin{scheme}
~\textit{;;; EC-Eval input:}~
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
~\textit{(total-pushes = 3 maximum-depth = 3)}~
~\textit{;;; EC-Eval value:}~
~\textit{ok}~
~\textit{;;; EC-Eval input:}~
(factorial 5)
~\textit{(total-pushes = 144 maximum-depth = 28)}~
~\textit{;;; EC-Eval value:}~
~\textit{120}~
\end{scheme}

\noindent
評価機のドライバループが全ての応答の開始にスタックを再度初期化することに注意して下さい。
それにより表示された統計は直前の式の評価のために使用されたスタック命令のみを参照します。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.26}Exercise 5.26:}
監視付きのスタックを用いて評価機(\link{Section 5.4.2})の末尾再帰の特性を調査せよ。
評価機を開始し、\link{Section 1.2.1}の反復\code{factorial}手続きを定義せよ。

\begin{scheme}
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product) (+ counter 1))))
  (iter 1 1))
\end{scheme}


手続きをいくつかの\( n \)の小さな値で実行せよ。これらの値に対する\( n! \)を求めるのに必要な
最大スタック深度とpushの数を記録せよ。

\begin{enumerate}[a]

\item
\( n! \)を評価するために必要な最大深度が\( n \)から独立していることを発見するだろう。
この深さは何か?

\item
あなたのデータから任意の\( n \ge 1 \)に対して\( n! \)を評価するのに使用されるpush命令の
総数を求める\( n \)の方程式を求めよ。使用される命令数は\( n \)の線形関数であり、従って
2つの定数から決定されることに注意せよ。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.27}Exercise 5.27:}
\link{Exercise 5.26}との比較として、以下の階乗を再帰的に求める手続きの振舞を調査せよ。

\begin{scheme}
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
\end{scheme}

この手続きを監視付きのスタックを用いて実行し、任意の\( n \ge 1 \)に対して\( n! \)を
評価するために使用される、スタックの最大深度とプッシュの総数を\( n \)の関数として求めよ。
(再び、これらの関数は線形になる)。あなたの経験を以下の表に適切な\( n \)の式を埋めることで
まとめよ。
\begin{comment}

\begin{example}
               Maximum depth       Number of pushes

Recursive
factorial

Iterative
factorial
\end{example}

\end{comment}
\begin{displaymath}
\vbox{
\offinterlineskip
\halign{
\strut 	\hfil \quad #\quad \hfil & \vrule 
	\hfil \quad #\quad \hfil & \vrule
	\hfil \quad #\quad \hfil \cr

				& 最大深度 & pushの総数 \cr
	\noalign{\hrule}
	再帰      		&  		&  \cr
	階乗      		&  		&  \cr
	\noalign{\hrule}
	反復      		&  		&  \cr
	階乗      		&  		&  \cr
}
}
\end{displaymath}
最大深度は演算の実行において評価機により使用された記憶域の量の尺度である。
pushの総数は必要な時間に良く関連している。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.28}Exercise 5.28:}
\link{Section 5.4.2}にて説明されているように\code{eval\-/sequence}を変えることで評価機の定義を変更し、
評価機がもはや末尾再帰ではないようにせよ。\link{Exercise 5.26}と\link{Exercise 5.27}の
実験を再実行し、\code{factorial}手続きの両版が今では必要とされる記憶域がそれらの入力に対し
線形に増加することを実演せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.29}Exercise 5.29:}
木再帰フィボナッチ数の演算におけるスタック命令を監視せよ。

\begin{scheme}
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
\end{scheme}

\begin{enumerate}[a]

\item
\( n \ge 2 \)に対して\( {\rm Fib}(n) \)を求まる場合に必要なスタックの最大深度に
対する\( n \)の方程式を与えよ。ヒント：\link{Section 1.2.2}において私達は
この処理により使用される記憶域は\( n \)に対し線形に増加することを議論した。

\item
\( n \ge 2 \)に対して\( {\rm Fib}(n) \)を求めるのに使用されたpushの総数に対する
方程式を与えよ。(費やされた時間に良く関連する)pushの総数は\( n \)の指数関数的に
増加することを見付けなければならない。ヒント：\( S(n) \)を\( {\rm Fib}(n) \)を
求めるのに使用されたpushの総数とせよ。\( S(n - 1) \), \( S(n - 2) \), それにある
固定の``オーバヘッド''として\( n \)から独立した定数\( k \)を用いて\( S(n) \)を
表現する方程式が存在することを主張することができるはずだ。方程式を与えて、\( k \)が
何であるかを述べよ。次に\( S(n) \)が\( a\cdot{\rm Fib}(n + 1) + b \)として表現できる
ことを示し、\( a \)と\( b \)の値を与えよ。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.30}Exercise 5.30:}
私達の評価機は現在は2つの種類のエラー---未知の型の式と未知の型の手続き---のみを発し
キャッチする。他のエラーは評価機のREPLから抜けてしまう。評価機をレジスタマシン
シミュレータを用いて実行した時に、これらのエラーはその下に横たわるSchemeシステムに
よりキャッチされるこれはユーザプログラムがエラーを発生させた時にコンピュータが
強制終了するのと同様である。\footnote{残念ながら、C言語のような従来のコンパイラベース
言語システムにおいてはこれが普通の状況です。\acronym{UNIX}(tm)ではシステムは
``コア(core)をダンプ(dump)''し、\acronym{DOS}/Windows(tm)ではcatatonic(硬まる、フリーズ)します。
Macintosh(tm)は---もしラッキーな場合は---爆発する爆弾の絵を表示しコンピュータをリブートするよう提案します。}
本物のエラーシステムを働かせることは大きなプロジェクトである。しかし、ここで
何が関与しているのかを理解する努力には大きな価値がある。

\begin{enumerate}[a]

\item
未定義の変数にアクセスを試すような評価プロセスで発生するエラーはlookup命令を
変更し識別可能な状態コードを返すように変更することで捕まえることができるだろう。
状態コードは全てのユーザ変数が取り得ない値でなければならない。評価機はこの状態コードに対し
テストを行い、\code{signal\-/error}に飛ぶために必要なことを行う。評価機の中でそのような
変更が必要な全ての箇所を見つけ修正せよ。これはとても大変な作業だ。

\item
ゼロで割ることやシンボルから\code{car}を抽出するような試行により、プリミティブな
手続きの適用上で発せられるエラーの取り扱いの問題はずっと酷い物だ。
専門的に記述された高品質なシステムにおいては、プリミティブの適用全てはプリミティブの
一部として安全性が確認されている。例えば全ての\code{car}の呼出は最初に引数がペアであるかを
確認する。もし引数がペアでなければ、適用は区別可能な状態コードを評価機に返す。すると
評価機は失敗を報告する。私達はこれを私達のレジスタマシンシミュレータに全てのプリミティブ
手続きの適用性チェックを行い適切な識別可能な状態コードを失敗時に返すようにすることで
手筈を整えることができるだろう。すると評価機の\code{primitive\-/apply}コードが状態コードを
チェックし必要なら\code{signal\-/error}へ飛ぶことができる。この構造を構築し、働くようにせよ。
これは巨大なプロジェクトである。

\end{enumerate}
\end{quote}

\section{コンパイル}
\label{Section 5.5}

\link{Section 5.4}の明示的制御評価機はコントローラがSchemeプログラムを解釈するレジスタマシンです。
この節ではSchemeプログラムをコントローラがSchemeインタプリタではないレジスタマシン上にて
どのように実行するのかについて学びます。

明示的制御評価機械は普遍的です。Schemeで記述できるどんな演算プロセスも実行できます。
評価機のコントローラは望んだ演算を実行するためのデータパスの使用を調整します。
従って、評価機のデータパスは普遍的です。適切なコントローラを与えられた場合に、
私達が望む任意の演算を実行するのに十分です。\footnote{これは理論的な発言です。
この評価機のデータパスが一般的なコンピュータのために特に便利な、または効率的な
データパスの集合であると主張している訳ではありません。例えば、これらは高いパフォーマンスの
浮動小数点演算や、激しくビットベクタを操作する演算の実装にはあまり向いていません。}

商業上の汎用なコンピュータはレジスタと効率的で便利なデータパスの普遍的な集合を
構成する命令の周りに構築されるレジスタマシンです。汎用目的の機械は私達がここまで
使用しているようなレジスタマシン言語のためのインタプリタです。この言語は
機械の\newterm{native language}(\jnewterm{ネイティブ言語})、または単純に\newterm{machine language}(\jnewterm{機械語})と
呼ばれます。機械語で記述されたプログラムはその機械のデータパスを用いた命令列です。
例えば、明示的制御評価機の命令列は専門のインタプリタマシンのためのコントローラではなく、
汎用目的のコンピュータのための機械語プログラムだと考えることができます。

2つの共通な戦略が高水準の言語とレジスタマシンの言語の間のギャップを橋渡しします。
明示的制御評価機は逐次翻訳(interpretation)上の戦略を説明します。機械のネイティブ言語で
書かれたインタプリタは、評価を実行する機械のネイティブ言語とは異なっても良い
ある言語(\newterm{source language}(\jnewterm{ソース言語}))で書かれたプログラムを実行するように
機械を構成します。ソース言語のプリミティブ手続きは与えられた機械のネイティブ言語により
記述されたサブルーチンのライブラリとして実装されます。
(\newterm{source program}(\jnewterm{ソースプログラム})と呼ばれる)逐次翻訳するプログラムは
データ構造として表現されます。インタプリタはこのデータ構造を横断し、ソースプログラムを
分析します。それを行うにつれ、ソースプログラムの意図された振舞を適切なプリミティブの
サブルーチンをライブラリから呼ぶことによりシミュレートします。

この節では、\newterm{compilation}(\jnewterm{コンパイル})という代替的な戦略を探求します。
与えられたソース言語と機械に対するコンパイラはソースプログラムを機械のネイティブ言語で書かれた
(\newterm{object program}(\jnewterm{オブジェクトプログラム})と呼ばれる)等価なプログラムに
翻訳します。この節で実装するコンパイラはSchemeで書かれたプログラムを明示的制御評価機の
データパスを用いて実行される命令列へと翻訳します。\footnote{実際には、コンパイルされた
コードを実行する機械はインタプリタマシンよりもより単純に成り得ます。\code{exp}と
\code{unev}のレジスタを使用しないためです。これらを使用するインタプリタは未評価の式の
部分を保持します。しかしコンパイラを用いる場合には、これらの式はレジスタマシンが実行する
コンパイルされたコードの中に組込まれます。同じ理由により、式の構文を扱う機械語命令を
必要としません。しかしコンパイルされたコードは明示的制御評価機械では存在しなかった
いくつかの追加の(コンパイルされた手続きオブジェクトを表現するための)機械語命令を使用します。}

逐次翻訳と比べた時、コンパイルはプログラム実行の効率性において大きな向上を与えられます。
このことは下記にてコンパイラの概観において説明して行きます。一方で、インタプリタは
より強力な環境を対話式のプログラム開発とデバッグのために提供します。実行する
ソースプログラムが実行時にも試験し、変更するために使用可能なためです。
それに加えて、プリミティブのライブラリ全体が存在し、新しいプログラムがデバッグの間に
構築し、追加することができることも挙げられます。

コンパイルと逐次翻訳の相補的な利点の視点において、最新のプログラム開発環境は
入り交じった戦略を追求しています。Lispインタプリタは一般的に逐次翻訳された手続きと
コンパイルされた手続きがお互いを呼びだせるように構築されています。
これはプログラマがデバッグすることを想定されているこれらのプログラムの部品を
コンパイルすることを可能にします。従ってコンパイルの効率上の利点を得ながら、
プログラムのそれらの部品に対して対話式開発とデバッグの流動的な、実行の解釈的な
モードを維持することもできます。\link{Section 5.5.7}において、コンパイラを実装した後には
インタプリタとどのように接続して統合的なインタプリタ・コンパイラ開発システムを
生成するかを示します。

\subsubsection*{コンパイラの概要}

私達のコンパイラは私達のインタプリタに両者のその構造と実行する機能において
とても良く似ています。従って、コンパイラにより式の解析のために使用される仕組みは
インタプリタにて使用されたものと同様になります。さらに、コンパイルされたコードと
逐次翻訳されたコードの接続を簡単にするために、インタプリタと同じ
レジスタ使用法の仕様に従うコードを生成する様にコンパイラを設計します。
環境は\code{env}レジスタに保持され、引数リストは\code{argl}に蓄積され、適用される
手続きは\code{proc}に入り、手続きはそれらの回答を\code{val}に入れて戻り、手続きが戻らなければ
いけない位置は\code{continue}に維持されます。一般的に、コンパイラはソースプログラムを
インタプリタが同じソースプログラムを評価する場合に行うのと本質的に同じレジスタ命令
を実行するオブジェクトプログラムに翻訳します。

この説明ではとても基本的なコンパイラを実装するための戦略を提案します。式をインタプリタと
同じ方法で横断します。インタプリタが式の評価で実行するだろうレジスタ命令に遭遇したら、
その命令を実行はしませんがその代わりに列に蓄積します。結果としての命令列は
オブジェクトコードになります。逐次翻訳に対するコンパイルの効率上の利点を注意して下さい。
インタプリタが式、例えば\code{(f 84 96)}を評価する度に、式の分類(手続きの適用であるかを見出す)と
オペランドリストの終端の検査(2つのオペランドが残っているかを見出す)を行います。
コンパイラを用いる場合、式は命令列がコンパイル時に生成された時に一度しか解析されません。
コンパイラにより生成されたオブジェクトコードは演算子と2つのオペランドを評価する命令しか
含んでおらず、引数リストを組み立て、(\code{proc}内の)手続きを(\code{argl}内の)その引数に適用します。

これは\link{Section 4.1.7}の解析評価機で実装したものと同じ種類の最適化です。しかし、コンパイルされた
コード中で効率を良くするためのさらなる機会が存在します。インタプリタが実行するにしたがって、
インタプリタは言語の任意の式に必ず当てはまる過程を追います。対照的に、与えられたコンパイル済みコードの断片は
ある特定の式を実行することを意味します。これは例えばスタックを用いてレジスタを保存する場合等に
大きな違いを生みます。インタプリタが式を評価する時には、任意の偶発性に対して準備をしなければ
なりません。部分式を評価する前に、インタプリタは後で必要となる全てのレジスタを保存します。
部分式が無原則な評価を要求するかもしれないためです。一方、コンパイラは処理対象の特定の式の構造を利用して
不必要なスタック命令を回避するコードを生成することができます。

その一例として、組み合わせ\code{(f 84 96)}について考えてみます。インタプリタが組み合わせの
演算子を評価する前に、値が後で必要になるオペランドと環境を持つレジスタを保存することで
この評価のための準備を行います。次にインタプリタは演算子を評価してその結果を\code{val}に
取得し、保存したレジスタを戻し、最後に結果を\code{val}から\code{proc}に移します。しかし、
私達が評価しているこの式では、演算子がシンボルの\code{f}であり、その評価は機械語の
\code{lookup\-/variable\-/value}にて達成され、これはどのレジスタの値も変化させません。
この節で実装するコンパイラはこの事実を活用し、演算子をこの命令を使用して評価するコードを
生成します。

\begin{scheme}
(assign proc (op lookup-variable-value)
             (const f)
             (reg env))
\end{scheme}

\noindent
このコードは不必要な保存と復元を回避するだけでなく、lookupの値を直接\code{proc}に割り当てます。
一方でインタプリタは結果を\code{val}の中に取得し、その後に\code{proc}へと移します。

コンパイラはまた環境へのアクセスを最適化することができます。コードを解析した後に、
コンパイラは多くの場合において、どのフレームの中に特定の変数が位置するかを知り、
\code{lookup\-/variable\-/value}による検索を実行するのではなしに、直接アクセスすることができます。
そのような変数のアクセスをどのように実装するかについての議論は\link{Section 5.5.6}にて行います。



\subsection{コンパイラの構造}
\label{Section 5.5.1}

\link{Section 4.1.7}において、私達は元のメタ循環インタプリタを変更して分析を実行から分離しました。
各式を分析して環境を引数として取り必要とされる命令を実行する実行手続きを生成しました。
私達のコンパイラでは、本質的には同じ分析を行います。しかし、実行手続きを生成する代わりに、
私達のレジスタマシンにより実行される命令列を生成します。

手続き\code{compile}はコンパイラ内でのトップレベルの割り振りです。これは\link{Section 4.1.1}の
\code{eval}手続き、\link{Section 4.1.7}の\code{analyze}手続き、そして\link{Section 5.4.1}の明示的制御評価機の
エントリポイント\code{eval\-/dispatch}に対応します。コンパイラはインタプリタと同様に、
\link{Section 4.1.2}における式の構文手続きを用います。\footnote{しかし、私達のコンパイラが
Schemeプログラムであり、式を操作するためにそれが用いる構文手続きがメタ循環評価機により
仕様される実際のScheme手続きであることに注意して下さい。一方で、明示的制御評価機では
等価な構文命令がレジスタマシンに対する命令として使用可能であると前提しました。
(もちろん、Schemeでレジスタマシンをシミュレートした時には、実際のSchemeの手続きを
使用しました。)}\code{compile}はコンパイルされる式の構文の型の事例分析を実行します。
各式の型に対し、特別な\newterm{code generator}(\jnewterm{コード生成器})を割り振ります。

\begin{scheme}
(define (compile exp target linkage)
  (cond ((self-evaluating? exp)
         (compile-self-evaluating exp target linkage))
        ((quoted? exp) (compile-quoted exp target linkage))
        ((variable? exp)
         (compile-variable exp target linkage))
        ((assignment? exp)
         (compile-assignment exp target linkage))
        ((definition? exp)
         (compile-definition exp target linkage))
        ((if? exp) (compile-if exp target linkage))
        ((lambda? exp) (compile-lambda exp target linkage))
        ((begin? exp)
         (compile-sequence
          (begin-actions exp) target linkage))
        ((cond? exp) 
         (compile (cond->if exp) target linkage))
        ((application? exp)
         (compile-application exp target linkage))
        (else
         (error "Unknown expression type: COMPILE" exp))))
\end{scheme}

\subsubsection*{ターゲットとリンク記述子}

\code{compile}とそれが呼ぶコード生成器はコンパイル対象の式に加えて2つの引数を取ります。
コンパイルされたコードがその中で式の値を返すレジスタを指定する\newterm{target}(\jnewterm{ターゲット})と
実行が完了した時に、式のコンパイルの結果としてのコードがどのように続けるべきかを
説明する\newterm{linkage descriptor}(\jnewterm{リンク記述子})です。リンク記述子はコードが
以下の3つの内1つを行うよう要求することができます。

\begin{itemize}

\item
列の次の命令を続ける(これはリンク記述子\code{next}により指定されます)

\item
コンパイルしている手続きから戻る(これはリンク記述子\code{return}により指定されます)

\item
名前付きエントリポイントへ飛ぶ(これはリンク記述子として指定したラベルを用いて指定します)

\end{itemize}

\noindent
例えば、式\code{5}(これは自己評価型)をターゲットをレジスタ\code{val}、リンク記述子を\code{next}で
コンパイルする時、以下の命令を生成しなければなりません。

\begin{scheme}
(assign val (const 5))
\end{scheme}

\noindent
同じ式をリンク記述子\code{return}でコンパイルする時には以下の命令を生成しなければなりません。

\begin{scheme}
(assign val (const 5))
(goto (reg continue))
\end{scheme}

\noindent
最初の場合には、実行は列内の次の命令と共に続行します。2つ目の場合には、手続き呼出から
戻ります。両者の場合において、式の値はターゲットレジスタ\code{val}に配置されます。

\subsubsection*{命令列とスタックの使用法}

各コード生成器は式のために生成したオブジェクトコードを含む\newterm{instruction sequence}(\jnewterm{命令列})を
返します。複合式に対するコード生成は部分式のためのより単純なコード生成器からの出力を組み合わせる
ことにより達成されます。これは複合式の評価が部分式を評価することにより達成されるのと同じです。

命令列を組み合わせる最も単純な手法は\code{append\-/instruction\-/sequences}という手続きです。
これは引数として順に実行されるべき任意の数の命令列を取り、それらを接続し、組み合わされた列を返します。
つまり、もし\( \langle \)\( seq_1 \)\( \rangle \)と\( \langle \)\( seq_2 \)\( \rangle \)が
命令列であるならば、以下の評価は、

\begin{scheme}
(append-instruction-sequences ~\( \dark \langle \)~~\( \dark seq_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark seq_2 \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
次の列を生成します。

\begin{scheme}
~\( \dark \langle \)~~\( \dark seq_1 \)~~\( \dark \rangle \)~
~\( \dark \langle \)~~\( \dark seq_2 \)~~\( \dark \rangle \)~
\end{scheme}

\noindent
レジスタが保存される必要がある度に、コンパイラのコード生成器は\code{preserving}を使用します。
これは命令列を組み立てるための、より芸が細かい手法です。\code{preserving}は3つの引数を
取ります。レジスタの集合と2つの命令列です。これは列をレジスタ集合内の各レジスタの中身が、
2つ目の列の実行に必要ならば、最初の列の実行の間は維持(preserve)されるような方法で接続します。
言い換えれば、もし最初の命令列がレジスタを変更し、2つ目の列が実際にそのレジスタの元の中身を
必要とするならば、\code{preserving}は列を接続する前に最初の列をそのレジスタの\code{save}と\code{restore}で
包みます。そうでなければ、\code{preserving}は単純に接続した命令列を返します。
従って、例えば
\code{(preserving (list}\( \;\;\langle{reg_1}\rangle\;\;\langle{reg_2}\rangle \)\code{)}\( \;\;\langle{seg_1}\rangle\;\;\langle{seg_2}\rangle \)\code{)}
は、
\( \langle \)\( seq_1 \)\( \rangle \)と\( \langle \)\( seq_2 \)\( \rangle \)がどのように
\( \langle \)\( reg_1 \)\( \rangle \)と\( \langle \)\( reg_2 \)\( \rangle \)を使用するかに依存して
以下の4つの命令列の内1つを生成します。

\begin{comment}

\begin{smallexample}
<seq_1> | (save <reg_1>)    | (save <reg_2>)    | (save <reg_2>)
<seq_2> | <seq_1>           | <seq_1>           | (save <reg_1>)
        | (restore <reg_1>) | (restore <reg_2>) | <seq_1>
        | <seq_2>           | <seq_2>           | (restore <reg_1>)
        |                   |                   | (restore <reg_2>)
        |                   |                   | <seq_2>
\end{smallexample}

\end{comment}
\begin{displaymath}
\vbox{
\offinterlineskip
\halign{
\strut 	\kern0.8em # \kern0.4em \hfil & \vrule 
	\kern0.8em # \kern0.4em \hfil & \vrule
	\kern0.8em # \kern0.4em \hfil & \vrule
	\kern0.8em # \kern0.4em \hfil \cr

$\langle{seq_1}\rangle$ 			& \hbox{\tt (save} $\langle{reg_1}\rangle${\tt)} & 
\hbox{\tt (save} $\langle{reg_2}\rangle${\tt)} 	& \hbox{\tt (save} $\langle{reg_2}\rangle${\tt)} \cr

$\langle{seq_2}\rangle$ 			& $\langle{seq_1}\rangle$	& 
$\langle{seq_1}\rangle$ 			& \hbox{\tt (save} $\langle{reg_1}\rangle${\tt)} \cr

						& \hbox{\tt (restore} $\langle{reg_1}\rangle${\tt)} & 
\hbox{\tt (restore} $\langle{reg_2}\rangle${\tt)} 	& $\langle{seq_1}\rangle$ \cr

						& $\langle{seq_2}\rangle$ & 
$\langle{seq_2}\rangle$				& \hbox{\tt (restore} $\langle{reg_1}\rangle${\tt)} \cr

						&  &
			      			& \hbox{\tt (restore} $\langle{reg_2}\rangle${\tt)} \cr

						&  &
			      			& $\langle{seq_2}\rangle$ \cr
}
}
\end{displaymath}

\noindent
\code{preserving}を用いて命令列を組み立てることにより、コンパイラは不必要なスタック命令を
回避することが可能になります。これはまた\code{save}と\code{restore}の命令を\code{preserving}手続きの
中で生成するか、しないかの詳細を分離し、個別のコード生成器それぞれを書く場合に
浮かび上がる考慮点から隔離します。実際に\code{save}と\code{restore}の命令は明示的には
コード生成器により生成されることはありません。

原理上は、命令列を単純に命令のリストとして表現できるでしょう。
\code{append\-/instruction\-/sequences}はそうすると命令列の組み立てを通常のリストの
\code{append}にて行うことができます。するとしかし、\code{preserving}は複雑な命令に
なります。それが各命令列に対し、レジスタをどのように使用するかの分析を行わな
ければならないためです。また複雑であると同様に\code{preserving}が非効率にもなります。
各命令列の引数をも分析しなければならなくなるためです。例えこれらの列自身が
\code{preserving}の呼出により構築されていて、それらの部品が既に分析されていてもです。
そのような分析の繰り返しを防ぐために、各命令列とそのレジスタ使用に関する情報とを
結び付けます。基本的な命令列を構築する時に、私達はこの情報を明示的に与えます。
そして命令列を接続する手続きは列の組み合わせのために、レジスタ使用の情報を
構成部品である列に結び付けられた情報から引き出します。


命令列は3つの情報を持ちます。

\begin{itemize}

\item
命令列内の命令が実行される前に初期化しなければならないレジスタ集合(これらのレジスタは
命令列により\newterm{needed}(必要とされる)と述べられる)

\item
列内の命令によりその値が変更されるレジスタ集合

\item
列内の実際の命令(\newterm{statements}(\jnewterm{命令文})とも呼ばれる)

\end{itemize}

\noindent
命令列をその3つの部品として表現します。命令列のコンストラクタは従って以下のようになります。

\begin{scheme}
(define (make-instruction-sequence
         needs modifies statements)
  (list needs modifies statements))
\end{scheme}

\noindent
喩えば、現在の環境内で変数\code{x}の値を探し、その結果を\code{val}に割り当てて戻る2つの命令の列は
レジスタ\code{env}と\code{continue}が初期化される必要があり、そしてレジスタ\code{val}を変更します。
この列は従って以下のように構築されます。

\begin{scheme}
(make-instruction-sequence 
 '(env continue)
 '(val)
 '((assign val
           (op lookup-variable-value) (const x) (reg env))
   (goto (reg continue))))
\end{scheme}

\noindent
時々、命令文が無い命令列を構築する必要があります。

\begin{scheme}
(define (empty-instruction-sequence)
  (make-instruction-sequence '() '() '()))
\end{scheme}

\noindent
命令列を組み立てる手続きは\link{Section 5.5.4}に示します。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.31}Exercise 5.31:}
手続き適用を評価する場合において、明示的制御評価機は常に演算子の評価の周りで
\code{env}レジスタの保存と復元を行う。また各オペランドの評価の評価の周りでも(最後の1つを除いて)
\code{env}の保存と復元を行う。そえいオペランド列の評価の周りでは\code{proc}の保存と
復元を行う。以下の各組み合わせに対し、これらの\code{save}と\code{restore}命令のどれが
余分であり、従ってコンパイラの\code{preserving}の仕組みにより削減できるかを述べよ。

\begin{scheme}
(f 'x 'y)
((f) 'x 'y)
(f (g 'x) y)
(f (g 'x) 'y)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.32}Exercise 5.32:}
\code{preserving}の仕組みを用いた場合、コンパイラは組み合わせの演算子の評価の周りで
演算子がシンボルの場合に\code{env}の保存と復元を削減することができる。
またそのような最適化を評価機の中に構築することもできるだろう。実際に、\link{Section 5.4}の
明示的制御評価機は既に似たような最適化をオペランドの無い組み合わせを特別な場合として
扱うことで実行している。

\begin{enumerate}[a]

\item
明示的制御評価機を拡張し演算子がシンボルである組み合わせを別のクラスの
式として認識するようにせよ。そしてこの事実をそのような式の評価において活用
するようにせよ。

\item
Alyssa P. Hackerは評価機を拡張し、組込むことができる全てのコンパイラの最適化を
より多くの特別な場合として認識することで、コンパイルの利点全体を
無くすことができると提案した。あなたはこの考えをどう思うか?

\end{enumerate}
\end{quote}

\subsection{式のコンパイル}
\label{Section 5.5.2}


この節と次の節では、\code{compile}手続きが割り振るコード生成器を実装します。

\subsubsection*{リンクコードのコンパイル}

一般的に、各コード生成器の出力は手続き\code{compile\-/linkage}により生成された、
要求されたリンク記述子を実装した命令で終わります。もしリンク記述子が\code{return}なら、
命令\code{(goto (reg continue))}を生成せねばなりません。これは\code{continue}レジスタを
必要とし、他のレジスタを変更はしません。もしリンク記述子が\code{next}なら、何の追加の
命令も必要ありません。さもなければ、リンク記述子はラベルであり、そのラベルへの
\code{goto}を生成します。この命令はレジスタを必要とせず、変更もしません。\footnote{
この手続きは
\newterm{backquote}(\jnewterm{バッククォート}、または\newterm{quasiquote}(\jnewterm{擬似クォート}))と呼ばれるLispの機能を使用します。
これはリストを構築するのに便利です。リストの前にバッククォート記号を置くことは
クォートすることにとても似ていますが、リスト内のカンマで合図された物全てを評価することが
異なります。


例えば、もし\code{linkage}の値がシンボル\code{branch25}の場合、以下の式は

\begin{smallscheme}
`((goto (label ,linkage)))
\end{smallscheme}


次のリストとして評価されます。

\begin{smallscheme}
((goto (label branch25)))
\end{smallscheme}


同様に、もし\code{x}の値がリスト\code{(a b c)}ならば、以下の式は

\begin{smallscheme}
`(1 2 ,(car x))
\end{smallscheme}


次のリストとして評価されます。

\begin{smallscheme}
(1 2 a)
\end{smallscheme}
}

% For example, if the value of \code{linkage} is the symbol\\ \code{branch25},
% then the expression\\ \code{`((goto (label ,linkage)))}\\ evaluates to the
% list\\ \code{((goto (label branch25)))}.\\ Similarly, if the value of \code{x}
% is the list \code{(a b c)}, then\\ \code{`(1 2 ,(car x))}\\ evaluates to the
% list\\ \code{(1 2 a)}.}

\begin{scheme}
(define (compile-linkage linkage)
  (cond ((eq? linkage 'return)
         (make-instruction-sequence '(continue) '()
          '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
          `((goto (label ,linkage)))))))
\end{scheme}

\noindent
リンクのコードが命令列に対し\code{preserving}により\code{continue}レジスタを維持しながら
追加されます。リンク記述子\code{return}が\code{continue}レジスタを必要とするためです。
もし与えられた命令列が\code{continue}を変更し、リンクのコードがそれを必要とする場合、
\code{continue}は保存と復元が行われます。

\begin{scheme}
(define (end-with-linkage linkage instruction-sequence)
  (preserving '(continue)
   instruction-sequence
   (compile-linkage linkage)))
\end{scheme}

\subsubsection*{単純な式のコンパイル}

自己評価型式、クォート、変数に対するコード生成器は
必要な値をターゲットのレジスタに割り当てリンク記述子により指示されたように進める
命令列を構築します。

\begin{scheme}
(define (compile-self-evaluating exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,exp))))))
(define (compile-quoted exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,(text-of-quotation exp)))))))
(define (compile-variable exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '(env) (list target)
    `((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
\end{scheme}

\noindent
これら全ての代入命令はターゲットレジスタを変更します。また変数の検索を行う物は
\code{env}レジスタを必要とします。

代入と定義はインタプリタの物と同様に扱われます。再帰的に変数に割り当てられる値を求める
コードを生成し、それに対して実際に変数の設定、または定義を行う物と式全体の値(シンボル\code{ok})を割り当てる
物の2つの命令列を接続します。再帰的なコンパイルはターゲット\code{val}とリンク記述子\code{next}を持つので
コードはその結果を\code{val}に入れ、その後に接続されたコードを用いて続けられます。接続は
\code{env}を維持(preserving)している間に行われます。環境が変数の設定、または定義のため
必要なためです。また変数の値のためのコードは複雑な式のコンパイルと成り得るため任意の方法で
レジスタを変更する可能性があります。

\begin{scheme}
(define (compile-assignment exp target linkage)
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op set-variable-value!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))

(define (compile-definition exp target linkage)
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op define-variable!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
\end{scheme}

\noindent
接続された2つの命令列は\code{env}と\code{val}を必要とし、ターゲットを変更します。
例え\code{env}をこの列のために維持したとしても、\code{val}は維持しません。
\code{get\-/value\-/code}が明示的にその結果をこの命令列のために\code{val}に配置するように
設計されているためです。(実際には、もし\code{val}を維持した場合、バグを持つことになります。
これにより直前の\code{val}の中身が\code{get\-/value\-/code}の実行直後に復元されるためです。)

\subsubsection*{条件式のコンパイル}

与えられたターゲットとリンク記述子と共にコンパイルされる\code{if}式のためのコードは
以下の形式を持ちます。

\begin{scheme}
~\( \dark \langle \)~~\emph{述語のコンパイル, ターゲット \code{val}, リンク記述子 \code{next}}~~\( \dark \rangle \)~
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
 ~\( \dark \langle \)~~\emph{結果部 与えられたターゲット
  与えられたリンク記述子 又は \code{after\-/if}}~~\( \dark \rangle \)~
false-branch
 ~\( \dark \langle \)~~\emph{代替部 与えられたターゲット リンク記述子}~~\( \dark \rangle \)~
after-if
\end{scheme}

\noindent
このコードを生成するために、述語、結果部、代替部をコンパイルし、結果のコードを
述語の結果をテストするコードと新しく生成された真と偽の分岐をマークするラベルと
条件文の最後と共に組み立てます。\footnote{
私達は単にラベル\code{true\-/branch},
\code{false\-/branch}, \code{after\-/if}を上で示されたように使うことはできません。なぜなら
プログラム中に\code{if}文は複数存在する可能性があるためです。\code{make\-/label}は
シンボルを引数として、与えられたシンボルで始まる取り新しいシンボルを返します。
例えば、\code{(make\-/label 'a)}に対する連続した呼出は\code{a1}, \code{a2}, \( \dots \)を返します。
\code{make\-/label}はクエリ言語における一意の変数名の生成と同様に、以下の様に実装する
ことができます。

\begin{smallscheme}
(define label-counter 0)
(define (new-label-number)
  (set! label-counter (+ 1 label-counter))
  label-counter)
(define (make-label name)
  (string->symbol
    (string-append (symbol->string name)
                   (number->string (new-label-number)))))
\end{smallscheme}
}
このコードの準備では、テストが偽である場合、真の分岐へと飛ぶ必要があります。
唯一、微妙に複雑なのは真の分岐がリンク記述子をどのように扱うかについてです。
もし条件文のリンク記述子が\code{return}、またはラベルの場合、真と偽の分岐は両方共
これと同じリンク記述子を用います。もしリンク記述子が\code{next}なら、真の分岐は
偽の分岐を飛び越し条件文の最後へと飛ぶコードで終わります。

\begin{scheme}
(define (compile-if exp target linkage)
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
             (compile
              (if-consequent exp) target 
                                  consequent-linkage))
            (a-code
             (compile (if-alternative exp) target linkage)))
        (preserving '(env continue)
         p-code
         (append-instruction-sequences
          (make-instruction-sequence '(val) '()
           `((test (op false?) (reg val))
             (branch (label ,f-branch))))
          (parallel-instruction-sequences
           (append-instruction-sequences t-branch c-code)
           (append-instruction-sequences f-branch a-code))
          after-if))))))
\end{scheme}

\noindent
\code{env}は述語コードの間維持されます。真と偽の分岐で必要になるかもしれないためです。
そして\code{continue}もそれら分岐内でリンクのためのコードにて使用されるかもしれないため維持されます。
真と偽の分岐のためのコード(順には実行されません)は\link{Section 5.5.4}で説明される
専用の結合器、\code{parallel\-/instruction\-/sequences}を使用して接続されます。

\code{cond}は派生式であることに注意してください。そのためコンパイラが取り扱いのために
必要なこと全ては(\link{Section 4.1.2}の)\code{cond\-/>if}変換器を適用して、結果の\code{if}式を
コンパイルするだけです。

\subsubsection*{列のコンパイル}

列のコンパイル(手続きのボディ、または明示的な\code{begin}式)はそれらの評価を並列化します。
列の各式は次の条件でコンパイルされます。最後の式は列に対して指示されたリンク記述子を
用いて。他の式はリンク記述子\code{next}を用いて(列の残りを実行するために)。
個別の式の命令列は接続され単一の命令列を形成します。(列の残りのために必要な)\code{env}と
(列の終わりのリンクコードで必要な可能性のある)\code{continue}は維持されます。

\begin{scheme}
(define (compile-sequence seq target linkage)
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
       (compile (first-exp seq) target 'next)
       (compile-sequence (rest-exps seq) target linkage))))
\end{scheme}

\subsubsection*{\code{lambda}式のコンパイル}

\code{lambda}式は手続きを構築します。\code{lambda}式のためのオブジェクトコードは
以下の形式に従わねばなりません。

\begin{scheme}
~\( \dark \langle \)~~\emph{手続きオブジェクトの構築}~ 
 ~\emph{ターゲットレジスタにそれを割り当てる}~~\( \dark \rangle \)~
~\( \dark \langle \)~~\var{\dark リンク}~~\( \dark \rangle \)~
\end{scheme}

\noindent
\code{lambda}式をコンパイルする時、手続きのボディのためのコードも生成します。
例えボディが手続き構築時に実行されなくても、オブジェクトコードの中の
\code{lambda}式のコードの直後に挿入しておくことは便利です。
もし\code{lambda}式に対するリンク記述子がラベルか\code{return}ならば、このことに問題はありません。
しかし、もしリンク記述子が\code{next}ならば、手続きのボディの後ろに挿入されたラベルへ飛ぶリンク記述子を
使用することによりボディに対するコードを回避する必要があります。従ってオブジェクト
コードは以下の形式になります。

\begin{scheme}
~\( \dark \langle \)~~\emph{手続きオブジェクトの構築}~ 
 ~\emph{それをターゲットレジスタに割当}~~\( \dark \rangle \)~
 ~\( \dark \langle \)~~\emph{与えられたリンク記述子に対するコード}~~\( \dark \rangle \)~ ~\emph{または}~ ~\code{(goto (label after\-/lambda))}~
 ~\( \dark \langle \)~~\emph{手続きボディのコンパイル後コード}~~\( \dark \rangle \)~
after-lambda
\end{scheme}

\noindent
\code{compile\-/lambda}は手続きのボディのコードが続く手続きオブジェクトを構築するためのコードを
生成します。手続きオブジェクトは実行時に現在の環境(定義時点での環境)をコンパイルされた
手続きボディのエントリポイント(新しく生成されたラベル)と共に
組み立てることで構築されます。\footnote{\label{Footnote 38}
\link{Section 4.1.3}で説明した
複合手続きのための構造と同様に、コンパイル後の手続きを表現するためのデータ構造を
実装するための機械語命令を必要とします。

\begin{smallscheme}
(define (make-compiled-procedure entry env)
  (list 'compiled-procedure entry env))
(define (compiled-procedure? proc)
  (tagged-list? proc 'compiled-procedure))
(define (compiled-procedure-entry c-proc) (cadr c-proc))
(define (compiled-procedure-env c-proc) (caddr c-proc))
\end{smallscheme}
}

\begin{scheme}
(define (compile-lambda exp target linkage)
  (let ((proc-entry (make-label 'entry))
        (after-lambda (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage lambda-linkage
         (make-instruction-sequence '(env) (list target)
          `((assign ,target
                    (op make-compiled-procedure)
                    (label ,proc-entry)
                    (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
\end{scheme}

\noindent
\code{compile\-/lambda}は\code{append\-/instruction\-/sequences}(\link{Section 5.5.4})ではなく、
特別な結合器\code{tack\-/on\-/instruction\-/sequence}を手続きのボディと\code{lambda}式のコードを
接続するのに利用します。ボディは組み立てられた列が入力された時に実行される命令列の一部では
ないためです。そうではなく、それはただ、そこに置くことが便利だから、その列の中にあります。

\code{compile\-/lambda\-/body}は手続きのボディのためのコードを構築します。
このコードはエントリポイントに対するラベルで開始します。次に来るのは
実行時の環境を手続きのボディの評価を評価するために正しい環境へとスイッチする
命令列です。即ち、手続きの定義環境であり、これは手続きが呼ばれる時に利用される引数に
対する形式パラメタの束縛を含むように拡張されています。
これの後には、式の列のコードが来ます。これが手続きのボディを作り上げます。
この列はリンク記述子\code{return}とターゲット\code{val}と共にコンパイルさるため、
手続きの結果は\code{val}に入れらた状態で手続きから戻ることで終わります。

\begin{scheme}
(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
        (assign env
                (op compiled-procedure-env)
                (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return))))
\end{scheme}

\subsection{組み合わせのコンパイル}
\label{Section 5.5.3}

コンパイル処理の本質は手続き適用のコンパイルです。与えられたターゲットとリンク記述子と
共にコンパイルされた組み合わせのコードは以下の形式を持ちます。

\begin{scheme}
~\( \dark \langle \)~~\emph{演算子のコンパイル, ターゲット \code{proc}, リンク記述子 \code{next}}~~\( \dark \rangle \)~
~\( \dark \langle \)~~\emph{オペランドを評価し、\code{argl}内に引数リストを構築}~~\( \dark \rangle \)~
~\( \dark \langle \)~~\emph{手続き呼出のコンパイル}~ 
 ~\emph{与えられたターゲットとリンク記述子と共に}~~\( \dark \rangle \)~
\end{scheme}

\noindent
レジスタ\code{env}, \code{proc}, \code{argl}は演算子(演算子)とオペランドの評価の間に
保存と復元を行う必要があるかもしれません。ここだけがこのコンパイラにおいて
\code{val}以外のターゲットが指定される箇所であることに注意して下さい。

必要なコードは\code{compile\-/application}により生成されます。これは再帰的に演算子を
コンパイルして\code{proc}に適用する手続きを配置するコードを生成し、オペランドをコンパイルして
個別の適用の個々のオペランドを評価するコードを生成します。オペランドの命令列は
(\code{construct\-/arglist}により)\code{argl}に引数リストを構築するコードと共に組み合わされます。
そして結果となる引数リストのコードは手続きのコードと(\code{compile\-/procedure\-/call}により生成された)
手続き呼出を実行するコードと共に組み合わされます。コードの列の接続において、
\code{env}レジスタは演算子の評価の周りにおいて維持(preserving)されなければなりません。
(演算子の評価がオペランドの評価で必要とな\code{env}を変更する
可能性があるため)。そして\code{proc}レジスタは引数リストの周りで維持されなければなりません。
(オペランドの評価が実際の手続き適用に必要な\code{proc}レジスタを変更するかもしれないため)。
\code{Continue}もまたその間中、維持されなければなりません。手続き呼出のリンクコードが
必要とするためです。

\begin{scheme}
(define (compile-application exp target linkage)
  (let ((proc-code (compile (operator exp) 'proc 'next))
        (operand-codes
         (map (lambda 
                (operand) (compile operand 'val 'next))
              (operands exp))))
    (preserving '(env continue)
     proc-code
     (preserving '(proc continue)
      (construct-arglist operand-codes)
      (compile-procedure-call target linkage)))))
\end{scheme}

\noindent
引数リストを構築するためのコードは\code{val}内に評価して、次にその値を\code{argl}に蓄積される
引数リスト上に\code{cons}します。\code{argl}上に順に引数を\code{cons}するため、最後の引数から
開始し、最初のもので終わらなければなりません。そうすることで引数は結果リストの中に
最初から最後の順で現れることになります。この一連の評価のための設定を行うため、\code{argl}を
空に初期化することで命令を無駄にするのではなく、\code{argl}の初期値を構築する最初の
コード列を作成します。従って、引数リスト構築の一般的な形式は以下になります。

\begin{scheme}
~\( \dark \langle \)~~\emph{最後のオペランドのコンパイル, ターゲットは\code{val}}~~\( \dark \rangle \)~
(assign argl (op list) (reg val))
~\( \dark \langle \)~~\emph{次のオペランドのコンパイル, ターゲットは\code{val}}~~\( \dark \rangle \)~
(assign argl (op cons) (reg val) (reg argl))
~\( \dots \)~
~\( \dark \langle \)~~\emph{最初のオペランドのコンパイル, ターゲットは\code{val}}~~\( \dark \rangle \)~
(assign argl (op cons) (reg val) (reg argl))
\end{scheme}

\noindent
\code{argl}は各オペランドの評価の間、最初の1つを除いて維持しなければなりません。
(そうすることで、そこまで蓄積した引数を失わないように)。そして\code{env}は
(続きのオペランド評価での使用のため)各オペランドの評価の周りで、
最後の1つを除いて維持されなければなりません。

この引数コードのコンパイルは少しだけ巧妙です。評価する最初のオペランドの特別な
扱いと、\code{argl}と\code{env}を異なる箇所にて維持する必要性のためです。
\code{construct\-/arglist}手続きは引数として個々のオペランドを評価するコードを取ります。
もしオペランドが全く無ければ、単純に以下の命令を発行します。

\begin{scheme}
(assign argl (const ()))
\end{scheme}

\noindent
そうでなければ、\code{construct\-/arglist}は\code{argl}を最後の引数で初期化するコードを
生成し、引数の残りを評価するコードを接続し、それらを相次いで\code{argl}の中に隣接させていきます。
引数を最後から最初へ処理するために、オペランドのコード列のリストを
\code{compile\-/application}により提供された順から逆順(reverse)にする必要があります。

\begin{scheme}
(define (construct-arglist operand-codes)
  (let ((operand-codes (reverse operand-codes)))
    (if (null? operand-codes)
        (make-instruction-sequence '() '(argl)
         '((assign argl (const ()))))
        (let ((code-to-get-last-arg
               (append-instruction-sequences
                (car operand-codes)
                (make-instruction-sequence '(val) '(argl)
                 '((assign argl (op list) (reg val)))))))
          (if (null? (cdr operand-codes))
              code-to-get-last-arg
              (preserving '(env)
               code-to-get-last-arg
               (code-to-get-rest-args
                (cdr operand-codes))))))))

(define (code-to-get-rest-args operand-codes)
  (let ((code-for-next-arg
         (preserving '(argl)
          (car operand-codes)
          (make-instruction-sequence '(val argl) '(argl)
           '((assign argl
              (op cons) (reg val) (reg argl)))))))
    (if (null? (cdr operand-codes))
        code-for-next-arg
        (preserving '(env)
         code-for-next-arg
         (code-to-get-rest-args (cdr operand-codes))))))
\end{scheme}

\subsubsection*{手続きの適用}

組み合わせの要素を評価した後に、コンパイルされたコードは\code{proc}内の手続きを
\code{argl}内の引数に適用しなければなりません。このコードは本質的に\link{Section 4.1.1}の
メタ循環評価機の\code{apply}手続き、または\link{Section 5.4.1}の明示的制御評価機の
\code{apply\-/dispatch}エントリポイントと同じ割り振りを実行します。
適用する手続きがプリミティブな手続きであるか複合手続きであるかを確認します。
プリミティブな手続きに対しては、\code{apply\-/primitive\-/procedure}を使用します。
簡潔にこれがどのようにコンパイルされた手続きを取り扱うのかについて見ていきます。
手続き適用のコードは以下の形式を持ちます。

\begin{scheme}
(test (op primitive-procedure?) (reg proc))
 (branch (label primitive-branch))
compiled-branch
 ~\( \dark \langle \)~~\emph{与えられたターゲットと適切なリンク記述子と共に 
  手続きをコンパイルするコード}~~\( \dark \rangle \)~
primitive-branch
 (assign ~\( \dark \langle \)~~\var{\dark target}~~\( \dark \rangle \)~
         (op apply-primitive-procedure)
         (reg proc)
         (reg argl))
 ~\( \dark \langle \)~~\var{\dark リンクコード}~~\( \dark \rangle \)~
after-call
\end{scheme}

\noindent
コンパイルされた分岐はprimitive-branchをスキップしなければならないことに注意して下さい。
従って、もし元の手続き呼出のリンク記述子が\code{next}ならば、複合分岐はprimitive-branchの後に
挿入されたラベルへと飛ぶリンクコードを使用しなければなりません。(これは\code{compile\-/if}に
おいて、真の分岐のために使用されたリンクコードと同様です。)

\begin{scheme}
(define (compile-procedure-call target linkage)
  (let ((primitive-branch (make-label 'primitive-branch))
        (compiled-branch (make-label 'compiled-branch))
        (after-call (make-label 'after-call)))

    (let ((compiled-linkage
           (if (eq? linkage 'next) after-call linkage)))
      (append-instruction-sequences
       (make-instruction-sequence '(proc) '()
        `((test (op primitive-procedure?) (reg proc))
          (branch (label ,primitive-branch))))
       (parallel-instruction-sequences
        (append-instruction-sequences
         compiled-branch
         (compile-proc-appl target compiled-linkage))
        (append-instruction-sequences
         primitive-branch
         (end-with-linkage linkage
          (make-instruction-sequence '(proc argl)
                                     (list target)
           `((assign ,target
                     (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl)))))))
       after-call))))
\end{scheme}

\noindent
\code{compile\-/if}の真と偽の分岐のような、プリミティブかつ、複合な分岐は通常の
\code{append\-/instruction\-/sequences}ではなく\code{parallel\-/instruction\-/sequences}を
用いて接続されます。それらは順には実行されないためです。

\subsubsection*{コンパイル済み手続きの適用}

手続きの適用を取り扱うコードはコンパイラの最も微妙な部分です。例えそれが生成する命令列が
とても短くても変わりません。(\code{compile\-/lambda}により構築されたような)コンパイルされた手続きは
手続きが開始する場所を指定するラベルであるエントリポイントを持ちます。
このエントリポイントにてコードは\code{val}に結果を求め、命令\code{(goto (reg continue))}を実行すること
により戻ります。従って与えられたターゲットとリンク記述子を伴なう(\code{compile\-/proc\-/appl}により生成される)
コンパイルされた手続きの適用はリンク記述子がラベルであれば以下のようになります。

\begin{scheme}
(assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign ~\( \dark \langle \)~~\var{\dark target}~~\( \dark \rangle \)~ (reg val))   ~\textrm{; ターゲットが\code{val}でなければ含まれる}~
 (goto (label ~\( \dark \langle \)~~\var{\dark リンク記述子}~~\( \dark \rangle \)~))   ~\textrm{; リンクコード}~
\end{scheme}

\noindent
またはリンク記述子が\code{return}の場合は次のとおりです。

\begin{scheme}
(save continue)
 (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign ~\( \dark \langle \)~~\var{\dark target}~~\( \dark \rangle \)~ (reg val))   ~\textrm{; ターゲットが\code{val}でなければ含まれる}~
 (restore continue)
 (goto (reg continue))         ~\textrm{; リンクコード}~
\end{scheme}

\noindent
このコードは手続きが\code{proc\-/return}に戻るように\code{continue}を設定し、手続きの
エントリポイントへと飛びます。\code{proc\-/return}のコードは手続きの結果を\code{val}から
ターゲットレジスタへと(もし必要なら)転送し、次にリンク記述子により指定された
位置へと飛びます。(リンク記述子は常に\code{return}かラベルです。なぜなら
\code{compile\-/procedure\-/call}が複合手続きの分岐のためのリンク記述子\code{next}を
\code{after\-/call}ラベルに置き換えるためです。)

実際には、もしターゲットが\code{val}でなければ、それはまさに私達のコンパイラが
生成するコードです。\footnote{実際に、ターゲットが\code{val}でなく、リンク記述子が
\code{return}である場合にはエラーを発します。私達がリンク記述子\code{return}を要求する
箇所は手続きのコンパイル内のみです。そして私達の仕様は、手続きはその値を\code{val}にて返す、です。}
しかし、通常はターゲットは\code{val}であり(コンパイラが異なるレジスタを指定する唯一の場合は
演算子の評価のターゲットを\code{proc}にする時です)、そのため手続きの結果は直接
ターゲットレジスタに入れられ、コピーを行う特別な位置へ戻る必要はありません。その代わりに、
手続きが直接呼び出し元のリンク記述子により指定される場所へ直接``戻る''ように\code{continue}を
設定します。

\begin{scheme}
~\( \dark \langle \)~~\emph{\code{continue}にリンク記述子を設定}~~\( \dark \rangle \)~
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
\end{scheme}

\noindent
もしリンク記述子がラベルならば、手続きがそのラベルに戻るように\code{continue}を設定します。
(つまり、上記の\code{proc\-/return}において手続きの終端\code{(goto (reg continue))}が
\code{(goto (label <\var{linkage}>))}と等価になります。)

\begin{scheme}
(assign continue (label ~\( \dark \langle \)~~\var{\dark リンク記述子}~~\( \dark \rangle \)~))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
\end{scheme}

\noindent
もしリンク記述子が\code{return}なら、\code{continue}を設定する必要は全くありません。
それは既に望まれた位置を持っています。(言い換えれば、手続きの終端\code{(goto (reg
continue))}は\code{proc\-/return}の\code{(goto (reg continue))}が飛ぶはずだった場所へ
直接飛びます。)

\begin{scheme}
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
\end{scheme}

\noindent
このリンク記述子\code{return}の実装を用いて、コンパイラは末尾再帰のコードを生成します。
手続きのボディの最後ステップとしての手続きの呼出は直接移動を行いスタック上にどのような
情報も保存しません。

その代わりに手続き呼出の場合をリンク記述子\code{return}とターゲット\code{val}を用いて、
上記で示されたように\code{val}以外のターゲットに対しても取り扱ったと仮定します。
これは末尾再帰を損うでしょう。それでも、私達のシステムは任意の式に対して同じ値を
与えます。しかし、私達が手続きを呼ぶ度に、\code{continue}を保存し、呼出の後に
(必要の無い)保存の取消を呼び出すことになります。これらの余分な保存が入れ子の手続き
呼出の間に蓄積されます。\footnote{コンパイラに末尾再帰のコードを生成させることは
簡単な考えのように見えるかもしれません。しかし一般的な言語のための多くのコンパイラは
C言語とPascalを含めて、これを行いません。従ってこれらの言語は反復プロセスを手続き
呼出のみを用いて表現することができません。これらの言語における末尾再帰の困難さは
それらの実装がスタックを用いて手続きの引数とローカル変数と同様にリターンアドレスを
も格納しているためです。この本で説明されているSchemeの実装は引数と変数をガベージ
コレクションされるようにメモリに保存します。変数と引数に対してスタックを使用する
理由は他のやり方によりガベージコレクションの必要の無い言語内で、その必要性を回避するからです。
そして一般的にはより効率的になると信じられています。実際には、最新のLispコンパイラは
末尾再帰を無効化せずにスタックを引数のために使用することができます。(このことの説明に
関しては\link{Hanson 1990}を参照して下さい)。またスタックの割当がそもそもガベージ
コレクションより効率的であるかどうかについての討論もいくつか存在します。しかし、
詳細はコンピュータアーキテクチャの委細に依存しているように見えます。(この問題の
反対の立場からの視点については\link{Appel 1987}と\link{Miller and Rozas 1994}を参照して下さい。)}

code{compile\-/proc\-/appl}は上記の手続き適用のコードを生成します。これは呼出のためのターゲットが
\code{val}であるか、そしてリンク記述子が\code{return}であるかについてに依存する4つの場合について
考慮します。命令列が全てのレジスタを変更するために宣言されることについて注意して下さい。
手続きのボディの実行が自由な形でレジスタを変更することができるためです。\footnote{
変数\code{all\-/regs}は全てのレジスタの名前のリストに対して束縛されます。

\begin{smallscheme}
(define all-regs '(env proc val argl continue))
\end{smallscheme}
}
またターゲットが\code{val}であり、リンク記述子が\code{return}の場合に対するコードの列は
\code{continue}を必要とすると宣言されていることに注意して下さい。例え\code{continue}が
明示的に2つの命令列の中で使用されていなくとも、私達がコンパイルされた手続きを入力した
時に\code{continue}が正しい値を持つことを確実にしなければなりません。

\begin{scheme}
(define (compile-proc-appl target linkage)
  (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
         (make-instruction-sequence '(proc) all-regs
           `((assign continue (label ,linkage))
             (assign val (op compiled-procedure-entry)
                         (reg proc))
             (goto (reg val)))))
        ((and (not (eq? target 'val))
              (not (eq? linkage 'return)))
         (let ((proc-return (make-label 'proc-return)))
           (make-instruction-sequence '(proc) all-regs
            `((assign continue (label ,proc-return))
              (assign val (op compiled-procedure-entry)
                          (reg proc))
              (goto (reg val))
              ,proc-return
              (assign ,target (reg val))
              (goto (label ,linkage))))))
        ((and (eq? target 'val) (eq? linkage 'return))
         (make-instruction-sequence 
          '(proc continue) 
          all-regs
          '((assign val (op compiled-procedure-entry)
                        (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val))
              (eq? linkage 'return))
         (error "return linkage, target not val: COMPILE"
                target))))
\end{scheme}

\subsection{命令列のコンパイル}
\label{Sec. 5.5.4}
\label{Section 5.5.4}

この節では命令列がどのように表現され、組み合わされるのかについての詳細を説明します。
\link{Section 5.5.1}から命令列が必要なレジスタのリスト、変更されるレジスタ、実際の命令のリスト
として表現されたことを思い出して下さい。またラベル(シンボル)を命令列の退化した場合だと
考慮します。これはどのレジスタも必要とせず、また変更しません。故に、命令列により必要とされる、または
変更されるレジスタを決定するために以下のセレクタを用います。

\begin{scheme}
(define (registers-needed s)
  (if (symbol? s) '() (car s)))
(define (registers-modified s)
  (if (symbol? s) '() (cadr s)))
(define (statements s)
  (if (symbol? s) (list s) (caddr s)))
\end{scheme}

\noindent
また与えられた命令列が与えられたレジスタを必要とするか、変更するかを決定するために
以下の述語を用います。

\begin{scheme}
(define (needs-register? seq reg)
  (memq reg (registers-needed seq)))
(define (modifies-register? seq reg)
  (memq reg (registers-modified seq)))
\end{scheme}

\noindent
これらの述語とセレクタを用いて、コンパイラを通して使用される様々な命令列の
結合器(combiner)を実装することができます。

基本的な結合器は\code{append\-/instruction\-/sequences}です。これは引数として順に実行される
任意の数の命令列を取り、命令文(statement)が全ての命令列の命令文を一緒に接続した命令文
である命令列を返します。結果の命令列により必要とされる、または変更されるレジスタの
決定が繊細な点になります。これは命令列のどれかにより変更されるレジスタが変更されます。
またこれは最初の命令列が実行する前に初期化されなければならないレジスタ(最初の命令列で
必要とされるレジスタ)に加えて、それに続く命令列により初期化されない(変更されない)
他の命令列により必要とされるレジスタ全てです。

命令列は\code{append\-/2\-/sequences}により一度に2つが接続されます。これは2つの命令列
\code{seq1}と\code{seq2}を取り、命令文が\code{seq1}の命令文の後に\code{seq2}の命令文が置かれる命令列を
返します。これの変更されたレジスタは\code{seq1}か\code{seq2}のどちらかにより変更された
レジスタです。そして必要とされるレジスタは\code{seq1}により必要とされるレジスタと
\code{seq2}で必要とされ\code{seq1}で変更されないレジスタを加えたものです。
(集合の命令を用いて、必要なレジスタの新しい集合は\code{seq1}により必要とされるレジスタの
集合と、\code{seq2}により必要とされるレジスタと\code{seq1}により変更されたレジスタの
差集合との、和集合です。)

\begin{scheme}
(define (append-instruction-sequences . seqs)
  (define (append-2-sequences seq1 seq2)
    (make-instruction-sequence
     (list-union
      (registers-needed seq1)
      (list-difference (registers-needed seq2)
                       (registers-modified seq1)))
     (list-union (registers-modified seq1)
                 (registers-modified seq2))
     (append (statements seq1) (statements seq2))))
  (define (append-seq-list seqs)
    (if (null? seqs)
        (empty-instruction-sequence)
        (append-2-sequences
         (car seqs)
         (append-seq-list (cdr seqs)))))
  (append-seq-list seqs))
\end{scheme}

\noindent
この手続きはリストとして表現された集合を操作するためのいくつかの簡単な命令を使います。
\link{Section 2.3.3}で説明された(順序無し)集合表現と同様です。

\begin{scheme}
(define (list-union s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (list-union (cdr s1) s2))
        (else (cons (car s1) (list-union (cdr s1) s2)))))
(define (list-difference s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (list-difference (cdr s1) s2))
        (else (cons (car s1)
                    (list-difference (cdr s1) s2)))))
\end{scheme}

\noindent
\code{preserving}は2つ目の主な命令列結合器ですが、レジスタのリスト\code{regs}と順に実行する2つの命令列
\code{seq1}と\code{seq2}を取ります。これは\code{seq1}の命令文(statements)のその後に
\code{seq2}の命令文が続く命令文を持つ命令列を返します。この命令文には\code{seq1}により
変更されるが\code{seq2}で必要とされる\code{regs}内のレジスタを守るために\code{seq1}の周りに
適切な\code{save}と\code{restore}が追加されます。これを達成するために、\code{preserving}は
最初に必要とされる\code{save}とそれに続く\code{seq1}、それに続く必要とされる\code{restore}を
持つ命令列を作ります。この命令列は\code{seq1}により必要とされるレジスタに加えて
レジスタの保存と復元を必要とします。そして\code{seq1}で変更されたレジスタを保存と
回復が行われるものを除いて変更します。次に、この増補された命令列と\code{seq2}が通常の
方法で接続されます。以下の手続きはこの戦略を、維持されるべきレジスタのリストを横断しながら
再帰的に実装します。\footnote{\code{preserving}が\code{append}を3つの引数と共に呼び出すことに
注意して下さい。この本に表われる\code{append}の定義は2つの引数しか受け付けませんが、
Schemeの標準は任意の数の引数を取る\code{append}手続きを提供します。}

\begin{scheme}
(define (preserving regs seq1 seq2)
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (if (and (needs-register? seq2 first-reg)
                 (modifies-register? seq1 first-reg))
            (preserving (cdr regs)
             (make-instruction-sequence
              (list-union (list first-reg)
                          (registers-needed seq1))
              (list-difference (registers-modified seq1)
                               (list first-reg))
              (append `((save ,first-reg))
                      (statements seq1)
                      `((restore ,first-reg))))
             seq2)
            (preserving (cdr regs) seq1 seq2)))))
\end{scheme}

\noindent
別の命令列結合器である\code{tack\-/on\-/instruction\-/sequence}は\code{compile\-/lambda}により
手続きのボディを他の命令列に接続するために使用されます。手続きのボディは組み合わされた列の
一部として実行されるための``インライン''形式ではないため、それによるレジスタの使用は
それが組込まれる命令列のレジスタ使用に影響を与えません。従って手続きボディの必要な、また
変更されるレジスタの集合は別の命令列に接続する時に無視されます。

\begin{scheme}
(define (tack-on-instruction-sequence seq body-seq)
  (make-instruction-sequence
   (registers-needed seq)
   (registers-modified seq)
   (append (statements seq)
           (statements body-seq))))
\end{scheme}

\noindent
\code{compile\-/if}と\code{compile\-/procedure\-/call}は\code{parallel\-/instruction\-/sequences}と
呼ばれる特別な結合器を使用してテストに続く二者択一の分岐を接続します。2つの分岐は
絶対に順には実行されません。どんなテストの評価に対しても、一方か、別の一方に入ります。
このため、2つ目の分岐により必要とされるレジスタは
例えもしこれらが1つ目の分岐により変更されようとも依然として結合後の命令列でも必要とします。

\begin{scheme}
(define (parallel-instruction-sequences seq1 seq2)
  (make-instruction-sequence
   (list-union (registers-needed seq1)
               (registers-needed seq2))
   (list-union (registers-modified seq1)
               (registers-modified seq2))
   (append (statements seq1)
           (statements seq2))))
\end{scheme}

\subsection{コンパイルされたコードの例}
\label{Section 5.5.5}

これでコンパイラの全ての要素について学び終えました。
ここまでのものがどのように御互いに組合せられるのかを見るためにコンパイル済みのコードの例を
試してみましょう。再帰\code{factorial}手続きの定義を\code{compile}を呼ぶことでコンパイルしてみます。

\begin{scheme}
(compile
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n)))
 'val
 'next)
\end{scheme}

\noindent
\code{define}式の値はレジスタ\code{val}に配置されなければならないと指定しました。
私達は\code{define}を実行した後にコンパイル済みコードが何を行うのか気にしません。
そのためリンク記述子に対する\code{next}の選択は気まぐれです。

\code{compile}は式が定義であるかを判断します。そのため\code{compile\-/definition}を
呼び出し(ターゲット\code{val}に対し)割り当てられるべき値を求めるコードをコンパイルします。
続いて定義を導入するコード、さらに\code{define}の値(シンボル\code{ok})をターゲットレジスタに
入れるコード、最後にリンクコードが続きます。\code{env}は値の演算の周りで維持されます。
定義の導入のために必要とされるためです。今回のリンク記述子は\code{next}ですから、
リンクコードは存在しません。従ってコンパイルされたコードの骨格は以下のようになります。

\begin{scheme}
~\( \dark \langle \)~~\emph{値を求めるコードで変更されるなら\code{env}を保存}~~\( \dark \rangle \)~
  ~\( \dark \langle \)~~\emph{定義値、ターゲット\code{val}、
   リンク記述子\code{next}のコンパイル}~~\( \dark \rangle \)~
  ~\( \dark \langle \)~~\emph{上で保存したなら\code{env}の復元}~~\( \dark \rangle \)~
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
\end{scheme}

\noindent
変数\code{factorial}に対する値を生成するためにコンパイルされる式は、値が階乗を計算する
手続きである\code{lambda}式です。\code{compile}は\code{compile\-/lambda}を呼ぶことによりこれを
扱います。\code{compile\-/lambda}は手続きのボディをコンパイルし、それに新しいエントリポイントと
してラベル付けを行い、新しいエントリポイントの手続きボディを実行時環境と組み合わせ、
結果を\code{val}に割り当てるコードを生成します。次に命令列はこの時点で挿入された、
このコンパイルされたコードをスキップします。手続きのコードそれ自体は手続き定義環境を
形式パラメタ\code{n}を手続きの引数に束縛するフレームにより拡張することから始めます。
その次に実際の手続きのボディが来ます。変数の値のためのこのコードは\code{env}レジスタを
変更しませんので、上で示された任意の\code{save}と\code{restore}は生成されません。
(\code{entry2}における手続きのコードはこの時点では実行されません。そのため、その\code{env}の
使用は無関係です)。従って、コンパイルされたコードの骨組は以下のようになります。

\begin{scheme}
  (assign val
          (op make-compiled-procedure)
          (label entry2)
          (reg env))
  (goto (label after-lambda1))
entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment)
          (const (n))
          (reg argl)
          (reg env))
  ~\( \dark \langle \)~~\emph{手続きボディのコンパイル}~~\( \dark \rangle \)~
after-lambda1
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
\end{scheme}

\noindent
手続きのボディは常に(\code{compile\-/lambda\-/body}により)、ターゲット\code{val}と
リンク記述子\code{return}を用いる命令列としてコンパイルされます。今回の場合の
命令列は単一の\code{if}式から成り立ちます。

\begin{scheme}
(if (= n 1)
    1
    (* (factorial (- n 1)) n))
\end{scheme}

\noindent
\code{compile\-/if}は最初に述語を演算し(ターゲットは\code{val})、次にその結果を確認して
述語が偽であれば真の分岐を回避します。\code{env}と\code{continue}が述語のコードの周りで
維持されます。それらが\code{if}式の残りの部分で必要となる可能性があるためです。
\code{if}式が手続きのボディを構成する命令列内の最後の式であるため(そしてただ1つの式であるため)、
そのターゲットは\code{val}で、リンク記述子は\code{return}になります。そのため真と偽の両方の
分岐がターゲット\code{val}とリンク記述子\code{return}と共にコンパイルされます。
(言い換えれば、どちらかの分岐により値が演算される条件文の値がその手続きの値です。)

\begin{scheme}
~\( \dark \langle \)~~\emph{述語により変更され、分岐により必要とされるなら 
 \code{continue}, \code{env}を保存する}~~\( \dark \rangle \)~
  ~\( \dark \langle \)~~\emph{述語, ターゲット\code{val}, リンク記述子\code{next}のコンパイル}~~\( \dark \rangle \)~
  ~\( \dark \langle \)~~\emph{上で保存したなら\code{continue}, \code{env}を復元する}~~\( \dark \rangle \)~
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5
  ~\( \dark \langle \)~~\emph{真の分岐, ターゲット\code{val}, リンク記述子\code{return}のコンパイル}~~\( \dark \rangle \)~
false-branch4
  ~\( \dark \langle \)~~\emph{偽の分岐, ターゲット\code{val}, リンク記述子\code{return}のコンパイル}~~\( \dark \rangle \)~
after-if3
\end{scheme}

\noindent
述語\code{(= n 1)}は手続きの呼出です。これは演算子(シンボル\code{=})を探し、その値を
\code{proc}内に配置します。次に引数\code{1}と変数\code{n}を\code{argl}に集めます。そして
\code{proc}がプリミティブ、または複合手続きを含むかどうかをテストし、それに応じて
プリミティブの分岐か複合の分岐へ飛びます。両方の分岐がラベル\code{after\-/call}にて
再開します。演算子とオペランドの評価の周りでレジスタを維持する必要性は
どのレジスタも保存することにはなりません。今回の場合はそれらの評価は問題となる
レジスタを変更しないためです。

\begin{scheme}
  (assign proc
          (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val
          (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val
          (op apply-primitive-procedure)
          (reg proc)
          (reg argl))
after-call15
\end{scheme}

\noindent
真の分岐は定数1ですが、(ターゲット\code{val}とリンク記述子\code{return}と共に)以下の
ようにコンパイルされます。

\begin{scheme}
(assign val (const 1))
(goto (reg continue))
\end{scheme}

\noindent
偽の分岐のコードは別の手続き呼出です。手続きはシンボル\code{*}で、その引数は\code{n}と
別の手続き呼出の結果(\code{factorial}の呼出)です。これらの呼出の全てが\code{proc}と\code{argl}、
それ自身のプリミティブと複合の分岐の準備を行います。\link{Figure 5.17}は手続き
\code{factorial}の定義の完全なコンパイルを示します。述語の周りで可能性のある\code{continue}と\code{env}の
\code{save}と\code{restore}が実際に生成されていることに注意して下さい。これらのレジスタが
述語内の手続き呼出にて変更され、また分岐内の手続き呼び出しと\code{return}のリンクコードにより
必要とされるためです。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.33}Exercise 5.33:}
上で与えられたものとは微妙に異なる以下の階乗手続きの定義について考えよ。

\begin{scheme}
(define (factorial-alt n)
  (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
\end{scheme}


この手続きをコンパイルし結果のコードを\code{factorial}に対して生成されたコードと比べよ。
見つけた全ての違いについて説明せよ。どちらのプログラムが他方よりもより効率的に
実行するだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.34}Exercise 5.34:}
反復階乗手続きをコンパイルせよ

\begin{scheme}
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
\end{scheme}


結果のコードに注釈を付け、一方のプロセスがスタック領域を増進させ、他方が一定の
スタック領域で実行される元となる、\code{factorial}の反復版と再帰版のコードの間の
本質的な違いを示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Figure 5.17}Figure 5.17:} \( \downarrow \) \code{factorial}手続き定義のコンパイル結果

\begin{smallscheme}
~\textrm{;; 手続きを構築し、手続きのボディのコードを飛ばす}~
  (assign val
          (op make-compiled-procedure) 
          (label entry2) 
          (reg env))
  (goto (label after-lambda1))
entry2     ~\textrm{; \code{factorial}の呼出はここから入る}~
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment) 
          (const (n)) 
          (reg argl) 
          (reg env))
~\textrm{;; 実際の手続きのボディを開始する}~
  (save continue)
  (save env)
~\textrm{;; \code{(= n 1)}を求める}~
  (assign proc 
          (op lookup-variable-value) 
          (const =) 
          (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val 
          (op lookup-variable-value) 
          (const n) 
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call15   ~\textrm{; ここで\code{val}は\code{(= n 1)}の結果を持つ}~
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5  ~\textrm{; return 1}~
  (assign val (const 1))
  (goto (reg continue))
false-branch4
~\textrm{;; \code{(* (factorial (- n 1)) n)}を求めて返す}~
  (assign proc 
          (op lookup-variable-value) 
          (const *) 
          (reg env))
  (save continue)
  (save proc)   ~\textrm{; \code{*}手続きを保存する}~
  (assign val 
          (op lookup-variable-value) 
          (const n) 
          (reg env))
  (assign argl (op list) (reg val))
  (save argl)   ~\textrm{; \code{*}の引数リストの一部を保存}~
~\textrm{;; \code{(factorial (- n 1))}を求める。これは\code{*}のもう一方の引数}~
  (assign proc
          (op lookup-variable-value) 
          (const factorial) 
          (reg env))
  (save proc)  ~\textrm{; \code{factorial}手続きを保存}~
~\textrm{;; \code{(- n 1)}を求める。これは\code{factorial}に対する引数}~
  (assign proc 
          (op lookup-variable-value)
          (const -) 
          (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val 
          (op lookup-variable-value) 
          (const n) 
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
compiled-branch7
  (assign continue (label after-call6))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call6   ~\textrm{; ここで\code{val}は\code{(- n 1)}の結果を持つ}~
  (assign argl (op list) (reg val))
  (restore proc) ~\textrm{; \code{factorial}に戻す}~
~\textrm{;; \code{factorial}の適用}~
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
compiled-branch10
  (assign continue (label after-call9))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch11
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call9      ~\textrm{; ここで\code{val}は\code{(factorial (- n 1))}の結果を持つ}~
  (restore argl) ~\textrm{; \code{*}の引数リストの一部を復元}~
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc) ~\textrm{; \code{*}に戻す}~
  (restore continue)
~\textrm{;; \code{*}を適用しその値を返す}~
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
compiled-branch13
~\textrm{;; ここの複合手続きは末尾再帰で呼ばれることに注意すること}~
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch14
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
  (goto (reg continue))
after-call12
after-if3
after-lambda1
~\textrm{;; 手続きを変数\code{factorial}に割り当てる}~
  (perform (op define-variable!) 
           (const factorial) 
           (reg val) 
           (reg env))
  (assign val (const ok))
\end{smallscheme}

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.35}Exercise 5.35:}
どの式がコンパイルされると\link{Figure 5.18}に示されるコードを生成するか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Figure 5.18}Figure 5.18:} \( \downarrow \) コンパイラ出力の例。\link{Exercise 5.35}参照

\begin{smallscheme}
(assign val 
        (op make-compiled-procedure) 
        (label entry16) 
        (reg env))
  (goto (label after-lambda15))
entry16
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment) 
          (const (x)) 
          (reg argl) 
          (reg env))
  (assign proc 
          (op lookup-variable-value) 
          (const +) 
          (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc 
          (op lookup-variable-value) 
          (const g) 
          (reg env))
  (save proc)
  (assign proc 
          (op lookup-variable-value) 
          (const +) 
          (reg env))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val 
          (op lookup-variable-value) 
          (const x) 
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch19
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call17
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch22
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call20
  (assign argl (op list) (reg val))
  (restore env)
  (assign val 
          (op lookup-variable-value) 
          (const x) 
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch25))
compiled-branch24
  (assign val 
          (op compiled-procedure-entry) 
          (reg proc))
  (goto (reg val))
primitive-branch25
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
  (goto (reg continue))
after-call23
after-lambda15
  (perform (op define-variable!) 
           (const f) 
           (reg val) 
           (reg env))
  (assign val (const ok))
\end{smallscheme}

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.36}Exercise 5.36:}
私達のコンパイラが生成する組み合わせのオペランドに対する評価の順はどれか?
左から右であるか、右から左であるか、または何らかの他の順であるか?
コンパイラの中のどこがこの順を決定するか? コンパイラを変更し、それが何らかの
別の評価順を生成するようにせよ。(\link{Section 5.4.1}における明示的制御評価機の評価順の
議論を参考にせよ)。オペランドの評価順を変更することが引数リストを構築するコードの
効率にどのような影響があるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.37}Exercise 5.37:}
スタック使用の最適化のためのコンパイラの\code{preserving}の仕組みを理解する1つの方法は
この考えを用いなかった場合にどんな余分な命令が生成されるかを見てみることだ。
\code{preserving}を変更し、常に\code{save}と\code{restore}の命令を生成するようにせよ。
いくつかの簡単な式をコンパイルし、生成された不必要なスタック命令を確認せよ。
\code{preserving}の仕組みが失われていないものから生成されたコードと比較せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.38}Exercise 5.38:}
私達のコンパイラは不必要なスタック命令を防ぐことに関して賢いものだ。しかし、
機械により提供されるプリミティブな命令を用いて言語のプリミティブな手続きの
呼出をコンパイルすることに関しては全く賢くない。例えば、\code{(+ a 1)}を求める
ためにどれだけのコードがコンパイルされるか考えてみる。このコードは引数リストを
\code{argl}に準備し、(環境内でシンボル\code{+}を探すことにより見つけた)プリミティブな加算手続きを
\code{proc}に入れる。そしてこの手続きがプリミティブであるか複合であるかをテストする。
コンパイラは常にこのテストを実行するコードと、同様にプリミティブと複合の分岐の
ためのコード(内、一方のみが実行される)が生成される。私達はコントローラのプリミティブを
実装する部品を示さなかった。しかし、これらの命令が機械のデータパス内のプリミティブな
数値演算命令を利用することは仮定した。もしコンパイラがプリミティブを\newterm{open-code}
できたらどれだけ少ないコードが生成されたか考えよ。これはつまり、
もしこれらのプリミティブな機械語命令を直接使用するコードを生成することができれば、である。
式\code{(+ a 1)}は以下と同じくらい単純なものにコンパイルされるだろう。\footnote{私達は
同じシンボル\code{+}をソース言語の手続きと機械語命令の両方を示すためにここで使用しました。
一般的に、ソース言語のプリミティブと機械のプリミティブの間に1対1の対応はありません。}

\begin{scheme}
(assign
 val (op lookup-variable-value) (const a) (reg env))
(assign val (op +) (reg val) (const 1))
\end{scheme}

この課題では私達のコンパイラを拡張し、選択されたプリミティブのopen-codeをサポートする。
特別な目的のコードがこれらのプリミティブな手続きの呼出に対し、一般的な手続き適用のコードの
代わりに生成される。これをサポートするためには、私達の機械に特別な引数レジスタ、
\code{arg1}と\code{arg2}を追加する。機械のプリミティブな数値演算子は入力を\code{arg1}と\code{arg2}から
得る。その結果は\code{val}, \code{arg1}, \code{arg2}のどれかに入れて良い。

コンパイラはソースプログラム内のopen-codeなプリミティブの適用を認識できなければ
ならない。\code{compile}手続きに割り振りを追加し、
現在認識可能な予約語(特殊形式)に加えてこれらのプリミティブの名前を認識できるようにする。\footnote{プリミティブを
予約語に入れることは一般的には悪い考えです。そうするとユーザがこれらの名前を異なる
手続きに束縛し直すことができなくなるためです。さらに、もし使用中のコンパイラに予約語を
追加すると、これらの名前で手続きを定義した既存のプログラムが動作しなくなります。
この問題をどのように回避するかの見解については\link{Exercise 5.44}を参照して下さい。}
特殊形式のそれぞれに対してコンパイラはコード生成器を持つ。この課題ではopen-codeな
プリミティブのためのコード生成器の仲間を構築する。

\begin{enumerate}[a]

\item
open-codeなプリミティブ全ては特殊形式とは異なり、オペランドが評価されることを
必要とする。全てのopen-codeのコード生成器から使用されるコード生成器\code{spread\-/arguments}を書け。
\code{spread\-/arguments}はオペランドのリストを取り、与えられたオペランドを次に続く引数
レジスタをターゲットにコンパイルしなければならない。オペランドがopen-codeなプリミティブへの
呼出を含んでも良いことに注意すること。そのため引数レジスタはオペランド評価の間は
維持されなければならない。

\item
プリミティブな手続き\code{=}, \code{*}, \code{-}, \code{+}のそれぞれに対してその演算子と
ターゲット、リンク記述子の組み合わせを取り引数をレジスタに入れ、与えられた
ターゲットをターゲットに取り、与えられたリンク記述子と共に命令を実行するコードを
生成するコード生成器を書け。2つのオペランドを扱う式を扱うのみで良い。
これらのコード生成器に対する割り振りを作成せよ。

\item
貴方の新しいコンパイラを階乗の例を用いて試してみよ。結果のコードをopen-code無しで
生成した結果と比較せよ。

\item
\code{+}と\code{*}のコード生成器を拡張し任意の数のオペランドを持つ式を取り扱えるようにせよ。
3つ以上のオペランドを持つ式は、それぞれが2つだけ入力を持つ命令の列にコンパイルしなけれ
ばならない。

\end{enumerate}
\end{quote}

\subsection{レキシカルアドレッシング}
\label{Section 5.5.6}

コンパイラにより実行される最も一般的な最適化の1つは変数検索の最適化です。
ここまで実装した私達のコンパイラは評価機の\code{lookup\-/variable\-/value}命令を用いる
コードを生成します。これは実行時環境を通してフレーム毎に取り組みながら、
変数を現在束縛されている全ての変数と比較することで変数の検索を行う。
この検索はもしフレームが深く入れ子になったり、変数の数が多い場合には高コストに
成り得ます。例えば以下の式を評価した結果の適用において、式\code{(* x y z)}の評価の
間に\code{x}の値を探す問題について考えみましょう。

\begin{scheme}
(let ((x 3) (y 4))
  (lambda (a b c d e)
    (let ((y (* a b x)) (z (+ c d x)))
      (* x y z))))
\end{scheme}

\noindent
\code{let}式は\code{lambda}の組み合わせのための単なる構文糖ですので、この式は以下と
等価です。

\begin{scheme}
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) (* x y z))
      (* a b x)
      (+ c d x))))
 3
 4)
\end{scheme}

\noindent
\code{lookup\-/variable\-/value}が\code{x}を検索する度に、シンボル\code{x}は \code{y}、または\code{z}に
\code{eq?}でないことを(最初のフレームで)確認しなければなりません。また
(2つ目のフレームにて)\code{a}, \code{b}, \code{c}, \code{d}, \code{e}についても同様に必要です。
差し当たり、私達のプログラムは\code{define}を使用しないと仮定します。つまり変数は
\code{lambda}の使用にのみ束縛されます。私達の言語はレキシカルスコープであるため、
任意の式のための実行時環境は式が現れるプログラムのレキシカルな(語彙的な)構造を
並列化する構造を持ちます。\footnote{これはもし内部定義を許可するのであれば、
それら全てを走査しない限りは正しくありません。\link{Exercise 5.43}を参照して下さい。}
従って、コンパイラは上の式を分析した時に、手続きが適用される度に\code{(* x y z)}内の
変数\code{x}が現在のフレームから2つ外のフレームの最初の変数として見つかることを知ることができます。

私達は新しい種類の変数検索命令、\code{lexical\-/address\-/lookup}を発明することにより、この
事実を利用することができます。この命令は引数として環境と2つの数値から成る
\newterm{lexical address}(\jnewterm{レキシカルアドレス})を取ります。2つの数値は、いくつのフレームを
見送るかを指定する\newterm{frame number}とそのフレーム内でいくつの変数を見送るかを
指定する\newterm{displacement number}です。\code{lexical\-/address\-/lookup}は現在のフレームに
対して相対的なレキシカルアドレスに格納された変数の値を生成します。
もし私達の機械に\code{lexical\-/address\-/lookup}命令を追加したなら、コンパイラに対して
\code{lookup\-/variable\-/value}ではなく、この命令を使用して変数を参照するコードを生成させる
ことができます。同様に、コンパイルされたコードは\code{set\-/variable\-/value!}の代わりに
新しい\code{lexical\-/address\-/set!}命令を使用することができます。

そのようなコードを生成するためには、コンパイラは参照をコンパイルしようとする変数の
レキシカルアドレスを決定できなければなりません。プログラム中の変数のレキシカルアドレスは
それがコードのどこにあるのかに依存します。例えば、以下のプログラムでは式
\( \langle \)\var{e1}\( \kern0.08em\rangle \)のアドレスは(2, 0)です。
つまり、2フレーム後ろでそのフレームの最初の変数です。同じ地点で\code{y}はアドレス(0, 0)であり、
\code{c}はアドレス(1, 2)に存在します。式\( \langle \)\var{e2}\( \kern0.09em\rangle \)においては、
\code{x}は(1, 0)に、\code{y}は(1, 1)に、\code{c}は(0, 2)に存在します。

\begin{scheme}
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) ~\( \dark \langle \)~~\var{\dark e1}~~\( \dark \rangle \)~)
      ~\( \dark \langle \)~~\var{\dark e2}~~\( \dark \rangle \)~
      (+ c d x))))
 3
 4)
\end{scheme}

\noindent
コンパイラにとってレキシカルアドレスを使用する1つの方法は
\newterm{compile-time environment}(\jnewterm{コンパイル時環境})と呼ばれるデータ構造を管理することです。
これは実行時環境内にて特定の変数アクセス命令が実行された時に、どの変数がどのフレーム内の
どの位置に存在することになるのかを追跡します。コンパイル時環境はフレームのリストであり、
各フレームが変数の変数のリストを保持します。(もちろん値が束縛されない変数も存在します。
値はコンパイル時には計算されないためです)。コンパイル時環境は\code{compile}の追加の引数に
なり、各コード生成器に渡されます。\code{lambda}のボディがコンパイルされる時、
\code{compile\-/lambda\-/body}がコンパイル時環境を手続きのパラメータを持つフレームにより拡張し、
ボディを構成する命令列がその拡張された環境を用いてコンパイルされます。コンパイルの各
時点にて、\code{compile\-/variable}と\code{compile\-/assignment}は適切なレキシカルアドレスを
生成するためにコンパイル時環境を使用します。

\link{Exercise 5.39}から\link{Exercise 5.43}は
コンパイラにレキシカルな検索を組込むためにこのレキシカルアドレス付けの戦略の草案を
どのようにして完了させるかについて説明します。\link{Exercise 5.44}はコンパイル時環境の
別の使用法を説明します。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.39}Exercise 5.39:}
新しい検索命令を実装する\code{lexical\-/address\-/lookup}手続きを書け。2つの引数、レキシカル
アドレスと実行時環境を取ること。そして指定したレキシカルアドレスに格納された
変数の値を返すこと。\code{lexical\-/address\-/lookup}はもし変数の値がシンボル\code{*unassigned*}ならば
エラーを発する。\footnote{これはもし内部定義を削除するためにこの検索手法を実装するので
あれば必要となる、変数検索に対する変更です(\link{Exercise 5.43})。レキシカルアドレスを
うまく動かすためにはこれらの定義を排除する必要があります。}また指定したレキシカル
アドレスの変数の値を変更する操作を実装する手続き\code{lexical\-/address\-/set!}を書け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.40}Exercise 5.40:}
コンパイラを変更し、上で説明されたコンパイル時環境を保存するようにせよ。
つまり、\code{compile}と多様なコード生成器の引数にcompile-time-environmentを
追加し、それを\code{compile\-/lambda\-/body}の中で拡張せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.41}Exercise 5.41:}
引数として変数とコンパイル時環境を取り、その環境に関するその変数のレキシカルアドレスを
返す手続き\code{find\-/variable}を書け。例えば、上で示されたプログラムの断片において、
式\( \langle \)\var{e1}\( \kern0.08em\rangle \)をコンパイルしている間の
コンパイル時環境は\code{((y z) (a b c d e) (x y))}である。\code{find\-/variable}は以下を
生成しなければならない。

\begin{scheme}
(find-variable 'c '((y z) (a b c d e) (x y)))
~\textit{(1 2)}~
(find-variable 'x '((y z) (a b c d e) (x y)))
~\textit{(2 0)}~
(find-variable 'w '((y z) (a b c d e) (x y)))
~\textit{not-found}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.42}Exercise 5.42:}
\link{Exercise 5.41}の\code{find\-/variable}を使用して、\code{compile\-/variable}と
\code{compile\-/assignment}を書き直し、レキシカルアドレス命令を出力するようにせよ。
\code{find\-/variable}が\code{not\-/found}を返す場合においては(つまり、変数がコンパイル時
環境内には存在しない場合には)、コード生成器に対して以前と同じ環境命令を使用させ
ることで束縛を検索させなければならない。(コンパイル時に変数が見つからない唯一の
場所はグローバル環境である。これは実行時環境の一部であり、コンパイル時環境の
一部ではない。\footnote{レキシカルアドレスはグローバル環境内の変数をアクセスする
ためには利用できません。なぜなら、これらの名前は対話形式的に任意の時点で定義と
再定義が可能なためです。\link{Exercise 5.43}の内部定義走査を用いてコンパイラが
知ることができる定義は、グローバル環境に従うトップレベルのものだけです。
定義のコンパイルは、定義された名前がコンパイル時環境に入れることにはなりません。}
従って、もしあなたが望むなら、それらに対し\code{env}内の全ての実行時環境を探させる代わりに、
環境の命令に、命令\code{(op get\-/global\-/environment)}により獲得できるグローバル環境を
直接探させてもかまわない)。変更したコンパイラをこの節の最初の入れ子の\code{lambda}の
組み合わせのような、いくつかの簡単な事例を用いてテストせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.43}Exercise 5.43:}
\link{Section 4.1.6}においてブロック構造に対する内部定義は``実際の''\code{define}だと
考慮されるべきでないと主張した。そうではなく、手続きのボディは通常の
\code{set!}を用いて正しい値に初期化された\code{lambda}の
変数のように、内部変数定義が導入されたかのように解釈されるべきである。
\link{Section 4.1.6}と\link{Exercise 4.16}はどのようにメタ循環インタプリタを変更して
内部定義を走査することで、これを達成するかを示した。コンパイラを変更し、
手続きのボディをコンパイルする前にこれと同じ変形を実行するようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.44}Exercise 5.44:}
この節ではレキシカルアドレスを生成するためのコンパイル時環境の使用に焦点を合わせた。
しかしコンパイル時環境の他の使用法も存在する。例として、\link{Exercise 5.38}では
コンパイルされたコードの効率をopen-codeなプリミティブ手続きにより向上させた。
私達の実装はopen-codeな手続きを予約語として扱った。もしプログラムがそのような名前を
再束縛するなら、\link{Exercise 5.38}にて説明された仕組みは依然としてプリミティブとして
open-codeし、新しい束縛を無視するだろう。例えば、以下の手続きについて考えてみる。

\begin{scheme}
(lambda (+ * a b x y)
  (+ (* a x) (* b y)))
\end{scheme}

\noindent
これは\code{x}と\code{y}の一次結合を求める。これを引数\code{+matrix}, \code{*matrix}、それに
4つの行列(matrix)と共に呼ぶこともあるだろう。しかし、open-codeなコンパイラは
依然として\code{(+ (* a x) (* b y))}内の\code{+}と\code{*}をプリミティブな\code{+}と\code{*}として
open-codeしてしまうだろう。open-codeなコンパイラを変更し、プリミティブな手続きの
名前を含む式に対して正しいコードをコンパイルするために、コンパイル時環境を参考に
するようにせよ。(このコードはプログラムがこれらの名前に対して\code{define}や\code{set!}を
行わない限り正しく動くようになる。)
\end{quote}

\subsection{コンパイル済みコードと評価機の連結}
\label{Section 5.5.7}

私達はまだコンパイルされたコードを評価機にどのようにロードするか、またはどのように
実行するかについて説明していません。ここでは明示的制御評価機が\link{Section 5.4.4}の時点にて定義された
状態であると仮定します。\link{Footnote 38}で指定された追加の命令も含みます。
Scheme式をコンパイルし、結果としてのオブジェクトコードを評価機にロードし、評価機に
グローバル環境の中で実行させ、結果を表示し、評価機のドライバループへと入る手続き
\code{compile\-/and\-/go}を実装します。また評価機を変更し、逐次翻訳された式がコンパイルされた
手続きを逐次翻訳されたものと同じように呼ぶことができるようにもします。
するとコンパイルされた手続きを機械に入れてそれを呼び出すことができます。

\begin{scheme}
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
~\textit{;;; EC-Eval value:}~
~\textit{ok}~
~\textit{;;; EC-Eval input:}~
(factorial 5)
~\textit{;;; EC-Eval value:}~
~\textit{120}~
\end{scheme}

\noindent
評価機にコンパイルされた手続きの取り扱いを可能にするには(例えば上記の\code{factorial}の呼出を評価すること)、
\code{apply\-/dispatch}(\link{Section 5.4.1})のコードを変更して、それがコンパイルされた手続きを
(複合、またはプリミティブな手続きから区別可能なものとして)認識し、制御を直接コンパイルされた
コードのエントリポイントへと移動させる必要があります。\footnote{もちろん、
逐次翻訳された手続きと同様にコンパイルされた手続きも複合(compound, 非プリミティブ)です。明示的
制御評価機で使用された用語との互換性のために、この節では``複合''を逐次翻訳された
(コンパイルされたの逆を)意味するものとして使用します。}

\begin{scheme}
apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))
  (branch (label compound-apply))
  (test (op compiled-procedure?) (reg proc))
  (branch (label compiled-apply))
  (goto (label unknown-procedure-type))
compiled-apply
  (restore continue)
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
\end{scheme}

\noindent
\code{compiled\-/apply}での\code{continue}の復元に注意して下さい。評価機は\code{apply\-/dispatch}にて
継続がスタックの一番上になるように準備されています。一方で、コンパイルされたコードの
エントリポイントは継続が\code{continue}の中にあることを期待しています。そのため、
\code{continue}はコンパイルされたコードが実行される前に復元されなければなりません。

評価機を開始した時にいくつかのコンパイルされたコードを実行することを可能にするために、
\code{branch}命令を評価機の最初に追加します。これはもし\code{flag}レジスタが設定されて
いれば、機械を新しいエントリポイントへと飛ばします。\footnote{
今や評価機は\code{branch}を
用いて開始するので、私達は常に評価機を開始する前に\code{flag}レジスタを初期化しなければ
なりません。機械を通常のREPLにて開始するためには、以下を用いることができます。

\begin{smallscheme}
(define (start-eceval)
  (set! the-global-environment (setup-environment))
  (set-register-contents! eceval 'flag false)
  (start eceval))
\end{smallscheme}
}

\begin{scheme}
(branch (label external-entry))      ~\textrm{; \code{flag}が立っていれば飛ぶ}~
read-eval-print-loop
  (perform (op initialize-stack))
  ~\( \dots \)~
\end{scheme}

\noindent
\code{external\-/entry}は機械が結果を\code{val}に入れ\code{(goto (reg continue))}で
終わる命令列の位置を持つ\code{val}と共に開始すると仮定します。
このエントリポイントで開始する場合、\code{val}で指定された位置へ飛びます。
しかし、最初に\code{continue}に実行が\code{print\-/result}に戻るように設定します。
\code{print\-/result}は\code{val}内の値を表示し、次に評価機のREPLの最初へと
飛びます。\footnote{
コンパイルされた手続きはシステムが表示しようとするかもしれない
オブジェクトであるため、システムの表示命令(\link{Section 4.1.4}の)\code{user\-/print}も
変更し、コンパイルされた手続きの構成部品を表示しようとしないようにします。

\begin{smallscheme}
(define (user-print object)
  (cond ((compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>)))
        ((compiled-procedure? object)
         (display '<compiled-procedure>))
        (else (display object))))
\end{smallscheme}
}

\begin{scheme}
external-entry
  (perform (op initialize-stack))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (reg val))
\end{scheme}

\noindent
これで以下手続きを用いて手続き定義をコンパイルし、コンパイルされたコードを実行し、
手続きを試行することができるようREPLを実行することができます。コンパイルされた
コードに\code{continue}内の位置に、\code{val}内の結果を持って戻って欲しいため、
式をターゲット\code{val}とリンク記述子\code{return}を用いてコンパイルします。
コンパイラにより生成されたオブジェクトコードを評価機で実行可能な命令に変形する
ために、レジスタマシンシミュレータ(\link{Section 5.2.2})の手続き\code{assemble}を使用します。
次に\code{val}レジスタを命令のリストを指すように初期化し、\code{flag}を評価機が
\code{external\-/entry}へ飛ぶように設定し、評価機を開始します。

\begin{scheme}
(define (compile-and-go expression)
  (let ((instructions
         (assemble
          (statements
           (compile expression 'val 'return))
          eceval)))
    (set! the-global-environment (setup-environment))
    (set-register-contents! eceval 'val instructions)
    (set-register-contents! eceval 'flag true)
    (start eceval)))
\end{scheme}

\noindent
もし\link{Section 5.4.4}の終わりのようにスタック監視を設定したなら、
コンパイルされたコードのスタック使用量を調査できます。

\begin{scheme}
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
~\textit{(total-pushes = 0 maximum-depth = 0)}~
~\textit{;;; EC-Eval value:}~
~\textit{ok}~
~\textit{;;; EC-Eval input:}~
(factorial 5)
~\textit{(total-pushes = 31 maximum-depth = 14)}~
~\textit{;;; EC-Eval value:}~
~\textit{120}~
\end{scheme}

\noindent
この例を、\link{Section 5.4.4}の終わりで示された同じ手続きの逐次翻訳された版を
用いた\code{(factorial 5)}の評価と比べてみて下さい。
逐次翻訳された版は144回のpushと最大スタック深度28を必要としました。
これは私達のコンパイル戦略に起因する最適化を説明しています。

\subsubsection*{逐次翻訳とコンパイル}

この節のプログラムを用いることで、今では逐次翻訳とコンパイルの代替的な実行戦略
を実験することができます。\footnote{コンパイラを拡張してコンパイルされたコードに
逐次翻訳された手続きの呼び出しを許可することでさらにうまく行うことができます。
\link{Exercise 5.47}を参照して下さい。}インタプリタは機械をユーザプログラムのレベルへと
上げます。コンパイラはユーザプログラムを機械語のレベルへと下げます。
私達はScheme言語を(またはどんなプログラミング言語も)機械語の上に構築された体系化の
目的を同じとした仲間だと見做すことができます。インタプリタは対話的なプログラム開発と
デバッグに最適です。プログラムのステップの実行がこれらの抽象化を用いて組織化され、
そのため、プログラマにとってより理解しやすくなります。コンパイルされたコードは
より速く実行することができます。プログラムのステップの実行が機械語を利用して体系化され、
コンパイラは自由に高いレベルの抽象化を近道する最適化を作ることができます。\footnote{
実行
戦略とは独立して、もしユーザプログラムを実行した場合にエラーに遭遇した時にシステムを
殺すことや間違った値を生成するおおを許可するのではなく、エラーが発見され、その旨が
伝えられることを望むのならば、明らかなオーバヘッドを経験することになります。
例えば、配列の境界外参照は実行する前に参照の有効性をチェックすることで発見することが
できます。しかし、チェックのオーバヘッドは配列参照自体の何倍ものコストに成り得ます。
そしてプログラマはそのようなチェックが望ましいかの決定において安全性よりもスピードに
重きを置きます。良いコンパイラはそのようなチェックを行うコードを生成することが
可能であるべきです。また冗長なチェックは回避し、プログラマにコンパイルされたコード内での
エラーチェックの範囲と型を制御できるようにするべきです。

CやC++のような人気のある言語のコンパイラはほとんど何も実行コードの中にエラーチェックの
命令を挿入しません。可能な限り速く実行するためです。結果として、プログラマに対して
明示的にエラーチェックを提供させることに陥ります。残念なことに、人々は良くこのことを
軽視します。例えスピードが制約ではない重要なアプリケーションにおいてもです。
こうのような人々のプログラムは高速、かつ危険な生活へと導きます。例えば、1988年に
インターネットを麻痺させた悪名高い``Worm''(ワーム)は\acronym{UNIX}(tm) OS
(オペレーティングシステム)のfingerデーモンにおける入力バッファがオーバフローしたか
どうかのチェックミスを利用しました。(\link{Spafford 1989}参照)
}

逐次翻訳とコンパイルの代替もまた、新しいコンピュータへ言語を移植するための異なる
戦略へと導きます。新しい機械にLispを実装したいと願っていると仮定します。
1つの戦略は\link{Section 5.4}の明示的制御評価機と共に始めて、その命令を新しい機械の命令へと
翻訳することです。異なる戦略はコンパイラと共に始めてコード生成器を変更し、新しい
機械のコードを生成するようにします。2つ目の戦略はどんなLispプログラムも最初に
元のLispシステム上で動くコンパイラを用いてコンパイルし、実行時ライブラリの
コンパイル済みの版とリンクすることにより、新しい機械の上で実行させることが
可能になります。\footnote{もちろん、逐次翻訳とコンパイルの戦略のどちらを用いても、
新しい機械の記憶域割り当て、入出力(I/O)、そして評価機とコンパイラの議論において
``プリミティブ''として扱った全ての多彩な命令もまた新しい機械のために実装しなければ
なりません。ここで仕事量を最小化するための1つの方法としてはこれらの命令を可能な限り
Lispで書き、次に新しい機械のためにコンパイルすることが上げられます。究極的には、
全てが新しい機械のために手で書かれた(ガベージコレクションや実際の機械の
プリミティブを適用する仕組みの様な)小さなカーネルに縮小されます。}
もっと良いことには、コンパイラそれ自身をコンパイルすることができます。そしてこれを
新しい機械の上で他のLispプログラムをコンパイルするために実行するのです。\footnote{この
戦略は、コンパイルされたコンパイラを用いた、新しい機械上でのプログラムのコンパイルが
元のLispシステム上のプログラムのコンパイルと同一であるかどうかという、コンパイラの
正確性の楽しいテストへと至ります。違いの原因の追跡は楽しいのですが、しばしばイライラも
させます。その結果はとても小さな詳細に非常に敏感なためです。}または、\link{Section 4.1}の
インタプリタの内1つをコンパイルして新しい機械上で実行できるインタプリタを
生成することもできます。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.45}Exercise 5.45:}
コンパイルされたコードにより使用されたスタック命令を同じ演算のための評価機により
使用されたスタック命令と比較することで、コンパイラのスタック使用の最適化の範囲を
速さ(スタック命令の総数の削減)と記憶域(最大スタック深度の削減)の両方において
判断することができる。この最適化されたスタックの使用を、同じ演算のための特別な目的の機械
と比較することでコンパイルの品質の何らかの指標を与えることができる。

\begin{enumerate}[a]

\item
\link{Exercise 5.27}は、評価機が上で与えられた再帰階乗手続きを用いて
\( n! \)を求めるのに必要なプッシュの数と最大スタック深度を\( n \)の関数として決定するよう
求めた。\link{Exercise 5.14}は\link{Figure 5.11}で示された特別な目的の階乗マシンに
対しする同じ測定を求めた。ここでは同じ分析をコンパイルした\code{factorial}手続きを用いて
実行する。

コンパイルされた版のプッシュの数と逐次翻訳された版のプッシュの数との比率を取得せよ
次に同じ事を最大スタック深度に対しても行なえ。\( n! \)を求めるために使用される命令数と
スタック深度は\( n \)の線形であるために、これらの比率は\( n \)が巨大になるにつれ
定数へと収束するはずである。これらの定数は何か? 同様に、特定目的マシンの使用量と
逐次翻訳の版の使用量との比率も求めよ。

特定目的と逐次翻訳されたコードとの間の比率と、コンパイルされたコードと逐次翻訳された
コードとの間の比率を比較せよ。特定目的マシンがコンパイルされたコードよりもとても良い
ことに気付くはずだ。手作りのコントローラのコードは基本的な汎用目的のコンパイラにより
生成されたものよりとても優れているはずだからである。

\item
パフォーマンスにおいて手作り版により近いコードを生成することを手助けする、
コンパイラに対する改善を提案できるだろうか?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.46}Exercise 5.46:}
\link{Exercise 5.45}のような分析を木再帰フィボナッチ手続きのコンパイルの効果を
判断するために実行せよ。

\begin{scheme}
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1))
         (fib (- n 2)))))
\end{scheme}

\noindent
\link{Figure 5.12}の特定目的フィボナッチマシンを用いた場合の効果と
比較せよ。(逐次翻訳のパフォーマンスの測定のために、\link{Exercise 5.29}を参照せよ)。
フィボナッチ数では、使用された時間的リソースは\( n \)の線形にはならない。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.47}Exercise 5.47:}
この節では逐次翻訳されたコードがコンパイルされたコードを呼び出すことができるように
するために、明示的制御評価機をどのように変更するかを説明した。コンパイルされた手続きが
プリミティブとコンパイルされた手続きのみでなく、逐次翻訳された手続きも同様に呼び出すこと
ができるようにするために、コンパイラをどのように変更するのか示せ。
これは\code{compile\-/procedure\-/call}を複合(逐次翻訳)の場合を取り扱うように変更する必要がある。
全ての同じ\code{target}と\code{linkage}の組み合わせを\code{compile\-/proc\-/appl}が行うように
取り扱うよう気をつけよ。実際に手続き適用を行うためには、コードは評価機の\code{compound\-/apply}
エントリポイントへ飛ぶ必要がある。このラベルはオブジェクトコードの中では直接参照することが
できない。(アセンブラが全てのラベルに対し、それがアセンブルしている、そこで定義される
コードにより参照されることを要求するためである)。従って、\code{compapp}と呼ばれるレジスタを
評価機に追加し、このエントリポイントを持たせて、これを初期化する命令を追加する。

\begin{scheme}
 (assign compapp (label compound-apply))
 (branch (label external-entry)) ~\textrm{;\code{flag}が立っていれば飛ぶ}~
read-eval-print-loop ~\( \dots \)~
\end{scheme}

あなたのコードをテストするために、手続き\code{g}を呼ぶ手続き\code{f}を定義することから始めよ。
\code{compile\-/and\-/go}を用いて\code{f}の定義をコンパイルし、評価機を開始せよ。ここから
評価機に対し入力を行い\code{g}を定義し\code{f}の呼出を試せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.48}Exercise 5.48:}
この節で実装された\code{compile\-/and\-/go}インターフェイスは扱いにくい。コンパイラを
(評価機が開始された時に)一度しか呼ぶことができないためだ。
以下のように明示的制御評価機の中から呼び出すことができる\code{compile\-/and\-/run}を
追加することでコンパイラ-インタプリタ間のインターフェイスを増補せよ。

\begin{scheme}
~\textit{;;; EC-Eval input:}~
(compile-and-run
 '(define (factorial n)
    (if (= n 1) 1 (* (factorial (- n 1)) n))))
~\textit{;;; EC-Eval value:}~
~\textit{ok}~
~\textit{;;; EC-Eval input:}~
(factorial 5)
~\textit{;;; EC-Eval value:}~
~\textit{120}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.49}Exercise 5.49:}
明示的制御評価機のREPLを用いる代わりとして、read-compile-execute-print loopを
実行するレジスタマシンを設計せよ。言い換えれば、このマシンは式を読み込み、それを
コンパイルし、その結果のコードをアセンブルして実行し、その結果を表示するループを
実行する。これは私達のシミュレートされた構成内で簡単に実行できる。なぜなら、
手続き\code{compile}と\code{assemble}を``レジスタマシンの命令''として呼ぶことを
手配できるからだ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.50}Exercise 5.50:}
コンパイラを用いて\link{Section 4.1}のメタ循環評価機をコンパイルし、レジスタマシン
シミュレータと用いてこのプログラムを実行せよ。(一度に複数の定義をコンパイルするために、
\code{begin}の中に定義を詰めることができる)。結果としてのインタプリタの実行は
複数レベルの逐次翻訳のため、とても遅い。しかし、実行の詳細全てを理解することは
教育的な課題である。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.51}Exercise 5.51:}
C言語(またはあなたが選んだ何らかの他の低レベルな言語)によるSchemeの基本的な実装を、
\link{Section 5.4}の明示的制御評価機をC言語に翻訳することで開発せよ。このコードを実行するためには、
適切なメモリ割当ルーチンと他の実行時サポートも提供する必要がある。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.52}Exercise 5.52:}
\link{Exercise 5.51}に対する好対照として、コンパイラを変更してSchemeの手続きを
C言語の命令列へとコンパイルするようにせよ。\link{Section 4.1}のメタ循環評価機をコンパイルして
C言語で書かれたSchemeインタプリタを生成せよ。
\end{quote}

%=======================================================================================================

\backmatter

\chapter*{参考文献}
\addcontentsline{toc}{chapter}{参考文献}
\label{References}

\phantomsection \label{Abelson et al. 1992}
Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister,
Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992.  The Supercomputer
Toolkit: A general framework for special-purpose computing.
\textit{International Journal of High-Speed Electronics} 3(3): 337-361.
\href{http://www.hpl.hp.com/techreports/94/HPL-94-30.html}{\code{(Onl)}}

\phantomsection \label{Allen 1978}
Allen, John.  1978.  \textit{Anatomy of Lisp}. New York: McGraw-Hill.

\phantomsection \label{ANSI 1994}
\acronym{ANSI} X3.226-1994. \textit{American National Standard for Information
Sys\-tems---Programming Language---Common Lisp}.

\phantomsection \label{Appel 1987}
Appel, Andrew W.  1987.  Garbage collection can be faster than stack
allocation.  \textit{Information Processing Letters} 25(4): 275-279.
\href{http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8219}{\code{(Online)}}

\phantomsection \label{Backus 1978}
Backus, John.  1978.  Can programming be liberated from the von Neumann style?
\textit{Communications of the \acronym{ACM}} 21(8): 613-641.
\href{http://www.stanford.edu/class/cs242/readings/backus.pdf}{\code{(Online)}}

\phantomsection \label{Baker (1978)}
Baker, Henry G., Jr.  1978.  List processing in real time on a serial computer.
\textit{Communications of the \acronym{ACM}} 21(4): 280-293.
\href{http://dspace.mit.edu/handle/1721.1/41976}{\code{(Online)}}

\phantomsection \label{Batali et al. 1982}
Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise.
1982.  The Scheme-81 architecture---System and chip.  In \textit{Proceedings of
the \acronym{MIT} Conference on Advanced Research in \acronym{VLSI}}, edited by
Paul Penfield, Jr. Dedham, MA: Artech House.

\phantomsection \label{Borning (1977)}
Borning, Alan.  1977.  ThingLab---An object-oriented system for building
simulations using constraints. In \textit{Proceedings of the 5th International
Joint Conference on Artificial Intelligence}.
\href{http://ijcai.org/Past\%20Proceedings/IJCAI-77-VOL1/PDF/085.pdf}{\code{(Online)}}

\phantomsection \label{Borodin and Munro (1975)}
Borodin, Alan, and Ian Munro.  1975.  \textit{The Computational Complexity of
Algebraic and Numeric Problems}. New York: American Elsevier.

\phantomsection \label{Chaitin 1975}
Chaitin, Gregory J.  1975.  Randomness and mathematical proof.
\textit{Scientific American} 232(5): 47-52.

\phantomsection \label{Church (1941)}
Church, Alonzo.  1941.  \textit{The Calculi of Lambda-Conversion}.  Princeton,
N.J.: Princeton University Press.

\phantomsection \label{Clark (1978)}
Clark, Keith L.  1978.  Negation as failure.  In \textit{Logic and Data Bases}.
New York: Plenum Press, pp. 293-322.
\href{http://www.doc.ic.ac.uk/~klc/neg.html}{\code{(Online)}}

\phantomsection \label{Clinger (1982)}
Clinger, William.  1982.  Nondeterministic call by need is neither lazy nor by
name. In \textit{Proceedings of the \acronym{ACM} Symposium on Lisp and
Functional Programming}, pp. 226-234.

\phantomsection \label{Clinger and Rees 1991}
Clinger, William, and Jonathan Rees.  1991.  Macros that work.  In
\textit{Proceedings of the 1991 \acronym{ACM} Conference on Principles of
Programming Languages}, pp. 155-162.
\href{http://mumble.net/~jar/pubs/macros_that_work.ps}{\code{(Online)}}

\phantomsection \label{Colmerauer et al. 1973}
Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel.  1973.  Un syst\`eme de
communication homme-machine en fran\c{c}ais.  Technical report, Groupe
Intelligence Artificielle, Universit\'e d'Aix Marseille, Luminy.

\phantomsection \label{Cormen et al. 1990}
Cormen, Thomas, Charles Leiserson, and Ronald Rivest.  1990. \textit{Introduction
to Algorithms}. Cambridge, MA: \acronym{MIT} Press.

\phantomsection \label{Darlington et al. 1982}
Darlington, John, Peter Henderson, and David Turner.  1982.  \textit{Functional
Programming and Its Applications}. New York: Cambridge University Press.

\phantomsection \label{Dijkstra 1968a}
Dijkstra, Edsger W. 1968a.  The structure of the ``\acronym{THE}''
multiprogramming system.  \textit{Communications of the \acronym{ACM}}
11(5): 341-346.
\href{http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD196.PDF}{\code{(Online)}}

\phantomsection \label{Dijkstra 1968b}
Dijkstra, Edsger W. 1968b.  Cooperating sequential processes.  In
\textit{Programming Languages}, edited by F. Genuys. New York: Academic Press,
pp.  43-112.
\href{http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD123.PDF}{\code{(Online)}}

\phantomsection \label{Dinesman 1968}
Dinesman, Howard P.  1968.  \textit{Superior Mathematical Puzzles}.  New York:
Simon and Schuster.

\phantomsection \label{deKleer et al. 1977}
deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman.  1977.
\acronym{AMORD}: Explicit control of reasoning.  In \textit{Proceedings of the
\acronym{ACM} Symposium on Artificial Intelligence and Programming Languages},
pp.  116-125.
\href{http://dspace.mit.edu/handle/1721.1/5750}{\code{(Online)}}

\phantomsection \label{Doyle (1979)}
Doyle, Jon. 1979. A truth maintenance system. \textit{Artificial Intelligence}
12: 231-272.
\href{http://dspace.mit.edu/handle/1721.1/5733}{\code{(Online)}}

\phantomsection \label{Feigenbaum and Shrobe 1993}
Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National Fifth
Generation Project: Introduction, survey, and evaluation.  In \textit{Future
Generation Computer Systems}, vol. 9, pp. 105-117.

\phantomsection \label{Feeley (1986)}
Feeley, Marc.  1986.  Deux approches \`a l'implantation du language
Scheme.  Masters thesis, Universit\'e de Montr\'eal.

\phantomsection \label{Feeley and Lapalme 1987}
Feeley, Marc and Guy Lapalme.  1987.  Using closures for code generation.
\textit{Journal of Computer Languages} 12(1): 47-66.
\href{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.6978}{\code{(Online)}}

Feller, William.  1957.  \textit{An Introduction to Probability Theory and Its
Applications}, volume 1. New York: John Wiley \& Sons.

\phantomsection \label{Fenichel and Yochelson (1969)}
Fenichel, R., and J. Yochelson.  1969.  A Lisp garbage collector for virtual
memory computer systems.  \textit{Communications of the \acronym{ACM}}
12(11): 611-612.

\phantomsection \label{Floyd (1967)}
Floyd, Robert. 1967. Nondeterministic algorithms. \textit{\acronym{JACM}},
14(4): 636-644.

\phantomsection \label{Forbus and deKleer 1993}
Forbus, Kenneth D., and Johan deKleer.  1993. \textit{Building Problem
Solvers}. Cambridge, MA: \acronym{MIT} Press.

\phantomsection \label{Friedman and Wise (1976)}
Friedman, Daniel P., and David S. Wise.  1976.  \acronym{CONS} should not
evaluate its arguments. In \textit{Automata, Languages, and Programming: Third
International Colloquium}, edited by S. Michaelson and R.  Milner, pp. 257-284.
\href{https://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR44}{\code{(Online)}}

\phantomsection \label{Friedman et al. 1992}
Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.
\textit{Essentials of Programming Languages}.  Cambridge, MA: \acronym{MIT}
Press/ McGraw-Hill.

\phantomsection \label{Gabriel 1988}
Gabriel, Richard P. 1988.  The Why of \emph{Y}.  \textit{Lisp Pointers}
2(2): 15-25.
\href{http://www.dreamsongs.com/Files/WhyOfY.pdf}{\code{(Online)}}

Goldberg, Adele, and David Robson.  1983.  \textit{Smalltalk-80: The Language and
Its Implementation}. Reading, MA: Addison-Wesley.

\phantomsection \label{Gordon et al. 1979}
Gordon, Michael, Robin Milner, and Christopher Wadsworth.  1979.
\textit{Edinburgh LCF}. Lecture Notes in Computer Science, volume 78. New York:
Springer-Verlag.

\phantomsection \label{Gray and Reuter 1993}
Gray, Jim, and Andreas Reuter. 1993. \textit{Transaction Processing: Concepts and
Models}. San Mateo, CA: Morgan-Kaufman.

\phantomsection \label{Green 1969}
Green, Cordell.  1969.  Application of theorem proving to problem solving.  In
\textit{Proceedings of the International Joint Conference on Artificial
Intelligence}, pp. 219-240.
\href{http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.81.9820}{\code{(Online)}}

\phantomsection \label{Green and Raphael (1968)}
Green, Cordell, and Bertram Raphael.  1968.  The use of theorem-proving
techniques in question-answering systems.  In \textit{Proceedings of the
\acronym{ACM} National Conference}, pp. 169-181.

\phantomsection \label{Griss 1981}
Griss, Martin L.  1981.  Portable Standard Lisp, a brief overview.  Utah
Symbolic Computation Group Operating Note 58, University of Utah.

\phantomsection \label{Guttag 1977}
Guttag, John V.  1977.  Abstract data types and the development of data
structures.  \textit{Communications of the \acronym{ACM}} 20(6): 396-404.
\href{http://www.unc.edu/~stotts/comp723/guttagADT77.pdf}{\code{(Online)}}

\phantomsection \label{Hamming 1980}
Hamming, Richard W.  1980.  \textit{Coding and Information Theory}.  Englewood
Cliffs, N.J.: Prentice-Hall.

\phantomsection \label{Hanson 1990}
Hanson, Christopher P.  1990.  Efficient stack allocation for tail-recur\-sive
languages.  In \textit{Proceedings of \acronym{ACM} Conference on Lisp and
Functional Programming}, pp. 106-118.

\phantomsection \label{Hanson 1991}
Hanson, Christopher P.  1991.  A syntactic closures macro facility.  \textit{Lisp
Pointers}, 4(3).
\href{http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/synclo.ps}{\code{(Online)}}

\phantomsection \label{Hardy 1921}
Hardy, Godfrey H.  1921.  Srinivasa Ramanujan.  \textit{Proceedings of the London
Mathematical Society} XIX(2).

\phantomsection \label{Hardy and Wright 1960}
Hardy, Godfrey H., and E. M. Wright.  1960.  \textit{An Introduction to the
Theory of Numbers}.  4th edition.  New York: Oxford University Press.

\phantomsection \label{Havender (1968)}
Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. \textit{IBM
Systems Journal} 7(2): 74-84.

\phantomsection \label{Hearn 1969}
Hearn, Anthony C.  1969.  Standard Lisp.  Technical report \acronym{AIM}-90,
Artificial Intelligence Project, Stanford University.
\href{http://www.softwarepreservation.org/projects/LISP/stanford/Hearn-StandardLisp-AIM-90.pdf}{\code{(Online)}}

\phantomsection \label{Henderson 1980}
Henderson, Peter. 1980.  \textit{Functional Programming: Application and
Implementation}. Englewood Cliffs, N.J.: Prentice-Hall.

\phantomsection \label{Henderson 1982}
Henderson. Peter. 1982. Functional Geometry. In \textit{Conference Record of the
1982 \acronym{ACM} Symposium on Lisp and Functional Programming}, pp. 179-187.
\href{http://pmh-systems.co.uk/phAcademic/papers/funcgeo.pdf}{\code{(Online)}}
\href{http://eprints.soton.ac.uk/257577/1/funcgeo2.pdf}{\code{(2002 version)}}

\phantomsection \label{Hewitt (1969)}
Hewitt, Carl E.  1969.  \acronym{PLANNER}: A language for proving
theorems in robots.  In \textit{Proceedings of the International Joint
Conference on Artificial Intelligence}, pp. 295-301.
\href{http://dspace.mit.edu/handle/1721.1/6171}{\code{(Online)}}

\phantomsection \label{Hewitt (1977)}
Hewitt, Carl E.  1977.  Viewing control structures as patterns of passing
messages.  \textit{Journal of Artificial Intelligence} 8(3): 323-364.
\href{http://dspace.mit.edu/handle/1721.1/6272}{\code{(Online)}}

\phantomsection \label{Hoare (1972)}
Hoare, C. A. R. 1972.  Proof of correctness of data representations.
\textit{Acta Informatica} 1(1).

\phantomsection \label{Hodges 1983}
Hodges, Andrew. 1983.  \textit{Alan Turing: The Enigma}. New York: Simon and
Schuster.

\phantomsection \label{Hofstadter 1979}
Hofstadter, Douglas R.  1979.  \textit{G\"odel, Escher, Bach: An Eternal Golden
Braid}. New York: Basic Books.

\phantomsection \label{Hughes 1990}
Hughes, R. J. M.  1990.  Why functional programming matters.  In \textit{Research
Topics in Functional Programming}, edited by David Turner.  Reading, MA:
Addison-Wesley, pp. 17-42.
\href{http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf}{\code{(Online)}}

\phantomsection \label{IEEE 1990}
\acronym{IEEE} Std 1178-1990.  1990.  \textit{\acronym{IEEE} Standard for the
Scheme Programming Language}.

\phantomsection \label{Ingerman et al. 1960}
Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted by
M. Lind, Herbert Kanner, and Robert Floyd.  1960.  \acronym{THUNKS}: A way of
compiling procedure statements, with some comments on procedure declarations.
Unpublished manuscript.  (Also, private communication from Wallace Feurzeig.)

\phantomsection \label{Kaldewaij 1990}
Kaldewaij, Anne. 1990.  \textit{Programming: The Derivation of Algorithms}. New
York: Prentice-Hall.

\phantomsection \label{Knuth (1973)}
Knuth, Donald E.  1973.  \textit{Fundamental Algorithms}. Volume 1 of \textit{The
Art of Computer Programming}.  2nd edition. Reading, MA: Addison-Wesley.

\phantomsection \label{Knuth 1981}
Knuth, Donald E.  1981.  \textit{Seminumerical Algorithms}. Volume 2 of \textit{The
Art of Computer Programming}.  2nd edition. Reading, MA: Addison-Wesley.

\phantomsection \label{Kohlbecker 1986}
Kohlbecker, Eugene Edmund, Jr. 1986.  Syntactic extensions in the programming
language Lisp.  Ph.D. thesis, Indiana University.
\href{http://www.ccs.neu.edu/scheme/pubs/dissertation-kohlbecker.pdf}{\code{(Online)}}

\phantomsection \label{Konopasek and Jayaraman 1984}
Konopasek, Milos, and Sundaresan Jayaraman.  1984.  \textit{The TK!Solver Book: A
Guide to Problem-Solving in Science, Engineering, Business, and
Education}. Berkeley, CA: Osborne/McGraw-Hill.

\phantomsection \label{Kowalski (1973; 1979)}
Kowalski, Robert.  1973.  Predicate logic as a programming language.  Technical
report 70, Department of Computational Logic, School of Artificial
Intelligence, University of Edinburgh.
\href{http://www.doc.ic.ac.uk/~rak/papers/IFIP\%2074.pdf}{\code{(Online)}}

Kowalski, Robert.  1979.  \textit{Logic for Problem Solving}. New York:
North-Holland.

\phantomsection \label{Lamport (1978)}
Lamport, Leslie. 1978.  Time, clocks, and the ordering of events in a
distributed system.  \textit{Communications of the \acronym{ACM}} 21(7): 558-565.
\href{http://www.stanford.edu/class/cs240/readings/lamport.pdf}{\code{(Online)}}

\phantomsection \label{Lampson et al. 1981}
Lampson, Butler, J. J. Horning, R.  London, J. G. Mitchell, and G. K.  Popek.
1981.  Report on the programming language Euclid.  Technical report, Computer
Systems Research Group, University of Toronto.
\href{http://www.bitsavers.org/pdf/xerox/parc/techReports/CSL-81-12_Report_On_The_Programming_Language_Euclid.pdf}{\code{(Online)}}

\phantomsection \label{Landin (1965)}
Landin, Peter.  1965.  A correspondence between Algol 60 and Church's lambda
notation: Part I.  \textit{Communications of the \acronym{ACM}} 8(2): 89-101.

\phantomsection \label{Lieberman and Hewitt 1983}
Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage collector based
on the lifetimes of objects. \textit{Communications of the \acronym{ACM}}
26(6): 419-429.
\href{http://dspace.mit.edu/handle/1721.1/6335}{\code{(Online)}}

\phantomsection \label{Liskov and Zilles (1975)}
Liskov, Barbara H., and Stephen N. Zilles.  1975.  Specification techniques for
data abstractions.  \textit{\acronym{IEEE} Transactions on Software Engineering}
1(1): 7-19.
\href{http://csg.csail.mit.edu/CSGArchives/memos/Memo-117.pdf}{\code{(Online)}}

\phantomsection \label{McAllester (1978; 1980)}
McAllester, David Allen.  1978.  A three-valued truth-maintenance system.  Memo
473, \acronym{MIT} Artificial Intelligence Laboratory.
\href{http://dspace.mit.edu/handle/1721.1/6296}{\code{(Online)}}

McAllester, David Allen.  1980.  An outlook on truth maintenance.  Memo 551,
\acronym{MIT} Artificial Intelligence Laboratory.
\href{http://dspace.mit.edu/handle/1721.1/6327}{\code{(Online)}}

\phantomsection \label{McCarthy 1960}
McCarthy, John.  1960.  Recursive functions of symbolic expressions and their
computation by machine.  \textit{Communications of the \acronym{ACM}}
3(4): 184-195.
\href{http://innovation.it.uts.edu.au/projectjmc/articles/recursive.html}{\code{(Online)}}

\phantomsection \label{McCarthy 1963}
McCarthy, John.  1963.  A basis for a mathematical theory of computation.  In
\textit{Computer Programming and Formal Systems}, edited by P. Braffort and
D. Hirschberg.  North-Holland.
\href{http://innovation.it.uts.edu.au/projectjmc/articles/basis.html}{\code{(Online)}}

\phantomsection \label{McCarthy 1978}
McCarthy, John.  1978.  The history of Lisp.  In \textit{Proceedings of the
\acronym{ACM} \acronym{SIGPLAN} Conference on the History of Programming
Languages}.
\href{http://innovation.it.uts.edu.au/projectjmc/articles/lisp.html}{\code{(Online)}}

\phantomsection \label{McCarthy et al. 1965}
McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I.  Levin.
1965.  \textit{Lisp 1.5 Programmer's Manual}.  2nd edition.  Cambridge, MA:
\acronym{MIT} Press.
\href{http://www.softwarepreservation.org/projects/LISP/book/LISP\%201.5\%20Programmers\%20Manual.pdf/view}{\code{(Online)}}

\phantomsection \label{McDermott and Sussman (1972)}
McDermott, Drew, and Gerald Jay Sussman.  1972. Conniver reference manual.
Memo 259, \acronym{MIT} Artificial Intelligence Laboratory.
\href{http://dspace.mit.edu/handle/1721.1/6203}{\code{(Online)}}

\phantomsection \label{Miller 1976}
Miller, Gary L.  1976.  Riemann's Hypothesis and tests for primality.
\textit{Journal of Computer and System Sciences} 13(3): 300-317.
\href{http://www.cs.cmu.edu/~glmiller/Publications/b2hd-Mi76.html}{\code{(Online)}}

\phantomsection \label{Miller and Rozas 1994}
Miller, James S., and Guillermo J. Rozas. 1994.  Garbage collection is fast,
but a stack is faster.  Memo 1462, \acronym{MIT} Artificial Intelligence
Laboratory.
\href{http://dspace.mit.edu/handle/1721.1/6622}{\code{(Online)}}

\phantomsection \label{Moon 1978}
Moon, David.  1978.  MacLisp reference manual, Version 0.  Technical report,
\acronym{MIT} Laboratory for Computer Science.
\href{http://www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf/view}{\code{(Online)}}

\phantomsection \label{Moon and Weinreb 1981}
Moon, David, and Daniel Weinreb.  1981.  Lisp machine manual.  Technical
report, \acronym{MIT} Artificial Intelligence Laboratory.
\href{http://www.unlambda.com/lmman/index.html}{\code{(Online)}}

\phantomsection \label{Morris et al. 1980}
Morris, J. H., Eric Schmidt, and Philip Wadler.  1980.  Experience with an
applicative string processing language.  In \textit{Proceedings of the 7th Annual
\acronym{ACM} \acronym{SIGACT}/\acronym{SIGPLAN} Symposium on the Principles of
Programming Languages}.

\phantomsection \label{Phillips 1934}
Phillips, Hubert.  1934. \textit{The Sphinx Problem Book}.  London: Faber and
Faber.

\phantomsection \label{Pitman 1983}
Pitman, Kent. 1983. The revised MacLisp Manual (Saturday evening edition).
Technical report 295, \acronym{MIT} Laboratory for Computer Science.
\href{http://maclisp.info/pitmanual}{\code{(Online)}}

\phantomsection \label{Rabin 1980}
Rabin, Michael O. 1980. Probabilistic algorithm for testing primality.
\textit{Journal of Number Theory} 12: 128-138.

\phantomsection \label{Raymond 1993}
Raymond, Eric.  1993. \textit{The New Hacker's Dictionary}. 2nd edition.
Cambridge, MA: \acronym{MIT} Press.
\href{http://www.outpost9.com/reference/jargon/jargon_toc.html}{\code{(Online)}}

Raynal, Michel. 1986. \textit{Algorithms for Mutual Exclusion}.  Cambridge, MA:
\acronym{MIT} Press.

\phantomsection \label{Rees and Adams 1982}
Rees, Jonathan A., and Norman I. Adams IV. 1982.  T: A dialect of Lisp or,
lambda: The ultimate software tool.  In \textit{Conference Record of the 1982
\acronym{ACM} Symposium on Lisp and Functional Programming}, pp.  114-122.
\href{http://people.csail.mit.edu/riastradh/t/adams82t.pdf}{\code{(Online)}}

Rees, Jonathan, and William Clinger (eds). 1991.  The \( \rm revised^4 \) report on the
algorithmic language Scheme.  \textit{Lisp Pointers}, 4(3).
\href{http://people.csail.mit.edu/jaffer/r4rs_toc.html}{\code{(Online)}}

\phantomsection \label{Rivest et al. (1977)}
Rivest, Ronald, Adi Shamir, and Leonard Adleman.  1977.  A method for obtaining
digital signatures and public-key cryptosystems. Technical memo LCS/TM82,
\acronym{MIT} Laboratory for Computer Science.
\href{http://people.csail.mit.edu/rivest/Rsapaper.pdf}{\code{(Online)}}

\phantomsection \label{Robinson 1965}
Robinson, J. A. 1965.  A machine-oriented logic based on the resolution
principle.  \textit{Journal of the \acronym{ACM}} 12(1): 23.

\phantomsection \label{Robinson 1983}
Robinson, J. A. 1983.  Logic programming---Past, present, and future.
\textit{New Generation Computing} 1: 107-124.

\phantomsection \label{Spafford 1989}
Spafford, Eugene H.  1989.  The Internet Worm: Crisis and aftermath.
\textit{Communications of the \acronym{ACM}} 32(6): 678-688.
\href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8503&rep=rep1&type=pdf}{\code{(Online)}}

\phantomsection \label{Steele 1977}
Steele, Guy Lewis, Jr.  1977.  Debunking the ``expensive procedure call'' myth.
In \textit{Proceedings of the National Conference of the \acronym{ACM}},
pp. 153-62.
\href{http://dspace.mit.edu/handle/1721.1/5753}{\code{(Online)}}

\phantomsection \label{Steele 1982}
Steele, Guy Lewis, Jr.  1982.  An overview of Common Lisp.  In
\textit{Proceedings of the \acronym{ACM} Symposium on Lisp and Functional
Programming}, pp. 98-107.

\phantomsection \label{Steele 1990}
Steele, Guy Lewis, Jr.  1990.  \textit{Common Lisp: The Language}. 2nd edition.
Digital Press.
\href{http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html}{\code{(Online)}}

\phantomsection \label{Steele and Sussman 1975}
Steele, Guy Lewis, Jr., and Gerald Jay Sussman.  1975.  Scheme: An interpreter
for the extended lambda calculus.  Memo 349, \acronym{MIT} Artificial
Intelligence Laboratory.
\href{http://dspace.mit.edu/handle/1721.1/5794}{\code{(Online)}}

\phantomsection \label{Steele et al. 1983}
Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R.  Crispin,
Richard M. Stallman, and Geoffrey S. Goodfellow.  1983.  \textit{The Hacker's
Dictionary}. New York: Harper \& Row.
\href{http://www.dourish.com/goodies/jargon.html}{\code{(Online)}}

\phantomsection \label{Stoy 1977}
Stoy, Joseph E.  1977.  \textit{Denotational Semantics}. Cambridge, MA:
\acronym{MIT} Press.

\phantomsection \label{Sussman and Stallman 1975}
Sussman, Gerald Jay, and Richard M. Stallman.  1975.  Heuristic techniques in
computer-aided circuit analysis.  \textit{\acronym{IEEE} Transactions on Circuits
and Systems} CAS-22(11): 857-865.
\href{http://dspace.mit.edu/handle/1721.1/5803}{\code{(Online)}}

\phantomsection \label{Sussman and Steele 1980}
Sussman, Gerald Jay, and Guy Lewis Steele Jr.  1980.  Constraints---A language
for expressing almost-hierachical descriptions.  \textit{AI Journal} 14: 1-39.
\href{http://dspace.mit.edu/handle/1721.1/6312}{\code{(Online)}}

\phantomsection \label{Sussman and Wisdom 1992}
Sussman, Gerald Jay, and Jack Wisdom.  1992. Chaotic evolution of the solar
system.  \textit{Science} 257: 256-262.
\href{http://groups.csail.mit.edu/mac/users/wisdom/ss-chaos.pdf}{\code{(Online)}}

\phantomsection \label{Sussman et al. (1971)}
Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak.  1971.  Microplanner
reference manual.  Memo 203A, \acronym{MIT} Artificial Intelligence Laboratory.
\href{http://dspace.mit.edu/handle/1721.1/6184}{\code{(Online)}}

\phantomsection \label{Sutherland (1963)}
Sutherland, Ivan E.  1963.  \acronym{SKETCHPAD}: A man-machine graphical
communication system.  Technical report 296, \acronym{MIT} Lincoln Laboratory.
\href{http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.10.4290}{\code{(Onl.)}}

\phantomsection \label{Teitelman 1974}
Teitelman, Warren.  1974.  Interlisp reference manual.  Technical report, Xerox
Palo Alto Research Center.

\phantomsection \label{Thatcher et al. 1978}
Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978.  Data type
specification: Parameterization and the power of specification techniques. In
\textit{Conference Record of the Tenth Annual \acronym{ACM} Symposium on Theory
of Computing}, pp. 119-132.

\phantomsection \label{Turner 1981}
Turner, David.  1981.  The future of applicative languages.  In
\textit{Proceedings of the 3rd European Conference on Informatics}, Lecture Notes
in Computer Science, volume 123. New York: Springer-Verlag, pp.  334-348.

\phantomsection \label{Wand 1980}
Wand, Mitchell.  1980.  Continuation-based program transformation strategies.
\textit{Journal of the \acronym{ACM}} 27(1): 164-180.
\href{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.83.8567}{\code{(Online)}}

\phantomsection \label{Waters (1979)}
Waters, Richard C.  1979.  A method for analyzing loop programs.
\textit{\acronym{IEEE} Transactions on Software Engineering} 5(3): 237-247.

Winograd, Terry.  1971.  Procedures as a representation for data in a computer
program for understanding natural language.  Technical report AI TR-17,
\acronym{MIT} Artificial Intelligence Laboratory.
\href{http://dspace.mit.edu/handle/1721.1/7095}{\code{(Online)}}

\phantomsection \label{Winston 1992}
Winston, Patrick. 1992. \textit{Artificial Intelligence}.  3rd edition.  Reading,
MA: Addison-Wesley.

\phantomsection \label{Zabih et al. 1987}
Zabih, Ramin, David McAllester, and David Chapman.  1987.  Non-deterministic
Lisp with dependency-directed backtracking.  \textit{\acronym{AAAI}-87},
pp. 59-64.
\href{http://www.aaai.org/Papers/AAAI/1987/AAAI87-011.pdf}{\code{(Online)}}

\phantomsection \label{Zippel (1979)}
Zippel, Richard.  1979.  Probabilistic algorithms for sparse polynomials.
Ph.D. dissertation, Department of Electrical Engineering and Computer Science,
\acronym{MIT}.

\phantomsection \label{Zippel 1993}
Zippel, Richard.  1993.  \textit{Effective Polynomial Computation}.  Boston, MA:
Kluwer Academic Publishers.

\chapter*{課題リスト}
\addcontentsline{toc}{chapter}{課題リスト}
\label{List of Exercises}

% 
\input{exercises}

\chapter*{図一覧}
\addcontentsline{toc}{chapter}{図一覧}
\label{List of Figures}

% 
\input{figures}


\setindexprenote{\normalsize \begin{quote}
この索引内のどんな間違いも、コンピュータの手助けにより準備された
という事実により説明できるだろう。

---Donald E. Knuth, \textit{Fundamental Algorithms}\\ 
(Volume 1 of \textit{The Art of Computer Programming}) \end{quote}}

\printindex

\chapter*{奥付}
\addcontentsline{toc}{chapter}{奥付}
\label{Colophon}

表紙は1588年、Agostino Ramelliのブックホイールのメカニズムです。これは初期のハイパーテキスト ナビゲーション支援と
見ることができるのではないでしょうか。この版画のイメージは
\href{http://newgottland.com/2012/02/09/before-the-ereader-there-was-the-wheelreader/ramelli_bookwheel_1032px/}{New Gottland}. 
のJ. E. Johnsonにより提供されています。

タイプフェイスは本文はLinux Libertineで、見出しはLinux Biolinumです。両方ともPhilipp H. Pollの手によります。
タイプライターフェイスはRaph LevienによるInconsolataであり、Dimosthenis KaponisとTakashi Tanigawaにより補完された
Inconsolata LGCの形式で利用しています。

(日本語版では漢字にIPAフォントを使用させて頂いてます。)

グラフィックデザインとタイポグラフィはAndres Rabaにより行われました。TexinfoのソースはPerlスクリプトにより
LaTeXに変換され、XeLaTeXにより\acronym{PDF}にコンパイルされています。図はInkscapeを用いて描かれました。

\end{document}
